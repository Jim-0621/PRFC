File: src/java/org/apache/cassandra/cql3/functions/NativeFunctions.java
Patch:
@@ -44,6 +44,7 @@ public class NativeFunctions
             AggregateFcts.addFunctionsTo(this);
             CollectionFcts.addFunctionsTo(this);
             BytesConversionFcts.addFunctionsTo(this);
+            LengthFcts.addFunctionsTo(this);
             MathFcts.addFunctionsTo(this);
             MaskingFcts.addFunctionsTo(this);
             VectorFcts.addFunctionsTo(this);

File: test/distributed/org/apache/cassandra/distributed/impl/Instance.java
Patch:
@@ -794,6 +794,7 @@ public Future<Void> shutdown(boolean graceful)
 
             error = parallelRun(error, executor,
                     () -> StorageService.instance.setRpcReady(false),
+                    () -> StorageService.instance.setIsShutdownUnsafeForTests(true),
                     CassandraDaemon.getInstanceForTesting()::destroyClientTransports);
 
             if (config.has(GOSSIP) || config.has(NETWORK))

File: src/java/org/apache/cassandra/utils/memory/MemtableCleanerThread.java
Patch:
@@ -35,7 +35,7 @@
 
 /**
  * A thread that reclaims memory from a MemtablePool on demand.  The actual reclaiming work is delegated to the
- * cleaner Runnable, e.g., FlushLargestColumnFamily
+ * cleaner Runnable, e.g., MemtableCleaner {@link AbstractAllocatorMemtable#flushLargestMemtable()}.
  */
 public class MemtableCleanerThread<P extends MemtablePool> implements Interruptible
 {

File: src/java/org/apache/cassandra/utils/memory/MemtableCleanerThread.java
Patch:
@@ -35,7 +35,7 @@
 
 /**
  * A thread that reclaims memory from a MemtablePool on demand.  The actual reclaiming work is delegated to the
- * cleaner Runnable, e.g., FlushLargestColumnFamily
+ * cleaner Runnable, e.g., MemtableCleaner {@link AbstractAllocatorMemtable#flushLargestMemtable()}.
  */
 public class MemtableCleanerThread<P extends MemtablePool> implements Interruptible
 {

File: src/java/org/apache/cassandra/service/snapshot/TakeSnapshotTask.java
Patch:
@@ -94,7 +94,7 @@ public Map<ColumnFamilyStore, TableSnapshot> getSnapshotsToCreate()
 
         for (ColumnFamilyStore cfs : entitiesForSnapshot)
         {
-            Set<File> snapshotDirs = cfs.getDirectories().getSnapshotDirs(snapshotName);
+            Set<File> snapshotDirs = cfs.getDirectories().getSnapshotDirsWithoutCreation(snapshotName);
 
             TableSnapshot tableSnapshot = new TableSnapshot(cfs.metadata.keyspace,
                                                             cfs.metadata.name,

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -195,6 +195,8 @@ public class Config
     public Integer native_transport_port_ssl = null;
     public int native_transport_max_threads = 128;
     public int native_transport_max_frame_size_in_mb = 256;
+    /** do bcrypt hashing in a limited pool to prevent cpu load spikes; 0 means that all requests will go to default request executor**/
+    public int native_transport_max_auth_threads = 0;
     public volatile long native_transport_max_concurrent_connections = -1L;
     public volatile long native_transport_max_concurrent_connections_per_ip = -1L;
     public boolean native_transport_flush_in_batches_legacy = false;

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -1561,7 +1561,7 @@ private boolean isReversed(TableMetadata table, Map<ColumnMetadata, Ordering> or
                 return false;
             Boolean[] reversedMap = new Boolean[table.clusteringColumns().size()];
             int i = 0;
-            for (var entry : orderingColumns.entrySet())
+            for (Map.Entry<ColumnMetadata, Ordering> entry : orderingColumns.entrySet())
             {
                 ColumnMetadata def = entry.getKey();
                 Ordering ordering = entry.getValue();

File: src/java/org/apache/cassandra/index/sai/VectorQueryContext.java
Patch:
@@ -19,6 +19,7 @@
 package org.apache.cassandra.index.sai;
 
 import java.io.IOException;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.NavigableSet;
@@ -181,7 +182,7 @@ public IgnoredKeysBits(OnHeapGraph<PrimaryKey> graph, NavigableSet<PrimaryKey> i
         @Override
         public boolean get(int ordinal)
         {
-            var keys = graph.keysFromOrdinal(ordinal);
+            Collection<PrimaryKey> keys = graph.keysFromOrdinal(ordinal);
             return keys.stream().anyMatch(k -> !ignored.contains(k));
         }
 

File: src/java/org/apache/cassandra/index/sai/disk/v1/segment/SegmentTrieBuffer.java
Patch:
@@ -79,7 +79,7 @@ public long add(ByteComparable term, int termLength, int segmentRowId)
 
     public Iterator<IndexEntry> iterator()
     {
-        var iterator = trie.entrySet().iterator();
+        Iterator<Map.Entry<ByteComparable, PackedLongValues.Builder>> iterator = trie.entrySet().iterator();
 
         return new Iterator<>()
         {

File: src/java/org/apache/cassandra/index/sai/disk/v1/vector/BitsUtil.java
Patch:
@@ -94,7 +94,7 @@ public NoDeletedPostings(NonBlockingHashMapLong<VectorPostings<T>> postings)
         @Override
         public boolean get(int i)
         {
-            var p = postings.get(i);
+            VectorPostings<T> p = postings.get(i);
             assert p != null : "No postings for ordinal " + i;
             return !p.isEmpty();
         }
@@ -114,7 +114,7 @@ public NoDeletedIntersectingPostings(Bits toAccept, NonBlockingHashMapLong<Vecto
         @Override
         public boolean get(int i)
         {
-            var p = postings.get(i);
+            VectorPostings<T> p = postings.get(i);
             assert p != null : "No postings for ordinal " + i;
             return !p.isEmpty() && toAccept.get(i);
         }

File: src/java/org/apache/cassandra/index/sai/disk/v1/vector/CompactionVectorValues.java
Patch:
@@ -79,8 +79,8 @@ public long write(SequentialWriter writer) throws IOException
         writer.writeInt(size());
         writer.writeInt(dimension());
 
-        for (var i = 0; i < size(); i++) {
-            var bb = values.get(i);
+        for (int i = 0; i < size(); i++) {
+            ByteBuffer bb = values.get(i);
             assert bb != null : "null vector at index " + i + " of " + size();
             writer.write(bb);
         }

File: src/java/org/apache/cassandra/index/sai/iterators/KeyRangeOrderingIterator.java
Patch:
@@ -65,7 +65,7 @@ public PrimaryKey computeNext()
                 }
                 while (nextKeys.size() < chunkSize && input.hasNext());
                 // Get the next iterator before closing this one to prevent releasing the resource.
-                var previousIterator = nextIterator;
+                KeyRangeIterator previousIterator = nextIterator;
                 // If this results in an exception, previousIterator is closed in close() method.
                 nextIterator = nextRangeFunction.apply(nextKeys);
                 if (previousIterator != null)

File: src/java/org/apache/cassandra/index/sai/plan/Operation.java
Patch:
@@ -258,13 +258,13 @@ private static int getPriority(Operator op)
      */
     static KeyRangeIterator buildIterator(QueryController controller)
     {
-        var orderings = controller.indexFilter().getExpressions()
-                                  .stream().filter(e -> e.operator() == Operator.ANN).collect(Collectors.toList());
+        List<RowFilter.Expression> orderings = controller.indexFilter().getExpressions()
+                                                         .stream().filter(e -> e.operator() == Operator.ANN).collect(Collectors.toList());
         assert orderings.size() <= 1;
         if (controller.indexFilter().getExpressions().size() == 1 && orderings.size() == 1)
             // If we only have one expression, we just use the ANN index to order and limit.
             return controller.getTopKRows(orderings.get(0));
-        var iterator = Node.buildTree(controller.indexFilter()).analyzeTree(controller).rangeIterator(controller);
+        KeyRangeIterator iterator = Node.buildTree(controller.indexFilter()).analyzeTree(controller).rangeIterator(controller);
         if (orderings.isEmpty())
             return iterator;
         return controller.getTopKRows(iterator, orderings.get(0));

File: src/java/org/apache/cassandra/index/sai/utils/AtomicRatio.java
Patch:
@@ -54,7 +54,7 @@ public void update(long numerator, long denominator)
 
     public double get()
     {
-        var current = ratio.get();
+        Ratio current = ratio.get();
         return (double) current.numerator / current.denominator;
     }
 

File: src/java/org/apache/cassandra/audit/AuditLogManager.java
Patch:
@@ -51,6 +51,8 @@
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.MBeanWrapper;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 /**
  * Central location for managing the logging of client/user-initated actions (like queries, log in commands, and so on).
  *
@@ -387,7 +389,7 @@ private String obfuscatePasswordInformation(Exception e, List<String> queries)
         {
             for (String query : queries)
             {
-                if (query.toLowerCase().contains(PasswordObfuscator.PASSWORD_TOKEN))
+                if (toLowerCaseLocalized(query).contains(PasswordObfuscator.PASSWORD_TOKEN))
                     return "Syntax Exception. Obscured for security reasons.";
             }
         }

File: src/java/org/apache/cassandra/concurrent/Stage.java
Patch:
@@ -39,6 +39,7 @@
 
 import static java.util.stream.Collectors.toMap;
 import static org.apache.cassandra.concurrent.ExecutorFactory.Global.executorFactory;
+import static org.apache.cassandra.utils.LocalizeString.toUpperCaseLocalized;
 
 public enum Stage
 {
@@ -79,7 +80,7 @@ public enum Stage
     private static String normalizeName(String stageName)
     {
         // Handle discrepancy between JMX names and actual pool names
-        String upperStageName = stageName.toUpperCase();
+        String upperStageName = toUpperCaseLocalized(stageName);
         if (upperStageName.endsWith("STAGE"))
         {
             upperStageName = upperStageName.substring(0, stageName.length() - 5);

File: src/java/org/apache/cassandra/cql3/CQL3Type.java
Patch:
@@ -42,6 +42,7 @@
 import org.apache.cassandra.utils.ByteBufferUtil;
 
 import static java.util.stream.Collectors.toList;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 public interface CQL3Type
 {
@@ -139,7 +140,7 @@ public String toCQLLiteral(ByteBuffer buffer)
         @Override
         public String toString()
         {
-            return super.toString().toLowerCase();
+            return toLowerCaseLocalized(super.toString());
         }
     }
 

File: src/java/org/apache/cassandra/cql3/Duration.java
Patch:
@@ -30,6 +30,7 @@
 import static org.apache.cassandra.cql3.statements.RequestValidations.checkFalse;
 import static org.apache.cassandra.cql3.statements.RequestValidations.checkTrue;
 import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 import static org.apache.commons.lang3.time.DateUtils.MILLIS_PER_DAY;
 
 import io.netty.util.concurrent.FastThreadLocal;
@@ -251,7 +252,7 @@ private static long groupAsLong(Matcher matcher, int group)
 
     private static Builder add(Builder builder, long number, String symbol)
     {
-        switch (symbol.toLowerCase())
+        switch (toLowerCaseLocalized(symbol))
         {
             case "y": return builder.addYears(number);
             case "mo": return builder.addMonths(number);

File: src/java/org/apache/cassandra/cql3/FieldIdentifier.java
Patch:
@@ -17,13 +17,14 @@
  */
 package org.apache.cassandra.cql3;
 
-import java.util.Locale;
 import java.nio.ByteBuffer;
 
 import org.apache.cassandra.db.marshal.UTF8Type;
 import org.apache.cassandra.exceptions.SyntaxException;
 import org.apache.cassandra.serializers.MarshalException;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 /**
  * Identifies a field in a UDT.
  */
@@ -41,7 +42,7 @@ public FieldIdentifier(ByteBuffer bytes)
      */
     public static FieldIdentifier forUnquoted(String text)
     {
-        return new FieldIdentifier(convert(text == null ? null : text.toLowerCase(Locale.US)));
+        return new FieldIdentifier(convert(text == null ? null : toLowerCaseLocalized(text)));
     }
 
     /**

File: src/java/org/apache/cassandra/cql3/QualifiedName.java
Patch:
@@ -17,9 +17,10 @@
  */
 package org.apache.cassandra.cql3;
 
-import java.util.Locale;
 import java.util.Objects;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 /**
  * Class for the names of the keyspace-prefixed elements (e.g. table, index, view names)
  */
@@ -123,6 +124,6 @@ public boolean equals(Object o)
      */
     private static String toInternalName(String name, boolean keepCase)
     {
-        return keepCase ? name : name.toLowerCase(Locale.US);
+        return keepCase ? name : toLowerCaseLocalized(name);
     }
 }

File: src/java/org/apache/cassandra/cql3/ReservedKeywords.java
Patch:
@@ -30,6 +30,8 @@
 
 import org.apache.cassandra.exceptions.ConfigurationException;
 
+import static org.apache.cassandra.utils.LocalizeString.toUpperCaseLocalized;
+
 public final class ReservedKeywords
 {
     private static final String FILE_NAME = "reserved_keywords.txt";
@@ -58,6 +60,6 @@ private static Set<String> getFromResource()
 
     public static boolean isReserved(String text)
     {
-        return reservedKeywords.contains(text.toUpperCase());
+        return reservedKeywords.contains(toUpperCaseLocalized(text));
     }
 }

File: src/java/org/apache/cassandra/cql3/RoleName.java
Patch:
@@ -17,15 +17,15 @@
  */
 package org.apache.cassandra.cql3;
 
-import java.util.Locale;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 public class RoleName
 {
     private String name;
 
     public void setName(String name, boolean keepCase)
     {
-        this.name = keepCase ? name : (name == null ? name : name.toLowerCase(Locale.US));
+        this.name = keepCase ? name : (name == null ? name : toLowerCaseLocalized(name));
     }
 
     public boolean hasName()

File: src/java/org/apache/cassandra/cql3/SchemaElement.java
Patch:
@@ -18,7 +18,8 @@
 package org.apache.cassandra.cql3;
 
 import java.util.Comparator;
-import java.util.Locale;
+
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 /**
  * A schema element (keyspace, udt, udf, uda, table, index, view).
@@ -43,7 +44,7 @@ enum SchemaElementType
         @Override
         public String toString()
         {
-            return super.toString().toLowerCase(Locale.US);
+            return toLowerCaseLocalized(super.toString());
         }
     }
 

File: src/java/org/apache/cassandra/cql3/functions/CastFcts.java
Patch:
@@ -45,6 +45,7 @@
 import org.apache.cassandra.transport.ProtocolVersion;
 
 import static org.apache.cassandra.cql3.functions.TimeFcts.*;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 import org.apache.commons.lang3.StringUtils;
 
@@ -196,7 +197,7 @@ private static <O, I> CastFunction<?, O> wrapJavaFunction(AbstractType<I> inputT
 
     private static String toLowerCaseString(CQL3Type type)
     {
-        return type.toString().toLowerCase();
+        return toLowerCaseLocalized(type.toString());
     }
 
     /**

File: src/java/org/apache/cassandra/cql3/functions/FunctionResolver.java
Patch:
@@ -35,6 +35,7 @@
 
 import static java.util.stream.Collectors.joining;
 import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 public final class FunctionResolver
 {
@@ -46,7 +47,7 @@ public static ColumnSpecification makeArgSpec(String receiverKeyspace, String re
     {
         return new ColumnSpecification(receiverKeyspace,
                                        receiverTable,
-                                       new ColumnIdentifier("arg" + i + '(' + fun.name().toString().toLowerCase() + ')', true),
+                                       new ColumnIdentifier("arg" + i + '(' + toLowerCaseLocalized(fun.name().toString()) + ')', true),
                                        fun.argTypes().get(i));
     }
 

File: src/java/org/apache/cassandra/cql3/functions/masking/MaskingFunction.java
Patch:
@@ -26,6 +26,8 @@
 import org.apache.cassandra.cql3.functions.NativeScalarFunction;
 import org.apache.cassandra.db.marshal.AbstractType;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 /**
  * A {@link NativeScalarFunction} that totally or partially replaces the original value of a column value,
  * meant to obscure the real value of the column.
@@ -56,7 +58,7 @@ protected static abstract class Factory extends FunctionFactory
     {
         public Factory(String name, FunctionParameter... parameters)
         {
-            super(NAME_PREFIX + name.toLowerCase(), parameters);
+            super(NAME_PREFIX + toLowerCaseLocalized(name), parameters);
         }
     }
 }

File: src/java/org/apache/cassandra/cql3/functions/types/DataType.java
Patch:
@@ -23,6 +23,8 @@
 
 import org.apache.cassandra.transport.ProtocolVersion;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 /**
  * Data types supported by cassandra.
  */
@@ -122,7 +124,7 @@ public boolean isCompatibleWith(Name that)
         @Override
         public String toString()
         {
-            return super.toString().toLowerCase();
+            return toLowerCaseLocalized(super.toString());
         }
     }
 

File: src/java/org/apache/cassandra/cql3/functions/types/Duration.java
Patch:
@@ -23,6 +23,7 @@
 import com.google.common.base.Objects;
 
 import static com.google.common.base.Preconditions.checkArgument;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 /**
  * Represents a duration. A duration stores separately months, days, and seconds due to the fact
@@ -237,7 +238,7 @@ private static long groupAsLong(Matcher matcher, int group)
 
     private static Builder add(Builder builder, long number, String symbol)
     {
-        String s = symbol.toLowerCase();
+        String s = toLowerCaseLocalized(symbol);
         if (s.equals("y"))
         {
             return builder.addYears(number);

File: src/java/org/apache/cassandra/cql3/functions/types/Metadata.java
Patch:
@@ -19,6 +19,8 @@
 
 import org.apache.cassandra.cql3.ColumnIdentifier;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 /**
  * Keeps metadata on the connected cluster, including known nodes and schema definitions.
  */
@@ -65,7 +67,7 @@ else if (!((c >= 48 && c <= 57) // 0-9
         }
         if (isAlphanumeric)
         {
-            return id.toLowerCase();
+            return toLowerCaseLocalized(id);
         }
 
         // Check if it's enclosed in quotes. If it is, remove them and unescape internal double quotes

File: src/java/org/apache/cassandra/cql3/selection/Selectable.java
Patch:
@@ -42,6 +42,7 @@
 
 import static org.apache.cassandra.cql3.selection.SelectorFactories.createFactoriesAndCollectColumnDefinitions;
 import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 public interface Selectable extends AssignmentTestable
 {
@@ -447,7 +448,7 @@ public WithCast(Selectable arg, CQL3Type type)
         @Override
         public String toString()
         {
-            return String.format("cast(%s as %s)", arg, type.toString().toLowerCase());
+            return String.format("cast(%s as %s)", arg, toLowerCaseLocalized(type.toString()));
         }
 
         public Selector.Factory newSelectorFactory(TableMetadata table, AbstractType<?> expectedType, List<ColumnMetadata> defs, VariableSpecifications boundNames)

File: src/java/org/apache/cassandra/cql3/selection/Selection.java
Patch:
@@ -37,6 +37,8 @@
 import org.apache.cassandra.transport.ProtocolVersion;
 import org.apache.cassandra.utils.JsonUtils;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 public abstract class Selection
 {
     /**
@@ -327,7 +329,7 @@ private static List<ByteBuffer> rowToJson(List<ByteBuffer> row,
                 sb.append(", ");
 
             String columnName = spec.name.toString();
-            if (!columnName.equals(columnName.toLowerCase(Locale.US)))
+            if (!columnName.equals(toLowerCaseLocalized(columnName)))
                 columnName = "\"" + columnName + "\"";
 
             sb.append('"');

File: src/java/org/apache/cassandra/cql3/statements/PropertyDefinitions.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.cassandra.exceptions.SyntaxException;
 
 import static java.lang.String.format;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 public class PropertyDefinitions
 {
@@ -113,7 +114,7 @@ public static boolean parseBoolean(String key, String value) throws SyntaxExcept
         if (null == value)
             throw new IllegalArgumentException("value argument can't be null");
 
-        String lowerCasedValue = value.toLowerCase();
+        String lowerCasedValue = toLowerCaseLocalized(value);
 
         if (POSITIVE_PATTERN.matcher(lowerCasedValue).matches())
             return true;

File: src/java/org/apache/cassandra/db/compaction/OperationType.java
Patch:
@@ -17,6 +17,8 @@
  */
 package org.apache.cassandra.db.compaction;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 public enum OperationType
 {
     /** Each modification here should be also applied to {@link org.apache.cassandra.tools.nodetool.Stop#compactionType} */
@@ -69,7 +71,7 @@ public enum OperationType
     OperationType(String type, boolean writesData, int priority)
     {
         this.type = type;
-        this.fileName = type.toLowerCase().replace(" ", "");
+        this.fileName = toLowerCaseLocalized(type).replace(" ", "");
         this.writesData = writesData;
         this.priority = priority;
     }

File: src/java/org/apache/cassandra/db/lifecycle/LogRecord.java
Patch:
@@ -46,6 +46,8 @@
 import org.apache.cassandra.io.util.PathUtils;
 import org.apache.cassandra.utils.FBUtilities;
 
+import static org.apache.cassandra.utils.LocalizeString.toUpperCaseLocalized;
+
 /**
  * A decoded line in a transaction log file replica.
  *
@@ -63,7 +65,7 @@ public enum Type
 
         public static Type fromPrefix(String prefix)
         {
-            return valueOf(prefix.toUpperCase());
+            return valueOf(toUpperCaseLocalized(prefix));
         }
 
         public boolean hasFile()

File: src/java/org/apache/cassandra/db/marshal/EmptyType.java
Patch:
@@ -39,6 +39,7 @@
 import org.apache.cassandra.utils.NoSpamLogger;
 
 import static org.apache.cassandra.config.CassandraRelevantProperties.SERIALIZATION_EMPTY_TYPE_NONEMPTY_BEHAVIOR;
+import static org.apache.cassandra.utils.LocalizeString.toUpperCaseLocalized;
 
 /**
  * A type that only accept empty data.
@@ -59,7 +60,7 @@ private static NonEmptyWriteBehavior parseNonEmptyWriteBehavior()
             return NonEmptyWriteBehavior.FAIL;
         try
         {
-            return NonEmptyWriteBehavior.valueOf(value.toUpperCase().trim());
+            return NonEmptyWriteBehavior.valueOf(toUpperCaseLocalized(value).trim());
         }
         catch (Exception e)
         {

File: src/java/org/apache/cassandra/db/marshal/UserType.java
Patch:
@@ -50,6 +50,7 @@
 import static com.google.common.collect.Iterables.transform;
 import static org.apache.cassandra.config.CassandraRelevantProperties.TYPE_UDT_CONFLICT_BEHAVIOR;
 import static org.apache.cassandra.cql3.ColumnIdentifier.maybeQuote;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 /**
  * A user defined type.
@@ -274,7 +275,7 @@ public String toJSONString(ByteBuffer buffer, ProtocolVersion protocolVersion)
                 sb.append(", ");
 
             String name = stringFieldNames.get(i);
-            if (!name.equals(name.toLowerCase(Locale.US)))
+            if (!name.equals(toLowerCaseLocalized(name)))
                 name = "\"" + name + "\"";
 
             sb.append('"');

File: src/java/org/apache/cassandra/db/virtual/ClientsTable.java
Patch:
@@ -32,6 +32,8 @@
 import org.apache.cassandra.schema.TableMetadata;
 import org.apache.cassandra.transport.ConnectedClient;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 final class ClientsTable extends AbstractVirtualTable
 {
     private static final String ADDRESS = "address";
@@ -88,7 +90,7 @@ public DataSet data()
             result.row(remoteAddress.getAddress(), remoteAddress.getPort())
                   .column(HOSTNAME, remoteAddress.getHostName())
                   .column(USERNAME, client.username().orElse(null))
-                  .column(CONNECTION_STAGE, client.stage().toString().toLowerCase())
+                  .column(CONNECTION_STAGE, toLowerCaseLocalized(client.stage().toString()))
                   .column(PROTOCOL_VERSION, client.protocolVersion())
                   .column(CLIENT_OPTIONS, client.clientOptions().orElse(null))
                   .column(DRIVER_NAME, client.driverName().orElse(null))

File: src/java/org/apache/cassandra/db/virtual/CollectionVirtualTableAdapter.java
Patch:
@@ -85,6 +85,7 @@
 
 import static org.apache.cassandra.db.rows.Cell.NO_DELETION_TIME;
 import static org.apache.cassandra.utils.FBUtilities.camelToSnake;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 /**
  * This is a virtual table that iteratively builds rows using a data set provided by internal collection.
@@ -255,7 +256,7 @@ private static String camelToSnakeWithAbbreviations(String camel)
         Pattern pattern = Pattern.compile("^[A-Z1-9_]+$");
         // Contains only uppercase letters, numbers and underscores, so it's already snake case.
         if (pattern.matcher(camel).matches())
-            return camel.toLowerCase();
+            return toLowerCaseLocalized(camel);
 
         // Some special cases must be handled manually.
         String modifiedCamel = camel;

File: src/java/org/apache/cassandra/db/virtual/VirtualSchemaKeyspace.java
Patch:
@@ -29,6 +29,7 @@
 
 import static org.apache.cassandra.schema.SchemaConstants.VIRTUAL_SCHEMA;
 import static org.apache.cassandra.schema.TableMetadata.builder;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 public final class VirtualSchemaKeyspace extends VirtualKeyspace
 {
@@ -136,9 +137,9 @@ public DataSet data()
                     for (ColumnMetadata column : table.columns())
                     {
                         result.row(column.ksName, column.cfName, column.name.toString())
-                              .column(CLUSTERING_ORDER, column.clusteringOrder().toString().toLowerCase())
+                              .column(CLUSTERING_ORDER, toLowerCaseLocalized(column.clusteringOrder().toString()))
                               .column(COLUMN_NAME_BYTES, column.name.bytes)
-                              .column(KIND, column.kind.toString().toLowerCase())
+                              .column(KIND, toLowerCaseLocalized(column.kind.toString()))
                               .column(POSITION, column.position())
                               .column(TYPE, column.type.asCQL3Type().toString());
                     }

File: src/java/org/apache/cassandra/index/sai/analyzer/filter/BasicFilters.java
Patch:
@@ -23,6 +23,8 @@
 
 import org.apache.lucene.analysis.miscellaneous.ASCIIFoldingFilter;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 public class BasicFilters
 {
     private static final Locale DEFAULT_LOCALE = Locale.getDefault();
@@ -39,7 +41,7 @@ public LowerCase()
         @Override
         public String process(String input)
         {
-            return input.toLowerCase(locale);
+            return toLowerCaseLocalized(input, locale);
         }
     }
 

File: src/java/org/apache/cassandra/index/sai/disk/v1/IndexWriterConfig.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.cassandra.index.sai.utils.IndexTermType;
 
 import static org.apache.cassandra.config.CassandraRelevantProperties.SAI_VECTOR_SEARCH_MAX_TOP_K;
+import static org.apache.cassandra.utils.LocalizeString.toUpperCaseLocalized;
 
 /**
  * Per-index config for storage-attached index writers.
@@ -151,7 +152,7 @@ public static IndexWriterConfig fromOptions(String indexName, IndexTermType inde
             }
             if (options.containsKey(SIMILARITY_FUNCTION))
             {
-                String option = options.get(SIMILARITY_FUNCTION).toUpperCase();
+                String option = toUpperCaseLocalized(options.get(SIMILARITY_FUNCTION));
                 try
                 {
                     similarityFunction = VectorSimilarityFunction.valueOf(option);
@@ -164,7 +165,7 @@ public static IndexWriterConfig fromOptions(String indexName, IndexTermType inde
             }
             if (options.containsKey(OPTIMIZE_FOR))
             {
-                String option = options.get(OPTIMIZE_FOR).toUpperCase();
+                String option = toUpperCaseLocalized(options.get(OPTIMIZE_FOR));
                 try
                 {
                     optimizeFor = OptimizeFor.valueOf(option);

File: src/java/org/apache/cassandra/index/sai/disk/v1/vector/OptimizeFor.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.function.Function;
 
 import static java.lang.Math.pow;
+import static org.apache.cassandra.utils.LocalizeString.toUpperCaseLocalized;
 
 /**
  * Allows the vector index searches to be optimised for latency or recall. This is used by the
@@ -47,6 +48,6 @@ public int topKFor(int limit)
 
     public static OptimizeFor fromString(String value)
     {
-        return valueOf(value.toUpperCase());
+        return valueOf(toUpperCaseLocalized(value));
     }
 }

File: src/java/org/apache/cassandra/index/sasi/disk/OnDiskIndexBuilder.java
Patch:
@@ -43,6 +43,8 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import static org.apache.cassandra.utils.LocalizeString.toUpperCaseLocalized;
+
 public class OnDiskIndexBuilder
 {
     private static final Logger logger = LoggerFactory.getLogger(OnDiskIndexBuilder.class);
@@ -62,7 +64,7 @@ public enum Mode
 
         public static Mode mode(String mode)
         {
-            return Mode.valueOf(mode.toUpperCase());
+            return Mode.valueOf(toUpperCaseLocalized(mode));
         }
 
         public boolean supports(Op op)

File: src/java/org/apache/cassandra/metrics/CassandraMetricsRegistry.java
Patch:
@@ -22,7 +22,6 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
-import java.util.Locale;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
@@ -74,6 +73,7 @@
 import static org.apache.cassandra.db.virtual.CollectionVirtualTableAdapter.createSinglePartitionedKeyFiltered;
 import static org.apache.cassandra.db.virtual.CollectionVirtualTableAdapter.createSinglePartitionedValueFiltered;
 import static org.apache.cassandra.schema.SchemaConstants.VIRTUAL_METRICS;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 /**
  * Dropwizard metrics registry extension for Cassandra, as of for now uses the latest version of Dropwizard metrics
@@ -810,7 +810,7 @@ public String getRateUnit()
 
         private String calculateRateUnit(TimeUnit unit)
         {
-            final String s = unit.toString().toLowerCase(Locale.US);
+            final String s = toLowerCaseLocalized(unit.toString());
             return s.substring(0, s.length() - 1);
         }
     }
@@ -861,7 +861,7 @@ private JmxTimer(Timer metric,
         {
             super(metric, objectName, rateUnit);
             this.metric = metric;
-            this.durationUnit = durationUnit.toString().toLowerCase(Locale.US);
+            this.durationUnit = toLowerCaseLocalized(durationUnit.toString());
         }
 
         @Override

File: src/java/org/apache/cassandra/schema/CachingParams.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.cassandra.exceptions.ConfigurationException;
 
 import static java.lang.String.format;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 // CQL: {'keys' : 'ALL'|'NONE', 'rows_per_partition': '200'|'NONE'|'ALL'}
 public final class CachingParams
@@ -40,7 +41,7 @@ public enum Option
         @Override
         public String toString()
         {
-            return name().toLowerCase();
+            return toLowerCaseLocalized(name());
         }
     }
 

File: src/java/org/apache/cassandra/schema/IndexMetadata.java
Patch:
@@ -49,6 +49,7 @@
 import org.apache.cassandra.utils.UUIDSerializer;
 
 import static org.apache.cassandra.db.TypeSizes.sizeof;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 /**
  * An immutable representation of secondary index metadata.
@@ -72,7 +73,7 @@ public final class IndexMetadata
     static
     {
         indexNameAliases.put(StorageAttachedIndex.NAME, StorageAttachedIndex.class.getCanonicalName());
-        indexNameAliases.put(StorageAttachedIndex.class.getSimpleName().toLowerCase(), StorageAttachedIndex.class.getCanonicalName());
+        indexNameAliases.put(toLowerCaseLocalized(StorageAttachedIndex.class.getSimpleName()), StorageAttachedIndex.class.getCanonicalName());
         indexNameAliases.put(SASIIndex.class.getSimpleName(), SASIIndex.class.getCanonicalName());
     }
 
@@ -159,7 +160,7 @@ public String getIndexClassName()
         if (isCustom())
         {
             String className = options.get(IndexTarget.CUSTOM_INDEX_OPTION_NAME);
-            return indexNameAliases.getOrDefault(className.toLowerCase(), className);
+            return indexNameAliases.getOrDefault(toLowerCaseLocalized(className), className);
         }
         return CassandraIndex.class.getName();
     }

File: src/java/org/apache/cassandra/schema/KeyspaceParams.java
Patch:
@@ -32,6 +32,8 @@
 import org.apache.cassandra.tcm.serialization.MetadataSerializer;
 import org.apache.cassandra.tcm.serialization.Version;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 /**
  * An immutable class representing keyspace parameters (durability and replication).
  */
@@ -57,7 +59,7 @@ public enum Option
         @Override
         public String toString()
         {
-            return name().toLowerCase();
+            return toLowerCaseLocalized(name());
         }
     }
 

File: src/java/org/apache/cassandra/schema/TableParams.java
Patch:
@@ -44,6 +44,7 @@
 import static java.util.stream.Collectors.toMap;
 import static org.apache.cassandra.schema.TableParams.Option.*;
 import static org.apache.cassandra.db.TypeSizes.sizeof;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 public final class TableParams
 {
@@ -73,7 +74,7 @@ public enum Option
         @Override
         public String toString()
         {
-            return name().toLowerCase();
+            return toLowerCaseLocalized(name());
         }
     }
 

File: src/java/org/apache/cassandra/security/JKSKeyProvider.java
Patch:
@@ -29,6 +29,8 @@
 import org.apache.cassandra.config.TransparentDataEncryptionOptions;
 import org.apache.cassandra.io.util.File;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 /**
  * A {@code KeyProvider} that retrieves keys from a java keystore.
  */
@@ -64,7 +66,7 @@ public Key getSecretKey(String keyAlias) throws IOException
     {
         // there's a lovely behavior with jceks files that all aliases are lower-cased
         if (isJceks)
-            keyAlias = keyAlias.toLowerCase();
+            keyAlias = toLowerCaseLocalized(keyAlias);
 
         Key key;
         try

File: src/java/org/apache/cassandra/security/SSLFactory.java
Patch:
@@ -48,6 +48,7 @@
 import static org.apache.cassandra.config.CassandraRelevantProperties.DISABLE_TCACTIVE_OPENSSL;
 
 import static org.apache.cassandra.config.EncryptionOptions.ClientAuth.REQUIRED;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 /**
  * A Factory for providing and setting up client {@link SSLSocket}s. Also provides
@@ -337,7 +338,7 @@ public String[] filterCipherSuites(Iterable<String> ciphers, List<String> defaul
                     if (settingDescription != null)
                     {
                         logger.warn("Dropping unsupported cipher_suite {} from {} configuration",
-                                    c, settingDescription.toLowerCase());
+                                    c, toLowerCaseLocalized(settingDescription));
                     }
                 }
             }

File: src/java/org/apache/cassandra/serializers/CollectionSerializer.java
Patch:
@@ -23,7 +23,6 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
-import java.util.Locale;
 import java.util.function.Consumer;
 
 import com.google.common.collect.Range;
@@ -34,6 +33,8 @@
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 public abstract class CollectionSerializer<T> extends TypeSerializer<T>
 {
     protected abstract List<ByteBuffer> serializeValues(T value);
@@ -110,7 +111,7 @@ public <V> List<V> unpack(V input, ValueAccessor<V> accessor)
      */
     private String getCollectionName()
     {
-        return getType().getSimpleName().toLowerCase(Locale.US);
+        return toLowerCaseLocalized(getType().getSimpleName());
     }
 
     /**

File: src/java/org/apache/cassandra/service/StartupChecks.java
Patch:
@@ -80,6 +80,7 @@
 import static org.apache.cassandra.config.CassandraRelevantProperties.JAVA_VERSION;
 import static org.apache.cassandra.config.CassandraRelevantProperties.JAVA_VM_NAME;
 import static org.apache.cassandra.utils.Clock.Global.currentTimeMillis;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 /**
  * Verifies that the system and environment is in a fit state to be started.
@@ -217,7 +218,7 @@ public void execute(StartupChecksOptions startupChecksOptions) throws StartupExc
             {
                 try
                 {
-                    if (affectedFileSystemTypes.contains(Files.getFileStore(path).type().toLowerCase()))
+                    if (affectedFileSystemTypes.contains(toLowerCaseLocalized(Files.getFileStore(path).type())))
                         affectedPaths.add(path);
                 }
                 catch (IOException e)

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -177,6 +177,7 @@
 import static org.apache.cassandra.service.paxos.v1.ProposeVerbHandler.doPropose;
 import static org.apache.cassandra.utils.Clock.Global.currentTimeMillis;
 import static org.apache.cassandra.utils.Clock.Global.nanoTime;
+import static org.apache.cassandra.utils.LocalizeString.toUpperCaseLocalized;
 import static org.apache.cassandra.utils.TimeUUID.Generator.nextTimeUUID;
 import static org.apache.cassandra.utils.concurrent.CountDownLatch.newCountDownLatch;
 import static org.apache.commons.lang3.StringUtils.join;
@@ -2835,7 +2836,7 @@ public String getIdealConsistencyLevel()
     public String setIdealConsistencyLevel(String cl)
     {
         ConsistencyLevel original = DatabaseDescriptor.getIdealConsistencyLevel();
-        ConsistencyLevel newCL = ConsistencyLevel.valueOf(cl.trim().toUpperCase());
+        ConsistencyLevel newCL = ConsistencyLevel.valueOf(toUpperCaseLocalized(cl.trim()));
         DatabaseDescriptor.setIdealConsistencyLevel(newCL);
         return String.format("Updating ideal consistency level new value: %s old value %s", newCL, original.toString());
     }

File: src/java/org/apache/cassandra/service/paxos/ContentionStrategy.java
Patch:
@@ -52,6 +52,7 @@
 import static org.apache.cassandra.metrics.ClientRequestsMetricsHolder.casWriteMetrics;
 import static org.apache.cassandra.utils.Clock.Global.nanoTime;
 import static org.apache.cassandra.utils.Clock.waitUntil;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 /**
  * <p>A strategy for making back-off decisions for Paxos operations that fail to make progress because of other paxos operations.
@@ -369,7 +370,7 @@ public enum Type
         Type(String traceTitle)
         {
             this.traceTitle = traceTitle;
-            this.lowercase = name().toLowerCase();
+            this.lowercase = toLowerCaseLocalized(name());
         }
     }
 

File: src/java/org/apache/cassandra/service/reads/HybridSpeculativeRetryPolicy.java
Patch:
@@ -27,6 +27,8 @@
 import org.apache.cassandra.metrics.SnapshottingTimer;
 import org.apache.cassandra.schema.TableParams;
 
+import static org.apache.cassandra.utils.LocalizeString.toUpperCaseLocalized;
+
 public class HybridSpeculativeRetryPolicy implements SpeculativeRetryPolicy
 {
     private static final Pattern PATTERN =
@@ -128,7 +130,7 @@ static HybridSpeculativeRetryPolicy fromString(String str)
         SpeculativeRetryPolicy policy1 = value1 instanceof PercentileSpeculativeRetryPolicy ? value1 : value2;
         SpeculativeRetryPolicy policy2 = value1 instanceof FixedSpeculativeRetryPolicy ? value1 : value2;
 
-        Function function = Function.valueOf(matcher.group("fun").toUpperCase());
+        Function function = Function.valueOf(toUpperCaseLocalized(matcher.group("fun")));
         return new HybridSpeculativeRetryPolicy((PercentileSpeculativeRetryPolicy) policy1, (FixedSpeculativeRetryPolicy) policy2, function);
     }
 

File: src/java/org/apache/cassandra/service/reads/repair/ReadRepairStrategy.java
Patch:
@@ -23,6 +23,8 @@
 import org.apache.cassandra.locator.ReplicaPlan;
 import org.apache.cassandra.transport.Dispatcher;
 
+import static org.apache.cassandra.utils.LocalizeString.toUpperCaseLocalized;
+
 public enum ReadRepairStrategy implements ReadRepair.Factory
 {
     NONE
@@ -45,6 +47,6 @@ ReadRepair<E, P> create(ReadCommand command, ReplicaPlan.Shared<E, P> replicaPla
 
     public static ReadRepairStrategy fromString(String s)
     {
-        return valueOf(s.toUpperCase());
+        return valueOf(toUpperCaseLocalized(s));
     }
 }

File: src/java/org/apache/cassandra/streaming/StreamResultFuture.java
Patch:
@@ -36,6 +36,7 @@
 
 import static org.apache.cassandra.streaming.StreamingChannel.Factory.Global.streamingFactory;
 import static org.apache.cassandra.utils.Clock.Global.nanoTime;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 /**
  * A future on the result ({@link StreamState}) of a streaming plan.
@@ -198,7 +199,7 @@ void handleSessionPrepared(StreamSession session, StreamSession.PrepareDirection
 
     void handleSessionComplete(StreamSession session)
     {
-        logger.info("[Stream #{}] Session with {} is {}", session.planId(), session.peer, session.state().name().toLowerCase());
+        logger.info("[Stream #{}] Session with {} is {}", session.planId(), session.peer, toLowerCaseLocalized(session.state().name()));
         fireStreamEvent(new StreamEvent.SessionCompleteEvent(session));
         SessionInfo sessionInfo = session.getSessionInfo();
         coordinator.addSessionInfo(sessionInfo);

File: src/java/org/apache/cassandra/streaming/StreamingState.java
Patch:
@@ -42,6 +42,7 @@
 import org.apache.cassandra.utils.ObjectSizes;
 import org.apache.cassandra.utils.TimeUUID;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 import static org.apache.cassandra.utils.TimeUUID.Generator.nextTimeUUID;
 
 public class StreamingState implements StreamEventHandler, IMeasurableMemory
@@ -214,14 +215,14 @@ public String toString()
     {
         TableBuilder table = new TableBuilder();
         table.add("id", id.toString());
-        table.add("status", status().name().toLowerCase());
+        table.add("status", toLowerCaseLocalized(status().name()));
         table.add("progress", (progress() * 100) + "%");
         table.add("duration_ms", Long.toString(durationMillis()));
         table.add("last_updated_ms", Long.toString(lastUpdatedAtMillis()));
         table.add("failure_cause", failureCause());
         table.add("success_message", successMessage());
         for (Map.Entry<Status, Long> e : stateTimesMillis().entrySet())
-            table.add("status_" + e.getKey().name().toLowerCase() + "_ms", e.toString());
+            table.add("status_" + toLowerCaseLocalized(e.getKey().name()) + "_ms", e.toString());
         return table.toString();
     }
 

File: src/java/org/apache/cassandra/tcm/MetadataKeys.java
Patch:
@@ -29,9 +29,11 @@
 import org.apache.cassandra.tcm.extensions.ExtensionKey;
 import org.apache.cassandra.tcm.extensions.ExtensionValue;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 public class MetadataKeys
 {
-    public static final String CORE_NS = MetadataKeys.class.getPackage().getName().toLowerCase(Locale.ROOT);
+    public static final String CORE_NS = toLowerCaseLocalized(MetadataKeys.class.getPackage().getName(), Locale.ROOT);
 
     public static final MetadataKey SCHEMA                  = make(CORE_NS, "schema", "dist_schema");
     public static final MetadataKey NODE_DIRECTORY          = make(CORE_NS, "membership", "node_directory");

File: src/java/org/apache/cassandra/tools/RepairRunner.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.List;
 import java.util.Map;
 
+import org.apache.cassandra.service.ActiveRepairService.ParentRepairStatus;
 import org.apache.cassandra.service.StorageServiceMBean;
 import org.apache.cassandra.utils.concurrent.Condition;
 
@@ -32,10 +33,10 @@
 
 import static org.apache.cassandra.utils.Clock.Global.currentTimeMillis;
 import static java.util.concurrent.TimeUnit.SECONDS;
-import static org.apache.cassandra.service.ActiveRepairService.ParentRepairStatus;
 import static org.apache.cassandra.service.ActiveRepairService.ParentRepairStatus.FAILED;
 import static org.apache.cassandra.service.ActiveRepairService.ParentRepairStatus.valueOf;
 import static org.apache.cassandra.tools.NodeProbe.JMX_NOTIFICATION_POLL_INTERVAL_SECONDS;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 import static org.apache.cassandra.utils.concurrent.Condition.newOneTimeCondition;
 import static org.apache.cassandra.utils.progress.ProgressEventType.*;
 
@@ -165,7 +166,7 @@ private void queryForCompletedRepair(String triggeringCondition)
                 case FAILED:
                     printMessage(String.format("%s %s discovered repair %s.",
                                               triggeringCondition,
-                                              queriedString, parentRepairStatus.name().toLowerCase()));
+                                              queriedString, toLowerCaseLocalized(parentRepairStatus.name())));
                     if (parentRepairStatus == FAILED)
                     {
                         error = new IOException(messages.get(0));

File: src/java/org/apache/cassandra/tools/nodetool/ProfileLoad.java
Patch:
@@ -41,6 +41,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
+import static org.apache.cassandra.utils.LocalizeString.toUpperCaseLocalized;
 import static org.apache.commons.lang3.StringUtils.join;
 
 @Command(name = "profileload", description = "Low footprint profiling of activity for a period of time")
@@ -113,7 +114,7 @@ else if (args.size() == 1)
         Set<String> available = Arrays.stream(SamplerType.values()).map(Enum::toString).collect(Collectors.toSet());
         for (String s : samplers.split(","))
         {
-            String sampler = s.trim().toUpperCase();
+            String sampler = toUpperCaseLocalized(s.trim());
             checkArgument(available.contains(sampler), String.format("'%s' sampler is not available from: %s", s, Arrays.toString(SamplerType.values())));
             targets.add(sampler);
         }

File: src/java/org/apache/cassandra/transport/CBUtil.java
Patch:
@@ -47,6 +47,7 @@
 import org.apache.cassandra.utils.memory.MemoryUtil;
 
 import static org.apache.cassandra.config.CassandraRelevantProperties.CASSANDRA_NETTY_USE_HEAP_ALLOCATOR;
+import static org.apache.cassandra.utils.LocalizeString.toUpperCaseLocalized;
 
 /**
  * ByteBuf utility methods.
@@ -285,7 +286,7 @@ public static <T extends Enum<T>> T readEnumValue(Class<T> enumType, ByteBuf cb)
         String value = CBUtil.readString(cb);
         try
         {
-            return Enum.valueOf(enumType, value.toUpperCase());
+            return Enum.valueOf(enumType, toUpperCaseLocalized(value));
         }
         catch (IllegalArgumentException e)
         {
@@ -399,7 +400,7 @@ public static Map<String, List<String>> readStringToStringListMap(ByteBuf cb)
         Map<String, List<String>> m = new HashMap<String, List<String>>(length);
         for (int i = 0; i < length; i++)
         {
-            String k = readString(cb).toUpperCase();
+            String k = toUpperCaseLocalized(readString(cb));
             List<String> v = readStringList(cb);
             m.put(k, v);
         }

File: src/java/org/apache/cassandra/utils/GuidGenerator.java
Patch:
@@ -23,6 +23,7 @@
 
 import static org.apache.cassandra.config.CassandraRelevantProperties.JAVA_SECURITY_EGD;
 import static org.apache.cassandra.utils.Clock.Global.currentTimeMillis;
+import static org.apache.cassandra.utils.LocalizeString.toUpperCaseLocalized;
 
 public class GuidGenerator
 {
@@ -101,7 +102,7 @@ public static ByteBuffer guidAsBytes()
 
     private static String convertToStandardFormat(String valueAfterMD5)
     {
-        String raw = valueAfterMD5.toUpperCase();
+        String raw = toUpperCaseLocalized(valueAfterMD5);
         StringBuilder sb = new StringBuilder();
         sb.append(raw.substring(0, 8))
           .append("-")

File: src/java/org/apache/cassandra/utils/JsonUtils.java
Patch:
@@ -23,7 +23,6 @@
 import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Locale;
 import java.util.Map;
 
 import com.fasterxml.jackson.core.JsonFactory;
@@ -38,6 +37,7 @@
 import org.apache.cassandra.serializers.MarshalException;
 
 import static org.apache.cassandra.io.util.File.WriteMode.OVERWRITE;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 public final class JsonUtils
 {
@@ -203,7 +203,7 @@ public static void handleCaseSensitivity(Map<String, Object> valueMap)
             }
 
             // otherwise, lowercase it if needed
-            String lowered = mapKey.toLowerCase(Locale.US);
+            String lowered = toLowerCaseLocalized(mapKey);
             if (!mapKey.equals(lowered))
                 valueMap.put(lowered, valueMap.remove(mapKey));
         }

File: src/java/org/apache/cassandra/utils/NativeLibrary.java
Patch:
@@ -35,6 +35,7 @@
 import static org.apache.cassandra.config.CassandraRelevantProperties.IGNORE_MISSING_NATIVE_FILE_HINTS;
 import static org.apache.cassandra.config.CassandraRelevantProperties.OS_ARCH;
 import static org.apache.cassandra.config.CassandraRelevantProperties.OS_NAME;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 import static org.apache.cassandra.utils.NativeLibrary.OSType.LINUX;
 import static org.apache.cassandra.utils.NativeLibrary.OSType.MAC;
 import static org.apache.cassandra.utils.NativeLibrary.OSType.AIX;
@@ -102,7 +103,7 @@ public enum OSType
             default: wrappedLibrary = new NativeLibraryLinux();
         }
 
-        if (OS_ARCH.getString().toLowerCase().contains("ppc"))
+        if (toLowerCaseLocalized(OS_ARCH.getString()).contains("ppc"))
         {
             if (osType == LINUX)
             {
@@ -134,7 +135,7 @@ private NativeLibrary() {}
      */
     private static OSType getOsType()
     {
-        String osName = OS_NAME.getString().toLowerCase();
+        String osName = toLowerCaseLocalized(OS_NAME.getString());
         if  (osName.contains("linux"))
             return LINUX;
         else if (osName.contains("mac"))

File: src/java/org/apache/cassandra/utils/binlog/BinLog.java
Patch:
@@ -54,6 +54,7 @@
 
 import static java.lang.String.format;
 import static org.apache.cassandra.config.CassandraRelevantProperties.CHRONICLE_ANNOUNCER_DISABLE;
+import static org.apache.cassandra.utils.LocalizeString.toUpperCaseLocalized;
 
 /**
  * Bin log is a is quick and dirty binary log that is kind of a NIH version of binary logging with a traditional logging
@@ -389,7 +390,7 @@ public Builder path(Path path)
         public Builder rollCycle(String rollCycle)
         {
             Preconditions.checkNotNull(rollCycle, "rollCycle was null");
-            rollCycle = rollCycle.toUpperCase();
+            rollCycle = toUpperCaseLocalized(rollCycle);
             Preconditions.checkNotNull(RollCycles.valueOf(rollCycle), "unrecognized roll cycle");
             this.rollCycle = rollCycle;
             return this;

File: test/distributed/org/apache/cassandra/distributed/Cluster.java
Patch:
@@ -29,6 +29,8 @@
 import org.apache.cassandra.distributed.shared.Versions;
 import org.apache.cassandra.net.Message;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 /**
  * A simple cluster supporting only the 'current' Cassandra version, offering easy access to the convenience methods
  * of IInvokableInstance on each node.
@@ -81,7 +83,7 @@ public void enableMessageLogging()
             {
                 get(1).acceptsOnInstance((IIsolatedExecutor.SerializableConsumer<IMessage>) (msgPassed) -> {
                     Message decoded = Instance.deserializeMessage(msgPassed);
-                    if (!decoded.verb().toString().toLowerCase().contains("gossip"))
+                    if (!toLowerCaseLocalized(decoded.verb().toString()).contains("gossip"))
                         System.out.println(String.format("MSG %d -> %d: %s | %s", from, to, decoded, decoded.payload));
                 }).accept(msg);
             }

File: test/distributed/org/apache/cassandra/distributed/test/FailingRepairTest.java
Patch:
@@ -76,6 +76,8 @@
 import org.apache.cassandra.service.StorageService;
 import org.awaitility.Awaitility;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 @RunWith(Parameterized.class)
 public class FailingRepairTest extends TestBaseImpl implements Serializable
 {
@@ -132,7 +134,7 @@ private static SerializableRunnable failingReaders(Verb type, RepairParallelism
 
     private static String getCfName(Verb type, RepairParallelism parallelism, boolean withTracing)
     {
-        return type.name().toLowerCase() + "_" + parallelism.name().toLowerCase() + "_" + withTracing;
+        return toLowerCaseLocalized(type.name()) + "_" + toLowerCaseLocalized(parallelism.name()) + "_" + withTracing;
     }
 
     @BeforeClass

File: test/distributed/org/apache/cassandra/distributed/test/ReadDigestConsistencyTest.java
Patch:
@@ -33,6 +33,8 @@
 import org.apache.cassandra.utils.Throwables;
 import org.apache.cassandra.utils.TimeUUID;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 public class ReadDigestConsistencyTest extends TestBaseImpl
 {
     private final static Logger logger = LoggerFactory.getLogger(ReadDigestConsistencyTest.class);
@@ -101,7 +103,7 @@ public static void checkTraceForDigestMismatch(ICoordinator coordinator, String
                                              Arrays.toString(boundValues),
                                              coordinator.instance().broadcastAddress(),
                                              coordinator.instance().getReleaseVersionString()),
-                               activity.toLowerCase().contains("mismatch for key"));
+                                             toLowerCaseLocalized(activity).contains("mismatch for key"));
         }
     }
 

File: test/distributed/org/apache/cassandra/distributed/test/RepairCoordinatorBase.java
Patch:
@@ -35,6 +35,7 @@
 import org.apache.cassandra.distributed.test.DistributedRepairUtils.RepairType;
 
 import static org.apache.cassandra.config.CassandraRelevantProperties.NODETOOL_JMX_NOTIFICATION_POLL_INTERVAL_SECONDS;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 public class RepairCoordinatorBase extends TestBaseImpl
 {
@@ -98,7 +99,7 @@ protected String tableName(String prefix) {
 
     protected String postfix()
     {
-        return repairType.name().toLowerCase() + "_" + parallelism.name().toLowerCase() + "_" + withNotifications;
+        return toLowerCaseLocalized(repairType.name()) + "_" + toLowerCaseLocalized(parallelism.name()) + "_" + withNotifications;
     }
 
     protected NodeToolResult repair(int node, String... args) {

File: test/distributed/org/apache/cassandra/distributed/test/RepairCoordinatorFailingMessageTest.java
Patch:
@@ -42,6 +42,7 @@
 
 import static java.lang.String.format;
 import static org.apache.cassandra.distributed.api.IMessageFilters.Matcher.of;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 @RunWith(Parameterized.class)
 @Ignore("Until CASSANDRA-15566 is in these tests all time out")
@@ -100,7 +101,7 @@ private String tableName(String prefix) {
 
     private String postfix()
     {
-        return repairType.name().toLowerCase();
+        return toLowerCaseLocalized(repairType.name());
     }
 
     private NodeToolResult repair(int node, String... args) {

File: test/distributed/org/apache/cassandra/distributed/test/SSTableIdGenerationTest.java
Patch:
@@ -67,6 +67,7 @@
 import static org.apache.cassandra.db.SystemKeyspace.SSTABLE_ACTIVITY_V2;
 import static org.apache.cassandra.distributed.shared.FutureUtils.waitOn;
 import static org.apache.cassandra.distributed.test.ExecUtil.rethrow;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class SSTableIdGenerationTest extends TestBaseImpl
@@ -176,7 +177,7 @@ private final void testCompactionStrategiesWithMixedSSTables(final Class<? exten
             // create a table and two sstables with sequential id for each strategy, the sstables will contain overlapping partitions
             for (Class<? extends AbstractCompactionStrategy> compactionStrategyClass : compactionStrategyClasses)
             {
-                String tableName = "tbl_" + compactionStrategyClass.getSimpleName().toLowerCase();
+                String tableName = "tbl_" + toLowerCaseLocalized(compactionStrategyClass.getSimpleName());
                 cluster.schemaChange(createTableStmt(KEYSPACE, tableName, compactionStrategyClass));
 
                 createSSTables(cluster.get(1), KEYSPACE, tableName, 1, 2);
@@ -189,7 +190,7 @@ private final void testCompactionStrategiesWithMixedSSTables(final Class<? exten
             // create another two sstables with uuid for each previously created table
             for (Class<? extends AbstractCompactionStrategy> compactionStrategyClass : compactionStrategyClasses)
             {
-                String tableName = "tbl_" + compactionStrategyClass.getSimpleName().toLowerCase();
+                String tableName = "tbl_" + toLowerCaseLocalized(compactionStrategyClass.getSimpleName());
 
                 createSSTables(cluster.get(1), KEYSPACE, tableName, 3, 4);
 

File: test/simulator/main/org/apache/cassandra/simulator/Action.java
Patch:
@@ -897,7 +897,7 @@ private String describeModifiers()
                 continue;
 
             if (!transitive.is(modifier)) builder.append(modifier.displayId);
-            else builder.append(Character.toUpperCase(modifier.displayId));
+            else builder.append(Character.toUpperCase(modifier.displayId)); // checkstyle: permit this invocation
         }
 
         boolean hasTransitiveOnly = false;

File: test/simulator/main/org/apache/cassandra/simulator/SimulationRunner.java
Patch:
@@ -81,6 +81,7 @@
 import static org.apache.cassandra.simulator.debug.SelfReconcile.reconcileWithSelf;
 import static org.apache.cassandra.simulator.utils.IntRange.parseRange;
 import static org.apache.cassandra.simulator.utils.LongRange.parseNanosRange;
+import static org.apache.cassandra.utils.LocalizeString.toUpperCaseLocalized;
 
 @SuppressWarnings({ "ZeroLengthArrayAllocation", "CodeBlock2Expr", "SameParameterValue", "DynamicRegexReplaceableByCompiledPattern", "CallToSystemGC" })
 public class SimulationRunner
@@ -281,15 +282,15 @@ protected void propagate(B builder)
             Optional.ofNullable(topologyChanges).ifPresent(topologyChanges -> {
                 builder.topologyChanges(stream(topologyChanges.split(","))
                                         .filter(v -> !v.isEmpty())
-                                        .map(v -> TopologyChange.valueOf(v.toUpperCase()))
+                                        .map(v -> TopologyChange.valueOf(toUpperCaseLocalized(v)))
                                         .toArray(TopologyChange[]::new));
             });
             parseNanosRange(Optional.ofNullable(topologyChangeInterval)).ifPresent(builder::topologyChangeIntervalNanos);
             builder.topologyChangeLimit(Integer.parseInt(topologyChangeLimit));
             Optional.ofNullable(priority).ifPresent(kinds -> {
                 builder.scheduler(stream(kinds.split(","))
                                   .filter(v -> !v.isEmpty())
-                                  .map(v -> RunnableActionScheduler.Kind.valueOf(v.toUpperCase()))
+                                  .map(v -> RunnableActionScheduler.Kind.valueOf(toUpperCaseLocalized(v)))
                                   .toArray(RunnableActionScheduler.Kind[]::new));
             });
 

File: test/unit/org/apache/cassandra/SchemaLoader.java
Patch:
@@ -52,6 +52,7 @@
 import static org.apache.cassandra.config.CassandraRelevantProperties.TEST_COMPRESSION;
 import static org.apache.cassandra.config.CassandraRelevantProperties.TEST_COMPRESSION_ALGO;
 import static org.apache.cassandra.utils.Clock.Global.currentTimeMillis;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 public class SchemaLoader
 {
@@ -745,7 +746,7 @@ public static void cleanupSavedCaches()
 
     private static CompressionParams compressionParams(int chunkLength)
     {
-        String algo = TEST_COMPRESSION_ALGO.getString().toLowerCase();
+        String algo = toLowerCaseLocalized(TEST_COMPRESSION_ALGO.getString());
         switch (algo)
         {
             case "deflate":

File: test/unit/org/apache/cassandra/auth/CassandraNetworkAuthorizerTest.java
Patch:
@@ -41,6 +41,7 @@
 import static org.apache.cassandra.auth.AuthTestUtils.auth;
 import static org.apache.cassandra.auth.AuthTestUtils.getRolesReadCount;
 import static org.apache.cassandra.schema.SchemaConstants.AUTH_KEYSPACE_NAME;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
@@ -100,7 +101,7 @@ private static void assertDcPermRow(String username, String... dcs)
 
     private static String createName()
     {
-        return RandomStringUtils.randomAlphabetic(8).toLowerCase();
+        return toLowerCaseLocalized(RandomStringUtils.randomAlphabetic(8));
     }
 
     private static DCPermissions dcPerms(String username)

File: test/unit/org/apache/cassandra/config/DataStorageSpecTest.java
Patch:
@@ -28,6 +28,7 @@
 import static org.apache.cassandra.config.DataStorageSpec.DataStorageUnit.GIBIBYTES;
 import static org.apache.cassandra.config.DataStorageSpec.DataStorageUnit.KIBIBYTES;
 import static org.apache.cassandra.config.DataStorageSpec.DataStorageUnit.MEBIBYTES;
+import static org.apache.cassandra.utils.LocalizeString.toUpperCaseLocalized;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.junit.Assert.*;
 import static org.quicktheories.QuickTheory.qt;
@@ -242,7 +243,7 @@ public void thereAndBackLongBytesBound()
     {
         qt().forAll(gen()).check(there -> {
             DataStorageSpec.LongBytesBound back = new DataStorageSpec.LongBytesBound(there.toString());
-            DataStorageSpec.LongBytesBound BACK = new DataStorageSpec.LongBytesBound(there.toString().toUpperCase(Locale.ROOT).replace("I", "i"));
+            DataStorageSpec.LongBytesBound BACK = new DataStorageSpec.LongBytesBound(toUpperCaseLocalized(there.toString(), Locale.ROOT).replace("I", "i"));
             return there.equals(back) && there.equals(BACK);
         });
     }

File: test/unit/org/apache/cassandra/config/DatabaseDescriptorRefTest.java
Patch:
@@ -282,6 +282,7 @@ public class DatabaseDescriptorRefTest
     "org.apache.cassandra.utils.CloseableIterator",
     "org.apache.cassandra.utils.FBUtilities",
     "org.apache.cassandra.utils.FBUtilities$1",
+    "org.apache.cassandra.utils.LocalizeString",
     "org.apache.cassandra.utils.SystemInfo",
     "org.apache.cassandra.utils.Pair",
     "org.apache.cassandra.utils.binlog.BinLogOptions",

File: test/unit/org/apache/cassandra/cql3/KeywordTestBase.java
Patch:
@@ -31,6 +31,8 @@
 
 import org.apache.cassandra.exceptions.SyntaxException;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 /**
  * This class tests all keywords which took a long time. Hence it was split into multiple
  * KeywordTestSplitN to prevent CI timing out. If timeouts reappear split it further
@@ -105,7 +107,7 @@ public void test() throws Throwable
             logger.info(selectStatement);
             rs = execute(selectStatement);
             row = rs.one();
-            String value = row.getString(keyword.toLowerCase());
+            String value = row.getString(toLowerCaseLocalized(keyword));
             Assert.assertEquals(keyword, value);
 
             /* Make a materialized view using the fields (cannot re-use the name as MV must be in same keyspace).

File: test/unit/org/apache/cassandra/cql3/functions/masking/PartialMaskingFunctionTest.java
Patch:
@@ -31,6 +31,7 @@
 import org.assertj.core.api.Assertions;
 
 import static java.lang.String.format;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 /**
  * Tests for {@link PartialMaskingFunction}.
@@ -46,7 +47,7 @@ protected void testMaskingOnColumn(String name, CQL3Type type, Object value) thr
 
     protected void testMaskingOnColumn(PartialMaskingFunction.Kind masker, String name, CQL3Type type, Object value) throws Throwable
     {
-        String functionName = SchemaConstants.SYSTEM_KEYSPACE_NAME + ".mask_" + masker.name().toLowerCase();
+        String functionName = SchemaConstants.SYSTEM_KEYSPACE_NAME + ".mask_" + toLowerCaseLocalized(masker.name());
 
         if (type.getType() instanceof StringType)
         {

File: test/unit/org/apache/cassandra/db/compaction/unified/ControllerTest.java
Patch:
@@ -45,6 +45,7 @@
 import org.mockito.MockitoAnnotations;
 
 import static java.lang.String.format;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
@@ -142,7 +143,7 @@ private static void addOptions(boolean useIntegers, Map<String, String> options)
         options.putIfAbsent(Controller.TARGET_SSTABLE_SIZE_OPTION, FBUtilities.prettyPrintMemory(100 << 20));
         // The below value is based on the value in the above statement. Decreasing the above statement should result in a decrease below.
         options.putIfAbsent(Controller.MIN_SSTABLE_SIZE_OPTION, "70.710MiB");
-        options.putIfAbsent(Controller.OVERLAP_INCLUSION_METHOD_OPTION, Overlaps.InclusionMethod.SINGLE.toString().toLowerCase());
+        options.putIfAbsent(Controller.OVERLAP_INCLUSION_METHOD_OPTION, toLowerCaseLocalized(Overlaps.InclusionMethod.SINGLE.toString()));
         options.putIfAbsent(Controller.SSTABLE_GROWTH_OPTION, "0.5");
     }
 

File: test/unit/org/apache/cassandra/db/guardrails/GuardrailPasswordTest.java
Patch:
@@ -36,6 +36,7 @@
 import static java.util.Collections.singletonList;
 import static org.apache.cassandra.db.guardrails.CassandraPasswordConfiguration.LENGTH_FAIL_KEY;
 import static org.apache.cassandra.db.guardrails.CassandraPasswordConfiguration.LENGTH_WARN_KEY;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -121,7 +122,7 @@ public void testAllSpecialCharactersArePossibleToUseInCQLQuery()
 
     private String getEntityName(String name)
     {
-        return (name + entity).toLowerCase();
+        return toLowerCaseLocalized(name + entity);
     }
 
     private void testPasswordGuardrailInternal() throws Throwable

File: test/unit/org/apache/cassandra/db/tries/TrieToDotTest.java
Patch:
@@ -22,6 +22,8 @@
 
 import org.apache.cassandra.io.compress.BufferType;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 public class TrieToDotTest
 {
     @Test
@@ -30,7 +32,7 @@ public void testToDotContent() throws Exception
         InMemoryTrie<String> trie = new InMemoryTrie<>(BufferType.OFF_HEAP);
         String s = "Trie node types and manipulation mechanisms. The main purpose of this is to allow for handling tries directly as" +
                    " they are on disk without any serialization, and to enable the creation of such files.";
-        s = s.toLowerCase();
+        s = toLowerCaseLocalized(s);
         for (String word : s.split("[^a-z]+"))
             trie.putRecursive(InMemoryTrieTestBase.comparable(word), word, (x, y) -> y);
 

File: test/unit/org/apache/cassandra/db/tries/TrieToMermaidTest.java
Patch:
@@ -22,6 +22,8 @@
 
 import org.apache.cassandra.io.compress.BufferType;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 public class TrieToMermaidTest
 {
     @Test
@@ -30,7 +32,7 @@ public void testToMermaidContent() throws Exception
         InMemoryTrie<String> trie = new InMemoryTrie<>(BufferType.OFF_HEAP);
         // This was used as a basis the graphs in BTIFormat.md
         String s = "a allow an and any are as node of on the this to trie types with without";
-        s = s.toLowerCase();
+        s = toLowerCaseLocalized(s);
         for (String word : s.split("[^a-z]+"))
             trie.putRecursive(InMemoryTrieTestBase.comparable(word), word, (x, y) -> y);
 

File: test/unit/org/apache/cassandra/db/virtual/LocalRepairTablesTest.java
Patch:
@@ -56,6 +56,8 @@
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.TimeUUID;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 public class LocalRepairTablesTest extends CQLTester
 {
     private static final String KS_NAME = "vts";
@@ -245,7 +247,7 @@ private void assertInit(String table, State<?, ?> state) throws Throwable
     private <T extends Enum<T>> void assertState(String table, State<?, ?> state, T expectedState) throws Throwable
     {
         assertRowsIgnoringOrder(execute(t("SELECT id, completed, status, failure_cause, success_message FROM %s." + table + " WHERE id = ?"), state.getId()),
-                                row(state.getId(), false, expectedState.name().toLowerCase(), null, null));
+                                row(state.getId(), false, toLowerCaseLocalized(expectedState.name()), null, null));
     }
 
     private void assertSuccess(String table, State<?, ?> state) throws Throwable

File: test/unit/org/apache/cassandra/db/virtual/SSTableTasksTableTest.java
Patch:
@@ -37,6 +37,7 @@
 import org.apache.cassandra.schema.MockSchema;
 import org.apache.cassandra.utils.TimeUUID;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 import static org.apache.cassandra.utils.TimeUUID.Generator.nextTimeUUID;
 
 public class SSTableTasksTableTest extends CQLTester
@@ -91,7 +92,7 @@ public boolean isGlobal()
         CompactionManager.instance.active.beginCompaction(compactionHolder);
         UntypedResultSet result = execute("SELECT * FROM vts.sstable_tasks");
         assertRows(result, row(CQLTester.KEYSPACE, currentTable(), compactionId, 1.0 * bytesCompacted / bytesTotal,
-                OperationType.COMPACTION.toString().toLowerCase(), bytesCompacted, sstables.size(),
+                toLowerCaseLocalized(OperationType.COMPACTION.toString()), bytesCompacted, sstables.size(),
                 directory, bytesTotal, CompactionInfo.Unit.BYTES.toString()));
 
         CompactionManager.instance.active.finishCompaction(compactionHolder);

File: test/unit/org/apache/cassandra/db/virtual/StreamingVirtualTableTest.java
Patch:
@@ -54,6 +54,7 @@
 import org.apache.cassandra.utils.FBUtilities;
 import org.assertj.core.util.Throwables;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 import static org.apache.cassandra.utils.TimeUUID.Generator.nextTimeUUID;
 
 public class StreamingVirtualTableTest extends CQLTester
@@ -185,7 +186,7 @@ private static long progressEvent(StreamingState state, SessionInfo s, List<Stre
             long fileSize = summary.totalSize / summary.files;
             for (int i = 0; i < summary.files - 1; i++)
             {
-                String fileName = summary.tableId + "-" + direction.name().toLowerCase() + "-" + i;
+                String fileName = summary.tableId + "-" + toLowerCaseLocalized(direction.name()) + "-" + i;
                 state.handleStreamEvent(new ProgressEvent(state.id(), new ProgressInfo((InetAddressAndPort) s.peer, 0, fileName, direction, fileSize, fileSize, fileSize)));
                 counter += fileSize;
             }
@@ -199,7 +200,7 @@ private static long completeEvent(StreamingState state, SessionInfo s, List<Stre
         for (StreamSummary summary : summaries)
         {
             long fileSize = summary.totalSize / summary.files;
-            String fileName = summary.tableId + "-" + direction.name().toLowerCase() + "-" + summary.files;
+            String fileName = summary.tableId + "-" + toLowerCaseLocalized(direction.name()) + "-" + summary.files;
             state.handleStreamEvent(new ProgressEvent(state.id(), new ProgressInfo((InetAddressAndPort) s.peer, 0, fileName, direction, fileSize, fileSize, fileSize)));
             counter += fileSize;
         }

File: test/unit/org/apache/cassandra/index/sai/analyzer/filter/BasicFiltersTest.java
Patch:
@@ -25,6 +25,7 @@
 import org.apache.cassandra.index.sai.SAITester;
 import org.apache.lucene.analysis.miscellaneous.ASCIIFoldingFilter;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 import static org.junit.Assert.assertEquals;
 
 public class BasicFiltersTest
@@ -37,7 +38,7 @@ public void testLowerCase()
         for (int count = 0; count < SAITester.getRandom().nextIntBetween(100, 1000); count++)
         {
             String actual = SAITester.getRandom().nextTextString(10, 50);
-            assertEquals(actual.toLowerCase(), lowerCase.process(actual));
+            assertEquals(toLowerCaseLocalized(actual), lowerCase.process(actual));
         }
     }
     

File: test/unit/org/apache/cassandra/index/sasi/analyzer/DelimiterAnalyzerTest.java
Patch:
@@ -34,6 +34,7 @@
 import org.junit.Assert;
 import org.junit.Test;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 import static org.junit.Assert.assertEquals;
 
 public class DelimiterAnalyzerTest
@@ -59,7 +60,7 @@ public void caseSensitiveAnalizer() throws Exception
             output.append(ByteBufferUtil.string(analyzer.next()) + (analyzer.hasNext() ? ' ' : ""));
 
         Assert.assertEquals(testString, output.toString());
-        Assert.assertFalse(testString.toLowerCase().equals(output.toString()));
+        Assert.assertFalse(toLowerCaseLocalized(testString).equals(output.toString()));
     }
 
     @Test
@@ -82,7 +83,7 @@ public void testBlankEntries() throws Exception
             output.append(ByteBufferUtil.string(analyzer.next()) + (analyzer.hasNext() ? ',' : ""));
 
         Assert.assertEquals("Nip,it,in,the,bud", output.toString());
-        Assert.assertFalse(testString.toLowerCase().equals(output.toString()));
+        Assert.assertFalse(toLowerCaseLocalized(testString).equals(output.toString()));
     }
 
     @Test(expected = ConfigurationException.class)

File: test/unit/org/apache/cassandra/service/reads/repair/AbstractReadRepairTest.java
Patch:
@@ -83,6 +83,7 @@
 import static org.apache.cassandra.locator.ReplicaUtils.FULL_RANGE;
 import static org.apache.cassandra.net.Verb.INTERNAL_RSP;
 import static org.apache.cassandra.utils.Clock.Global.nanoTime;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 @Ignore
 public abstract  class AbstractReadRepairTest
@@ -288,7 +289,7 @@ public String getDatacenter(InetAddressAndPort endpoint)
         String ksName = "ks";
 
         String ddl = String.format("CREATE TABLE tbl (k int primary key, v text) WITH read_repair='%s'",
-                                   repairStrategy.toString().toLowerCase());
+                                   toLowerCaseLocalized(repairStrategy.toString()));
 
         cfm = CreateTableStatement.parse(ddl, ksName).build();
         assert cfm.params.readRepair == repairStrategy;

File: test/unit/org/apache/cassandra/tools/TopPartitionsTest.java
Patch:
@@ -43,9 +43,9 @@
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.Util;
 
-
 import static java.lang.String.format;
 import static org.apache.cassandra.cql3.QueryProcessor.executeInternal;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 import static org.hamcrest.Matchers.greaterThan;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -56,7 +56,7 @@
  */
 public class TopPartitionsTest
 {
-    public static String KEYSPACE = TopPartitionsTest.class.getSimpleName().toLowerCase();
+    public static String KEYSPACE = toLowerCaseLocalized(TopPartitionsTest.class.getSimpleName());
     public static String TABLE = "test";
 
     @BeforeClass

File: tools/stress/src/org/apache/cassandra/stress/StressAction.java
Patch:
@@ -40,6 +40,7 @@
 import com.google.common.util.concurrent.Uninterruptibles;
 
 import static org.apache.cassandra.utils.Clock.Global.nanoTime;
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 public class StressAction implements Runnable
 {
@@ -217,7 +218,7 @@ private StressMetrics run(OpDistributionFactory operations,
         output.println(String.format("Running %s with %d threads %s",
                                      operations.desc(),
                                      threadCount,
-                                     durationUnits != null ? duration + " " + durationUnits.toString().toLowerCase()
+                                     durationUnits != null ? duration + " " + toLowerCaseLocalized(durationUnits.toString())
                                         : opCount > 0      ? "for " + opCount + " iteration"
                                                            : "until stderr of mean < " + settings.command.targetUncertainty));
         final WorkManager workManager;

File: tools/stress/src/org/apache/cassandra/stress/StressGraph.java
Patch:
@@ -40,6 +40,8 @@
 import org.apache.cassandra.stress.settings.StressSettings;
 import org.apache.cassandra.utils.JsonUtils;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 public class StressGraph
 {
     private StressSettings stressSettings;
@@ -200,7 +202,7 @@ else if (mode == ReadingMode.AGGREGATES)
                         continue;
                     }
                     // the graphing js expects lower case names
-                    json.put(parts[0].trim().toLowerCase(), parts[1].trim());
+                    json.put(toLowerCaseLocalized(parts[0].trim()), parts[1].trim());
                 }
                 else if (mode == ReadingMode.NEXTITERATION)
                 {

File: tools/stress/src/org/apache/cassandra/stress/settings/OptionEnumProbabilities.java
Patch:
@@ -26,6 +26,7 @@
 import java.util.List;
 import java.util.Map;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
 
 public final class OptionEnumProbabilities<T> extends OptionMulti
 {
@@ -48,7 +49,7 @@ private static final class OptMatcher<T> extends OptionSimple
         final T opt;
         OptMatcher(T opt, String defaultValue)
         {
-            super(opt.toString().toLowerCase() + "=", "[0-9]+(\\.[0-9]+)?", defaultValue, "Performs this many " + opt + " operations out of total", false);
+            super(toLowerCaseLocalized(opt.toString()) + "=", "[0-9]+(\\.[0-9]+)?", defaultValue, "Performs this many " + opt + " operations out of total", false);
             this.opt = opt;
         }
     }

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsLog.java
Patch:
@@ -29,6 +29,8 @@
 import org.apache.cassandra.stress.util.MultiResultLogger;
 import org.apache.cassandra.stress.util.ResultLogger;
 
+import static org.apache.cassandra.utils.LocalizeString.toUpperCaseLocalized;
+
 public class SettingsLog implements Serializable
 {
     public static enum Level
@@ -66,7 +68,7 @@ else if (interval.endsWith("s"))
             intervalMillis = 1000 * Integer.parseInt(interval);
         if (intervalMillis <= 0)
             throw new IllegalArgumentException("Log interval must be greater than zero");
-        level = Level.valueOf(options.level.value().toUpperCase());
+        level = Level.valueOf(toUpperCaseLocalized(options.level.value()));
     }
 
     public MultiResultLogger getOutput() throws FileNotFoundException

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsMode.java
Patch:
@@ -36,6 +36,7 @@
 import static java.lang.String.format;
 import static org.apache.cassandra.stress.settings.SettingsCredentials.CQL_PASSWORD_PROPERTY_KEY;
 import static org.apache.cassandra.stress.settings.SettingsCredentials.CQL_USERNAME_PROPERTY_KEY;
+import static org.apache.cassandra.utils.LocalizeString.toUpperCaseLocalized;
 
 public class SettingsMode implements Serializable
 {
@@ -79,7 +80,7 @@ public SettingsMode(GroupedOptions options, SettingsCredentials credentials)
                     : ProtocolVersion.fromInt(Integer.parseInt(opts.protocolVersion.value()));
             api = ConnectionAPI.JAVA_DRIVER_NATIVE;
             style = opts.useUnPrepared.setByUser() ? ConnectionStyle.CQL : ConnectionStyle.CQL_PREPARED;
-            compression = ProtocolOptions.Compression.valueOf(opts.useCompression.value().toUpperCase()).name();
+            compression = ProtocolOptions.Compression.valueOf(toUpperCaseLocalized(opts.useCompression.value())).name();
             username = opts.user.setByUser() ? opts.user.value() : credentials.cqlUsername;
             password = opts.password.setByUser() ? opts.password.value() : credentials.cqlPassword;
             maxPendingPerConnection = opts.maxPendingPerConnection.value().isEmpty() ? null : Integer.valueOf(opts.maxPendingPerConnection.value());

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsPopulation.java
Patch:
@@ -32,6 +32,8 @@
 import org.apache.cassandra.stress.generate.PartitionGenerator;
 import org.apache.cassandra.stress.util.ResultLogger;
 
+import static org.apache.cassandra.utils.LocalizeString.toUpperCaseLocalized;
+
 public class SettingsPopulation implements Serializable
 {
 
@@ -48,7 +50,7 @@ public static enum GenerateOrder
 
     private SettingsPopulation(GenerateOptions options, DistributionOptions dist, SequentialOptions pop)
     {
-        this.order = !options.contents.setByUser() ? PartitionGenerator.Order.ARBITRARY : PartitionGenerator.Order.valueOf(options.contents.value().toUpperCase());
+        this.order = !options.contents.setByUser() ? PartitionGenerator.Order.ARBITRARY : PartitionGenerator.Order.valueOf(toUpperCaseLocalized(options.contents.value()));
         if (dist != null)
         {
             this.distribution = dist.seed.get();

File: tools/stress/src/org/apache/cassandra/stress/settings/StressSettings.java
Patch:
@@ -29,6 +29,8 @@
 import org.apache.cassandra.stress.util.ResultLogger;
 import org.apache.cassandra.transport.SimpleClient;
 
+import static org.apache.cassandra.utils.LocalizeString.toLowerCaseLocalized;
+
 public class StressSettings implements Serializable
 {
     public final SettingsCommand command;
@@ -247,7 +249,7 @@ private static Map<String, String[]> parseMap(String[] args)
             {
                 if (i > 0)
                     putParam(key, params.toArray(new String[0]), r);
-                key = args[i].toLowerCase();
+                key = toLowerCaseLocalized(args[i]);
                 params.clear();
             }
             else

File: src/java/org/apache/cassandra/tcm/sequences/BootstrapAndJoin.java
Patch:
@@ -353,6 +353,8 @@ public static boolean bootstrap(final Collection<Token> tokens,
             logger.info("Resetting bootstrap progress to start fresh");
             SystemKeyspace.resetAvailableStreamedRanges();
         }
+
+        StorageService.instance.repairPaxosForTopologyChange("bootstrap");
         Future<StreamState> bootstrapStream = StorageService.instance.startBootstrap(metadata, beingReplaced, movements, strictMovements);
         try
         {

File: test/simulator/main/org/apache/cassandra/simulator/cluster/KeyspaceActions.java
Patch:
@@ -281,8 +281,8 @@ private Action next()
                     joined.add(join);
                     joined.remove(leave);
                     left.add(leave);
-                    TokenPlacementModel.ReplicatedRanges placementsAfter = placements(joined, currentRf);
                     nodeLookup.setTokenOf(join, nodeLookup.tokenOf(leave));
+                    TokenPlacementModel.ReplicatedRanges placementsAfter = placements(joined, currentRf);
                     Topology during = recomputeTopology(placementsBefore, placementsAfter);
                     updateTopology(during);
                     Topology after = recomputeTopology(placementsAfter, placementsAfter);

File: test/simulator/main/org/apache/cassandra/simulator/cluster/OnClusterJoin.java
Patch:
@@ -111,7 +111,7 @@ private ExecuteNextStep(ClusterActions actions, int on, int kind)
 
                 BootstrapAndJoin bootstrapAndJoin = ((BootstrapAndJoin) sequence);
                 assert bootstrapAndJoin.next.ordinal() == kind : String.format("Expected next step to be %s, but got %s", Transformation.Kind.values()[kind], bootstrapAndJoin.next);
-                boolean res = bootstrapAndJoin.finishJoiningRing().executeNext().isContinuable();
+                boolean res = bootstrapAndJoin.executeNext().isContinuable();
                 assert res;
             });
         }

File: src/java/org/apache/cassandra/metrics/Sampler.java
Patch:
@@ -42,7 +42,7 @@ public enum SamplerType
     MonotonicClock clock = MonotonicClock.approxTime;
 
     @VisibleForTesting
-    static final ThreadPoolExecutor samplerExecutor = new JMXEnabledThreadPoolExecutor(1, 1,
+    public static final ThreadPoolExecutor samplerExecutor = new JMXEnabledThreadPoolExecutor(1, 1,
             TimeUnit.SECONDS,
             new ArrayBlockingQueue<Runnable>(1000),
             new NamedThreadFactory("Sampler"),

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -79,10 +79,10 @@ public static Set<String> splitCommaDelimited(String src)
 
     public String cluster_name = "Test Cluster";
     public ParameterizedClass authenticator;
-    public String authorizer;
-    public String role_manager;
+    public ParameterizedClass authorizer;
+    public ParameterizedClass role_manager;
     public ParameterizedClass crypto_provider;
-    public String network_authorizer;
+    public ParameterizedClass network_authorizer;
     public ParameterizedClass cidr_authorizer;
 
     @Replaces(oldName = "permissions_validity_in_ms", converter = Converters.MILLIS_DURATION_INT, deprecated = true)

File: test/unit/org/apache/cassandra/audit/AuditLoggerAuthTest.java
Patch:
@@ -70,8 +70,8 @@ public static void setup() throws Exception
     {
         OverrideConfigurationLoader.override((config) -> {
             config.authenticator = new ParameterizedClass("PasswordAuthenticator");
-            config.role_manager = "CassandraRoleManager";
-            config.authorizer = "CassandraAuthorizer";
+            config.role_manager = new ParameterizedClass("CassandraRoleManager");
+            config.authorizer = new ParameterizedClass("CassandraAuthorizer");
             config.audit_logging_options.enabled = true;
             config.audit_logging_options.logger = new ParameterizedClass("InMemoryAuditLogger", null);
         });

File: test/unit/org/apache/cassandra/transport/CQLUserAuditTest.java
Patch:
@@ -65,7 +65,7 @@ public static void setup() throws Exception
     {
         OverrideConfigurationLoader.override((config) -> {
             config.authenticator = new ParameterizedClass("PasswordAuthenticator");
-            config.role_manager = "CassandraRoleManager";
+            config.role_manager = new ParameterizedClass("CassandraRoleManager");
             config.diagnostic_events_enabled = true;
             config.audit_logging_options.enabled = true;
             config.audit_logging_options.logger = new ParameterizedClass("DiagnosticEventAuditLogger", null);

File: src/java/org/apache/cassandra/cql3/ColumnsExpression.java
Patch:
@@ -368,7 +368,7 @@ public boolean isCollectionElementExpression()
      */
     public boolean isMapElementExpression()
     {
-        return kind == Kind.ELEMENT && element != null && element.kind() == ElementExpression.Kind.COLLECTION_ELEMENT && firstColumn().type instanceof MapType;
+        return kind == Kind.ELEMENT && element != null && element.kind() == ElementExpression.Kind.COLLECTION_ELEMENT && firstColumn().type.unwrap() instanceof MapType;
     }
 
     /**

File: test/distributed/org/apache/cassandra/distributed/impl/AbstractCluster.java
Patch:
@@ -1213,8 +1213,8 @@ public static Predicate<String> getSharedClassPredicate(Class<?>[] isolate, Clas
                 return false;
 
             return shared.contains(s) ||
-                   InstanceClassLoader.getDefaultLoadSharedFilter().test(s) ||
-                   s.startsWith("org.jboss.byteman");
+                   InstanceClassLoader.getDefaultLoadSharedFilter().test(s)
+                    || s.startsWith("org.jboss.byteman.");
         };
     }
 

File: test/burn/org/apache/cassandra/utils/LongBTreeTest.java
Patch:
@@ -728,6 +728,9 @@ public void testFastBuilder()
                 Object[] btree = builder.build();
                 assertEquals(i + 1, BTree.size(btree));
                 assertTrue(""+i, BTree.<Integer>isWellFormed(btree, naturalOrder()));
+                assertTrue(""+i, BTree.<Integer>isWellFormed(btree, naturalOrder()));
+                builder.close();
+                assertTrue(builder.validateEmpty());
             }
         }
     }

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
Patch:
@@ -244,7 +244,8 @@ static boolean shouldReplay(String name)
     /**
      * FOR TESTING PURPOSES.
      */
-    static void resetReplayLimit()
+    @VisibleForTesting
+    public static void resetReplayLimit()
     {
         replayLimitId = getNextId();
     }

File: src/java/org/apache/cassandra/tcm/migration/GossipProcessor.java
Patch:
@@ -31,7 +31,7 @@ public class GossipProcessor implements Processor
     @Override
     public Commit.Result commit(Entry.Id entryId, Transformation transform, Epoch lastKnown, Retry.Deadline retryPolicy)
     {
-        throw new IllegalStateException("Can't commit transformations when running in gossip mode. Enable the ClusterMetadataService with `nodetool addtocms`.");
+        throw new IllegalStateException("Can't commit transformations when running in gossip mode. Enable the ClusterMetadataService with `nodetool cms initialize`.");
     }
 
     @Override

File: test/unit/org/apache/cassandra/db/memtable/MemtableSizeHeapBuffersTest.java
Patch:
@@ -22,6 +22,7 @@
 import org.junit.BeforeClass;
 
 import org.apache.cassandra.config.Config;
+import org.apache.cassandra.dht.Murmur3Partitioner;
 import org.apache.cassandra.utils.memory.MemtablePool;
 import org.apache.cassandra.utils.memory.SlabPool;
 
@@ -31,7 +32,7 @@ public class MemtableSizeHeapBuffersTest extends MemtableSizeTestBase
     @BeforeClass
     public static void setUpClass()
     {
-        setup(Config.MemtableAllocationType.heap_buffers);
+        setup(Config.MemtableAllocationType.heap_buffers, Murmur3Partitioner.instance);
     }
 
     @Override

File: test/unit/org/apache/cassandra/db/memtable/MemtableSizeOffheapBuffersTest.java
Patch:
@@ -22,6 +22,7 @@
 import org.junit.BeforeClass;
 
 import org.apache.cassandra.config.Config;
+import org.apache.cassandra.dht.Murmur3Partitioner;
 import org.apache.cassandra.utils.memory.MemtablePool;
 import org.apache.cassandra.utils.memory.SlabPool;
 
@@ -31,7 +32,7 @@ public class MemtableSizeOffheapBuffersTest extends MemtableSizeTestBase
     @BeforeClass
     public static void setUpClass()
     {
-        setup(Config.MemtableAllocationType.offheap_buffers);
+        setup(Config.MemtableAllocationType.offheap_buffers, Murmur3Partitioner.instance);
     }
 
 

File: test/unit/org/apache/cassandra/db/memtable/MemtableSizeOffheapObjectsTest.java
Patch:
@@ -22,6 +22,7 @@
 import org.junit.BeforeClass;
 
 import org.apache.cassandra.config.Config;
+import org.apache.cassandra.dht.Murmur3Partitioner;
 import org.apache.cassandra.utils.memory.MemtablePool;
 import org.apache.cassandra.utils.memory.NativePool;
 
@@ -31,7 +32,7 @@ public class MemtableSizeOffheapObjectsTest extends MemtableSizeTestBase
     @BeforeClass
     public static void setUpClass()
     {
-        setup(Config.MemtableAllocationType.offheap_objects);
+        setup(Config.MemtableAllocationType.offheap_objects, Murmur3Partitioner.instance);
     }
 
     @Override

File: test/unit/org/apache/cassandra/db/memtable/MemtableSizeUnslabbedTest.java
Patch:
@@ -22,6 +22,7 @@
 import org.junit.BeforeClass;
 
 import org.apache.cassandra.config.Config;
+import org.apache.cassandra.dht.Murmur3Partitioner;
 import org.apache.cassandra.utils.memory.HeapPool;
 import org.apache.cassandra.utils.memory.MemtablePool;
 
@@ -31,7 +32,7 @@ public class MemtableSizeUnslabbedTest extends MemtableSizeTestBase
     @BeforeClass
     public static void setUpClass()
     {
-        setup(Config.MemtableAllocationType.unslabbed_heap_buffers);
+        setup(Config.MemtableAllocationType.unslabbed_heap_buffers, Murmur3Partitioner.instance);
     }
 
     @Override

File: src/java/org/apache/cassandra/db/Columns.java
Patch:
@@ -436,7 +436,7 @@ public long unsharedHeapSize()
         if(this == NONE)
             return 0;
 
-        return EMPTY_SIZE;
+        return EMPTY_SIZE + BTree.sizeOfStructureOnHeap(columns);
     }
 
     @Override

File: src/java/org/apache/cassandra/db/partitions/AtomicBTreePartition.java
Patch:
@@ -39,6 +39,7 @@
 import org.apache.cassandra.utils.memory.Cloner;
 import org.apache.cassandra.utils.memory.HeapCloner;
 import org.apache.cassandra.utils.memory.MemtableAllocator;
+import org.github.jamm.Unmetered;
 
 import com.google.common.annotations.VisibleForTesting;
 
@@ -82,6 +83,7 @@ public final class AtomicBTreePartition extends AbstractBTreePartition
      */
     private volatile int wasteTracker = TRACKER_NEVER_WASTED;
 
+    @Unmetered
     private final MemtableAllocator allocator;
     private volatile Holder ref;
 

File: src/java/org/apache/cassandra/utils/btree/BTree.java
Patch:
@@ -949,6 +949,9 @@ public static int size(Object[] tree)
 
     public static long sizeOfStructureOnHeap(Object[] tree)
     {
+        if (tree == EMPTY_LEAF)
+            return 0;
+
         long size = ObjectSizes.sizeOfArray(tree);
         if (isLeaf(tree))
             return size;

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -892,6 +892,7 @@ public static void setClientMode(boolean clientMode)
     public volatile int items_per_collection_fail_threshold = -1;
     public volatile int fields_per_udt_warn_threshold = -1;
     public volatile int fields_per_udt_fail_threshold = -1;
+    public volatile boolean vector_type_enabled = true;
     public volatile int vector_dimensions_warn_threshold = -1;
     public volatile int vector_dimensions_fail_threshold = -1;
     public volatile int data_disk_usage_percentage_warn_threshold = -1;

File: src/java/org/apache/cassandra/cql3/CQL3Type.java
Patch:
@@ -722,6 +722,7 @@ public void validate(ClientState state, String name)
             {
                 if (type.isVector())
                 {
+                    Guardrails.vectorTypeEnabled.ensureEnabled(name, state);
                     int dimensions = ((Vector) type).getType().dimension;
                     Guardrails.vectorDimensions.guard(dimensions, name, false, state);
                 }
@@ -920,6 +921,7 @@ public Raw freeze()
             @Override
             public void validate(ClientState state, String name)
             {
+                Guardrails.vectorTypeEnabled.ensureEnabled(name, state);
                 Guardrails.vectorDimensions.guard(dimension, name, false, state);
             }
 

File: src/java/org/apache/cassandra/cql3/Operator.java
Patch:
@@ -788,8 +788,8 @@ public String toString()
         public boolean isSatisfiedBy(AbstractType<?> type, ByteBuffer leftOperand, ByteBuffer rightOperand)
         {
             List<ByteBuffer> buffers = ListType.getInstance(type, false).unpack(rightOperand);
-            buffers.sort(type);
-            return type.compareForCQL(leftOperand, buffers.get(0)) >= 0 && type.compareForCQL(leftOperand, buffers.get(1)) <= 0;
+            // We use compare instead of compareForCQL to deal properly with reversed clustering columns
+            return type.compare(leftOperand, buffers.get(0)) >= 0 && type.compare(leftOperand, buffers.get(1)) <= 0;
         }
 
         @Override

File: src/java/org/apache/cassandra/cql3/restrictions/SimpleRestriction.java
Patch:
@@ -333,6 +333,9 @@ public void addToRowFilter(RowFilter filter, IndexRegistry indexRegistry, QueryO
                 List<ByteBuffer> buffers = bindAndGet(options);
                 if (operator.kind() != Operator.Kind.BINARY)
                 {
+                    // For BETWEEN we support like in SQL reversed bounds
+                    if (operator.kind() == Operator.Kind.TERNARY)
+                        buffers.sort(column.type);
                     filter.add(column, operator, multiInputOperatorValues(column, buffers));
                 }
                 else if (operator == Operator.LIKE)

File: src/java/org/apache/cassandra/cql3/Relation.java
Patch:
@@ -188,11 +188,11 @@ public boolean onToken()
      */
     public SingleRestriction toRestriction(TableMetadata table, VariableSpecifications boundNames)
     {
-        if (operator == Operator.NEQ)
-            throw invalidRequest("Unsupported '!=' relation: %s", this);
-
         ColumnsExpression columnsExpression = rawExpressions.prepare(table);
 
+        if (operator == Operator.NEQ && columnsExpression.kind() == ColumnsExpression.Kind.TOKEN)
+            throw invalidRequest("Unsupported '!=' relation: %s", this);
+
         // TODO support restrictions on list elements as we do in conditions, then we can probably move below validations
         //  to ElementExpression prepare/validateColumns
         if (columnsExpression.isMapElementExpression())

File: src/java/org/apache/cassandra/cql3/conditions/ColumnCondition.java
Patch:
@@ -353,7 +353,7 @@ private Terms prepareTerms(String keyspace, ColumnSpecification receiver)
 
         private void validateOperationOnDurations(AbstractType<?> type)
         {
-            if (type.referencesDuration() && operator.isSlice())
+            if (type.referencesDuration() && operator.isSlice() && operator != Operator.NEQ)
             {
                 checkFalse(type.isCollection(), "Slice conditions are not supported on collections containing durations");
                 checkFalse(type.isTuple(), "Slice conditions are not supported on tuples containing durations");

File: src/java/org/apache/cassandra/cql3/restrictions/MergedRestriction.java
Patch:
@@ -60,7 +60,7 @@ public final class MergedRestriction implements SingleRestriction
     private final boolean isMultiColumn;
 
     /**
-     * The number of restrictions that require {@code CONTAINS}, {@code CONTAINS_KEY} and Map equality restrictions.
+     * The number of restrictions that require {@code CONTAINS}, {@code CONTAINS_KEY}, {@code NOT_CONTAINS}, {@code NOT_CONTAINS_KEY} and Map equality restrictions.
      */
     private final int containsCount;
 
@@ -124,7 +124,7 @@ private static void validate(SimpleRestriction restriction, SimpleRestriction ot
         checkOperator(other);
 
         if (restriction.isContains() != other.isContains())
-            throw invalidRequest("Collection column %s can only be restricted by CONTAINS, CONTAINS KEY," +
+            throw invalidRequest("Collection column %s can only be restricted by CONTAINS, CONTAINS KEY, NOT_CONTAINS, NOT_CONTAINS_KEY" +
                                  " or map-entry equality if it already restricted by one of those",
                                  restriction.firstColumn().name);
 
@@ -201,7 +201,7 @@ private static String toCQLString(Iterable<ColumnMetadata> columns)
     }
 
     /**
-     * Checks if the restriction operator is a CONTAINS, CONTAINS_KEY or is an equality on a map element.
+     * Checks if the restriction operator is a CONTAINS, CONTAINS_KEY, NOT_CONTAINS, NOT_CONTAINS_KEY or is an equality on a map element.
      * @param restriction the restriction to check
      * @return {@code true} if the restriction operator is one of the contains operations, {@code false} otherwise.
      */

File: src/java/org/apache/cassandra/cql3/restrictions/PartitionKeyRestrictions.java
Patch:
@@ -110,7 +110,7 @@ public void addFunctionsTo(List<Function> functions)
      */
     public List<ByteBuffer> values(IPartitioner partitioner, QueryOptions options, ClientState state)
     {
-        // if we need to perform filtering its means that this query is a partition range query and that
+        // if we need to perform filtering it means that this query is a partition range query and that
         // this method should not be called
         if (isEmpty() || needFiltering())
             throw new IllegalStateException("the query is a partition range query and this method should not be called");

File: test/unit/org/apache/cassandra/index/sai/cql/UnindexedExpressionsTest.java
Patch:
@@ -69,9 +69,7 @@ public void unsupportedOperatorsAreHandledTest() throws Throwable
         // The IS NOT operator is only valid on materialized views
         assertInvalidMessage("Unsupported restriction:", "SELECT pk FROM %s WHERE val1 = 1 AND val2 is not null");
 
-        // The != operator is currently not supported at all
-        assertInvalidMessage("Unsupported '!=' relation: val2 != '22'", "SELECT pk FROM %s WHERE val1 = 1 AND val2 != '22'");
-
+        assertInvalidMessage(StatementRestrictions.REQUIRES_ALLOW_FILTERING_MESSAGE, "SELECT pk FROM %s WHERE val1 = 1 AND val2 != '22'");
         assertInvalidMessage(StatementRestrictions.REQUIRES_ALLOW_FILTERING_MESSAGE, "SELECT pk FROM %s WHERE val1 = 1 AND val2 < '22'");
         assertInvalidMessage(StatementRestrictions.REQUIRES_ALLOW_FILTERING_MESSAGE, "SELECT pk FROM %s WHERE val1 = 1 AND val2 <= '11'");
         assertInvalidMessage(StatementRestrictions.REQUIRES_ALLOW_FILTERING_MESSAGE, "SELECT pk FROM %s WHERE val1 = 1 AND val2 >= '11'");

File: test/distributed/org/apache/cassandra/distributed/impl/InstanceConfig.java
Patch:
@@ -101,7 +101,8 @@ private InstanceConfig(int num,
                 .set("memtable_flush_writers", 1)
                 .set("concurrent_compactors", 1)
                 .set("memtable_heap_space", "10MiB")
-                .set("commitlog_sync", "batch")
+                .set("commitlog_sync", "periodic")
+                .set("commitlog_sync_period_in_ms", 10000)
                 .set("storage_port", storage_port)
                 .set("native_transport_port", native_transport_port)
                 .set("endpoint_snitch", DistributedTestSnitch.class.getName())

File: test/distributed/org/apache/cassandra/distributed/test/ReplicaFilteringProtectionTest.java
Patch:
@@ -57,8 +57,7 @@ public static void setup() throws IOException
     {
         cluster = init(Cluster.build()
                               .withNodes(REPLICAS)
-                              .withConfig(config -> config.set("hinted_handoff_enabled", false)
-                                                          .set("commitlog_sync", "batch")).start());
+                              .withConfig(config -> config.set("hinted_handoff_enabled", false)).start());
 
         // Make sure we start w/ the correct defaults:
         cluster.get(1).runOnInstance(() -> assertEquals(DEFAULT_WARN_THRESHOLD, StorageService.instance.getCachedReplicaRowsWarnThreshold()));

File: test/unit/org/apache/cassandra/config/FailStartupDuplicateParamsTest.java
Patch:
@@ -42,7 +42,8 @@ public class FailStartupDuplicateParamsTest
 {
     private static final List<String> baseConfig = ImmutableList.of(
         "cluster_name: Test Cluster",
-        "commitlog_sync: batch",
+        "commitlog_sync: periodic",
+        "commitlog_sync_period: 10s",
         "commitlog_directory: build/test/cassandra/commitlog",
         "hints_directory: build/test/cassandra/hints",
         "partitioner: org.apache.cassandra.dht.ByteOrderedPartitioner",

File: test/unit/org/apache/cassandra/config/LoadOldYAMLBackwardCompatibilityTest.java
Patch:
@@ -80,7 +80,7 @@ public void testConfigurationLoaderBackwardCompatibility()
         assertEquals(new DataRateSpec.LongBytesPerSecondBound(24L  * 1024L * 1024L), config.inter_dc_stream_throughput_outbound);
         assertNull(config.commitlog_total_space);
         assertEquals(new DurationSpec.IntMillisecondsBound(0.0, TimeUnit.MILLISECONDS), config.commitlog_sync_group_window);
-        assertEquals(new DurationSpec.IntMillisecondsBound(0), config.commitlog_sync_period);
+        assertEquals(new DurationSpec.IntMillisecondsBound(10000), config.commitlog_sync_period);
         assertEquals(new DataStorageSpec.IntMebibytesBound(5), config.commitlog_segment_size);
         assertNull(config.periodic_commitlog_sync_lag_block);  //Integer
         assertNull(config.max_mutation_size);

File: test/unit/org/apache/cassandra/config/ParseAndConvertUnitsTest.java
Patch:
@@ -53,7 +53,7 @@ public void testConfigurationLoaderParser()
         assertEquals(new DurationSpec.IntMillisecondsBound(2000), config.internode_tcp_connect_timeout);
         assertEquals(new DurationSpec.IntMillisecondsBound(30000), config.internode_tcp_user_timeout);
         assertEquals(new DurationSpec.IntMillisecondsBound(0), config.commitlog_sync_group_window);
-        assertEquals(new DurationSpec.IntMillisecondsBound(0), config.commitlog_sync_period);
+        assertEquals(new DurationSpec.IntMillisecondsBound(10000), config.commitlog_sync_period);
         assertNull(config.periodic_commitlog_sync_lag_block);
         assertEquals(new DurationSpec.IntMillisecondsBound(250), config.cdc_free_space_check_interval);
         assertEquals(new DurationSpec.IntMillisecondsBound(100), config.dynamic_snitch_update_interval);

File: test/distributed/org/apache/cassandra/distributed/impl/InstanceConfig.java
Patch:
@@ -101,7 +101,8 @@ private InstanceConfig(int num,
                 .set("memtable_flush_writers", 1)
                 .set("concurrent_compactors", 1)
                 .set("memtable_heap_space", "10MiB")
-                .set("commitlog_sync", "batch")
+                .set("commitlog_sync", "periodic")
+                .set("commitlog_sync_period_in_ms", 10000)
                 .set("storage_port", storage_port)
                 .set("native_transport_port", native_transport_port)
                 .set("endpoint_snitch", DistributedTestSnitch.class.getName())

File: test/distributed/org/apache/cassandra/distributed/test/ReplicaFilteringProtectionTest.java
Patch:
@@ -57,8 +57,7 @@ public static void setup() throws IOException
     {
         cluster = init(Cluster.build()
                               .withNodes(REPLICAS)
-                              .withConfig(config -> config.set("hinted_handoff_enabled", false)
-                                                          .set("commitlog_sync", "batch")).start());
+                              .withConfig(config -> config.set("hinted_handoff_enabled", false)).start());
 
         // Make sure we start w/ the correct defaults:
         cluster.get(1).runOnInstance(() -> assertEquals(DEFAULT_WARN_THRESHOLD, StorageService.instance.getCachedReplicaRowsWarnThreshold()));

File: test/unit/org/apache/cassandra/config/FailStartupDuplicateParamsTest.java
Patch:
@@ -42,7 +42,8 @@ public class FailStartupDuplicateParamsTest
 {
     private static final List<String> baseConfig = ImmutableList.of(
         "cluster_name: Test Cluster",
-        "commitlog_sync: batch",
+        "commitlog_sync: periodic",
+        "commitlog_sync_period: 10s",
         "commitlog_directory: build/test/cassandra/commitlog",
         "hints_directory: build/test/cassandra/hints",
         "partitioner: org.apache.cassandra.dht.ByteOrderedPartitioner",

File: test/unit/org/apache/cassandra/config/LoadOldYAMLBackwardCompatibilityTest.java
Patch:
@@ -80,7 +80,7 @@ public void testConfigurationLoaderBackwardCompatibility()
         assertEquals(new DataRateSpec.LongBytesPerSecondBound(24L  * 1024L * 1024L), config.inter_dc_stream_throughput_outbound);
         assertNull(config.commitlog_total_space);
         assertEquals(new DurationSpec.IntMillisecondsBound(0.0, TimeUnit.MILLISECONDS), config.commitlog_sync_group_window);
-        assertEquals(new DurationSpec.IntMillisecondsBound(0), config.commitlog_sync_period);
+        assertEquals(new DurationSpec.IntMillisecondsBound(10000), config.commitlog_sync_period);
         assertEquals(new DataStorageSpec.IntMebibytesBound(5), config.commitlog_segment_size);
         assertNull(config.periodic_commitlog_sync_lag_block);  //Integer
         assertNull(config.max_mutation_size);

File: test/unit/org/apache/cassandra/config/ParseAndConvertUnitsTest.java
Patch:
@@ -53,7 +53,7 @@ public void testConfigurationLoaderParser()
         assertEquals(new DurationSpec.IntMillisecondsBound(2000), config.internode_tcp_connect_timeout);
         assertEquals(new DurationSpec.IntMillisecondsBound(30000), config.internode_tcp_user_timeout);
         assertEquals(new DurationSpec.IntMillisecondsBound(0), config.commitlog_sync_group_window);
-        assertEquals(new DurationSpec.IntMillisecondsBound(0), config.commitlog_sync_period);
+        assertEquals(new DurationSpec.IntMillisecondsBound(10000), config.commitlog_sync_period);
         assertNull(config.periodic_commitlog_sync_lag_block);
         assertEquals(new DurationSpec.IntMillisecondsBound(250), config.cdc_free_space_check_interval);
         assertEquals(new DurationSpec.IntMillisecondsBound(100), config.dynamic_snitch_update_interval);

File: test/distributed/org/apache/cassandra/distributed/impl/InstanceConfig.java
Patch:
@@ -101,7 +101,8 @@ private InstanceConfig(int num,
                 .set("memtable_flush_writers", 1)
                 .set("concurrent_compactors", 1)
                 .set("memtable_heap_space", "10MiB")
-                .set("commitlog_sync", "batch")
+                .set("commitlog_sync", "periodic")
+                .set("commitlog_sync_period_in_ms", 10000)
                 .set("storage_port", storage_port)
                 .set("native_transport_port", native_transport_port)
                 .set("endpoint_snitch", DistributedTestSnitch.class.getName())

File: test/distributed/org/apache/cassandra/distributed/test/ReplicaFilteringProtectionTest.java
Patch:
@@ -57,8 +57,7 @@ public static void setup() throws IOException
     {
         cluster = init(Cluster.build()
                               .withNodes(REPLICAS)
-                              .withConfig(config -> config.set("hinted_handoff_enabled", false)
-                                                          .set("commitlog_sync", "batch")).start());
+                              .withConfig(config -> config.set("hinted_handoff_enabled", false)).start());
 
         // Make sure we start w/ the correct defaults:
         cluster.get(1).runOnInstance(() -> assertEquals(DEFAULT_WARN_THRESHOLD, StorageService.instance.getCachedReplicaRowsWarnThreshold()));

File: test/unit/org/apache/cassandra/config/FailStartupDuplicateParamsTest.java
Patch:
@@ -42,7 +42,8 @@ public class FailStartupDuplicateParamsTest
 {
     private static final List<String> baseConfig = ImmutableList.of(
         "cluster_name: Test Cluster",
-        "commitlog_sync: batch",
+        "commitlog_sync: periodic",
+        "commitlog_sync_period: 10s",
         "commitlog_directory: build/test/cassandra/commitlog",
         "hints_directory: build/test/cassandra/hints",
         "partitioner: org.apache.cassandra.dht.ByteOrderedPartitioner",

File: test/unit/org/apache/cassandra/config/LoadOldYAMLBackwardCompatibilityTest.java
Patch:
@@ -80,7 +80,7 @@ public void testConfigurationLoaderBackwardCompatibility()
         assertEquals(new DataRateSpec.LongBytesPerSecondBound(24L  * 1024L * 1024L), config.inter_dc_stream_throughput_outbound);
         assertNull(config.commitlog_total_space);
         assertEquals(new DurationSpec.IntMillisecondsBound(0.0, TimeUnit.MILLISECONDS), config.commitlog_sync_group_window);
-        assertEquals(new DurationSpec.IntMillisecondsBound(0), config.commitlog_sync_period);
+        assertEquals(new DurationSpec.IntMillisecondsBound(10000), config.commitlog_sync_period);
         assertEquals(new DataStorageSpec.IntMebibytesBound(5), config.commitlog_segment_size);
         assertNull(config.periodic_commitlog_sync_lag_block);  //Integer
         assertNull(config.max_mutation_size);

File: test/unit/org/apache/cassandra/config/ParseAndConvertUnitsTest.java
Patch:
@@ -53,7 +53,7 @@ public void testConfigurationLoaderParser()
         assertEquals(new DurationSpec.IntMillisecondsBound(2000), config.internode_tcp_connect_timeout);
         assertEquals(new DurationSpec.IntMillisecondsBound(30000), config.internode_tcp_user_timeout);
         assertEquals(new DurationSpec.IntMillisecondsBound(0), config.commitlog_sync_group_window);
-        assertEquals(new DurationSpec.IntMillisecondsBound(0), config.commitlog_sync_period);
+        assertEquals(new DurationSpec.IntMillisecondsBound(10000), config.commitlog_sync_period);
         assertNull(config.periodic_commitlog_sync_lag_block);
         assertEquals(new DurationSpec.IntMillisecondsBound(250), config.cdc_free_space_check_interval);
         assertEquals(new DurationSpec.IntMillisecondsBound(100), config.dynamic_snitch_update_interval);

File: test/distributed/org/apache/cassandra/distributed/test/RepairBoundaryTest.java
Patch:
@@ -164,7 +164,6 @@ public static void init() throws IOException
     {
         cluster = Cluster.build(3)
                          .withConfig(config -> config.set("hinted_handoff_enabled", false)
-                                                     .set("commitlog_sync_batch_window_in_ms", 5)
                                                      .set("num_tokens", 1)
                                                      .set("initial_token", Long.toString(config.num() * 1000))
                                                      .with(NETWORK)

File: test/distributed/org/apache/cassandra/distributed/test/RepairTest.java
Patch:
@@ -89,7 +89,6 @@ private static ICluster create(Consumer<IInstanceConfig> configModifier) throws
     {
         configModifier = configModifier.andThen(
         config -> config.set("hinted_handoff_enabled", false)
-                        .set("commitlog_sync_batch_window_in_ms", 5)
                         .with(NETWORK)
                         .with(GOSSIP)
         );

File: test/distributed/org/apache/cassandra/distributed/test/ReplicaFilteringProtectionTest.java
Patch:
@@ -56,8 +56,7 @@ public static void setup() throws IOException
     {
         cluster = init(Cluster.build()
                               .withNodes(REPLICAS)
-                              .withConfig(config -> config.set("hinted_handoff_enabled", false)
-                                                          .set("commitlog_sync", "batch")).start());
+                              .withConfig(config -> config.set("hinted_handoff_enabled", false)).start());
 
         // Make sure we start w/ the correct defaults:
         cluster.get(1).runOnInstance(() -> assertEquals(DEFAULT_WARN_THRESHOLD, StorageService.instance.getCachedReplicaRowsWarnThreshold()));

File: test/unit/org/apache/cassandra/config/FailStartupDuplicateParamsTest.java
Patch:
@@ -42,7 +42,8 @@ public class FailStartupDuplicateParamsTest
 {
     private static final List<String> baseConfig = ImmutableList.of(
         "cluster_name: Test Cluster",
-        "commitlog_sync: batch",
+        "commitlog_sync: periodic",
+        "commitlog_sync_period: 10s",
         "commitlog_directory: build/test/cassandra/commitlog",
         "hints_directory: build/test/cassandra/hints",
         "partitioner: org.apache.cassandra.dht.ByteOrderedPartitioner",

File: test/unit/org/apache/cassandra/config/LoadOldYAMLBackwardCompatibilityTest.java
Patch:
@@ -79,7 +79,7 @@ public void testConfigurationLoaderBackwardCompatibility()
         assertEquals(new DataRateSpec.LongBytesPerSecondBound(24L  * 1024L * 1024L), config.inter_dc_stream_throughput_outbound);
         assertNull(config.commitlog_total_space);
         assertEquals(new DurationSpec.IntMillisecondsBound(0.0, TimeUnit.MILLISECONDS), config.commitlog_sync_group_window);
-        assertEquals(new DurationSpec.IntMillisecondsBound(0), config.commitlog_sync_period);
+        assertEquals(new DurationSpec.IntMillisecondsBound(10000), config.commitlog_sync_period);
         assertEquals(new DataStorageSpec.IntMebibytesBound(5), config.commitlog_segment_size);
         assertNull(config.periodic_commitlog_sync_lag_block);  //Integer
         assertNull(config.max_mutation_size);

File: test/unit/org/apache/cassandra/config/ParseAndConvertUnitsTest.java
Patch:
@@ -53,7 +53,7 @@ public void testConfigurationLoaderParser()
         assertEquals(new DurationSpec.IntMillisecondsBound(2000), config.internode_tcp_connect_timeout);
         assertEquals(new DurationSpec.IntMillisecondsBound(30000), config.internode_tcp_user_timeout);
         assertEquals(new DurationSpec.IntMillisecondsBound(0), config.commitlog_sync_group_window);
-        assertEquals(new DurationSpec.IntMillisecondsBound(0), config.commitlog_sync_period);
+        assertEquals(new DurationSpec.IntMillisecondsBound(10000), config.commitlog_sync_period);
         assertNull(config.periodic_commitlog_sync_lag_block);
         assertEquals(new DurationSpec.IntMillisecondsBound(250), config.cdc_free_space_check_interval);
         assertEquals(new DurationSpec.IntMillisecondsBound(100), config.dynamic_snitch_update_interval);

File: test/distributed/org/apache/cassandra/distributed/test/RepairBoundaryTest.java
Patch:
@@ -163,7 +163,6 @@ public static void init() throws IOException
     {
         cluster = Cluster.build(3)
                          .withConfig(config -> config.set("hinted_handoff_enabled", false)
-                                                     .set("commitlog_sync_batch_window_in_ms", 5)
                                                      .set("num_tokens", 1)
                                                      .set("initial_token", Long.toString(config.num() * 1000))
                                                      .with(NETWORK)

File: test/distributed/org/apache/cassandra/distributed/test/RepairTest.java
Patch:
@@ -84,7 +84,6 @@ private static ICluster create(Consumer<IInstanceConfig> configModifier) throws
     {
         configModifier = configModifier.andThen(
         config -> config.set("hinted_handoff_enabled", false)
-                        .set("commitlog_sync_batch_window_in_ms", 5)
                         .with(NETWORK)
                         .with(GOSSIP)
         );

File: test/distributed/org/apache/cassandra/distributed/test/ReplicaFilteringProtectionTest.java
Patch:
@@ -57,7 +57,6 @@ public static void setup() throws IOException
         cluster = init(Cluster.build()
                               .withNodes(REPLICAS)
                               .withConfig(config -> config.set("hinted_handoff_enabled", false)
-                                                          .set("commitlog_sync", "batch")
                                                           .set("num_tokens", 1)).start());
 
         // Make sure we start w/ the correct defaults:
@@ -68,7 +67,8 @@ public static void setup() throws IOException
     @AfterClass
     public static void teardown()
     {
-        cluster.close();
+        if (cluster != null)
+            cluster.close();
     }
 
     @Test

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -1185,6 +1185,7 @@ public BufferType toBufferType()
             switch (this)
             {
                 case unslabbed_heap_buffers:
+                case unslabbed_heap_buffers_logged:
                 case heap_buffers:
                     return BufferType.ON_HEAP;
                 case offheap_buffers:

File: test/distributed/org/apache/cassandra/distributed/test/ReadRepairTest.java
Patch:
@@ -356,6 +356,7 @@ public void readRepairRTRangeMovementTest() throws Throwable
         String key = "test1";
         try (Cluster cluster = init(Cluster.build()
                                            .withConfig(config -> config.with(Feature.GOSSIP, Feature.NETWORK)
+                                                                       .set("native_transport_timeout", String.format("%dms", Integer.MAX_VALUE))
                                                                        .set("read_request_timeout", String.format("%dms", Integer.MAX_VALUE)))
                                            .withTokenSupplier(TokenSupplier.evenlyDistributedTokens(4))
                                            .withNodeIdTopology(NetworkTopology.singleDcNetworkTopology(4, "dc0", "rack0"))

File: test/unit/org/apache/cassandra/repair/FuzzTestBase.java
Patch:
@@ -70,6 +70,7 @@
 import org.apache.cassandra.concurrent.SequentialExecutorPlus;
 import org.apache.cassandra.concurrent.SimulatedExecutorFactory;
 import org.apache.cassandra.concurrent.Stage;
+import org.apache.cassandra.config.Config;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.UnitConfigOverride;
 import org.apache.cassandra.cql3.CQLTester;
@@ -182,6 +183,8 @@ public static void setUpClass()
         UnitConfigOverride.maybeOverrideConfig();
 
         DatabaseDescriptor.daemonInitialization();
+        DatabaseDescriptor.setCommitLogWriteDiskAccessMode(Config.DiskAccessMode.mmap);
+
         DatabaseDescriptor.setPartitionerUnsafe(Murmur3Partitioner.instance); // TOOD (coverage): random select
         DatabaseDescriptor.setLocalDataCenter("test");
         StreamingChannel.Factory.Global.unsafeSet(new StreamingChannel.Factory()

File: test/simulator/test/org/apache/cassandra/simulator/test/SimulationTestBase.java
Patch:
@@ -206,7 +206,7 @@ public static <T extends Simulation> void simulate(ClusterSimulation.Builder<T>
         long seed = System.currentTimeMillis();
         // Development seed:
         //long seed = 1687184561194L;
-        System.out.println("Simulation seed: " + seed + "L");
+        logger.info("Simulation seed: {}L", seed);
         configure.accept(factory);
         try (ClusterSimulation<?> cluster = factory.create(seed))
         {

File: src/java/org/apache/cassandra/tcm/listeners/LegacyStateListener.java
Patch:
@@ -157,6 +157,7 @@ else if (prev.directory.peerState(change) == BOOT_REPLACING)
                         for (Token token : tokens)
                             logger.warn("Token {} changing ownership from {} to {}", token, replaced, replacement);
                     }
+                    Gossiper.instance.mergeNodeToGossip(change, next, tokens);
                 }
             }
             else

File: src/java/org/apache/cassandra/schema/TableMetadata.java
Patch:
@@ -1237,7 +1237,7 @@ private void appendColumnDefinitions(CqlBuilder builder,
                 DroppedColumn dropped = iterDropped.next();
                 dropped.column.appendCqlTo(builder);
 
-                if (!hasSingleColumnPrimaryKey || iter.hasNext())
+                if (!hasSingleColumnPrimaryKey || iterDropped.hasNext())
                     builder.append(',');
 
                 builder.newLine();

File: src/java/org/apache/cassandra/cql3/QueryProcessor.java
Patch:
@@ -108,7 +108,7 @@
 
 public class QueryProcessor implements QueryHandler
 {
-    public static final CassandraVersion CQL_VERSION = new CassandraVersion("3.4.7");
+    public static final CassandraVersion CQL_VERSION = new CassandraVersion("3.4.8");
 
     // See comments on QueryProcessor #prepare
     public static final CassandraVersion NEW_PREPARED_STATEMENT_BEHAVIOUR_SINCE_40 = new CassandraVersion("4.0.2");

File: test/unit/org/apache/cassandra/service/StartupChecksTest.java
Patch:
@@ -244,6 +244,7 @@ List<TableGCPeriod> getTablesGcPeriods(String userKeyspace)
     public void testKernelBug1057843Check() throws Exception
     {
         Assume.assumeTrue(DatabaseDescriptor.getCommitLogCompression() == null); // we would not be able to enable direct io otherwise
+        Assume.assumeTrue("Skipping this test on non-Linux OS", FBUtilities.isLinux);
         testKernelBug1057843Check("ext4", DiskAccessMode.direct, new Semver("6.1.63.1-generic"), false);
         testKernelBug1057843Check("ext4", DiskAccessMode.direct, new Semver("6.1.64.1-generic"), true);
         testKernelBug1057843Check("ext4", DiskAccessMode.direct, new Semver("6.1.65.1-generic"), true);

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1084,7 +1084,7 @@ private void exitWriteSurveyMode()
                           : ((BootstrapAndReplace)sequence).finishJoiningRing().executeNext().isContinuable();
 
         if (!success)
-            throw new RuntimeException(String.format("Could not perform next step of joining the ring {}, " +
+            throw new RuntimeException(String.format("Could not perform next step of joining the ring %s, " +
                                                      "restart this node and inflight operations will attempt to complete. " +
                                                      "If no progress is made, cancel the join process for this node and retry",
                                                      next));

File: src/java/org/apache/cassandra/tcm/compatibility/GossipHelper.java
Patch:
@@ -193,8 +193,8 @@ else if (sequence.kind() == MultiStepOperation.Kind.REPLACE)
         else if (sequence.kind() == MultiStepOperation.Kind.MOVE)
             return new HashSet<>(((Move)sequence).tokens);
 
-        throw new IllegalArgumentException(String.format("Extracting tokens from %s sequence is " +
-                                                         "neither necessary nor supported here"));
+        throw new IllegalArgumentException(String.format("Extracting tokens from %s sequence is neither necessary nor supported here",
+                                                         sequence.kind()));
     }
 
     private static Collection<Token> getTokensIn(IPartitioner partitioner, EndpointState epState)

File: test/harry/main/org/apache/cassandra/harry/ddl/SchemaGenerators.java
Patch:
@@ -485,7 +485,7 @@ public static List<ColumnSpec<?>> toColumns(Map<String, String> config, ColumnSp
         {
             ColumnSpec.DataType<?> type = nameToTypeMap.get(e.getValue());
             assert type != null : "Can't parse the type";
-            assert allowReverse || !type.isReversed() : String.format("%s columns aren't allowed to be reversed");
+            assert allowReverse || !type.isReversed() : String.format("%s columns aren't allowed to be reversed", type);
             columns.add(new ColumnSpec<>(e.getKey(), type, kind));
         }
 

File: src/java/org/apache/cassandra/db/marshal/DateType.java
Patch:
@@ -80,7 +80,7 @@ public Term fromJSONObject(Object parsed) throws MarshalException
     @Override
     public String toJSONString(ByteBuffer buffer, ProtocolVersion protocolVersion)
     {
-        return '"' + TimestampSerializer.getJsonDateFormatter().format(TimestampSerializer.instance.deserialize(buffer)) + '"';
+        return '"' + TimestampSerializer.getJsonDateFormatter().format(TimestampSerializer.instance.deserialize(buffer).toInstant()) + '"';
     }
 
     @Override

File: src/java/org/apache/cassandra/db/marshal/TimestampType.java
Patch:
@@ -102,7 +102,7 @@ public Term fromJSONObject(Object parsed) throws MarshalException
 
     private String toString(Date date)
     {
-        return date != null ? TimestampSerializer.getJsonDateFormatter().format(date) : "";
+        return date != null ? TimestampSerializer.getJsonDateFormatter().format(date.toInstant()) : "";
     }
 
     @Override

File: src/java/org/apache/cassandra/db/marshal/AbstractCompositeType.java
Patch:
@@ -63,7 +63,7 @@ public <VL, VR> int compareCustom(VL left, ValueAccessor<VL> accessorL, VR right
         int offsetL = startingOffset(isStaticL);
         int offsetR = startingOffset(isStaticR);
 
-        while (!accessorL.isEmptyFromOffset(left, offsetL) && !accessorR.isEmptyFromOffset(right, offsetL))
+        while (!accessorL.isEmptyFromOffset(left, offsetL) && !accessorR.isEmptyFromOffset(right, offsetR))
         {
             AbstractType<?> comparator = getComparator(i, left, accessorL, right, accessorR, offsetL, offsetR);
             offsetL += getComparatorSize(i, left, accessorL, offsetL);

File: src/java/org/apache/cassandra/db/marshal/TypeParser.java
Patch:
@@ -319,7 +319,7 @@ public Map<Byte, AbstractType<?>> getAliasParameters() throws SyntaxException, C
 
             String alias = readNextIdentifier();
             if (alias.length() != 1)
-                throwSyntaxError("An alias should be a single character");
+                throwSyntaxError("An alias should be a single character: '" + alias + "', string: " + str);
             char aliasChar = alias.charAt(0);
             if (aliasChar < 33 || aliasChar > 127)
                 throwSyntaxError("An alias should be a single character in [0..9a..bA..B-+._&]");

File: src/java/org/apache/cassandra/db/marshal/UserType.java
Patch:
@@ -349,7 +349,7 @@ public boolean isValueCompatibleWith(AbstractType<?> previous)
     @Override
     public boolean equals(Object o)
     {
-        if(!(o instanceof UserType))
+        if (o.getClass() != UserType.class)
             return false;
 
         UserType that = (UserType)o;

File: src/java/org/apache/cassandra/db/marshal/AbstractCompositeType.java
Patch:
@@ -63,7 +63,7 @@ public <VL, VR> int compareCustom(VL left, ValueAccessor<VL> accessorL, VR right
         int offsetL = startingOffset(isStaticL);
         int offsetR = startingOffset(isStaticR);
 
-        while (!accessorL.isEmptyFromOffset(left, offsetL) && !accessorR.isEmptyFromOffset(right, offsetL))
+        while (!accessorL.isEmptyFromOffset(left, offsetL) && !accessorR.isEmptyFromOffset(right, offsetR))
         {
             AbstractType<?> comparator = getComparator(i, left, accessorL, right, accessorR, offsetL, offsetR);
             offsetL += getComparatorSize(i, left, accessorL, offsetL);

File: src/java/org/apache/cassandra/db/marshal/TypeParser.java
Patch:
@@ -319,7 +319,7 @@ public Map<Byte, AbstractType<?>> getAliasParameters() throws SyntaxException, C
 
             String alias = readNextIdentifier();
             if (alias.length() != 1)
-                throwSyntaxError("An alias should be a single character");
+                throwSyntaxError("An alias should be a single character: '" + alias + "', string: " + str);
             char aliasChar = alias.charAt(0);
             if (aliasChar < 33 || aliasChar > 127)
                 throwSyntaxError("An alias should be a single character in [0..9a..bA..B-+._&]");

File: src/java/org/apache/cassandra/db/marshal/UserType.java
Patch:
@@ -347,7 +347,7 @@ public boolean isValueCompatibleWith(AbstractType<?> previous)
     @Override
     public boolean equals(Object o)
     {
-        if(!(o instanceof UserType))
+        if (o.getClass() != UserType.class)
             return false;
 
         UserType that = (UserType)o;

File: src/java/org/apache/cassandra/db/marshal/AbstractCompositeType.java
Patch:
@@ -59,7 +59,7 @@ public <VL, VR> int compareCustom(VL left, ValueAccessor<VL> accessorL, VR right
         int offsetL = startingOffset(isStaticL);
         int offsetR = startingOffset(isStaticR);
 
-        while (!accessorL.isEmptyFromOffset(left, offsetL) && !accessorR.isEmptyFromOffset(right, offsetL))
+        while (!accessorL.isEmptyFromOffset(left, offsetL) && !accessorR.isEmptyFromOffset(right, offsetR))
         {
             AbstractType<?> comparator = getComparator(i, left, accessorL, right, accessorR, offsetL, offsetR);
             offsetL += getComparatorSize(i, left, accessorL, offsetL);

File: src/java/org/apache/cassandra/db/marshal/TypeParser.java
Patch:
@@ -225,7 +225,7 @@ public Map<Byte, AbstractType<?>> getAliasParameters() throws SyntaxException, C
 
             String alias = readNextIdentifier();
             if (alias.length() != 1)
-                throwSyntaxError("An alias should be a single character");
+                throwSyntaxError("An alias should be a single character: '" + alias + "', string: " + str);
             char aliasChar = alias.charAt(0);
             if (aliasChar < 33 || aliasChar > 127)
                 throwSyntaxError("An alias should be a single character in [0..9a..bA..B-+._&]");

File: src/java/org/apache/cassandra/db/marshal/UserType.java
Patch:
@@ -342,7 +342,7 @@ public boolean isValueCompatibleWith(AbstractType<?> previous)
     @Override
     public boolean equals(Object o)
     {
-        if(!(o instanceof UserType))
+        if (o.getClass() != UserType.class)
             return false;
 
         UserType that = (UserType)o;

File: test/distributed/org/apache/cassandra/distributed/test/SSTableIdGenerationTest.java
Patch:
@@ -526,6 +526,6 @@ private static void checkRowsNumber(IInstance instance, String ks, String tableN
         SimpleQueryResult result = instance.executeInternalWithResult(format("SELECT * FROM %s.%s", ks, tableName));
         Object[][] rows = result.toObjectArrays();
         assertThat(rows).withFailMessage("Invalid results for %s.%s - should have %d rows but has %d: \n%s", ks, tableName, expectedNumber,
-                                         rows.length, result.toString()).hasSize(expectedNumber);
+                                         rows.length, result.toString()).hasNumberOfRows(expectedNumber);
     }
 }

File: src/java/org/apache/cassandra/db/marshal/AbstractCompositeType.java
Patch:
@@ -59,7 +59,7 @@ public <VL, VR> int compareCustom(VL left, ValueAccessor<VL> accessorL, VR right
         int offsetL = startingOffset(isStaticL);
         int offsetR = startingOffset(isStaticR);
 
-        while (!accessorL.isEmptyFromOffset(left, offsetL) && !accessorR.isEmptyFromOffset(right, offsetL))
+        while (!accessorL.isEmptyFromOffset(left, offsetL) && !accessorR.isEmptyFromOffset(right, offsetR))
         {
             AbstractType<?> comparator = getComparator(i, left, accessorL, right, accessorR, offsetL, offsetR);
             offsetL += getComparatorSize(i, left, accessorL, offsetL);

File: src/java/org/apache/cassandra/db/marshal/TypeParser.java
Patch:
@@ -225,7 +225,7 @@ public Map<Byte, AbstractType<?>> getAliasParameters() throws SyntaxException, C
 
             String alias = readNextIdentifier();
             if (alias.length() != 1)
-                throwSyntaxError("An alias should be a single character");
+                throwSyntaxError("An alias should be a single character: '" + alias + "', string: " + str);
             char aliasChar = alias.charAt(0);
             if (aliasChar < 33 || aliasChar > 127)
                 throwSyntaxError("An alias should be a single character in [0..9a..bA..B-+._&]");

File: src/java/org/apache/cassandra/db/marshal/UserType.java
Patch:
@@ -342,7 +342,7 @@ public boolean isValueCompatibleWith(AbstractType<?> previous)
     @Override
     public boolean equals(Object o)
     {
-        if(!(o instanceof UserType))
+        if (o.getClass() != UserType.class)
             return false;
 
         UserType that = (UserType)o;

File: test/unit/org/apache/cassandra/repair/RepairJobTest.java
Patch:
@@ -71,7 +71,6 @@
 import org.apache.cassandra.utils.asserts.SyncTaskListAssert;
 
 import static org.apache.cassandra.utils.asserts.SyncTaskAssert.assertThat;
-import static org.apache.cassandra.utils.asserts.SyncTaskListAssert.assertThat;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertTrue;
 
@@ -661,7 +660,7 @@ public void testOptimisedCreateStandardSyncTasks()
                                                                                             false,
                                                                                             PreviewKind.ALL));
 
-        assertThat(tasks.values()).areAllInstanceOf(AsymmetricRemoteSyncTask.class);
+        SyncTaskListAssert.assertThat(tasks.values()).areAllInstanceOf(AsymmetricRemoteSyncTask.class);
 
         // addr1 streams range1 from addr3:
         assertThat(tasks.get(pair(addr1, addr3)).rangesToSync).contains(RANGE_1);

File: src/java/org/apache/cassandra/hints/HintsDispatchTrigger.java
Patch:
@@ -73,6 +73,8 @@ private void schedule(HintsStore store)
 
         if (store.isWriting())
             writeExecutor.closeWriter(store);
+
+        HintsService.instance.getHintsBufferPool().clearEarliestHintsForHostId(store.hostId);
     }
 
     private boolean isScheduled(HintsStore store)

File: src/java/org/apache/cassandra/index/sai/disk/v1/postings/PostingListRangeIterator.java
Patch:
@@ -77,7 +77,7 @@ public PostingListRangeIterator(IndexIdentifier indexIdentifier,
                                     PrimaryKeyMap primaryKeyMap,
                                     IndexSegmentSearcherContext searcherContext)
     {
-        super(searcherContext.minimumKey, searcherContext.maximumKey, searcherContext.count());
+        super(searcherContext.minimumKey, searcherContext.maximumKey, searcherContext.count(), () -> {});
 
         this.indexIdentifier = indexIdentifier;
         this.primaryKeyMap = primaryKeyMap;

File: src/java/org/apache/cassandra/index/sai/iterators/KeyRangeOrderingIterator.java
Patch:
@@ -42,7 +42,7 @@ public class KeyRangeOrderingIterator extends KeyRangeIterator
 
     public KeyRangeOrderingIterator(KeyRangeIterator input, int chunkSize, Function<List<PrimaryKey>, KeyRangeIterator> nextRangeFunction)
     {
-        super(input);
+        super(input, () -> {});
         this.input = input;
         this.chunkSize = chunkSize;
         this.nextRangeFunction = nextRangeFunction;

File: src/java/org/apache/cassandra/index/sai/memory/InMemoryKeyRangeIterator.java
Patch:
@@ -37,7 +37,7 @@ public class InMemoryKeyRangeIterator extends KeyRangeIterator
      */
     public InMemoryKeyRangeIterator(SortedSet<PrimaryKey> keys)
     {
-        super(keys.first(), keys.last(), keys.size());
+        super(keys.first(), keys.last(), keys.size(), () -> {});
         this.keys = new PriorityQueue<>(keys);
         this.uniqueKeys = true;
     }
@@ -48,7 +48,7 @@ public InMemoryKeyRangeIterator(SortedSet<PrimaryKey> keys)
      */
     public InMemoryKeyRangeIterator(PrimaryKey min, PrimaryKey max, PriorityQueue<PrimaryKey> keys)
     {
-        super(min, max, keys.size());
+        super(min, max, keys.size(), () -> {});
         this.keys = keys;
         this.uniqueKeys = false;
     }

File: test/unit/org/apache/cassandra/index/sai/disk/v1/BalancedTreeIndexSearcherTest.java
Patch:
@@ -152,7 +152,6 @@ private <T extends Number> void testEqQueries(final IndexSegmentSearcher indexSe
                                                                        .add(Operator.EQ, rawType.decompose(rawValueProducer.apply(EQ_TEST_LOWER_BOUND_INCLUSIVE)))
                                                              , null, mock(QueryContext.class)))
         {
-            assertEquals(results.getMinimum(), results.getCurrent());
             assertTrue(results.hasNext());
 
             assertEquals(0L, results.next().token().getLongValue());
@@ -186,7 +185,6 @@ private <T extends Number> void testRangeQueries(final IndexSegmentSearcher inde
                                                                        .add(Operator.LTE, rawType.decompose(rawValueProducer.apply((short)7))),
                                                              null, mock(QueryContext.class)))
         {
-            assertEquals(results.getMinimum(), results.getCurrent());
             assertTrue(results.hasNext());
 
             List<Long> actualTokenList = Lists.newArrayList(Iterators.transform(results, key -> key.token().getLongValue()));

File: test/unit/org/apache/cassandra/index/sai/disk/v1/InvertedIndexSearcherTest.java
Patch:
@@ -114,7 +114,6 @@ public void testEqQueriesAgainstStringIndex() throws Exception
             {
                 try (KeyRangeIterator results = searcher.search(Expression.create(index).add(Operator.EQ, wrap(termsEnum.get(t).left)), null, context))
                 {
-                    assertEquals(results.getMinimum(), results.getCurrent());
                     assertTrue(results.hasNext());
 
                     for (int p = 0; p < numPostings; ++p)
@@ -129,7 +128,6 @@ public void testEqQueriesAgainstStringIndex() throws Exception
 
                 try (KeyRangeIterator results = searcher.search(Expression.create(index).add(Operator.EQ, wrap(termsEnum.get(t).left)), null, context))
                 {
-                    assertEquals(results.getMinimum(), results.getCurrent());
                     assertTrue(results.hasNext());
 
                     // test skipping to the last block

File: src/java/org/apache/cassandra/cql3/statements/schema/CreateIndexStatement.java
Patch:
@@ -244,7 +244,7 @@ private void validateIndexTarget(TableMetadata table, IndexMetadata.Kind kind, I
             throw ire(ONLY_PARTITION_KEY, column);
 
         if (column.type.isFrozenCollection() && target.type != Type.FULL)
-            throw ire(CREATE_ON_FROZEN_COLUMN, target.type, column, column);
+            throw ire(CREATE_ON_FROZEN_COLUMN, target.type, column, column.name.toCQLString());
 
         if (!column.type.isFrozenCollection() && target.type == Type.FULL)
             throw ire(FULL_ON_FROZEN_COLLECTIONS);

File: src/java/org/apache/cassandra/index/sai/disk/v1/SSTableIndexWriter.java
Patch:
@@ -200,7 +200,8 @@ else if (shouldFlush(sstableRowId))
             currentBuilder = newSegmentBuilder();
         }
 
-        if (term.remaining() == 0) return;
+        // Some types support empty byte buffers:
+        if (term.remaining() == 0 && !index.termType().indexType().allowsEmpty()) return;
 
         if (analyzer == null || !index.termType().isLiteral())
         {

File: src/java/org/apache/cassandra/cql3/statements/schema/CreateIndexStatement.java
Patch:
@@ -242,7 +242,7 @@ private void validateIndexTarget(TableMetadata table, IndexMetadata.Kind kind, I
             throw ire(ONLY_PARTITION_KEY, column);
 
         if (column.type.isFrozenCollection() && target.type != Type.FULL)
-            throw ire(CREATE_ON_FROZEN_COLUMN, target.type, column, column);
+            throw ire(CREATE_ON_FROZEN_COLUMN, target.type, column, column.name.toCQLString());
 
         if (!column.type.isFrozenCollection() && target.type == Type.FULL)
             throw ire(FULL_ON_FROZEN_COLLECTIONS);

File: src/java/org/apache/cassandra/index/sai/disk/v1/SSTableIndexWriter.java
Patch:
@@ -200,7 +200,8 @@ else if (shouldFlush(sstableRowId))
             currentBuilder = newSegmentBuilder();
         }
 
-        if (term.remaining() == 0) return;
+        // Some types support empty byte buffers:
+        if (term.remaining() == 0 && !index.termType().indexType().allowsEmpty()) return;
 
         if (analyzer == null || !index.termType().isLiteral())
         {

File: src/java/org/apache/cassandra/db/compaction/UnifiedCompactionStrategy.java
Patch:
@@ -297,7 +297,9 @@ private UnifiedCompactionTask createCompactionTask(LifecycleTransaction transact
     private void maybeUpdateShardManager()
     {
         // TODO - modify ShardManager::isOutOfDate to take an Epoch
-        if (shardManager != null && !shardManager.isOutOfDate(ClusterMetadata.current().epoch.getEpoch()))
+        if (shardManager != null
+            && (cfs.localRangesWeighted().ringVersion == ColumnFamilyStore.RING_VERSION_IRRELEVANT
+                || !shardManager.isOutOfDate(ClusterMetadata.current().epoch.getEpoch())))
             return; // the disk boundaries (and thus the local ranges too) have not changed since the last time we calculated
 
         synchronized (this)

File: src/java/org/apache/cassandra/tcm/sequences/InProgressSequences.java
Patch:
@@ -223,7 +223,7 @@ public void serialize(InProgressSequences t, DataOutputPlus out, Version version
             out.writeInt(t.state.size());
             for (Map.Entry<MultiStepOperation.SequenceKey, MultiStepOperation<?>> entry : t.state.entrySet())
             {
-                if (Version.UNKNOWN.isBefore(V2))
+                if (version.isBefore(V2))
                 {
                     NodeId.serializer.serialize((NodeId) entry.getKey(), out, version);
                     MultiStepOperation<?> seq = entry.getValue();
@@ -249,7 +249,7 @@ public InProgressSequences deserialize(DataInputPlus in, Version version) throws
             ImmutableMap.Builder<MultiStepOperation.SequenceKey, MultiStepOperation<?>> res = ImmutableMap.builder();
             for (int i = 0; i < ipsSize; i++)
             {
-                if (Version.UNKNOWN.isBefore(V2))
+                if (version.isBefore(V2))
                 {
                     NodeId nodeId = NodeId.serializer.deserialize(in, version);
                     MultiStepOperation.Kind kind = MultiStepOperation.Kind.valueOf(in.readUTF());
@@ -273,7 +273,7 @@ public long serializedSize(InProgressSequences t, Version version)
             size += sizeof(t.state.size());
             for (Map.Entry<MultiStepOperation.SequenceKey, MultiStepOperation<?>> entry : t.state.entrySet())
             {
-                if (Version.UNKNOWN.isBefore(V2))
+                if (version.isBefore(V2))
                 {
                     size += NodeId.serializer.serializedSize((NodeId) entry.getKey(), version);
                     MultiStepOperation<?> seq = entry.getValue();

File: src/java/org/apache/cassandra/config/CassandraRelevantProperties.java
Patch:
@@ -205,6 +205,8 @@ public enum CassandraRelevantProperties
     DTEST_API_LOG_TOPOLOGY("cassandra.dtest.api.log.topology"),
     /** This property indicates if the code is running under the in-jvm dtest framework */
     DTEST_IS_IN_JVM_DTEST("org.apache.cassandra.dtest.is_in_jvm_dtest"),
+    /** In_JVM dtest property indicating that the test should use "latest" configuration */
+    DTEST_JVM_DTESTS_USE_LATEST("jvm_dtests.latest"),
     ENABLE_DC_LOCAL_COMMIT("cassandra.enable_dc_local_commit", "true"),
     /**
      * Whether {@link org.apache.cassandra.db.ConsistencyLevel#NODE_LOCAL} should be allowed.

File: src/java/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -658,6 +658,9 @@ public UnfilteredRowIterator applyToPartition(UnfilteredRowIterator iter)
             @Override
             protected Row applyToStatic(Row row)
             {
+                if (row == Rows.EMPTY_STATIC_ROW)
+                    return row;
+
                 return applyToRow(row);
             }
 

File: src/java/org/apache/cassandra/db/compaction/UnifiedCompactionStrategy.java
Patch:
@@ -95,6 +95,7 @@ public UnifiedCompactionStrategy(ColumnFamilyStore cfs, Map<String, String> opti
         super(cfs, options);
         this.controller = controller;
         estimatedRemainingTasks = 0;
+        lastExpiredCheck = Clock.Global.currentTimeMillis();
     }
 
     public static Map<String, String> validateOptions(Map<String, String> options) throws ConfigurationException

File: src/java/org/apache/cassandra/db/compaction/unified/Controller.java
Patch:
@@ -268,9 +268,10 @@ public int getNumShards(double localDensity)
         if (minSSTableSize > 0)
         {
             double count = localDensity / minSSTableSize;
-            // Minimum size only applies if it is smaller than the base count.
+            // Minimum size only applies if the base count would result in smaller sstables.
+            // We also want to use the min size if we don't yet know the flush size (density is NaN).
             // Note: the minimum size cannot be larger than the target size's minimum.
-            if (count < baseShardCount)
+            if (!(count >= baseShardCount)) // also true for count == NaN
             {
                 // Make it a power of two, rounding down so that sstables are greater in size than the min.
                 // Setting the bottom bit to 1 ensures the result is at least 1.

File: test/distributed/org/apache/cassandra/distributed/test/SecondaryIndexCompactionTest.java
Patch:
@@ -21,6 +21,7 @@
 import java.io.IOException;
 import java.util.Set;
 
+import org.junit.Assume;
 import org.junit.Test;
 
 import org.apache.cassandra.db.ColumnFamilyStore;
@@ -43,6 +44,8 @@ public void test2iCompaction() throws IOException
     {
         try (Cluster cluster = init(Cluster.build(1).start()))
         {
+            Assume.assumeFalse("Test only valid for legacy index",
+                               "sai".equals(cluster.get(1).config().getString("default_secondary_index")));
             cluster.schemaChange(withKeyspace("create table %s.tbl (id int, ck int, something int, else int, primary key (id, ck));"));
             cluster.schemaChange(withKeyspace("create index tbl_idx on %s.tbl (ck)"));
 

File: test/distributed/org/apache/cassandra/distributed/test/SecondaryIndexTest.java
Patch:
@@ -88,7 +88,7 @@ public void test_only_coordinator_chooses_index_for_query()
         cluster.forEach(i -> i.flush(KEYSPACE));
 
         Pattern indexScanningPattern =
-                Pattern.compile(String.format("Index mean cardinalities are v_index_%d:[0-9]+. Scanning with v_index_%d.", seq.get(), seq.get()));
+                Pattern.compile(String.format("Index mean cardinalities are v_index_%d:[-0-9]+. Scanning with v_index_%d.", seq.get(), seq.get()));
 
         for (int i = 0 ; i < 33; ++i)
         {

File: test/distributed/org/apache/cassandra/distributed/test/UpgradeSSTablesTest.java
Patch:
@@ -60,8 +60,8 @@ public void upgradeSSTablesInterruptsOngoingCompaction() throws Throwable
             cluster.get(1).acceptsOnInstance((String ks) -> {
                 ColumnFamilyStore cfs = Keyspace.open(ks).getColumnFamilyStore("tbl");
                 cfs.disableAutoCompaction();
-                CompactionManager.instance.setMaximumCompactorThreads(1);
                 CompactionManager.instance.setCoreCompactorThreads(1);
+                CompactionManager.instance.setMaximumCompactorThreads(1);
             }).accept(KEYSPACE);
 
             String blob = "blob";
@@ -104,8 +104,8 @@ public void compactionDoesNotCancelUpgradeSSTables() throws Throwable
             cluster.get(1).acceptsOnInstance((String ks) -> {
                 ColumnFamilyStore cfs = Keyspace.open(ks).getColumnFamilyStore("tbl");
                 cfs.disableAutoCompaction();
-                CompactionManager.instance.setMaximumCompactorThreads(1);
                 CompactionManager.instance.setCoreCompactorThreads(1);
+                CompactionManager.instance.setMaximumCompactorThreads(1);
             }).accept(KEYSPACE);
 
             String blob = "blob";
@@ -198,8 +198,8 @@ public void truncateWhileUpgrading() throws Throwable
             cluster.get(1).acceptsOnInstance((String ks) -> {
                 ColumnFamilyStore cfs = Keyspace.open(ks).getColumnFamilyStore("tbl");
                 cfs.disableAutoCompaction();
-                CompactionManager.instance.setMaximumCompactorThreads(1);
                 CompactionManager.instance.setCoreCompactorThreads(1);
+                CompactionManager.instance.setMaximumCompactorThreads(1);
             }).accept(KEYSPACE);
 
             String blob = "blob";

File: test/distributed/org/apache/cassandra/distributed/test/sai/ConcurrencyFactorTest.java
Patch:
@@ -106,7 +106,7 @@ public void testInitialConcurrencySelection()
 
         // Token-restricted range query not using SAI so should use initial concurrency estimation
         query = String.format("SELECT * FROM %s.%s WHERE token(pk) > 0", KEYSPACE, SAI_TABLE);
-        runAndValidate("Submitting range requests on 2 ranges with a concurrency of 2 (230.4 rows per range expected)", query);
+        runAndValidate("Submitting range requests on 2 ranges with a concurrency of 2.*", query);
 
         // Token-restricted range query with SAI so should bypass initial concurrency estimation
         query = String.format("SELECT * FROM %s.%s WHERE token(pk) > 0 AND gdp > ?", KEYSPACE, SAI_TABLE);
@@ -124,7 +124,7 @@ private void runAndValidate(String trace, String query, Object... bondValues)
 
         await().atMost(5, TimeUnit.SECONDS).until(() -> {
             List<TracingUtil.TraceEntry> traceEntries = TracingUtil.getTrace(cluster, sessionId, ConsistencyLevel.ONE);
-            return traceEntries.stream().anyMatch(entry -> entry.activity.equals(trace));
+            return traceEntries.stream().anyMatch(entry -> entry.activity.matches(trace));
         });
     }
 

File: test/unit/org/apache/cassandra/config/ParseAndConvertUnitsTest.java
Patch:
@@ -104,7 +104,8 @@ public void testConfigurationLoaderParser()
         assertNull(config.file_cache_size);
         assertNull(config.index_summary_capacity);
         assertEquals(new DataStorageSpec.LongMebibytesBound(1), config.prepared_statements_cache_size);
-        assertNull(config.key_cache_size);
+        if (config.key_cache_size != null)  // null in default test config, 0 in latest test config (CASSANDRA-18753)
+            assertEquals(new DataStorageSpec.IntMebibytesBound(0), config.key_cache_size);
         assertEquals(new DataStorageSpec.LongMebibytesBound(16), config.row_cache_size);
         assertNull(config.native_transport_max_request_data_in_flight);
         assertNull(config.native_transport_max_request_data_in_flight_per_ip);

File: test/unit/org/apache/cassandra/cql3/validation/entities/FrozenCollectionsTest.java
Patch:
@@ -27,6 +27,7 @@
 import org.junit.Test;
 
 import org.apache.cassandra.ServerTestUtils;
+import org.apache.cassandra.Util;
 import org.apache.cassandra.cql3.CQLTester;
 import org.apache.cassandra.cql3.restrictions.StatementRestrictions;
 import org.apache.cassandra.db.marshal.*;
@@ -831,6 +832,7 @@ private void assertInvalidIndexCreationWithMessage(String statement, String erro
     @Test
     public void testSecondaryIndex() throws Throwable
     {
+        Util.assumeLegacySecondaryIndex();
         createTable("CREATE TABLE %s (a frozen<map<int, text>> PRIMARY KEY, b frozen<map<int, text>>)");
 
         // for now, we don't support indexing values or keys of collections in the primary key
@@ -996,6 +998,7 @@ public void testSecondaryIndex() throws Throwable
     @Test
     public void testClusteringColumnFiltering() throws Throwable
     {
+        Util.assumeLegacySecondaryIndex();
         createTable("CREATE TABLE %s (a int, b frozen<map<int, int>>, c int, d int, PRIMARY KEY (a, b, c))");
         createIndex("CREATE INDEX c_index ON %s (c)");
         createIndex("CREATE INDEX d_index ON %s (d)");

File: test/unit/org/apache/cassandra/cql3/validation/operations/CompactStorageSplit1Test.java
Patch:
@@ -24,6 +24,7 @@
 
 import org.junit.Test;
 
+import org.apache.cassandra.Util;
 import org.apache.cassandra.cql3.CQLTester;
 import org.apache.cassandra.cql3.validation.entities.SecondaryIndexTest;
 
@@ -722,6 +723,7 @@ public void testNormalColumnUsage() throws Throwable
     @Test
     public void testCompactTableWithValueOver64k() throws Throwable
     {
+        Util.assumeLegacySecondaryIndex();
         createTable("CREATE TABLE %s(a int, b blob, PRIMARY KEY (a)) WITH COMPACT STORAGE");
         createIndex("CREATE INDEX ON %s(b)");
         failInsert("INSERT INTO %s (a, b) VALUES (0, ?)", ByteBuffer.allocate(SecondaryIndexTest.TOO_BIG));
@@ -768,6 +770,7 @@ public void testIndexesOnClusteringInvalid() throws Throwable
     @Test
     public void testEmptyRestrictionValueWithSecondaryIndexAndCompactTables() throws Throwable
     {
+        Util.assumeLegacySecondaryIndex();
         createTable("CREATE TABLE %s (pk blob, c blob, v blob, PRIMARY KEY ((pk), c)) WITH COMPACT STORAGE");
         assertInvalidMessage("Secondary indexes are not supported on PRIMARY KEY columns in COMPACT STORAGE tables",
                              "CREATE INDEX on %s(c)");

File: test/unit/org/apache/cassandra/cql3/validation/operations/InsertInvalidateSizedRecordsTest.java
Patch:
@@ -31,6 +31,7 @@
 import org.junit.Test;
 
 import com.datastax.driver.core.exceptions.InvalidQueryException;
+import org.apache.cassandra.Util;
 import org.apache.cassandra.cql3.CQLTester;
 import org.apache.cassandra.io.util.File;
 import org.apache.cassandra.tools.ToolRunner;
@@ -145,6 +146,7 @@ public void compositeValueClustering()
     @Test
     public void singleValueIndex()
     {
+        Util.assumeLegacySecondaryIndex();
         createTable(KEYSPACE, "CREATE TABLE %s (a blob, b blob, PRIMARY KEY (a))");
         String table = KEYSPACE + "." + currentTable();
         execute("CREATE INDEX single_value_index ON %s (b)");

File: test/unit/org/apache/cassandra/cql3/validation/operations/InsertUpdateIfConditionTest.java
Patch:
@@ -459,7 +459,7 @@ public void testDropCreateTableIfNotExists() throws Throwable
     @Test
     public void testDropCreateIndexIfNotExists()
     {
-        String tableName = createTable("CREATE TABLE %s (id text PRIMARY KEY, value1 blob, value2 blob)with comment = 'foo'");
+        String tableName = createTable("CREATE TABLE %s (id text PRIMARY KEY, value1 text, value2 blob)with comment = 'foo'");
 
         // try dropping when doesn't exist
         schemaChange(format("DROP INDEX IF EXISTS %s.myindex", KEYSPACE));

File: test/unit/org/apache/cassandra/cql3/validation/operations/SelectLimitTest.java
Patch:
@@ -24,6 +24,7 @@
 import org.junit.Test;
 
 import org.apache.cassandra.ServerTestUtils;
+import org.apache.cassandra.Util;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.cql3.CQLTester;
 import org.apache.cassandra.dht.ByteOrderedPartitioner;
@@ -542,8 +543,9 @@ public void testFilteringOnClusteringColumnsWithLimitAndStaticColumns() throws T
     }
 
     @Test
-    public void testIndexOnRegularColumnWithPartitionWithoutRows() throws Throwable
+    public void testIndexOnRegularColumnWithPartitionWithoutRows()
     {
+        Util.assumeLegacySecondaryIndex();
         createTable("CREATE TABLE %s (pk int, c int, s int static, v int, PRIMARY KEY(pk, c))");
         createIndex("CREATE INDEX ON %s (v)");
 

File: test/unit/org/apache/cassandra/db/compaction/ActiveCompactionsTest.java
Patch:
@@ -35,6 +35,7 @@
 import com.google.common.util.concurrent.Uninterruptibles;
 import org.junit.Test;
 
+import org.apache.cassandra.Util;
 import org.apache.cassandra.cache.AutoSavingCache;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.cql3.CQLTester;
@@ -78,7 +79,7 @@ public void testActiveCompactionTrackingRaceWithIndexBuilder() throws Throwable
 
         ExecutorService es = Executors.newFixedThreadPool(2);
 
-        final int loopCount = 5000;
+        final int loopCount = 3500;
         for (int ii = 0; ii < loopCount; ii++)
         {
             CountDownLatch trigger = new CountDownLatch(1);
@@ -108,6 +109,7 @@ public void testActiveCompactionTrackingRaceWithIndexBuilder() throws Throwable
     @Test
     public void testSecondaryIndexTracking() throws Throwable
     {
+        Util.assumeLegacySecondaryIndex();
         createTable("CREATE TABLE %s (pk int, ck int, a int, b int, PRIMARY KEY (pk, ck))");
         String idxName = createIndex("CREATE INDEX on %s(a)");
         getCurrentColumnFamilyStore().disableAutoCompaction();

File: test/unit/org/apache/cassandra/db/compaction/writers/CompactionAwareWriterTest.java
Patch:
@@ -67,7 +67,8 @@ public static void beforeClass() throws Throwable
     {
         // Disabling durable write since we don't care
         schemaChange("CREATE KEYSPACE IF NOT EXISTS " + KEYSPACE + " WITH replication = {'class': 'SimpleStrategy', 'replication_factor': '1'} AND durable_writes=false");
-        schemaChange(String.format("CREATE TABLE %s.%s (k int, t int, v blob, PRIMARY KEY (k, t))", KEYSPACE, TABLE));
+        schemaChange(String.format("CREATE TABLE %s.%s (k int, t int, v blob, PRIMARY KEY (k, t)) WITH compaction = {'class': 'SizeTieredCompactionStrategy'}", KEYSPACE, TABLE));
+        // The compaction specification above is to avoid failures caused by UCS splitting large files.
     }
 
     @AfterClass

File: test/unit/org/apache/cassandra/index/SecondaryIndexManagerTest.java
Patch:
@@ -31,6 +31,7 @@
 import org.junit.After;
 import org.junit.Test;
 
+import org.apache.cassandra.Util;
 import org.apache.cassandra.cql3.CQLTester;
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.SystemKeyspace;
@@ -109,6 +110,7 @@ public void recreatingIndexMarksTheIndexAsBuilt() throws Throwable
     @Test
     public void addingSSTablesMarksTheIndexAsBuilt()
     {
+        Util.assumeLegacySecondaryIndex();
         createTable("CREATE TABLE %s (a int, b int, c int, PRIMARY KEY (a, b))");
         String indexName = createIndex("CREATE INDEX ON %s(c)");
 

File: test/unit/org/apache/cassandra/index/internal/CassandraIndexTest.java
Patch:
@@ -27,6 +27,7 @@
 import com.google.common.collect.*;
 import org.junit.Test;
 
+import org.apache.cassandra.Util;
 import org.apache.cassandra.cql3.CQLTester;
 import org.apache.cassandra.cql3.UntypedResultSet;
 import org.apache.cassandra.cql3.restrictions.StatementRestrictions;
@@ -480,6 +481,7 @@ public void insertWithTombstoneRemovesEntryFromIndex() throws Throwable
     @Test
     public void updateTTLOnIndexedClusteringValue() throws Throwable
     {
+        Util.assumeLegacySecondaryIndex();
         int basePk = 1;
         int indexedVal = 2;
         int initialTtl = 3600;

File: test/unit/org/apache/cassandra/index/sai/cql/MixedIndexImplementationsTest.java
Patch:
@@ -19,6 +19,7 @@
 
 import org.junit.Test;
 
+import org.apache.cassandra.Util;
 import org.apache.cassandra.cql3.restrictions.StatementRestrictions;
 import org.apache.cassandra.index.sai.SAITester;
 import org.apache.cassandra.index.sai.StorageAttachedIndex;
@@ -81,6 +82,8 @@ public void shouldAcceptColumnsWithOtherIndex() throws Throwable
     @Test
     public void shouldRequireAllowFilteringWithOtherIndex() throws Throwable
     {
+        Util.assumeLegacySecondaryIndex();
+
         createTable("CREATE TABLE %s (" +
                     "k1 int, k2 int, " +
                     "s1 int static, " +

File: test/unit/org/apache/cassandra/io/sstable/CQLSSTableWriterClientTest.java
Patch:
@@ -48,6 +48,7 @@ public void setUp()
     @After
     public void tearDown()
     {
-        DatabaseDescriptor.setPartitionerUnsafe(oldPartitioner);
+        if (oldPartitioner != null)
+            DatabaseDescriptor.setPartitionerUnsafe(oldPartitioner);
     }
 }

File: test/unit/org/apache/cassandra/io/sstable/LegacySSTableTest.java
Patch:
@@ -476,7 +476,7 @@ private static void verifyCache(String legacyVersion, long startCount) throws In
     {
         // Only perform test if format uses cache.
         SSTableReader sstable = Iterables.getFirst(Keyspace.open("legacy_tables").getColumnFamilyStore(String.format("legacy_%s_simple", legacyVersion)).getLiveSSTables(), null);
-        if (!(sstable instanceof KeyCacheSupport))
+        if (!(sstable instanceof KeyCacheSupport) || DatabaseDescriptor.getKeyCacheSizeInMiB() == 0)
             return;
 
         //For https://issues.apache.org/jira/browse/CASSANDRA-10778

File: test/unit/org/apache/cassandra/service/StorageProxyTest.java
Patch:
@@ -56,6 +56,7 @@ public static void initDD()
     @Test
     public void testSetGetPaxosVariant()
     {
+        StorageProxy.instance.setPaxosVariant("v1"); // test-latest uses v2 as default, ensure we are starting with a known state
         Assert.assertEquals(Config.PaxosVariant.v1, DatabaseDescriptor.getPaxosVariant());
         Assert.assertEquals("v1", StorageProxy.instance.getPaxosVariant());
         StorageProxy.instance.setPaxosVariant("v2");

File: test/unit/org/apache/cassandra/tools/CompactionStressTest.java
Patch:
@@ -49,7 +49,7 @@ public void testWriteAndCompact()
                                                  "-p",
                                                  profileFile,
                                                  "-t",
-                                                 "4");
+                                                 "8");
         tool.assertOnCleanExit();
 
         tool = ToolRunner.invokeClass("org.apache.cassandra.stress.CompactionStress",
@@ -59,7 +59,7 @@ public void testWriteAndCompact()
                                       "-p",
                                       profileFile,
                                       "-t",
-                                      "4");
+                                      "8");
               tool.assertOnCleanExit();
     }
 }

File: src/java/org/apache/cassandra/index/sai/iterators/KeyRangeOrderingIterator.java
Patch:
@@ -81,7 +81,8 @@ public PrimaryKey computeNext()
     protected void performSkipTo(PrimaryKey nextToken)
     {
         input.skipTo(nextToken);
-        nextIterator.skipTo(nextToken);
+        if (nextIterator != null)
+            nextIterator.skipTo(nextToken);
     }
 
     public void close()

File: src/java/org/apache/cassandra/index/sai/memory/VectorMemoryIndex.java
Patch:
@@ -29,7 +29,6 @@
 import java.util.concurrent.atomic.LongAdder;
 import java.util.function.Function;
 import java.util.stream.Collectors;
-import java.util.stream.IntStream;
 import javax.annotation.Nullable;
 
 import io.github.jbellis.jvector.util.Bits;
@@ -111,7 +110,7 @@ public long update(DecoratedKey key, Clustering<?> clustering, ByteBuffer oldVal
         }
         else
         {
-            different = IntStream.range(0, oldRemaining).anyMatch(i -> oldValue.get(i) != newValue.get(i));
+            different = index.termType().compare(oldValue, newValue) != 0;
         }
 
         long bytesUsed = 0;

File: src/java/org/apache/cassandra/index/sai/view/View.java
Patch:
@@ -52,7 +52,8 @@ public View(IndexTermType indexTermType, Collection<SSTableIndex> indexes)
         for (SSTableIndex sstableIndex : indexes)
         {
             this.view.put(sstableIndex.getSSTable().descriptor, sstableIndex);
-            rangeTermTreeBuilder.add(sstableIndex);
+            if (!indexTermType.isVector())
+                rangeTermTreeBuilder.add(sstableIndex);
         }
 
         this.rangeTermTree = rangeTermTreeBuilder.build();

File: src/java/org/apache/cassandra/tcm/CMSOperationsMBean.java
Patch:
@@ -26,9 +26,10 @@ public interface CMSOperationsMBean
 {
     public void initializeCMS(List<String> ignore);
     public void resumeReconfigureCms();
-    public void reconfigureCMS(int rf, boolean sync);
-    public void reconfigureCMS(Map<String, Integer> rf, boolean sync);
+    public void reconfigureCMS(int rf);
+    public void reconfigureCMS(Map<String, Integer> rf);
     public Map<String, List<String>> reconfigureCMSStatus();
+    public void cancelReconfigureCms();
 
     public Map<String, String> describeCMS();
     public void sealPeriod();

File: test/distributed/org/apache/cassandra/distributed/test/log/TriggeredReconfigureCMSTest.java
Patch:
@@ -60,7 +60,7 @@ public void testRemoveCMSMember() throws IOException, ExecutionException, Interr
                                                               .with(Feature.NETWORK, Feature.GOSSIP))
                                       .start())
         {
-            cluster.get(1).nodetoolResult("reconfigurecms", "--sync", "3").asserts().success();
+            cluster.get(1).nodetoolResult("reconfigurecms", "3").asserts().success();
             Set<String> cms = getCMSMembers(cluster.get(1));
             assertEquals(3, cms.size());
 
@@ -100,7 +100,7 @@ public void testDecommissionCMSMember() throws IOException
                                                               .with(Feature.NETWORK, Feature.GOSSIP))
                                       .start())
         {
-            cluster.get(1).nodetoolResult("reconfigurecms", "--sync", "3").asserts().success();
+            cluster.get(1).nodetoolResult("reconfigurecms", "3").asserts().success();
             Set<String> cms = getCMSMembers(cluster.get(1));
             assertEquals(3, cms.size());
             cluster.get(1).nodetoolResult("decommission").asserts().success();
@@ -119,7 +119,7 @@ public void testReplaceCMSMember() throws IOException
                                                               .with(Feature.NETWORK, Feature.GOSSIP))
                                       .start())
         {
-            cluster.get(1).nodetoolResult("reconfigurecms", "--sync", "3").asserts().success();
+            cluster.get(1).nodetoolResult("reconfigurecms", "3").asserts().success();
             Set<String> cms = getCMSMembers(cluster.get(1));
             assertEquals(3, cms.size());
             assertTrue(cms.contains("/127.0.0.1"));

File: test/distributed/org/apache/cassandra/distributed/upgrade/ClusterMetadataUpgradeHarryTest.java
Patch:
@@ -118,7 +118,7 @@ public void simpleUpgradeTest() throws Throwable
             });
 
             cluster.get(1).nodetoolResult("initializecms").asserts().success();
-            cluster.get(1).nodetoolResult("reconfigurecms", "datacenter1:3").asserts().success();
+            cluster.get(1).nodetoolResult("reconfigurecms", "3").asserts().success();
             cluster.schemaChange(withKeyspace("create table %s.xyz (id int primary key)"));
             stopLatch.decrement();
             harryRunner.get().get();

File: test/distributed/org/apache/cassandra/distributed/upgrade/ClusterMetadataUpgradeTest.java
Patch:
@@ -55,7 +55,7 @@ public void simpleUpgradeTest() throws Throwable
                 assertFalse("node " + i.config().num() + " is still in MIGRATING STATE",
                             ClusterUtils.isMigrating((IInvokableInstance) i));
             });
-            cluster.get(2).nodetoolResult("reconfigurecms", "--sync", "3").asserts().success();
+            cluster.get(2).nodetoolResult("reconfigurecms", "3").asserts().success();
             cluster.schemaChange(withKeyspace("create table %s.xyz (id int primary key)"));
             cluster.forEach(i -> {
                 Object [][] res = i.executeInternal("select host_id from system.local");

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -453,9 +453,9 @@ public AllSSTableOpStatus performCleanup(final ColumnFamilyStore cfStore, int jo
     {
         assert !cfStore.isIndex();
         Keyspace keyspace = cfStore.keyspace;
-        if (!StorageService.instance.isJoined())
+        if (!StorageService.instance.getTokenMetadata().getPendingRanges(keyspace.getName(), FBUtilities.getBroadcastAddress()).isEmpty())
         {
-            logger.info("Cleanup cannot run before a node has joined the ring");
+            logger.info("Cleanup cannot run while node has pending ranges for keyspace {} table {}, wait for node addition/decommission to complete and try again", cfStore.keyspace.getName(), cfStore.getTableName());
             return AllSSTableOpStatus.ABORTED;
         }
         // if local ranges is empty, it means no data should remain

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -2996,6 +2996,9 @@ public int forceKeyspaceCleanup(int jobs, String keyspaceName, String... tables)
         if (Schema.isLocalSystemKeyspace(keyspaceName))
             throw new RuntimeException("Cleanup of the system keyspace is neither necessary nor wise");
 
+        if (!tokenMetadata.getPendingRanges(keyspaceName, FBUtilities.getBroadcastAddress()).isEmpty())
+            throw new RuntimeException("Node is involved in cluster membership changes. Not safe to run cleanup.");
+
         CompactionManager.AllSSTableOpStatus status = CompactionManager.AllSSTableOpStatus.SUCCESSFUL;
         for (ColumnFamilyStore cfStore : getValidColumnFamilies(false, false, keyspaceName, tables))
         {

File: test/unit/org/apache/cassandra/cql3/validation/operations/CQLVectorTest.java
Patch:
@@ -404,7 +404,7 @@ public void udf() throws Throwable
         Vector<Integer> vector = vector(1, 2);
         execute("INSERT INTO %s (pk, value) VALUES (0, ?)", vector);
 
-        // identitiy function
+        // identity function
         String f = createFunction(KEYSPACE,
                                   "",
                                   "CREATE FUNCTION %s (x vector<int, 2>) " +

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -1280,7 +1280,7 @@ public static void log(Config config)
     public double severity_during_decommission = 0;
 
     // TODO Revisit MessagingService::current_version
-    public StorageCompatibilityMode storage_compatibility_mode = StorageCompatibilityMode.NONE;
+    public StorageCompatibilityMode storage_compatibility_mode;
 
     /**
      * For the purposes of progress barrier we only support ALL, EACH_QUORUM, QUORUM, LOCAL_QUORUM, ANY, and ONE.

File: src/java/org/apache/cassandra/net/OutboundConnectionSettings.java
Patch:
@@ -420,7 +420,7 @@ public boolean tcpNoDelay()
         if (tcpNoDelay != null)
             return tcpNoDelay;
 
-        if (isInLocalDC(getEndpointSnitch(), getBroadcastAddressAndPort(), to))
+        if (DatabaseDescriptor.isClientOrToolInitialized() || isInLocalDC(getEndpointSnitch(), getBroadcastAddressAndPort(), to))
             return INTRADC_TCP_NODELAY;
 
         return DatabaseDescriptor.getInterDCTcpNoDelay();

File: src/java/org/apache/cassandra/repair/messages/PrepareMessage.java
Patch:
@@ -89,7 +89,9 @@ public int hashCode()
     }
 
     private static final String MIXED_MODE_ERROR = "Some nodes involved in repair are on an incompatible major version. " +
-                                                   "Repair is not supported in mixed major version clusters (%d vs %d).";
+                                                   "Repair is not supported in mixed major version clusters (%d vs %d). Note that " +
+                                                   "5.x nodes running in storage compatibility mode = 4 are considered " +
+                                                   "4.x nodes.";
 
     public static final IVersionedSerializer<PrepareMessage> serializer = new IVersionedSerializer<PrepareMessage>()
     {

File: src/java/org/apache/cassandra/tools/BulkLoader.java
Patch:
@@ -61,7 +61,7 @@ public static void main(String[] args) throws BulkLoadException
 
     public static void load(LoaderOptions options) throws BulkLoadException
     {
-        DatabaseDescriptor.toolInitialization();
+        DatabaseDescriptor.clientInitialization();
         OutputHandler handler = new OutputHandler.SystemOutput(options.verbose, options.debug);
         SSTableLoader loader = new SSTableLoader(
                 options.directory.toAbsolute(),

File: test/unit/org/apache/cassandra/repair/FuzzTestBase.java
Patch:
@@ -1201,7 +1201,7 @@ private Message serde(Message msg)
         {
             try (DataOutputBuffer b = DataOutputBuffer.scratchBuffer.get())
             {
-                int messagingVersion = MessagingService.Version.CURRENT.value;
+                int messagingVersion = MessagingService.current_version;
                 Message.serializer.serialize(msg, b, messagingVersion);
                 DataInputBuffer in = new DataInputBuffer(b.unsafeGetBufferAndFlip(), false);
                 return Message.serializer.deserialize(in, msg.from(), messagingVersion);

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -1269,5 +1269,5 @@ public static void log(Config config)
 
     public double severity_during_decommission = 0;
 
-    public StorageCompatibilityMode storage_compatibility_mode = StorageCompatibilityMode.CASSANDRA_4;
+    public StorageCompatibilityMode storage_compatibility_mode;
 }

File: src/java/org/apache/cassandra/net/OutboundConnectionSettings.java
Patch:
@@ -420,7 +420,7 @@ public boolean tcpNoDelay()
         if (tcpNoDelay != null)
             return tcpNoDelay;
 
-        if (isInLocalDC(getEndpointSnitch(), getBroadcastAddressAndPort(), to))
+        if (DatabaseDescriptor.isClientOrToolInitialized() || isInLocalDC(getEndpointSnitch(), getBroadcastAddressAndPort(), to))
             return INTRADC_TCP_NODELAY;
 
         return DatabaseDescriptor.getInterDCTcpNoDelay();

File: src/java/org/apache/cassandra/repair/messages/PrepareMessage.java
Patch:
@@ -89,7 +89,9 @@ public int hashCode()
     }
 
     private static final String MIXED_MODE_ERROR = "Some nodes involved in repair are on an incompatible major version. " +
-                                                   "Repair is not supported in mixed major version clusters.";
+                                                   "Repair is not supported in mixed major version clusters. Note that " +
+                                                   "5.x nodes running in storage compatibility mode = 4 are considered " +
+                                                   "4.x nodes.";
 
     public static final IVersionedSerializer<PrepareMessage> serializer = new IVersionedSerializer<PrepareMessage>()
     {

File: src/java/org/apache/cassandra/tools/BulkLoader.java
Patch:
@@ -60,7 +60,7 @@ public static void main(String[] args) throws BulkLoadException
 
     public static void load(LoaderOptions options) throws BulkLoadException
     {
-        DatabaseDescriptor.toolInitialization();
+        DatabaseDescriptor.clientInitialization();
         OutputHandler handler = new OutputHandler.SystemOutput(options.verbose, options.debug);
         SSTableLoader loader = new SSTableLoader(
                 options.directory.toAbsolute(),

File: test/unit/org/apache/cassandra/repair/FuzzTestBase.java
Patch:
@@ -1204,7 +1204,7 @@ private Message serde(Message msg)
         {
             try (DataOutputBuffer b = DataOutputBuffer.scratchBuffer.get())
             {
-                int messagingVersion = MessagingService.Version.CURRENT.value;
+                int messagingVersion = MessagingService.current_version;
                 Message.serializer.serialize(msg, b, messagingVersion);
                 DataInputBuffer in = new DataInputBuffer(b.unsafeGetBufferAndFlip(), false);
                 return Message.serializer.deserialize(in, msg.from(), messagingVersion);

File: src/java/org/apache/cassandra/cql3/Attributes.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.List;
 
 import org.apache.cassandra.cql3.functions.Function;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.db.ExpirationDateOverflowHandling;
 import org.apache.cassandra.db.LivenessInfo;
 import org.apache.cassandra.db.marshal.Int32Type;

File: src/java/org/apache/cassandra/cql3/Json.java
Patch:
@@ -24,6 +24,8 @@
 import java.util.Map;
 
 import org.apache.cassandra.cql3.functions.Function;
+import org.apache.cassandra.cql3.terms.Constants;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.UTF8Type;
 import org.apache.cassandra.exceptions.InvalidRequestException;

File: src/java/org/apache/cassandra/cql3/Ordering.java
Patch:
@@ -20,6 +20,7 @@
 
 import org.apache.cassandra.cql3.restrictions.SingleColumnRestriction;
 import org.apache.cassandra.cql3.restrictions.SingleRestriction;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.schema.ColumnMetadata;
 import org.apache.cassandra.schema.TableMetadata;
 

File: src/java/org/apache/cassandra/cql3/QueryOptions.java
Patch:
@@ -26,6 +26,7 @@
 
 import org.apache.cassandra.config.DataStorageSpec;
 import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.schema.ColumnMetadata;
 import org.apache.cassandra.db.ConsistencyLevel;
 import org.apache.cassandra.db.marshal.UTF8Type;

File: src/java/org/apache/cassandra/cql3/TypeCast.java
Patch:
@@ -17,6 +17,7 @@
  */
 package org.apache.cassandra.cql3;
 
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.exceptions.InvalidRequestException;
 

File: src/java/org/apache/cassandra/cql3/functions/FunctionResolver.java
Patch:
@@ -25,7 +25,7 @@
 
 import javax.annotation.Nullable;
 
-import org.apache.cassandra.cql3.AbstractMarker;
+import org.apache.cassandra.cql3.terms.Marker;
 import org.apache.cassandra.cql3.AssignmentTestable;
 import org.apache.cassandra.cql3.ColumnIdentifier;
 import org.apache.cassandra.cql3.ColumnSpecification;
@@ -222,7 +222,7 @@ private static Function pickBestMatch(String keyspace,
      */
     private static boolean containsMarkers(List<? extends AssignmentTestable> args)
     {
-        return args.stream().anyMatch(AbstractMarker.Raw.class::isInstance);
+        return args.stream().anyMatch(Marker.Raw.class::isInstance);
     }
 
     /**

File: src/java/org/apache/cassandra/cql3/functions/masking/ColumnMask.java
Patch:
@@ -34,8 +34,7 @@
 import org.apache.cassandra.cql3.CQL3Type;
 import org.apache.cassandra.cql3.ColumnIdentifier;
 import org.apache.cassandra.cql3.CqlBuilder;
-import org.apache.cassandra.cql3.Term;
-import org.apache.cassandra.cql3.Terms;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.Arguments;
 import org.apache.cassandra.cql3.functions.Function;
 import org.apache.cassandra.cql3.functions.FunctionName;
@@ -267,7 +266,7 @@ private ByteBuffer[] preparePartialArguments(String keyspace, ScalarFunction fun
             {
                 String term = rawPartialArguments.get(i).toString();
                 AbstractType<?> type = function.argTypes().get(i + 1);
-                arguments[i] = Terms.asBytes(keyspace, term, type);
+                arguments[i] = Term.asBytes(keyspace, term, type);
             }
 
             return arguments;

File: src/java/org/apache/cassandra/cql3/restrictions/CustomIndexExpression.java
Patch:
@@ -20,6 +20,7 @@
 import java.util.Objects;
 
 import org.apache.cassandra.cql3.*;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.db.filter.RowFilter;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.index.Index;

File: src/java/org/apache/cassandra/cql3/restrictions/TermSlice.java
Patch:
@@ -21,7 +21,7 @@
 
 import org.apache.cassandra.schema.ColumnMetadata;
 import org.apache.cassandra.cql3.Operator;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.Function;
 import org.apache.cassandra.cql3.statements.Bound;
 import org.apache.cassandra.index.Index;

File: src/java/org/apache/cassandra/cql3/restrictions/TokenRestriction.java
Patch:
@@ -26,7 +26,7 @@
 import org.apache.cassandra.schema.ColumnMetadata;
 import org.apache.cassandra.schema.TableMetadata;
 import org.apache.cassandra.cql3.QueryOptions;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.Function;
 import org.apache.cassandra.cql3.statements.Bound;
 import org.apache.cassandra.db.filter.RowFilter;

File: src/java/org/apache/cassandra/cql3/selection/FieldSelector.java
Patch:
@@ -19,6 +19,7 @@
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.util.List;
 
 import com.google.common.base.Objects;
 
@@ -27,7 +28,6 @@
 import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.db.filter.ColumnFilter;
 import org.apache.cassandra.db.marshal.AbstractType;
-import org.apache.cassandra.db.marshal.ByteBufferAccessor;
 import org.apache.cassandra.db.marshal.UserType;
 import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.io.util.DataInputPlus;
@@ -109,8 +109,8 @@ public ByteBuffer getOutput(ProtocolVersion protocolVersion)
         ByteBuffer value = selected.getOutput(protocolVersion);
         if (value == null)
             return null;
-        ByteBuffer[] buffers = type.split(ByteBufferAccessor.instance, value);
-        return field < buffers.length ? buffers[field] : null;
+        List<ByteBuffer> buffers = type.unpack(value);
+        return field < buffers.size() ? buffers.get(field) : null;
     }
 
     @Override

File: src/java/org/apache/cassandra/cql3/selection/MapSelector.java
Patch:
@@ -28,7 +28,7 @@
 import com.google.common.base.Objects;
 
 import org.apache.cassandra.cql3.ColumnSpecification;
-import org.apache.cassandra.cql3.Maps;
+import org.apache.cassandra.cql3.terms.Maps;
 import org.apache.cassandra.cql3.QueryOptions;
 import org.apache.cassandra.cql3.functions.Function;
 import org.apache.cassandra.db.TypeSizes;
@@ -39,7 +39,6 @@
 import org.apache.cassandra.io.util.DataOutputPlus;
 import org.apache.cassandra.schema.ColumnMetadata;
 import org.apache.cassandra.schema.TableMetadata;
-import org.apache.cassandra.serializers.CollectionSerializer;
 import org.apache.cassandra.transport.ProtocolVersion;
 import org.apache.cassandra.utils.Pair;
 
@@ -218,7 +217,7 @@ public ByteBuffer getOutput(ProtocolVersion protocolVersion)
             buffers.add(entry.getKey());
             buffers.add(entry.getValue());
         }
-        return CollectionSerializer.pack(buffers, elements.size());
+        return type.pack(buffers);
     }
 
     public void reset()

File: src/java/org/apache/cassandra/cql3/selection/SetSelector.java
Patch:
@@ -27,15 +27,14 @@
 import com.google.common.base.Objects;
 
 import org.apache.cassandra.cql3.QueryOptions;
-import org.apache.cassandra.cql3.Sets;
+import org.apache.cassandra.cql3.terms.Sets;
 import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.db.filter.ColumnFilter.Builder;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.SetType;
 import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputPlus;
 import org.apache.cassandra.schema.TableMetadata;
-import org.apache.cassandra.serializers.CollectionSerializer;
 import org.apache.cassandra.transport.ProtocolVersion;
 
 /**
@@ -104,7 +103,7 @@ public ByteBuffer getOutput(ProtocolVersion protocolVersion)
         {
             buffers.add(elements.get(i).getOutput(protocolVersion));
         }
-        return CollectionSerializer.pack(buffers, buffers.size());
+        return type.pack(new ArrayList<>(buffers));
     }
 
     public void reset()

File: src/java/org/apache/cassandra/cql3/selection/TermSelector.java
Patch:
@@ -26,7 +26,7 @@
 import org.apache.cassandra.schema.TableMetadata;
 import org.apache.cassandra.cql3.ColumnSpecification;
 import org.apache.cassandra.cql3.QueryOptions;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.db.filter.ColumnFilter;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.io.util.DataInputPlus;

File: src/java/org/apache/cassandra/cql3/selection/VectorSelector.java
Patch:
@@ -26,7 +26,7 @@
 
 import com.google.common.base.Preconditions;
 
-import org.apache.cassandra.cql3.Lists;
+import org.apache.cassandra.cql3.terms.Lists;
 import org.apache.cassandra.cql3.QueryOptions;
 import org.apache.cassandra.db.filter.ColumnFilter;
 import org.apache.cassandra.db.marshal.AbstractType;
@@ -126,7 +126,7 @@ public ByteBuffer getOutput(ProtocolVersion protocolVersion) throws InvalidReque
         for (int i = 0, m = elements.size(); i < m; i++)
             buffers.add(elements.get(i).getOutput(protocolVersion));
 
-        return type.decomposeRaw(buffers);
+        return type.pack(buffers);
     }
 
     @Override

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -37,6 +37,7 @@
 import org.apache.cassandra.audit.AuditLogEntryType;
 import org.apache.cassandra.auth.Permission;
 import org.apache.cassandra.cql3.restrictions.SingleRestriction;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.db.guardrails.Guardrails;
 import org.apache.cassandra.index.Index;
 import org.apache.cassandra.schema.ColumnMetadata;

File: src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java
Patch:
@@ -27,6 +27,8 @@
 import org.apache.cassandra.cql3.conditions.ColumnCondition;
 import org.apache.cassandra.cql3.conditions.Conditions;
 import org.apache.cassandra.cql3.restrictions.StatementRestrictions;
+import org.apache.cassandra.cql3.terms.Constants;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.db.Clustering;
 import org.apache.cassandra.db.Slice;
 import org.apache.cassandra.db.partitions.PartitionUpdate;

File: src/java/org/apache/cassandra/cql3/terms/ArrayLiteral.java
Patch:
@@ -16,10 +16,11 @@
  * limitations under the License.
  */
 
-package org.apache.cassandra.cql3;
+package org.apache.cassandra.cql3.terms;
 
 import java.util.List;
 
+import org.apache.cassandra.cql3.ColumnSpecification;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.ListType;
 import org.apache.cassandra.db.marshal.VectorType;
@@ -55,7 +56,7 @@ public Term prepare(String keyspace, ColumnSpecification receiver) throws Invali
     }
 
     @Override
-    public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
+    public TestResult testAssignment(String keyspace, ColumnSpecification receiver)
     {
         return forReceiver(receiver).testAssignment(keyspace, receiver);
     }

File: src/java/org/apache/cassandra/db/marshal/AbstractCompositeType.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.List;
 import java.util.regex.Pattern;
 
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.serializers.MarshalException;
 import org.apache.cassandra.transport.ProtocolVersion;
 import org.apache.cassandra.utils.ByteBufferUtil;

File: src/java/org/apache/cassandra/db/marshal/AbstractTimeUUIDType.java
Patch:
@@ -21,9 +21,9 @@
 import java.util.UUID;
 
 import org.apache.cassandra.cql3.CQL3Type;
-import org.apache.cassandra.cql3.Constants;
+import org.apache.cassandra.cql3.terms.Constants;
 import org.apache.cassandra.cql3.Duration;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.serializers.MarshalException;
 import org.apache.cassandra.serializers.UUIDSerializer;
 import org.apache.cassandra.utils.TimeUUID;

File: src/java/org/apache/cassandra/db/marshal/AbstractType.java
Patch:
@@ -31,7 +31,7 @@
 import org.apache.cassandra.cql3.AssignmentTestable;
 import org.apache.cassandra.cql3.CQL3Type;
 import org.apache.cassandra.cql3.ColumnSpecification;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.db.rows.Cell;
 import org.apache.cassandra.exceptions.SyntaxException;
@@ -305,7 +305,7 @@ public boolean isReversed()
 
     public AbstractType<T> unwrap()
     {
-        return isReversed() ? ((ReversedType<T>) this).baseType.unwrap() : this;
+        return this;
     }
 
     public static AbstractType<?> parseDefaultParameters(AbstractType<?> baseType, TypeParser parser) throws SyntaxException

File: src/java/org/apache/cassandra/db/marshal/AsciiType.java
Patch:
@@ -24,10 +24,10 @@
 import java.nio.charset.StandardCharsets;
 
 import io.netty.util.concurrent.FastThreadLocal;
-import org.apache.cassandra.cql3.Constants;
+import org.apache.cassandra.cql3.terms.Constants;
 
 import org.apache.cassandra.cql3.CQL3Type;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.serializers.MarshalException;
 import org.apache.cassandra.serializers.TypeSerializer;

File: src/java/org/apache/cassandra/db/marshal/BooleanType.java
Patch:
@@ -20,8 +20,8 @@
 import java.nio.ByteBuffer;
 
 import org.apache.cassandra.cql3.CQL3Type;
-import org.apache.cassandra.cql3.Constants;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Constants;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.serializers.TypeSerializer;
 import org.apache.cassandra.serializers.BooleanSerializer;

File: src/java/org/apache/cassandra/db/marshal/ByteType.java
Patch:
@@ -22,8 +22,8 @@
 import org.apache.commons.lang3.mutable.MutableByte;
 
 import org.apache.cassandra.cql3.CQL3Type;
-import org.apache.cassandra.cql3.Constants;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Constants;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.serializers.ByteSerializer;
 import org.apache.cassandra.serializers.MarshalException;

File: src/java/org/apache/cassandra/db/marshal/BytesType.java
Patch:
@@ -20,8 +20,8 @@
 import java.nio.ByteBuffer;
 
 import org.apache.cassandra.cql3.CQL3Type;
-import org.apache.cassandra.cql3.Constants;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Constants;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.serializers.TypeSerializer;
 import org.apache.cassandra.serializers.BytesSerializer;

File: src/java/org/apache/cassandra/db/marshal/CounterColumnType.java
Patch:
@@ -20,7 +20,7 @@
 import java.nio.ByteBuffer;
 
 import org.apache.cassandra.cql3.CQL3Type;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.db.context.CounterContext;
 import org.apache.cassandra.serializers.CounterSerializer;

File: src/java/org/apache/cassandra/db/marshal/DateType.java
Patch:
@@ -20,8 +20,8 @@
 import java.nio.ByteBuffer;
 import java.util.Date;
 
-import org.apache.cassandra.cql3.Constants;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Constants;
+import org.apache.cassandra.cql3.terms.Term;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: src/java/org/apache/cassandra/db/marshal/DecimalType.java
Patch:
@@ -27,8 +27,8 @@
 import com.google.common.primitives.Ints;
 
 import org.apache.cassandra.cql3.CQL3Type;
-import org.apache.cassandra.cql3.Constants;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Constants;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.serializers.TypeSerializer;
 import org.apache.cassandra.serializers.DecimalSerializer;

File: src/java/org/apache/cassandra/db/marshal/DoubleType.java
Patch:
@@ -22,8 +22,8 @@
 import org.apache.commons.lang3.mutable.MutableDouble;
 
 import org.apache.cassandra.cql3.CQL3Type;
-import org.apache.cassandra.cql3.Constants;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Constants;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.serializers.TypeSerializer;
 import org.apache.cassandra.serializers.DoubleSerializer;

File: src/java/org/apache/cassandra/db/marshal/DurationType.java
Patch:
@@ -20,9 +20,9 @@
 import java.nio.ByteBuffer;
 
 import org.apache.cassandra.cql3.CQL3Type;
-import org.apache.cassandra.cql3.Constants;
+import org.apache.cassandra.cql3.terms.Constants;
 import org.apache.cassandra.cql3.Duration;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.serializers.DurationSerializer;
 import org.apache.cassandra.serializers.MarshalException;

File: src/java/org/apache/cassandra/db/marshal/DynamicCompositeType.java
Patch:
@@ -36,7 +36,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.exceptions.SyntaxException;

File: src/java/org/apache/cassandra/db/marshal/EmptyType.java
Patch:
@@ -24,8 +24,8 @@
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.cql3.CQL3Type;
-import org.apache.cassandra.cql3.Constants;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Constants;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputPlus;

File: src/java/org/apache/cassandra/db/marshal/FloatType.java
Patch:
@@ -22,8 +22,8 @@
 import org.apache.commons.lang3.mutable.MutableFloat;
 
 import org.apache.cassandra.cql3.CQL3Type;
-import org.apache.cassandra.cql3.Constants;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Constants;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.serializers.TypeSerializer;
 import org.apache.cassandra.serializers.FloatSerializer;

File: src/java/org/apache/cassandra/db/marshal/FrozenType.java
Patch:
@@ -20,7 +20,7 @@
 import java.nio.ByteBuffer;
 import java.util.List;
 
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.exceptions.SyntaxException;

File: src/java/org/apache/cassandra/db/marshal/InetAddressType.java
Patch:
@@ -22,8 +22,8 @@
 import java.nio.ByteBuffer;
 
 import org.apache.cassandra.cql3.CQL3Type;
-import org.apache.cassandra.cql3.Constants;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Constants;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.serializers.TypeSerializer;
 import org.apache.cassandra.serializers.InetAddressSerializer;

File: src/java/org/apache/cassandra/db/marshal/Int32Type.java
Patch:
@@ -23,8 +23,8 @@
 import org.apache.commons.lang3.mutable.MutableInt;
 
 import org.apache.cassandra.cql3.CQL3Type;
-import org.apache.cassandra.cql3.Constants;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Constants;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.serializers.Int32Serializer;
 import org.apache.cassandra.serializers.MarshalException;

File: src/java/org/apache/cassandra/db/marshal/IntegerType.java
Patch:
@@ -23,8 +23,8 @@
 import java.util.Objects;
 
 import org.apache.cassandra.cql3.CQL3Type;
-import org.apache.cassandra.cql3.Constants;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Constants;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.serializers.TypeSerializer;
 import org.apache.cassandra.serializers.IntegerSerializer;

File: src/java/org/apache/cassandra/db/marshal/LexicalUUIDType.java
Patch:
@@ -20,8 +20,8 @@
 import java.nio.ByteBuffer;
 import java.util.UUID;
 
-import org.apache.cassandra.cql3.Constants;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Constants;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.serializers.TypeSerializer;
 import org.apache.cassandra.serializers.MarshalException;

File: src/java/org/apache/cassandra/db/marshal/LongType.java
Patch:
@@ -23,8 +23,8 @@
 import org.apache.commons.lang3.mutable.MutableLong;
 
 import org.apache.cassandra.cql3.CQL3Type;
-import org.apache.cassandra.cql3.Constants;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Constants;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.serializers.TypeSerializer;
 import org.apache.cassandra.serializers.LongSerializer;

File: src/java/org/apache/cassandra/db/marshal/PartitionerDefinedOrder.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.Objects;
 
 import org.apache.cassandra.config.DatabaseDescriptor;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.db.PartitionPosition;

File: src/java/org/apache/cassandra/db/marshal/ShortType.java
Patch:
@@ -23,8 +23,8 @@
 import org.apache.commons.lang3.mutable.MutableShort;
 
 import org.apache.cassandra.cql3.CQL3Type;
-import org.apache.cassandra.cql3.Constants;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Constants;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.serializers.MarshalException;
 import org.apache.cassandra.serializers.ShortSerializer;

File: src/java/org/apache/cassandra/db/marshal/SimpleDateType.java
Patch:
@@ -20,9 +20,9 @@
 import java.nio.ByteBuffer;
 
 import org.apache.cassandra.cql3.CQL3Type;
-import org.apache.cassandra.cql3.Constants;
+import org.apache.cassandra.cql3.terms.Constants;
 import org.apache.cassandra.cql3.Duration;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.serializers.MarshalException;
 import org.apache.cassandra.serializers.SimpleDateSerializer;
 import org.apache.cassandra.serializers.TypeSerializer;

File: src/java/org/apache/cassandra/db/marshal/TimeType.java
Patch:
@@ -21,8 +21,8 @@
 import java.time.LocalTime;
 import java.time.ZoneOffset;
 
-import org.apache.cassandra.cql3.Constants;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Constants;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.serializers.TimeSerializer;
 import org.apache.cassandra.cql3.CQL3Type;

File: src/java/org/apache/cassandra/db/marshal/TimestampType.java
Patch:
@@ -20,9 +20,9 @@
 import java.nio.ByteBuffer;
 import java.util.Date;
 
-import org.apache.cassandra.cql3.Constants;
+import org.apache.cassandra.cql3.terms.Constants;
 import org.apache.cassandra.cql3.Duration;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Term;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: src/java/org/apache/cassandra/db/marshal/UTF8Type.java
Patch:
@@ -21,10 +21,10 @@
 import java.nio.charset.CharacterCodingException;
 import java.nio.charset.StandardCharsets;
 
-import org.apache.cassandra.cql3.Constants;
+import org.apache.cassandra.cql3.terms.Constants;
 
 import org.apache.cassandra.cql3.CQL3Type;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.serializers.MarshalException;
 import org.apache.cassandra.serializers.TypeSerializer;

File: src/java/org/apache/cassandra/db/marshal/UUIDType.java
Patch:
@@ -24,8 +24,8 @@
 import com.google.common.primitives.UnsignedLongs;
 
 import org.apache.cassandra.cql3.CQL3Type;
-import org.apache.cassandra.cql3.Constants;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Constants;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.functions.ArgumentDeserializer;
 import org.apache.cassandra.serializers.TypeSerializer;
 import org.apache.cassandra.serializers.MarshalException;

File: src/java/org/apache/cassandra/serializers/AbstractTextSerializer.java
Patch:
@@ -53,7 +53,8 @@ public ByteBuffer serialize(String value)
     }
 
 
-        public String toString(String value)
+    @Override
+    public String toString(String value)
     {
         return value;
     }

File: test/distributed/org/apache/cassandra/distributed/test/AlterTest.java
Patch:
@@ -26,7 +26,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.apache.cassandra.cql3.Lists;
+import org.apache.cassandra.cql3.terms.Lists;
 import org.apache.cassandra.db.Keyspace;
 import org.apache.cassandra.distributed.Cluster;
 import org.apache.cassandra.distributed.api.Feature;

File: test/unit/org/apache/cassandra/cql3/EmptyValuesTest.java
Patch:
@@ -100,7 +100,7 @@ private void verifyPlainInsert(String emptyValue) throws Throwable
         execute("TRUNCATE %s");
 
         // In most cases we cannot insert empty value when we do not bind variables
-        // This is due to the current implementation of org.apache.cassandra.cql3.Constants.Literal.testAssignment
+        // This is due to the current implementation of org.apache.cassandra.cql3.terms.Constants.Literal.testAssignment
         // execute("INSERT INTO %s (id, v) VALUES (1, '" + emptyValue + "')");
         execute("INSERT INTO %s (id, v) VALUES (1, ?)", ByteBufferUtil.EMPTY_BYTE_BUFFER);
         flush();

File: test/unit/org/apache/cassandra/cql3/selection/SelectorSerializationTest.java
Patch:
@@ -26,7 +26,7 @@
 import org.junit.Test;
 
 import org.apache.cassandra.cql3.*;
-import org.apache.cassandra.cql3.Constants.Literal;
+import org.apache.cassandra.cql3.terms.Constants.Literal;
 import org.apache.cassandra.cql3.functions.AggregateFcts;
 import org.apache.cassandra.cql3.functions.Function;
 import org.apache.cassandra.cql3.functions.TimeFcts;

File: test/unit/org/apache/cassandra/cql3/validation/entities/CollectionsTest.java
Patch:
@@ -964,7 +964,7 @@ public void testInvalidInputForSet() throws Throwable
         createTable("CREATE TABLE %s(pk int PRIMARY KEY, s set<text>)");
         assertInvalidMessage("Not enough bytes to read a set",
                              "INSERT INTO %s (pk, s) VALUES (?, ?)", 1, "test");
-        assertInvalidMessage("Null value read when not allowed",
+        assertInvalidMessage("Not enough bytes to read a set",
                              "INSERT INTO %s (pk, s) VALUES (?, ?)", 1, Long.MAX_VALUE);
         assertInvalidMessage("Not enough bytes to read a set",
                              "INSERT INTO %s (pk, s) VALUES (?, ?)", 1, "");
@@ -976,9 +976,9 @@ public void testInvalidInputForSet() throws Throwable
     public void testInvalidInputForMap() throws Throwable
     {
         createTable("CREATE TABLE %s(pk int PRIMARY KEY, m map<text, text>)");
-        assertInvalidMessage("Not enough bytes to read a map",
+        assertInvalidMessage("The data cannot be deserialized as a map",
                              "INSERT INTO %s (pk, m) VALUES (?, ?)", 1, "test");
-        assertInvalidMessage("Null value read when not allowed",
+        assertInvalidMessage("The data cannot be deserialized as a map",
                              "INSERT INTO %s (pk, m) VALUES (?, ?)", 1, Long.MAX_VALUE);
         assertInvalidMessage("Not enough bytes to read a map",
                              "INSERT INTO %s (pk, m) VALUES (?, ?)", 1, "");

File: test/unit/org/apache/cassandra/cql3/validation/operations/CQLVectorTest.java
Patch:
@@ -63,6 +63,7 @@ public void select()
         assertRows(execute("SELECT * FROM %s WHERE pk IN ([1, 2])"), row);
         assertRows(execute("SELECT * FROM %s WHERE pk IN ([1, 2], [1, 2])"), row);
         assertRows(execute("SELECT * FROM %s WHERE pk IN (?)", vector), row);
+        assertRows(execute("SELECT * FROM %s WHERE pk IN ?", list(vector)), row);
         assertRows(execute("SELECT * FROM %s WHERE pk IN ([1, 1 + 1])"), row);
         assertRows(execute("SELECT * FROM %s WHERE pk IN ([1, ?])", 2), row);
         assertRows(execute("SELECT * FROM %s WHERE pk IN ([1, (int) ?])", 2), row);
@@ -315,7 +316,7 @@ private void assertRejectsEmptyValues(String type) throws Throwable
                                   InvalidRequestException.class,
                                   "INSERT INTO %s (k, v) VALUES (0, 0x)");
 
-        assertInvalidThrowMessage("Invalid empty vector value",
+        assertInvalidThrowMessage(format("Not enough bytes to read a vector<%s, 2>", type),
                                   InvalidRequestException.class,
                                   "INSERT INTO %s (k, v) VALUES (0, ?)",
                                   ByteBufferUtil.EMPTY_BYTE_BUFFER);

File: test/unit/org/apache/cassandra/db/aggregation/GroupMakerTest.java
Patch:
@@ -27,7 +27,7 @@
 
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.cql3.ColumnIdentifier;
-import org.apache.cassandra.cql3.Constants.Literal;
+import org.apache.cassandra.cql3.terms.Constants.Literal;
 import org.apache.cassandra.cql3.QueryOptions;
 import org.apache.cassandra.cql3.VariableSpecifications;
 import org.apache.cassandra.cql3.functions.ScalarFunction;

File: test/unit/org/apache/cassandra/db/marshal/AbstractTypeTest.java
Patch:
@@ -42,10 +42,10 @@
 import org.apache.cassandra.cql3.AssignmentTestable;
 import org.apache.cassandra.cql3.ColumnIdentifier;
 import org.apache.cassandra.cql3.ColumnSpecification;
-import org.apache.cassandra.cql3.Constants;
+import org.apache.cassandra.cql3.terms.Constants;
 import org.apache.cassandra.cql3.Json;
 import org.apache.cassandra.cql3.QueryOptions;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.VariableSpecifications;
 import org.apache.cassandra.io.util.DataInputBuffer;
 import org.apache.cassandra.io.util.DataInputPlus;

File: test/unit/org/apache/cassandra/db/marshal/TypeValidationTest.java
Patch:
@@ -204,8 +204,8 @@ private static void buildAndSplit(Gen<? extends TupleType> baseGen)
         qt().forAll(tupleWithValueGen(baseGen)).checkAssert(pair -> {
             TupleType tuple = pair.left;
             ByteBuffer value = pair.right;
-            Assertions.assertThat(TupleType.buildValue(tuple.split(ByteBufferAccessor.instance, value)))
-                      .as("TupleType.buildValue(split(value)) == value")
+            Assertions.assertThat(tuple.pack(tuple.unpack(value)))
+                      .as("tuple.pack(tuple.unpack(value)) == value")
                       .isEqualTo(value);
         });
     }

File: test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java
Patch:
@@ -61,7 +61,7 @@
 import org.apache.cassandra.cql3.CQLTester;
 import org.apache.cassandra.cql3.Operator;
 import org.apache.cassandra.cql3.QueryProcessor;
-import org.apache.cassandra.cql3.Term;
+import org.apache.cassandra.cql3.terms.Term;
 import org.apache.cassandra.cql3.UntypedResultSet;
 import org.apache.cassandra.cql3.statements.schema.IndexTarget;
 import org.apache.cassandra.db.Clustering;

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -226,6 +226,8 @@ public enum Version
 
         public static final Version CURRENT;
 
+        private static final Logger logger = LoggerFactory.getLogger(Version.class);
+
         static
         {
              if (DatabaseDescriptor.getStorageCompatibilityMode().isBefore(5))

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -271,7 +271,7 @@ protected void setup()
         }
         catch (InterruptedException | ExecutionException | IOException e)
         {
-            throw new AssertionError("Can't initialize cluster metadata service");
+            throw new AssertionError("Can't initialize cluster metadata service", e);
         }
         catch (StartupException e)
         {

File: test/unit/org/apache/cassandra/tools/JMXCompatibilityTest.java
Patch:
@@ -60,7 +60,7 @@
  * select * from table_00 where pk=42;
  * }
  */
-public class JMXCompatabilityTest extends CQLTester
+public class JMXCompatibilityTest extends CQLTester
 {
     private static final Map<String, String> ENV = ImmutableMap.of("JAVA_HOME", CassandraRelevantProperties.JAVA_HOME.getString());
 
@@ -72,6 +72,7 @@ public class JMXCompatabilityTest extends CQLTester
     @BeforeClass
     public static void setup() throws Exception
     {
+        decorateCQLWithTestNames = false;
         DatabaseDescriptor.daemonInitialization();
         DatabaseDescriptor.setColumnIndexSizeInKiB(0); // make sure the column index is created
 

File: test/unit/org/apache/cassandra/tools/JMXCompatibilityTest.java
Patch:
@@ -60,7 +60,7 @@
  * select * from table_00 where pk=42;
  * }
  */
-public class JMXCompatabilityTest extends CQLTester
+public class JMXCompatibilityTest extends CQLTester
 {
     private static final Map<String, String> ENV = ImmutableMap.of("JAVA_HOME", CassandraRelevantProperties.JAVA_HOME.getString());
 
@@ -72,6 +72,7 @@ public class JMXCompatabilityTest extends CQLTester
     @BeforeClass
     public static void setup() throws Exception
     {
+        decorateCQLWithTestNames = false;
         DatabaseDescriptor.daemonInitialization();
         DatabaseDescriptor.setColumnIndexSizeInKiB(0); // make sure the column index is created
 

File: test/unit/org/apache/cassandra/tools/BulkLoaderTest.java
Patch:
@@ -101,7 +101,9 @@ public void testBulkLoader_WithArgs1() throws Exception
                                                         "cluster[0-9]-connection-reaper-[0-9]",
                                                         "Attach Listener",
                                                         "process reaper",
-                                                        "JNA Cleaner"},
+                                                        "JNA Cleaner",
+                                                        // the driver isn't expected to terminate threads on close synchronously (CASSANDRA-19000)
+                                                        "cluster[0-9]-nio-worker-[0-9]" },
                                          false);
     assertSchemaNotLoaded();
     assertCLSMNotLoaded();

File: test/unit/org/apache/cassandra/tools/BulkLoaderTest.java
Patch:
@@ -101,7 +101,9 @@ public void testBulkLoader_WithArgs1() throws Exception
                                                         "cluster[0-9]-connection-reaper-[0-9]",
                                                         "Attach Listener",
                                                         "process reaper",
-                                                        "JNA Cleaner"},
+                                                        "JNA Cleaner",
+                                                        // the driver isn't expected to terminate threads on close synchronously (CASSANDRA-19000)
+                                                        "cluster[0-9]-nio-worker-[0-9]" },
                                          false);
     assertSchemaNotLoaded();
     assertCLSMNotLoaded();

File: test/unit/org/apache/cassandra/tools/BulkLoaderTest.java
Patch:
@@ -93,7 +93,9 @@ public void testBulkLoader_WithArgs1() throws Exception
                                                         "globalEventExecutor-[1-9]-[1-9]",
                                                         "globalEventExecutor-[1-9]-[1-9]",
                                                         "Shutdown-checker",
-                                                        "cluster[0-9]-connection-reaper-[0-9]" });
+                                                        "cluster[0-9]-connection-reaper-[0-9]",
+                                                        // the driver isn't expected to terminate threads on close synchronously (CASSANDRA-19000)
+                                                        "cluster[0-9]-nio-worker-[0-9]" });
         assertSchemaNotLoaded();
         assertCLSMNotLoaded();
         assertSystemKSNotLoaded();

File: test/unit/org/apache/cassandra/tools/BulkLoaderTest.java
Patch:
@@ -82,7 +82,9 @@ public void testBulkLoader_WithArgs1() throws Exception
         if (!(tool.getException().getCause().getCause().getCause() instanceof NoHostAvailableException))
             throw tool.getException();
 
-        assertNoUnexpectedThreadsStarted(null, new String[] { "globalEventExecutor-1-1", "globalEventExecutor-1-2" });
+        assertNoUnexpectedThreadsStarted(null, new String[] { "globalEventExecutor-1-1", "globalEventExecutor-1-2",
+                                                                                 // the driver isn't expected to terminate threads on close synchronously (CASSANDRA-19000)
+                                                                                 "cluster[0-9]-nio-worker-[0-9]" });
         assertSchemaNotLoaded();
         assertCLSMNotLoaded();
         assertSystemKSNotLoaded();

File: src/java/org/apache/cassandra/repair/SystemDistributedKeyspace.java
Patch:
@@ -214,7 +214,7 @@ public static void startRepairs(UUID id, UUID parent_id, String keyspaceName, St
     {
         //Don't record repair history if an upgrade is in progress as version 3 nodes generates errors
         //due to schema differences
-        boolean includeNewColumns = !Gossiper.instance.hasMajorVersion3Nodes();
+        boolean includeNewColumns = !Gossiper.instance.hasMajorVersion3OrUnknownNodes();
 
         InetAddressAndPort coordinator = FBUtilities.getBroadcastAddressAndPort();
         Set<String> participants = Sets.newHashSet();

File: src/java/org/apache/cassandra/tracing/TraceKeyspace.java
Patch:
@@ -118,7 +118,7 @@ static Mutation makeStartSessionMutation(ByteBuffer sessionId,
         rb.ttl(ttl)
           .add("client", client)
           .add("coordinator", FBUtilities.getBroadcastAddressAndPort().address);
-        if (!Gossiper.instance.hasMajorVersion3Nodes())
+        if (!Gossiper.instance.hasMajorVersion3OrUnknownNodes())
             rb.add("coordinator_port", FBUtilities.getBroadcastAddressAndPort().port);
         rb.add("request", request)
           .add("started_at", new Date(startedAt))
@@ -145,7 +145,7 @@ static Mutation makeEventMutation(ByteBuffer sessionId, String message, int elap
 
         rowBuilder.add("activity", message)
                   .add("source", FBUtilities.getBroadcastAddressAndPort().address);
-        if (!Gossiper.instance.hasMajorVersion3Nodes())
+        if (!Gossiper.instance.hasMajorVersion3OrUnknownNodes())
             rowBuilder.add("source_port", FBUtilities.getBroadcastAddressAndPort().port);
         rowBuilder.add("thread", threadName);
 

File: test/unit/org/apache/cassandra/Util.java
Patch:
@@ -828,7 +828,7 @@ public static void disableBloomFilter(ColumnFamilyStore cfs)
 
     /**
      * Setups Gossiper to mimic the upgrade behaviour when {@link Gossiper#isUpgradingFromVersionLowerThan(CassandraVersion)}
-     * or {@link Gossiper#hasMajorVersion3Nodes()} is called.
+     * or {@link Gossiper#hasMajorVersion3OrUnknownNodes()} is called.
      */
     public static void setUpgradeFromVersion(String version)
     {

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -897,6 +897,9 @@ public static void setClientMode(boolean clientMode)
     public volatile int maximum_replication_factor_fail_threshold = -1;
     public volatile boolean zero_ttl_on_twcs_warned = true;
     public volatile boolean zero_ttl_on_twcs_enabled = true;
+    public volatile boolean non_partition_restricted_index_query_enabled = true;
+    public volatile int sai_sstable_indexes_per_query_warn_threshold = 32;
+    public volatile int sai_sstable_indexes_per_query_fail_threshold = -1;
 
     public volatile DurationSpec.LongNanosecondsBound streaming_state_expires = new DurationSpec.LongNanosecondsBound("3d");
     public volatile DataStorageSpec.LongBytesBound streaming_state_size = new DataStorageSpec.LongBytesBound("40MiB");

File: src/java/org/apache/cassandra/exceptions/RequestFailureReason.java
Patch:
@@ -36,7 +36,8 @@ public enum RequestFailureReason
     INCOMPATIBLE_SCHEMA      (3),
     READ_SIZE                (4),
     NODE_DOWN                (5),
-    INDEX_NOT_AVAILABLE      (6);
+    INDEX_NOT_AVAILABLE      (6),
+    READ_TOO_MANY_INDEXES    (7);
 
     public static final Serializer serializer = new Serializer();
 

File: src/java/org/apache/cassandra/service/reads/thresholds/CoordinatorWarnings.java
Patch:
@@ -96,6 +96,9 @@ public static void done()
 
             recordAborts(merged.rowIndexReadSize, cql, loggableTokens, cfs.metric.rowIndexSizeAborts, WarningsSnapshot::rowIndexReadSizeAbortMessage);
             recordWarnings(merged.rowIndexReadSize, cql, loggableTokens, cfs.metric.rowIndexSizeWarnings, WarningsSnapshot::rowIndexSizeWarnMessage);
+
+            recordAborts(merged.indexReadSSTablesCount, cql, loggableTokens, cfs.metric.tooManySSTableIndexesReadAborts, WarningsSnapshot::tooManyIndexesReadAbortMessage);
+            recordWarnings(merged.indexReadSSTablesCount, cql, loggableTokens, cfs.metric.tooManySSTableIndexesReadWarnings, WarningsSnapshot::tooManyIndexesReadWarnMessage);
         });
 
         // reset the state to block from double publishing

File: src/java/org/apache/cassandra/config/CassandraRelevantProperties.java
Patch:
@@ -264,6 +264,9 @@ public enum CassandraRelevantProperties
     @Deprecated(since = "4.1")
     IGNORE_DC("cassandra.ignore_dc"),
     IGNORE_DYNAMIC_SNITCH_SEVERITY("cassandra.ignore_dynamic_snitch_severity"),
+
+    IGNORE_KERNEL_BUG_1057843_CHECK("cassandra.ignore_kernel_bug_1057843_check"),
+
     IGNORE_MISSING_NATIVE_FILE_HINTS("cassandra.require_native_file_hints"),
     /** @deprecated should be removed in favor of enable flag of relevant startup check (checkRack) */
     /** @deprecated See CASSANDRA-17797 */
@@ -619,7 +622,6 @@ public enum CassandraRelevantProperties
     WAIT_FOR_TRACING_EVENTS_TIMEOUT_SECS("cassandra.wait_for_tracing_events_timeout_secs", "0"),
     ;
 
-
     static
     {
         CassandraRelevantProperties[] values = CassandraRelevantProperties.values();

File: src/java/org/apache/cassandra/config/CassandraRelevantProperties.java
Patch:
@@ -264,6 +264,9 @@ public enum CassandraRelevantProperties
     @Deprecated(since = "4.1")
     IGNORE_DC("cassandra.ignore_dc"),
     IGNORE_DYNAMIC_SNITCH_SEVERITY("cassandra.ignore_dynamic_snitch_severity"),
+
+    IGNORE_KERNEL_BUG_1057843_CHECK("cassandra.ignore_kernel_bug_1057843_check"),
+
     IGNORE_MISSING_NATIVE_FILE_HINTS("cassandra.require_native_file_hints"),
     /** @deprecated should be removed in favor of enable flag of relevant startup check (checkRack) */
     /** @deprecated See CASSANDRA-17797 */

File: src/java/org/apache/cassandra/config/CassandraRelevantProperties.java
Patch:
@@ -320,7 +320,7 @@ public enum CassandraRelevantProperties
      *
      * This is a dev/CI only property. Do not use otherwise.
      */
-    JUNIT_STORAGE_COMPATIBILITY_MODE("cassandra.junit_storage_compatibility_mode", StorageCompatibilityMode.CASSANDRA_4.toString()),
+    JUNIT_STORAGE_COMPATIBILITY_MODE("cassandra.junit_storage_compatibility_mode", StorageCompatibilityMode.NONE.toString()),
     /** startup checks properties */
     LIBJEMALLOC("cassandra.libjemalloc"),
     /** Line separator ("\n" on UNIX). */

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -5023,7 +5023,7 @@ public static StorageCompatibilityMode getStorageCompatibilityMode()
     {
         // Config is null for junits that don't load the config. Get from env var that CI/build.xml sets
         if (conf == null)
-            return CassandraRelevantProperties.JUNIT_STORAGE_COMPATIBILITY_MODE.getEnum(StorageCompatibilityMode.CASSANDRA_4);
+            return CassandraRelevantProperties.JUNIT_STORAGE_COMPATIBILITY_MODE.getEnum(StorageCompatibilityMode.NONE);
         else
             return conf.storage_compatibility_mode;
     }

File: test/simulator/main/org/apache/cassandra/simulator/ClusterSimulation.java
Patch:
@@ -500,6 +500,7 @@ static SchedulerFactory schedulerFactory(RunnableActionScheduler.Kind... kinds)
                 switch (Choices.random(random, kinds).choose(random))
                 {
                     default: throw new AssertionError();
+                    case IMMEDIATE: return new RunnableActionScheduler.Immediate();
                     case SEQUENTIAL: return new RunnableActionScheduler.Sequential();
                     case UNIFORM: return new RunnableActionScheduler.RandomUniform(random);
                     case RANDOM_WALK: return new RunnableActionScheduler.RandomWalk(random);

File: test/simulator/main/org/apache/cassandra/simulator/RunnableActionScheduler.java
Patch:
@@ -26,7 +26,7 @@
 
 public abstract class RunnableActionScheduler implements Consumer<Action>
 {
-    public enum Kind { RANDOM_WALK, UNIFORM, SEQUENTIAL }
+    public enum Kind { RANDOM_WALK, UNIFORM, SEQUENTIAL, IMMEDIATE }
 
     public static class Immediate extends RunnableActionScheduler
     {

File: test/simulator/main/org/apache/cassandra/simulator/paxos/PaxosClusterSimulation.java
Patch:
@@ -75,6 +75,7 @@ public PaxosClusterSimulation create(long seed) throws IOException
     {
         super(random, seed, uniqueNum, builder,
               config -> config.set("paxos_variant", builder.initialPaxosVariant.name())
+                              .set("storage_compatibility_mode", "NONE")
                               .set("paxos_cache_size", (builder.stateCache != null ? builder.stateCache : random.uniformFloat() < 0.5) ? null : "0MiB")
                               .set("paxos_state_purging", "repaired")
                               .set("paxos_on_linearizability_violations", "log")

File: test/simulator/asm/org/apache/cassandra/simulator/asm/GlobalMethodTransformer.java
Patch:
@@ -92,7 +92,8 @@ else if (globalMethods && ((opcode == Opcodes.INVOKESTATIC && (
             super.visitMethodInsn(Opcodes.INVOKESTATIC, "org/apache/cassandra/simulator/systems/InterceptorOfSystemMethods$Global", name, descriptor, false);
         }
         else if ((globalMethods || deterministic) && opcode == Opcodes.INVOKESTATIC &&
-            owner.equals("java/util/concurrent/ThreadLocalRandom") && (name.equals("getProbe") || name.equals("advanceProbe") || name.equals("localInit"))
+                 ((owner.equals("java/util/concurrent/ThreadLocalRandom") && (name.equals("getProbe") || name.equals("advanceProbe") || name.equals("localInit")))
+                  || (owner.equals("java/util/concurrent/atomic/Striped64") && (name.equals("getProbe") || name.equals("advanceProbe"))))
         )
         {
             transformer.witness(GLOBAL_METHOD);

File: test/simulator/main/org/apache/cassandra/simulator/SimulationRunner.java
Patch:
@@ -360,9 +360,9 @@ protected void run(long seed, B builder) throws IOException
 
             try (ClusterSimulation<?> cluster = builder.create(seed))
             {
-                try
+                try (Simulation simulation = cluster.simulation())
                 {
-                    cluster.simulation.run();
+                    simulation.run();
                 }
                 catch (Throwable t)
                 {

File: test/simulator/main/org/apache/cassandra/simulator/cluster/KeyspaceActions.java
Patch:
@@ -202,6 +202,7 @@ private PlacementSimulator.ReplicatedRanges placements(NodesByDc nodesByDc, Node
         for (int i = 0; i < rfs.length; i++)
             rf.put(factory.lookup().dc(i + 1), rfs[i]);
 
+        nodes.sort(PlacementSimulator.Node::compareTo);
         return new PlacementSimulator.NtsReplicationFactor(rfs).replicate(nodes);
     }
 
@@ -285,9 +286,7 @@ private Action next()
                     Topology during = recomputeTopology(placementsBefore, placementsAfter);
                     updateTopology(during);
                     Topology after = recomputeTopology(placementsAfter, placementsAfter);
-                    Action action = null;
-                    //TODO p
-                    //new OnClusterReplace(KeyspaceActions.this, before, during, after, leave, join);
+                    Action action = new OnClusterReplace(KeyspaceActions.this, before, during, after, leave, join);
                     return scheduleAndUpdateTopologyOnCompletion(action, after);
                     // if replication factor is 2, cannot perform safe replacements
                     // however can have operations that began earlier during RF=2

File: test/simulator/main/org/apache/cassandra/simulator/cluster/OnClusterLeave.java
Patch:
@@ -109,7 +109,8 @@ private ExecuteNextStep(ClusterActions actions, int on, int kind)
 
                 UnbootstrapAndLeave unbootstrapAndLeave = ((UnbootstrapAndLeave) sequence);
                 assert unbootstrapAndLeave.next.ordinal() == kind : String.format("Expected next step to be %s, but got %s", Transformation.Kind.values()[kind], unbootstrapAndLeave.next);
-                assert unbootstrapAndLeave.executeNext().isContinuable();
+                boolean res = unbootstrapAndLeave.executeNext().isContinuable();
+                assert res;
             });
         }
     }

File: test/simulator/main/org/apache/cassandra/simulator/cluster/OnClusterReplace.java
Patch:
@@ -159,7 +159,8 @@ private ExecuteNextStep(ClusterActions actions, int on, int kind)
 
                 BootstrapAndReplace bootstrapAndReplace = ((BootstrapAndReplace) sequence);
                 assert bootstrapAndReplace.next.ordinal() == kind : String.format("Expected next step to be %s, but got %s", Transformation.Kind.values()[kind], bootstrapAndReplace.next);
-                assert bootstrapAndReplace.executeNext().isContinuable();
+                boolean res = bootstrapAndReplace.executeNext().isContinuable();
+                assert res;
             });
         }
     }

File: test/simulator/main/org/apache/cassandra/simulator/debug/Reconcile.java
Patch:
@@ -41,6 +41,7 @@
 import org.apache.cassandra.io.util.File;
 import org.apache.cassandra.simulator.ClusterSimulation;
 import org.apache.cassandra.simulator.RandomSource;
+import org.apache.cassandra.simulator.Simulation;
 import org.apache.cassandra.simulator.SimulationRunner.RecordOption;
 import org.apache.cassandra.simulator.systems.InterceptedWait.CaptureSites.Capture;
 import org.apache.cassandra.simulator.systems.SimulatedTime;
@@ -491,7 +492,8 @@ else if (withTime == VALUE)
 
             class Line { int line = 1; } Line line = new Line(); // box for heap dump analysis
             try (ClusterSimulation<?> cluster = builder.create(seed);
-                 CloseableIterator<?> iter = cluster.simulation.iterator())
+                 Simulation simulation = cluster.simulation();
+                 CloseableIterator<?> iter = simulation.iterator())
             {
                 try
                 {

File: test/simulator/main/org/apache/cassandra/simulator/harry/HarryValidatingQuery.java
Patch:
@@ -34,7 +34,6 @@
 import harry.operations.Query;
 import org.apache.cassandra.distributed.Cluster;
 import org.apache.cassandra.distributed.api.IInstance;
-import org.apache.cassandra.simulator.SimulatorUtils;
 import org.apache.cassandra.simulator.systems.InterceptedExecution;
 import org.apache.cassandra.simulator.systems.InterceptingExecutor;
 import org.apache.cassandra.simulator.systems.SimulatedAction;
@@ -115,7 +114,7 @@ protected void validate(Query query, TokenPlacementModel.ReplicatedRanges ring)
                             if (!throwables.isEmpty())
                             {
                                 logger.error(String.format("Could not validate %d out of %d replicas %s", throwables.size(), replicas.size(), replicas), throwables.get(0));
-                                SimulatorUtils.failWithOOM();
+                                System.exit(0);
                             }
                         }
 

File: test/simulator/test/org/apache/cassandra/simulator/test/ShortPaxosSimulationTest.java
Patch:
@@ -34,7 +34,7 @@
  *
           -Dstorage-config=$MODULE_DIR$/test/conf
           -Djava.awt.headless=true
-          -javaagent:$MODULE_DIR$/lib/jamm-0.3.2.jar
+          -javaagent:$MODULE_DIR$/lib/jamm-0.4.0.jar
           -ea
           -Dcassandra.debugrefcount=true
           -Xss384k
@@ -56,7 +56,7 @@
           -Dcassandra.test.messagingService.nonGracefulShutdown=true
           -Dcassandra.use_nix_recursive_delete=true
           -Dcie-cassandra.disable_schema_drop_log=true
-          -Dlog4j2.configurationFile=$MODULE_DIR$/test/conf/log4j2-simulator.xml
+          -Dlogback.configurationFile=file://$MODULE_DIR$/test/conf/logback-simulator.xml
           -Dcassandra.ring_delay_ms=10000
           -Dcassandra.tolerate_sstable_size=true
           -Dcassandra.skip_sync=true

File: test/simulator/test/org/apache/cassandra/simulator/test/SimulationTestBase.java
Patch:
@@ -194,9 +194,9 @@ public static <T extends Simulation> void simulate(ClusterSimulation.Builder<T>
         configure.accept(factory);
         try (ClusterSimulation<?> cluster = factory.create(seed))
         {
-            try
+            try (Simulation simulation = cluster.simulation())
             {
-                cluster.simulation.run();
+                simulation.run();
             }
             catch (Throwable t)
             {

File: src/java/org/apache/cassandra/io/sstable/format/big/BigFormat.java
Patch:
@@ -478,7 +478,9 @@ static class BigVersion extends Version
             super(format, version);
 
             isLatestVersion = version.compareTo(current_version) == 0;
-            correspondingMessagingVersion = MessagingService.VERSION_30;
+
+            // Note that, we probably forgot to change that to 40 for N version, and therefore we cannot do it now.
+            correspondingMessagingVersion = version.compareTo("oa") >= 0 ? MessagingService.VERSION_50 : MessagingService.VERSION_30;
 
             hasCommitLogLowerBound = version.compareTo("mb") >= 0;
             hasCommitLogIntervals = version.compareTo("mc") >= 0;

File: src/java/org/apache/cassandra/io/sstable/format/bti/BtiFormat.java
Patch:
@@ -302,7 +302,7 @@ static class BtiVersion extends Version
             super(format, version);
 
             isLatestVersion = version.compareTo(current_version) == 0;
-            correspondingMessagingVersion = MessagingService.VERSION_40;
+            correspondingMessagingVersion = MessagingService.VERSION_50;
         }
 
         @Override

File: src/java/org/apache/cassandra/io/sstable/format/big/BigFormat.java
Patch:
@@ -385,7 +385,9 @@ static class BigVersion extends Version
             super(format, version);
 
             isLatestVersion = version.compareTo(current_version) == 0;
-            correspondingMessagingVersion = MessagingService.VERSION_30;
+
+            // Note that, we probably forgot to change that to 40 for N version, and therefore we cannot do it now.
+            correspondingMessagingVersion = version.compareTo("oa") >= 0 ? MessagingService.VERSION_50 : MessagingService.VERSION_30;
 
             hasCommitLogLowerBound = version.compareTo("mb") >= 0;
             hasCommitLogIntervals = version.compareTo("mc") >= 0;

File: src/java/org/apache/cassandra/io/sstable/format/bti/BtiFormat.java
Patch:
@@ -302,7 +302,7 @@ static class BtiVersion extends Version
             super(format, version);
 
             isLatestVersion = version.compareTo(current_version) == 0;
-            correspondingMessagingVersion = MessagingService.VERSION_40;
+            correspondingMessagingVersion = MessagingService.VERSION_50;
         }
 
         @Override

File: src/java/org/apache/cassandra/index/sai/disk/v1/postings/PostingListRangeIterator.java
Patch:
@@ -118,6 +118,7 @@ protected PrimaryKey computeNext()
             if (!(t instanceof QueryCancelledException))
                 logger.error(indexIdentifier.logMessage("Unable to provide next token!"), t);
 
+            FileUtils.closeQuietly(Arrays.asList(postingList, primaryKeyMap));
             throw Throwables.cleaned(t);
         }
     }

File: test/unit/org/apache/cassandra/locator/PropertyFileSnitchTest.java
Patch:
@@ -117,7 +117,7 @@ public void configContainsRemoteConfig() throws IOException
         // Locations of remote peers should not be accessible from this snitch unless
         // they are present in ClusterMetadata
         Random r = new Random(System.nanoTime());
-        InetAddressAndPort peer = MembershipUtils.randomEndpoint(r);
+        InetAddressAndPort peer = MembershipUtils.endpoint(99);
         replaceConfigFile(ImmutableMap.of(localAddress.getHostAddressAndPort(), "DC1:RAC1",
                                           peer.getHostAddressAndPort(), "OTHER_DC1:OTHER_RAC1"));
         PropertyFileSnitch snitch = new PropertyFileSnitch();

File: test/distributed/org/apache/cassandra/distributed/test/ReadRepairTest.java
Patch:
@@ -422,7 +422,7 @@ public void onFailure(Throwable t) {}
         {
             Throwable cause = e.getCause();
             Assert.assertTrue("Expected a different error message, but got " + cause.getMessage(),
-                              cause.getMessage().contains("Operation failed - received 1 responses and 1 failures: INVALID_ROUTING from /127.0.0.2:7012"));
+                              cause.getMessage().contains("INVALID_ROUTING from /127.0.0.2:7012"));
         }
         catch (InterruptedException e)
         {

File: test/distributed/org/apache/cassandra/distributed/test/topology/DecommissionAvoidTimeouts.java
Patch:
@@ -90,7 +90,7 @@ public void test() throws Exception
             cluster.schemaChange("CREATE KEYSPACE " + KEYSPACE + " WITH replication = {'class': 'NetworkTopologyStrategy', 'datacenter1': 3, 'datacenter2': 3}");
             String table = KEYSPACE + ".tbl";
             cluster.schemaChange("CREATE TABLE " + table + " (pk blob PRIMARY KEY)");
-
+            cluster.forEach(i -> i.runOnInstance(() -> Undead.State.enabled = true));
             List<IInvokableInstance> dc1 = cluster.get(1, 2, 3, 4);
             List<IInvokableInstance> dc2 = cluster.get(5, 6, 7, 8);
             IInvokableInstance toDecom = dc2.get(1);

File: test/distributed/org/apache/cassandra/distributed/util/byterewrite/Undead.java
Patch:
@@ -45,7 +45,7 @@ public static void close()
     @Shared
     public static class State
     {
-        public static volatile boolean enabled = true;
+        public static volatile boolean enabled = false;
     }
 
     public static class BB

File: src/java/org/apache/cassandra/tcm/Commit.java
Patch:
@@ -187,7 +187,8 @@ public Failure(ExceptionCode code, String message, boolean rejected)
                 if (message == null)
                     message = "";
                 this.code = code;
-                this.message = message;
+                // TypeSizes#sizeOf encoder only allows strings that are up to Short.MAX_VALUE bytes large
+                this.message =  message.substring(0, Math.min(message.length(), Short.MAX_VALUE));
                 this.rejected = rejected;
             }
 

File: src/java/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -1132,8 +1132,8 @@ public ReadCommand deserialize(DataInputPlus in, int version) throws IOException
             int digestVersion = isDigest ? (int)in.readUnsignedVInt() : 0;
             TableId tableId = TableId.deserialize(in);
 
-            Epoch schemaVersion = null;
-            if (version >= MessagingService.VERSION_50)
+            Epoch schemaVersion = Epoch.EMPTY;
+            if (version >= MessagingService.VERSION_51)
                 schemaVersion = Epoch.serializer.deserialize(in);
             TableMetadata tableMetadata;
             try

File: src/java/org/apache/cassandra/tcm/listeners/LegacyStateListener.java
Patch:
@@ -129,6 +129,8 @@ else if(next.directory.peerState(change) == MOVING)
             {
                 // legacy log messages for tests
                 logger.debug("Node {} state MOVING, tokens {}", next.directory.endpoint(change), prev.tokenMap.tokens(change));
+                Gossiper.instance.mergeNodeToGossip(change, next);
+                PeersTable.updateLegacyPeerTable(change, prev, next);
             }
             else if (NodeState.isBootstrap(next.directory.peerState(change)))
             {

File: tools/stress/src/org/apache/cassandra/stress/operations/predefined/CqlCounterAdder.java
Patch:
@@ -72,9 +72,9 @@ protected List<Object> getQueryParameters(byte[] key)
     }
 
     @Override
-    protected CqlRunOp<Integer> buildRunOp(ClientWrapper client, String query, Object queryId, List<Object> params, ByteBuffer key)
+    protected CqlRunOp<Integer> buildRunOp(QueryExecutor<?> queryExecutor, List<Object> params, ByteBuffer key)
     {
-        return new CqlRunOpAlwaysSucceed(client, query, queryId, params, key, 1);
+        return new CqlRunOpAlwaysSucceed(queryExecutor, params, key, 1);
     }
 
     public boolean isWrite()

File: tools/stress/src/org/apache/cassandra/stress/operations/predefined/CqlCounterGetter.java
Patch:
@@ -52,9 +52,9 @@ protected String buildQuery()
     }
 
     @Override
-    protected CqlRunOp<Integer> buildRunOp(ClientWrapper client, String query, Object queryId, List<Object> params, ByteBuffer key)
+    protected CqlRunOp<Integer> buildRunOp(QueryExecutor<?> queryExecutor, List<Object> params, ByteBuffer key)
     {
-        return new CqlRunOpTestNonEmpty(client, query, queryId, params, key);
+        return new CqlRunOpTestNonEmpty(queryExecutor, params, key);
     }
 
 }

File: tools/stress/src/org/apache/cassandra/stress/operations/predefined/CqlInserter.java
Patch:
@@ -71,9 +71,9 @@ protected List<Object> getQueryParameters(byte[] key)
     }
 
     @Override
-    protected CqlRunOp<Integer> buildRunOp(ClientWrapper client, String query, Object queryId, List<Object> params, ByteBuffer key)
+    protected CqlRunOp<Integer> buildRunOp(QueryExecutor<?> queryExecutor, List<Object> params, ByteBuffer key)
     {
-        return new CqlRunOpAlwaysSucceed(client, query, queryId, params, key, 1);
+        return new CqlRunOpAlwaysSucceed(queryExecutor, params, key, 1);
     }
 
     public boolean isWrite()

File: tools/stress/src/org/apache/cassandra/stress/operations/predefined/CqlReader.java
Patch:
@@ -71,10 +71,10 @@ protected List<Object> getQueryParameters(byte[] key)
     }
 
     @Override
-    protected CqlRunOp<ByteBuffer[][]> buildRunOp(ClientWrapper client, String query, Object queryId, List<Object> params, ByteBuffer key)
+    protected CqlRunOp<ByteBuffer[][]> buildRunOp(QueryExecutor<?> queryExecutor, List<Object> params, ByteBuffer key)
     {
         List<ByteBuffer> expectRow = getColumnValues();
-        return new CqlRunOpMatchResults(client, query, queryId, params, key, Arrays.asList(expectRow));
+        return new CqlRunOpMatchResults(queryExecutor, params, key, Arrays.asList(expectRow));
     }
 
 }

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -726,7 +726,6 @@ public void stopNativeTransport()
     {
         if (nativeTransportService != null)
         {
-            StorageService.instance.setRpcReady(false);
             nativeTransportService.stop();
         }
     }

File: test/distributed/org/apache/cassandra/distributed/test/NativeProtocolTest.java
Patch:
@@ -139,9 +139,10 @@ public void testBinaryReflectsRpcReadiness() throws Throwable
             i.runOnInstance((IIsolatedExecutor.SerializableRunnable) () -> StorageService.instance.startNativeTransport());
             assertTrue(i.callOnInstance((IIsolatedExecutor.SerializableCallable<Boolean>) () -> StorageService.instance.isRpcReady(FBUtilities.getBroadcastAddress())));
 
-            // by calling e.g. nodetool disablebinary, rpc will be set to false again
+            // by calling e.g. nodetool disablebinary, rpc will NOT be set to false again
+            // please read CASSANDRA-18935 for in-depth explanation why it is so
             i.runOnInstance((IIsolatedExecutor.SerializableRunnable) () -> StorageService.instance.stopNativeTransport());
-            assertFalse(i.callOnInstance((IIsolatedExecutor.SerializableCallable<Boolean>) () -> StorageService.instance.isRpcReady(FBUtilities.getBroadcastAddress())));
+            assertTrue(i.callOnInstance((IIsolatedExecutor.SerializableCallable<Boolean>) () -> StorageService.instance.isRpcReady(FBUtilities.getBroadcastAddress())));
         }
     }
 }
\ No newline at end of file

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -480,9 +480,7 @@ public void migrateSystemDataIfNeeded() throws IOException
                     try (Stream<Path> keyspaceChildren = Files.list(keyspaceDirectory))
                     {
                         Path[] tableDirectories = keyspaceChildren.filter(Files::isDirectory)
-                                                                  .filter(p -> !SystemKeyspace.TABLES_SPLIT_ACROSS_MULTIPLE_DISKS
-                                                                                              .contains(p.getFileName()
-                                                                                                         .toString()))
+                                                                  .filter(p -> SystemKeyspace.TABLES_SPLIT_ACROSS_MULTIPLE_DISKS.stream().noneMatch(t -> p.getFileName().toString().startsWith(t + '-')))
                                                                   .toArray(Path[]::new);
 
                         for (Path tableDirectory : tableDirectories)

File: src/java/org/apache/cassandra/index/sai/SSTableContext.java
Patch:
@@ -104,9 +104,9 @@ public SSTableContext sharedCopy()
     /**
      * Returns a new {@link SSTableIndex} for a per-column index
      */
-    public SSTableIndex newSSTableIndex(IndexContext indexContext)
+    public SSTableIndex newSSTableIndex(StorageAttachedIndex index)
     {
-        return indexDescriptor.newSSTableIndex(this, indexContext);
+        return indexDescriptor.newSSTableIndex(this, index);
     }
 
     /**

File: src/java/org/apache/cassandra/index/sai/StorageAttachedIndexBuilder.java
Patch:
@@ -152,7 +152,7 @@ private boolean indexSSTable(SSTableReader sstable, Set<StorageAttachedIndex> in
             boolean perIndexComponentsOnly = perSSTableFileLock == null;
             // remove existing per column index files instead of overwriting
             IndexDescriptor indexDescriptor = IndexDescriptor.create(sstable);
-            indexes.forEach(index -> indexDescriptor.deleteColumnIndex(index.getIndexContext()));
+            indexes.forEach(index -> indexDescriptor.deleteColumnIndex(index.termType(), index.identifier()));
 
             indexWriter = StorageAttachedIndexWriter.createBuilderWriter(indexDescriptor, indexes, txn, perIndexComponentsOnly);
 
@@ -342,7 +342,7 @@ private Set<StorageAttachedIndex> validateIndexes(Set<StorageAttachedIndex> inde
 
         if (!dropped.isEmpty())
         {
-            String droppedIndexes = dropped.stream().map(sai -> sai.getIndexContext().getIndexName()).collect(Collectors.toList()).toString();
+            String droppedIndexes = dropped.stream().map(sai -> sai.identifier().indexName).collect(Collectors.toList()).toString();
             if (isFullRebuild)
                 throw new RuntimeException(logMessage(String.format("%s are dropped, will stop index build.", droppedIndexes)));
             else

File: src/java/org/apache/cassandra/index/sai/disk/v1/MetadataSource.java
Patch:
@@ -22,9 +22,9 @@
 import java.util.Map;
 import javax.annotation.concurrent.NotThreadSafe;
 
-import org.apache.cassandra.index.sai.IndexContext;
 import org.apache.cassandra.index.sai.disk.format.IndexComponent;
 import org.apache.cassandra.index.sai.disk.format.IndexDescriptor;
+import org.apache.cassandra.index.sai.utils.IndexIdentifier;
 import org.apache.cassandra.index.sai.disk.io.IndexFileUtils;
 import org.apache.lucene.store.ByteArrayDataInput;
 import org.apache.lucene.store.ChecksumIndexInput;
@@ -47,9 +47,9 @@ public static MetadataSource loadGroupMetadata(IndexDescriptor indexDescriptor)
         return MetadataSource.load(indexDescriptor.openPerSSTableInput(IndexComponent.GROUP_META));
     }
 
-    public static MetadataSource loadColumnMetadata(IndexDescriptor indexDescriptor, IndexContext indexContext) throws IOException
+    public static MetadataSource loadColumnMetadata(IndexDescriptor indexDescriptor, IndexIdentifier indexIdentifier) throws IOException
     {
-        return MetadataSource.load(indexDescriptor.openPerIndexInput(IndexComponent.META, indexContext));
+        return MetadataSource.load(indexDescriptor.openPerIndexInput(IndexComponent.META, indexIdentifier));
     }
 
     private static MetadataSource load(IndexInput indexInput) throws IOException

File: src/java/org/apache/cassandra/index/sai/disk/v1/vector/DiskAnn.java
Patch:
@@ -34,8 +34,8 @@
 import io.github.jbellis.jvector.pq.CompressedVectors;
 import io.github.jbellis.jvector.util.Bits;
 import io.github.jbellis.jvector.vector.VectorSimilarityFunction;
-import org.apache.cassandra.index.sai.IndexContext;
 import org.apache.cassandra.index.sai.disk.format.IndexComponent;
+import org.apache.cassandra.index.sai.disk.v1.IndexWriterConfig;
 import org.apache.cassandra.index.sai.disk.v1.PerColumnIndexFiles;
 import org.apache.cassandra.index.sai.disk.v1.postings.VectorPostingList;
 import org.apache.cassandra.index.sai.disk.v1.segment.SegmentMetadata;
@@ -52,9 +52,9 @@ public class DiskAnn implements AutoCloseable
     // only one of these will be not null
     private final CompressedVectors compressedVectors;
 
-    public DiskAnn(SegmentMetadata.ComponentMetadataMap componentMetadatas, PerColumnIndexFiles indexFiles, IndexContext context) throws IOException
+    public DiskAnn(SegmentMetadata.ComponentMetadataMap componentMetadatas, PerColumnIndexFiles indexFiles, IndexWriterConfig config) throws IOException
     {
-        similarityFunction = context.getIndexWriterConfig().getSimilarityFunction();
+        similarityFunction = config.getSimilarityFunction();
 
         SegmentMetadata.ComponentMetadata termsMetadata = componentMetadatas.get(IndexComponent.TERMS_DATA);
         graphHandle = indexFiles.termsData();

File: test/microbench/org/apache/cassandra/test/microbench/sai/KeyLookupBench.java
Patch:
@@ -37,7 +37,6 @@
 import org.apache.cassandra.index.sai.disk.v1.SSTableComponentsWriter;
 import org.apache.cassandra.index.sai.disk.v1.WidePrimaryKeyMap;
 import org.apache.cassandra.index.sai.utils.PrimaryKey;
-import org.apache.cassandra.index.sai.utils.TypeUtil;
 import org.apache.cassandra.io.sstable.Descriptor;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.io.util.File;
@@ -173,7 +172,7 @@ public long advanceToKey()
     private static DecoratedKey makeKey(TableMetadata table, Object...partitionKeys)
     {
         ByteBuffer key;
-        if (TypeUtil.isComposite(table.partitionKeyType))
+        if (table.partitionKeyType instanceof CompositeType)
             key = ((CompositeType)table.partitionKeyType).decompose(partitionKeys);
         else
             key = table.partitionKeyType.fromString((String)partitionKeys[0]);

File: test/unit/org/apache/cassandra/index/sai/analyzer/NonTokenizingAnalyzerTest.java
Patch:
@@ -23,6 +23,7 @@
 import org.junit.Test;
 
 import org.apache.cassandra.db.marshal.UTF8Type;
+import org.apache.cassandra.index.sai.SAITester;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
 import static org.junit.Assert.assertEquals;
@@ -68,7 +69,7 @@ public void caseSensitiveAnalyzer() throws Exception
 
     private String getAnalyzedString(String input, NonTokenizingOptions options) throws Exception
     {
-        NonTokenizingAnalyzer analyzer = new NonTokenizingAnalyzer(UTF8Type.instance, options);
+        NonTokenizingAnalyzer analyzer = new NonTokenizingAnalyzer(SAITester.createIndexTermType(UTF8Type.instance), options);
         analyzer.reset(ByteBuffer.wrap(input.getBytes()));
         return analyzer.hasNext() ? ByteBufferUtil.string(analyzer.next) : null;
     }

File: test/unit/org/apache/cassandra/index/sai/disk/format/VersionTest.java
Patch:
@@ -30,7 +30,7 @@ public class VersionTest
     @BeforeClass
     public static void initialise()
     {
-        DatabaseDescriptor.daemonInitialization();
+        DatabaseDescriptor.toolInitialization();
     }
 
     @Test

File: test/unit/org/apache/cassandra/index/sai/disk/v1/SegmentTest.java
Patch:
@@ -46,7 +46,7 @@ public class SegmentTest
     @BeforeClass
     public static void init()
     {
-        DatabaseDescriptor.daemonInitialization();
+        DatabaseDescriptor.toolInitialization();
         DatabaseDescriptor.setPartitionerUnsafe(Murmur3Partitioner.instance);
         partitioner = DatabaseDescriptor.getPartitioner();
         min = partitioner.getMinimumToken();

File: test/unit/org/apache/cassandra/index/sai/disk/v1/bbtree/BlockBalancedTreeQueriesTest.java
Patch:
@@ -21,7 +21,6 @@
 
 import org.apache.cassandra.cql3.Operator;
 import org.apache.cassandra.db.marshal.Int32Type;
-import org.apache.cassandra.index.sai.SAITester;
 import org.apache.cassandra.index.sai.plan.Expression;
 import org.apache.cassandra.index.sai.utils.SAIRandomizedTester;
 import org.apache.cassandra.utils.bytecomparable.ByteComparable;
@@ -40,7 +39,7 @@ public class BlockBalancedTreeQueriesTest extends SAIRandomizedTester
     @Test
     public void testMatchesAll()
     {
-        Expression expression = new Expression(SAITester.createIndexContext("meh", Int32Type.instance));
+        Expression expression = Expression.create(createMockIndex("meh", Int32Type.instance));
         BlockBalancedTreeReader.IntersectVisitor query = BlockBalancedTreeQueries.balancedTreeQueryFrom(expression, 4);
 
         for (int visit = 0; visit < between(100, 1000); visit++)
@@ -213,7 +212,7 @@ private byte[] toSortableBytes(int value)
 
     private Expression buildExpression(Operator op, int value)
     {
-        Expression expression = new Expression(SAITester.createIndexContext("meh", Int32Type.instance));
+        Expression expression = Expression.create(createMockIndex("meh", Int32Type.instance));
         expression.add(op, Int32Type.instance.decompose(value));
         return expression;
     }

File: test/unit/org/apache/cassandra/index/sai/utils/AbstractPrimaryKeyTester.java
Patch:
@@ -146,7 +146,7 @@ else if (expected < 0)
     protected DecoratedKey makeKey(TableMetadata table, Object...partitionKeys)
     {
         ByteBuffer key;
-        if (TypeUtil.isComposite(table.partitionKeyType))
+        if (table.partitionKeyType instanceof CompositeType)
             key = ((CompositeType)table.partitionKeyType).decompose(partitionKeys);
         else
             key = table.partitionKeyType.decomposeUntyped(partitionKeys[0]);

File: test/unit/org/apache/cassandra/index/sai/virtual/IndexesSystemViewTest.java
Patch:
@@ -25,7 +25,6 @@
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.virtual.VirtualKeyspace;
 import org.apache.cassandra.db.virtual.VirtualKeyspaceRegistry;
-import org.apache.cassandra.index.sai.IndexContext;
 import org.apache.cassandra.index.sai.SAITester;
 import org.apache.cassandra.index.sai.StorageAttachedIndex;
 import org.apache.cassandra.inject.Injections;
@@ -121,14 +120,13 @@ private Object[] row(String indexName,
     {
             ColumnFamilyStore cfs = getCurrentColumnFamilyStore();
             StorageAttachedIndex sai = (StorageAttachedIndex) cfs.indexManager.getIndexByName(indexName);
-            IndexContext context = sai.getIndexContext();
 
             return row(indexName,
                        currentTable(),
                        columnName,
                        isQueryable,
                        isBuilding,
                        isString,
-                       context.getAnalyzerFactory().toString());
+                       sai.hasAnalyzer() ? sai.analyzer().toString() : "NoOpAnalyzer");
     }
 }

File: test/unit/org/apache/cassandra/index/sai/virtual/SSTablesSystemViewTest.java
Patch:
@@ -177,7 +177,7 @@ private Object[] readRow(String indexName,
         ColumnFamilyStore cfs = getCurrentColumnFamilyStore();
         StorageAttachedIndex sai = (StorageAttachedIndex) cfs.indexManager.getIndexByName(indexName);
 
-        for (SSTableIndex sstableIndex : sai.getIndexContext().getView())
+        for (SSTableIndex sstableIndex : sai.view())
         {
             SSTableReader sstable = sstableIndex.getSSTable();
 

File: src/java/org/apache/cassandra/db/compaction/unified/UnifiedCompactionTask.java
Patch:
@@ -43,7 +43,7 @@ public UnifiedCompactionTask(ColumnFamilyStore cfs,
                                  long gcBefore,
                                  ShardManager shardManager)
     {
-        super(cfs, txn, gcBefore, strategy.getController().getIgnoreOverlapsInExpirationCheck());
+        super(cfs, txn, gcBefore);
         this.controller = strategy.getController();
         this.shardManager = shardManager;
     }

File: src/java/org/apache/cassandra/index/sai/plan/QueryController.java
Patch:
@@ -146,7 +146,9 @@ public IndexContext getContext(RowFilter.Expression expression)
                                                     cfs.getPartitioner(),
                                                     cfs.getComparator(),
                                                     expression.column(),
-                                                    IndexTarget.Type.VALUES,
+                                                    expression.operator().isContainsKey()
+                                                            ? IndexTarget.Type.KEYS
+                                                            : IndexTarget.Type.VALUES,
                                                     null)
                                  : indexes.iterator().next().getIndexContext();
     }

File: test/unit/org/apache/cassandra/hints/HintsMaker.java
Patch:
@@ -186,7 +186,7 @@ private void makeHintFile(File dir,
                 {
                     while (session.position() < maxLength && mutationIterator.hasNext())
                     {
-                        Hint hint = Hint.create(mutationIterator.next(), System.currentTimeMillis());
+                        Hint hint = Hint.create(mutationIterator.next(), System.currentTimeMillis(), Integer.MAX_VALUE);
                         session.append(hint);
                     }
 

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -117,7 +117,7 @@ public static Set<String> splitCommaDelimited(String src)
     public volatile boolean force_new_prepared_statement_behaviour = false;
 
     public ParameterizedClass seed_provider;
-    public DiskAccessMode disk_access_mode = DiskAccessMode.auto;
+    public DiskAccessMode disk_access_mode = DiskAccessMode.mmap_index_only;
 
     public DiskFailurePolicy disk_failure_policy = DiskFailurePolicy.ignore;
     public CommitFailurePolicy commit_failure_policy = CommitFailurePolicy.stop;

File: src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java
Patch:
@@ -458,7 +458,7 @@ protected SSTableReader(Builder<?, ?> builder, Owner owner)
         this.openReason = builder.getOpenReason();
         this.first = builder.getFirst();
         this.last = builder.getLast();
-        this.bounds = AbstractBounds.strictlyWrapsAround(first.getToken(), last.getToken())
+        this.bounds = first == null || last == null || AbstractBounds.strictlyWrapsAround(first.getToken(), last.getToken())
                       ? null // this will cause the validation to fail, but the reader is opened with no validation,
                              // e.g. for scrubbing, we should accept screwed bounds
                       : AbstractBounds.bounds(first.getToken(), true, last.getToken(), true);

File: src/java/org/apache/cassandra/io/sstable/format/Version.java
Patch:
@@ -74,14 +74,14 @@ protected Version(SSTableFormat format, String version)
     public abstract boolean hasOldBfFormat();
 
     /**
-     * @deprecated it is replaced by {@link #hasImprovedMinMax()} since 'nc' and to be completetly removed since 'oa'
+     * @deprecated it is replaced by {@link #hasImprovedMinMax()} since 'oa' and to be completetly removed after 'oa'
      */
     /** @deprecated See CASSANDRA-18134 */
     @Deprecated(since = "5.0")
     public abstract boolean hasAccurateMinMax();
 
     /**
-     * @deprecated it is replaced by {@link #hasImprovedMinMax()} since 'nc' and to be completetly removed since 'oa'
+     * @deprecated it is replaced by {@link #hasImprovedMinMax()} since 'oa' and to be completetly removed after 'oa'
      */
     /** @deprecated See CASSANDRA-18134 */
     @Deprecated(since = "5.0")

File: test/microbench/org/apache/cassandra/test/microbench/DeletionTimeDeSerBench.java
Patch:
@@ -67,9 +67,9 @@ public class DeletionTimeDeSerBench
     final static ArrayList<DeletionTime> TEST_DTS_30PC_LIVE = generateDTs(30);
 
     // Parameters
-    final static String ncSstableParam = "NC";
+    final static String nbSstableParam = "NB";
     final static String oaSstableParam = "OA";
-    @Param({ ncSstableParam, oaSstableParam })
+    @Param({ nbSstableParam, oaSstableParam })
     String sstableParam;
 
     final static String live70PcParam = "70PcLive";
@@ -341,7 +341,7 @@ private static Serializer getSerializer(String value)
     {
         switch (value)
         {
-            case ncSstableParam:
+            case nbSstableParam:
                 return new DeletionTime.LegacySerializer();
 
             case oaSstableParam:

File: test/unit/org/apache/cassandra/io/sstable/LegacySSTableTest.java
Patch:
@@ -101,7 +101,7 @@ public class LegacySSTableTest
     // Get all versions up to the current one. Useful for testing in compatibility mode C18301
     private static String[] getValidLegacyVersions()
     {
-        String[] versions = {"oa", "da", "nc", "nb", "na", "me", "md", "mc", "mb", "ma"};
+        String[] versions = {"oa", "da", "nb", "na", "me", "md", "mc", "mb", "ma"};
         return Arrays.stream(versions).filter((v) -> v.compareTo(BigFormat.getInstance().getLatestVersion().toString()) <= 0).toArray(String[]::new);
     }
 

File: test/unit/org/apache/cassandra/io/sstable/format/big/VersionSupportedFeaturesTest.java
Patch:
@@ -40,7 +40,7 @@ protected Stream<String> getPendingRepairSupportedVersions()
     @Override
     protected Stream<String> getPartitionLevelDeletionPresenceMarkerSupportedVersions()
     {
-        return range("nc", "zz");
+        return range("oa", "zz");
     }
 
     @Override
@@ -52,13 +52,13 @@ protected Stream<String> getLegacyMinMaxSupportedVersions()
     @Override
     protected Stream<String> getImprovedMinMaxSupportedVersions()
     {
-        return range("nc", "zz");
+        return range("oa", "zz");
     }
 
     @Override
     protected Stream<String> getKeyRangeSupportedVersions()
     {
-        return range("nc", "zz");
+        return range("oa", "zz");
     }
 
     @Override

File: src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java
Patch:
@@ -458,7 +458,7 @@ protected SSTableReader(Builder<?, ?> builder, Owner owner)
         this.openReason = builder.getOpenReason();
         this.first = builder.getFirst();
         this.last = builder.getLast();
-        this.bounds = AbstractBounds.strictlyWrapsAround(first.getToken(), last.getToken())
+        this.bounds = first == null || last == null || AbstractBounds.strictlyWrapsAround(first.getToken(), last.getToken())
                       ? null // this will cause the validation to fail, but the reader is opened with no validation,
                              // e.g. for scrubbing, we should accept screwed bounds
                       : AbstractBounds.bounds(first.getToken(), true, last.getToken(), true);

File: src/java/org/apache/cassandra/io/sstable/format/Version.java
Patch:
@@ -74,14 +74,14 @@ protected Version(SSTableFormat format, String version)
     public abstract boolean hasOldBfFormat();
 
     /**
-     * @deprecated it is replaced by {@link #hasImprovedMinMax()} since 'nc' and to be completetly removed since 'oa'
+     * @deprecated it is replaced by {@link #hasImprovedMinMax()} since 'oa' and to be completetly removed after 'oa'
      */
     /** @deprecated See CASSANDRA-18134 */
     @Deprecated(since = "5.0")
     public abstract boolean hasAccurateMinMax();
 
     /**
-     * @deprecated it is replaced by {@link #hasImprovedMinMax()} since 'nc' and to be completetly removed since 'oa'
+     * @deprecated it is replaced by {@link #hasImprovedMinMax()} since 'oa' and to be completetly removed after 'oa'
      */
     /** @deprecated See CASSANDRA-18134 */
     @Deprecated(since = "5.0")

File: test/microbench/org/apache/cassandra/test/microbench/DeletionTimeDeSerBench.java
Patch:
@@ -67,9 +67,9 @@ public class DeletionTimeDeSerBench
     final static ArrayList<DeletionTime> TEST_DTS_30PC_LIVE = generateDTs(30);
 
     // Parameters
-    final static String ncSstableParam = "NC";
+    final static String nbSstableParam = "NB";
     final static String oaSstableParam = "OA";
-    @Param({ ncSstableParam, oaSstableParam })
+    @Param({ nbSstableParam, oaSstableParam })
     String sstableParam;
 
     final static String live70PcParam = "70PcLive";
@@ -341,7 +341,7 @@ private static Serializer getSerializer(String value)
     {
         switch (value)
         {
-            case ncSstableParam:
+            case nbSstableParam:
                 return new DeletionTime.LegacySerializer();
 
             case oaSstableParam:

File: test/unit/org/apache/cassandra/io/sstable/LegacySSTableTest.java
Patch:
@@ -101,7 +101,7 @@ public class LegacySSTableTest
     // Get all versions up to the current one. Useful for testing in compatibility mode C18301
     private static String[] getValidLegacyVersions()
     {
-        String[] versions = {"oa", "da", "nc", "nb", "na", "me", "md", "mc", "mb", "ma"};
+        String[] versions = {"oa", "da", "nb", "na", "me", "md", "mc", "mb", "ma"};
         return Arrays.stream(versions).filter((v) -> v.compareTo(BigFormat.getInstance().getLatestVersion().toString()) <= 0).toArray(String[]::new);
     }
 

File: test/unit/org/apache/cassandra/io/sstable/format/big/VersionSupportedFeaturesTest.java
Patch:
@@ -40,7 +40,7 @@ protected Stream<String> getPendingRepairSupportedVersions()
     @Override
     protected Stream<String> getPartitionLevelDeletionPresenceMarkerSupportedVersions()
     {
-        return range("nc", "zz");
+        return range("oa", "zz");
     }
 
     @Override
@@ -52,13 +52,13 @@ protected Stream<String> getLegacyMinMaxSupportedVersions()
     @Override
     protected Stream<String> getImprovedMinMaxSupportedVersions()
     {
-        return range("nc", "zz");
+        return range("oa", "zz");
     }
 
     @Override
     protected Stream<String> getKeyRangeSupportedVersions()
     {
-        return range("nc", "zz");
+        return range("oa", "zz");
     }
 
     @Override

File: src/java/org/apache/cassandra/io/sstable/format/big/IndexState.java
Patch:
@@ -66,7 +66,6 @@ public void setToBlock(int blockIdx) throws IOException
         {
             reader.seekToPosition(columnOffset(blockIdx));
             mark = reader.file.mark();
-            reader.deserializer.clearState();
         }
 
         currentIndexIdx = blockIdx;
@@ -114,9 +113,9 @@ public void updateBlock() throws IOException
             }
             else
             {
-                reader.seekToPosition(startOfBlock);
+                reader.file.seek(startOfBlock);
                 mark = reader.file.mark();
-                reader.seekToPosition(currentFilePointer);
+                reader.file.seek(currentFilePointer);
             }
         }
     }

File: test/unit/org/apache/cassandra/cql3/ViewAbstractParameterizedTest.java
Patch:
@@ -60,9 +60,9 @@ protected com.datastax.driver.core.ResultSet executeNet(String query, Object...
     }
 
     @Override
-    protected com.datastax.driver.core.ResultSet executeNetWithPaging(String query, int pageSize)
+    protected com.datastax.driver.core.ResultSet executeNetWithPaging(String query, int pageSize, Object... values)
     {
-        return executeNetWithPaging(version, query, pageSize);
+        return executeNetWithPaging(version, query, pageSize, values);
     }
 
     @Override

File: src/java/org/apache/cassandra/io/sstable/format/big/IndexState.java
Patch:
@@ -66,7 +66,6 @@ public void setToBlock(int blockIdx) throws IOException
         {
             reader.seekToPosition(columnOffset(blockIdx));
             mark = reader.file.mark();
-            reader.deserializer.clearState();
         }
 
         currentIndexIdx = blockIdx;
@@ -114,9 +113,9 @@ public void updateBlock() throws IOException
             }
             else
             {
-                reader.seekToPosition(startOfBlock);
+                reader.file.seek(startOfBlock);
                 mark = reader.file.mark();
-                reader.seekToPosition(currentFilePointer);
+                reader.file.seek(currentFilePointer);
             }
         }
     }

File: test/unit/org/apache/cassandra/cql3/ViewAbstractParameterizedTest.java
Patch:
@@ -60,9 +60,9 @@ protected com.datastax.driver.core.ResultSet executeNet(String query, Object...
     }
 
     @Override
-    protected com.datastax.driver.core.ResultSet executeNetWithPaging(String query, int pageSize)
+    protected com.datastax.driver.core.ResultSet executeNetWithPaging(String query, int pageSize, Object... values)
     {
-        return executeNetWithPaging(version, query, pageSize);
+        return executeNetWithPaging(version, query, pageSize, values);
     }
 
     @Override

File: test/unit/org/apache/cassandra/io/sstable/keycache/KeyCacheTest.java
Patch:
@@ -340,12 +340,11 @@ private void testKeyCache(String cf) throws ExecutionException, InterruptedExcep
             throw new IllegalStateException();
 
         Util.compactAll(cfs, Integer.MAX_VALUE).get();
-        boolean noEarlyOpen = DatabaseDescriptor.getSSTablePreemptiveOpenIntervalInMiB() < 0;
 
         // after compaction cache should have entries for new SSTables,
         // but since we have kept a reference to the old sstables,
         // if we had 2 keys in cache previously it should become 4
-        assertKeyCacheSize(noEarlyOpen ? 2 : 4, KEYSPACE1, cf);
+        assertKeyCacheSize(4, KEYSPACE1, cf);
 
         refs.release();
 
@@ -358,7 +357,7 @@ private void testKeyCache(String cf) throws ExecutionException, InterruptedExcep
         Util.getAll(Util.cmd(cfs, "key1").build());
         Util.getAll(Util.cmd(cfs, "key2").build());
 
-        assertKeyCacheSize(noEarlyOpen ? 4 : 2, KEYSPACE1, cf);
+        assertKeyCacheSize( 2, KEYSPACE1, cf);
     }
 
     @Test

File: test/unit/org/apache/cassandra/io/sstable/keycache/KeyCacheTest.java
Patch:
@@ -340,12 +340,11 @@ private void testKeyCache(String cf) throws ExecutionException, InterruptedExcep
             throw new IllegalStateException();
 
         Util.compactAll(cfs, Integer.MAX_VALUE).get();
-        boolean noEarlyOpen = DatabaseDescriptor.getSSTablePreemptiveOpenIntervalInMiB() < 0;
 
         // after compaction cache should have entries for new SSTables,
         // but since we have kept a reference to the old sstables,
         // if we had 2 keys in cache previously it should become 4
-        assertKeyCacheSize(noEarlyOpen ? 2 : 4, KEYSPACE1, cf);
+        assertKeyCacheSize(4, KEYSPACE1, cf);
 
         refs.release();
 
@@ -358,7 +357,7 @@ private void testKeyCache(String cf) throws ExecutionException, InterruptedExcep
         Util.getAll(Util.cmd(cfs, "key1").build());
         Util.getAll(Util.cmd(cfs, "key2").build());
 
-        assertKeyCacheSize(noEarlyOpen ? 4 : 2, KEYSPACE1, cf);
+        assertKeyCacheSize( 2, KEYSPACE1, cf);
     }
 
     @Test

File: src/java/org/apache/cassandra/index/sai/plan/QueryController.java
Patch:
@@ -67,8 +67,6 @@
 
 public class QueryController
 {
-    public static final int ORDER_CHUNK_SIZE = SAI_VECTOR_SEARCH_ORDER_CHUNK_SIZE.getInt();
-
     private final ColumnFamilyStore cfs;
     private final ReadCommand command;
     private final QueryContext queryContext;
@@ -79,6 +77,7 @@ public class QueryController
     private final PrimaryKey.Factory keyFactory;
     private final PrimaryKey firstPrimaryKey;
     private final PrimaryKey lastPrimaryKey;
+    private final int orderChunkSize;
 
     public QueryController(ColumnFamilyStore cfs,
                            ReadCommand command,
@@ -98,6 +97,7 @@ public QueryController(ColumnFamilyStore cfs,
         this.keyFactory = new PrimaryKey.Factory(cfs.getPartitioner(), cfs.getComparator());
         this.firstPrimaryKey = keyFactory.create(mergeRange.left.getToken());
         this.lastPrimaryKey = keyFactory.create(mergeRange.right.getToken());
+        this.orderChunkSize = SAI_VECTOR_SEARCH_ORDER_CHUNK_SIZE.getInt();
     }
 
     public PrimaryKey.Factory primaryKeyFactory()
@@ -275,7 +275,7 @@ public KeyRangeIterator getTopKRows(RowFilter.Expression expression)
     // This is a hybrid query. We apply all other predicates before ordering and limiting.
     public KeyRangeIterator getTopKRows(KeyRangeIterator source, RowFilter.Expression expression)
     {
-        return new KeyRangeOrderingIterator(source, ORDER_CHUNK_SIZE, list -> this.getTopKRows(list, expression));
+        return new KeyRangeOrderingIterator(source, orderChunkSize, list -> this.getTopKRows(list, expression));
     }
 
     private KeyRangeIterator getTopKRows(List<PrimaryKey> rawSourceKeys, RowFilter.Expression expression)

File: src/java/org/apache/cassandra/cql3/statements/DescribeStatement.java
Patch:
@@ -132,11 +132,12 @@ public final ResultMessage execute(QueryState state, QueryOptions options, long
     @Override
     public ResultMessage executeLocally(QueryState state, QueryOptions options)
     {
-        Keyspaces keyspaces = Schema.instance.distributedAndLocalKeyspaces();
+        Keyspaces keyspaces = Schema.instance.distributedKeyspaces();
         UUID schemaVersion = Schema.instance.getVersion();
 
         keyspaces = Keyspaces.builder()
                              .add(keyspaces)
+                             .add(Schema.instance.getLocalKeyspaces())
                              .add(VirtualKeyspaceRegistry.instance.virtualKeyspacesMetadata())
                              .build();
 

File: src/java/org/apache/cassandra/cql3/statements/schema/CreateTableStatement.java
Patch:
@@ -139,7 +139,6 @@ public void validate(ClientState state)
         {
             int totalUserTables = Schema.instance.getUserKeyspaces()
                                                  .stream()
-                                                 .map(ksm -> ksm.name)
                                                  .map(Keyspace::open)
                                                  .mapToInt(keyspace -> keyspace.getColumnFamilyStores().size())
                                                  .sum();

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -1294,7 +1294,7 @@ public Future<?> submitValidation(Callable<Object> validation)
     /* Used in tests. */
     public void disableAutoCompaction()
     {
-        for (String ksname : Schema.instance.getNonSystemKeyspaces().names())
+        for (String ksname : Schema.instance.distributedKeyspaces().names())
         {
             for (ColumnFamilyStore cfs : Keyspace.open(ksname).getColumnFamilyStores())
                 cfs.disableAutoCompaction();

File: src/java/org/apache/cassandra/dht/BootStrapper.java
Patch:
@@ -73,7 +73,7 @@ public Future<StreamState> bootstrap(StreamStateStore stateStore, boolean useStr
                                                    stateStore,
                                                    true,
                                                    DatabaseDescriptor.getStreamingConnectionsPerHost());
-        final Collection<String> nonLocalStrategyKeyspaces = Schema.instance.getNonLocalStrategyKeyspaces().names();
+        final Collection<String> nonLocalStrategyKeyspaces = Schema.instance.distributedKeyspaces().names();
         if (nonLocalStrategyKeyspaces.isEmpty())
             logger.debug("Schema does not contain any non-local keyspaces to stream on bootstrap");
         for (String keyspaceName : nonLocalStrategyKeyspaces)

File: src/java/org/apache/cassandra/metrics/TableMetrics.java
Patch:
@@ -283,7 +283,7 @@ private static Pair<Long, Long> totalNonSystemTablesSize(Predicate<SSTableReader
     {
         long total = 0;
         long filtered = 0;
-        for (String keyspace : Schema.instance.getNonSystemKeyspaces().names())
+        for (String keyspace : Schema.instance.distributedKeyspaces().names())
         {
 
             Keyspace k = Schema.instance.getKeyspaceInstance(keyspace);

File: src/java/org/apache/cassandra/repair/consistent/admin/SchemaArgsParser.java
Patch:
@@ -73,7 +73,7 @@ public Iterator<ColumnFamilyStore> iterator()
         if (schemaArgs.isEmpty())
         {
             // iterate over everything
-            Iterator<String> ksNames = Schema.instance.getNonLocalStrategyKeyspaces().names().iterator();
+            Iterator<String> ksNames = Schema.instance.distributedKeyspaces().names().iterator();
 
             return new AbstractIterator<ColumnFamilyStore>()
             {

File: src/java/org/apache/cassandra/schema/SchemaEvent.java
Patch:
@@ -101,9 +101,9 @@ public enum SchemaEventType
         this.viewsDiff = viewsDiff;
         this.indexesDiff = indexesDiff;
 
-        this.keyspaces = schema.distributedAndLocalKeyspaces().names();
+        this.keyspaces = schema.getKeyspaces().immutableCopy();
         this.nonSystemKeyspaces = schema.distributedKeyspaces().names();
-        this.userKeyspaces = schema.getUserKeyspaces().names();
+        this.userKeyspaces = schema.getUserKeyspaces().immutableCopy();
         this.numberOfTables = schema.getNumberOfTables();
         this.version = schema.getVersion();
 

File: src/java/org/apache/cassandra/service/PendingRangeCalculatorService.java
Patch:
@@ -53,7 +53,7 @@ public class PendingRangeCalculatorService
     private final AtLeastOnceTrigger update = executor.atLeastOnceTrigger(() -> {
         PendingRangeCalculatorServiceDiagnostics.taskStarted(1);
         long start = currentTimeMillis();
-        Collection<String> keyspaces = Schema.instance.getNonLocalStrategyKeyspaces().names();
+        Collection<String> keyspaces = Schema.instance.distributedKeyspaces().names();
         for (String keyspaceName : keyspaces)
             calculatePendingRanges(Keyspace.open(keyspaceName).getReplicationStrategy(), keyspaceName);
         if (logger.isTraceEnabled())

File: test/unit/org/apache/cassandra/dht/BootStrapperTest.java
Patch:
@@ -74,7 +74,7 @@ public static void tearDown()
     public void testSourceTargetComputation() throws UnknownHostException
     {
         final int[] clusterSizes = new int[] { 1, 3, 5, 10, 100};
-        for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())
+        for (String keyspaceName : Schema.instance.distributedKeyspaces().names())
         {
             int replicationFactor = Keyspace.open(keyspaceName).getReplicationStrategy().getReplicationFactor().allReplicas;
             for (int clusterSize : clusterSizes)

File: test/unit/org/apache/cassandra/locator/SimpleStrategyTest.java
Patch:
@@ -159,7 +159,7 @@ private void verifyGetNaturalEndpoints(Token[] endpointTokens, Token[] keyTokens
     {
         TokenMetadata tmd;
         AbstractReplicationStrategy strategy;
-        for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())
+        for (String keyspaceName : Schema.instance.distributedKeyspaces().names())
         {
             tmd = new TokenMetadata();
             strategy = getStrategy(keyspaceName, tmd, new SimpleSnitch());
@@ -214,7 +214,7 @@ public void testGetEndpointsDuringBootstrap() throws UnknownHostException
         tmd.addBootstrapToken(bsToken, bootstrapEndpoint);
 
         AbstractReplicationStrategy strategy = null;
-        for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())
+        for (String keyspaceName : Schema.instance.distributedKeyspaces().names())
         {
             strategy = getStrategy(keyspaceName, tmd, new SimpleSnitch());
 

File: test/unit/org/apache/cassandra/schema/SchemaKeyspaceTest.java
Patch:
@@ -141,7 +141,7 @@ private Collection<Mutation> getSchemaMutations()
     @Test
     public void testConversionsInverses() throws Exception
     {
-        for (String keyspaceName : Schema.instance.getNonSystemKeyspaces().names())
+        for (String keyspaceName : Schema.instance.distributedKeyspaces().names())
         {
             for (ColumnFamilyStore cfs : Keyspace.open(keyspaceName).getColumnFamilyStores())
             {

File: test/unit/org/apache/cassandra/schema/SchemaTest.java
Patch:
@@ -49,7 +49,7 @@ public static void setup()
     @Test
     public void testTransKsMigration() throws IOException
     {
-        assertEquals(0, Schema.instance.getNonSystemKeyspaces().size());
+        assertEquals(0, Schema.instance.distributedKeyspaces().size());
 
         Gossiper.instance.start((int) (System.currentTimeMillis() / 1000));
         try

File: test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest.java
Patch:
@@ -32,6 +32,7 @@
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.Util.PartitionerSwitcher;
+import org.apache.cassandra.config.CassandraRelevantProperties;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.locator.InetAddressAndPort;
 import org.apache.cassandra.schema.Schema;
@@ -62,6 +63,7 @@ public class LeaveAndBootstrapTest
     @BeforeClass
     public static void defineSchema() throws Exception
     {
+        CassandraRelevantProperties.GOSSIPER_QUARANTINE_DELAY.setLong(10000);
         DatabaseDescriptor.daemonInitialization();
         partitionerSwitcher = Util.switchPartitioner(partitioner);
         SchemaLoader.loadSchema();
@@ -123,7 +125,7 @@ public void newTestWriteEndpointsDuringLeave() throws Exception
         PendingRangeCalculatorService.instance.blockUntilFinished();
 
         AbstractReplicationStrategy strategy;
-        for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())
+        for (String keyspaceName : Schema.instance.distributedKeyspaces().names())
         {
             strategy = getStrategy(keyspaceName, tmd);
             for (Token token : keyTokens)

File: test/unit/org/apache/cassandra/service/MoveTest.java
Patch:
@@ -557,7 +557,7 @@ private Map<Range<Token>, EndpointsForRange> generatePendingRanges(Map.Entry<Ran
     private void assertPendingRanges(TokenMetadata tmd, Map<Range<Token>, EndpointsForRange> pendingRanges, String keyspaceName) throws ConfigurationException
     {
         boolean keyspaceFound = false;
-        for (String nonSystemKeyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())
+        for (String nonSystemKeyspaceName : Schema.instance.distributedKeyspaces().names())
         {
             if(!keyspaceName.equals(nonSystemKeyspaceName))
                 continue;
@@ -626,7 +626,7 @@ public void newTestWriteEndpointsDuringMove() throws Exception
         assertTrue(tmd.isMoving(hosts.get(MOVING_NODE)));
 
         AbstractReplicationStrategy strategy;
-        for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())
+        for (String keyspaceName : Schema.instance.distributedKeyspaces().names())
         {
             strategy = getStrategy(keyspaceName, tmd);
             if(strategy instanceof NetworkTopologyStrategy)

File: src/java/org/apache/cassandra/cql3/statements/DescribeStatement.java
Patch:
@@ -132,11 +132,12 @@ public final ResultMessage execute(QueryState state, QueryOptions options, long
     @Override
     public ResultMessage executeLocally(QueryState state, QueryOptions options)
     {
-        Keyspaces keyspaces = Schema.instance.distributedAndLocalKeyspaces();
+        Keyspaces keyspaces = Schema.instance.distributedKeyspaces();
         UUID schemaVersion = Schema.instance.getVersion();
 
         keyspaces = Keyspaces.builder()
                              .add(keyspaces)
+                             .add(Schema.instance.getLocalKeyspaces())
                              .add(VirtualKeyspaceRegistry.instance.virtualKeyspacesMetadata())
                              .build();
 

File: src/java/org/apache/cassandra/cql3/statements/schema/CreateTableStatement.java
Patch:
@@ -139,7 +139,6 @@ public void validate(ClientState state)
         {
             int totalUserTables = Schema.instance.getUserKeyspaces()
                                                  .stream()
-                                                 .map(ksm -> ksm.name)
                                                  .map(Keyspace::open)
                                                  .mapToInt(keyspace -> keyspace.getColumnFamilyStores().size())
                                                  .sum();

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -1294,7 +1294,7 @@ public Future<?> submitValidation(Callable<Object> validation)
     /* Used in tests. */
     public void disableAutoCompaction()
     {
-        for (String ksname : Schema.instance.getNonSystemKeyspaces().names())
+        for (String ksname : Schema.instance.distributedKeyspaces().names())
         {
             for (ColumnFamilyStore cfs : Keyspace.open(ksname).getColumnFamilyStores())
                 cfs.disableAutoCompaction();

File: src/java/org/apache/cassandra/dht/BootStrapper.java
Patch:
@@ -73,7 +73,7 @@ public Future<StreamState> bootstrap(StreamStateStore stateStore, boolean useStr
                                                    stateStore,
                                                    true,
                                                    DatabaseDescriptor.getStreamingConnectionsPerHost());
-        final Collection<String> nonLocalStrategyKeyspaces = Schema.instance.getNonLocalStrategyKeyspaces().names();
+        final Collection<String> nonLocalStrategyKeyspaces = Schema.instance.distributedKeyspaces().names();
         if (nonLocalStrategyKeyspaces.isEmpty())
             logger.debug("Schema does not contain any non-local keyspaces to stream on bootstrap");
         for (String keyspaceName : nonLocalStrategyKeyspaces)

File: src/java/org/apache/cassandra/metrics/TableMetrics.java
Patch:
@@ -283,7 +283,7 @@ private static Pair<Long, Long> totalNonSystemTablesSize(Predicate<SSTableReader
     {
         long total = 0;
         long filtered = 0;
-        for (String keyspace : Schema.instance.getNonSystemKeyspaces().names())
+        for (String keyspace : Schema.instance.distributedKeyspaces().names())
         {
 
             Keyspace k = Schema.instance.getKeyspaceInstance(keyspace);

File: src/java/org/apache/cassandra/repair/consistent/admin/SchemaArgsParser.java
Patch:
@@ -73,7 +73,7 @@ public Iterator<ColumnFamilyStore> iterator()
         if (schemaArgs.isEmpty())
         {
             // iterate over everything
-            Iterator<String> ksNames = Schema.instance.getNonLocalStrategyKeyspaces().names().iterator();
+            Iterator<String> ksNames = Schema.instance.distributedKeyspaces().names().iterator();
 
             return new AbstractIterator<ColumnFamilyStore>()
             {

File: src/java/org/apache/cassandra/schema/SchemaEvent.java
Patch:
@@ -101,9 +101,9 @@ public enum SchemaEventType
         this.viewsDiff = viewsDiff;
         this.indexesDiff = indexesDiff;
 
-        this.keyspaces = schema.distributedAndLocalKeyspaces().names();
+        this.keyspaces = schema.getKeyspaces().immutableCopy();
         this.nonSystemKeyspaces = schema.distributedKeyspaces().names();
-        this.userKeyspaces = schema.getUserKeyspaces().names();
+        this.userKeyspaces = schema.getUserKeyspaces().immutableCopy();
         this.numberOfTables = schema.getNumberOfTables();
         this.version = schema.getVersion();
 

File: src/java/org/apache/cassandra/service/PendingRangeCalculatorService.java
Patch:
@@ -53,7 +53,7 @@ public class PendingRangeCalculatorService
     private final AtLeastOnceTrigger update = executor.atLeastOnceTrigger(() -> {
         PendingRangeCalculatorServiceDiagnostics.taskStarted(1);
         long start = currentTimeMillis();
-        Collection<String> keyspaces = Schema.instance.getNonLocalStrategyKeyspaces().names();
+        Collection<String> keyspaces = Schema.instance.distributedKeyspaces().names();
         for (String keyspaceName : keyspaces)
             calculatePendingRanges(Keyspace.open(keyspaceName).getReplicationStrategy(), keyspaceName);
         if (logger.isTraceEnabled())

File: test/unit/org/apache/cassandra/dht/BootStrapperTest.java
Patch:
@@ -74,7 +74,7 @@ public static void tearDown()
     public void testSourceTargetComputation() throws UnknownHostException
     {
         final int[] clusterSizes = new int[] { 1, 3, 5, 10, 100};
-        for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())
+        for (String keyspaceName : Schema.instance.distributedKeyspaces().names())
         {
             int replicationFactor = Keyspace.open(keyspaceName).getReplicationStrategy().getReplicationFactor().allReplicas;
             for (int clusterSize : clusterSizes)

File: test/unit/org/apache/cassandra/locator/SimpleStrategyTest.java
Patch:
@@ -159,7 +159,7 @@ private void verifyGetNaturalEndpoints(Token[] endpointTokens, Token[] keyTokens
     {
         TokenMetadata tmd;
         AbstractReplicationStrategy strategy;
-        for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())
+        for (String keyspaceName : Schema.instance.distributedKeyspaces().names())
         {
             tmd = new TokenMetadata();
             strategy = getStrategy(keyspaceName, tmd, new SimpleSnitch());
@@ -214,7 +214,7 @@ public void testGetEndpointsDuringBootstrap() throws UnknownHostException
         tmd.addBootstrapToken(bsToken, bootstrapEndpoint);
 
         AbstractReplicationStrategy strategy = null;
-        for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())
+        for (String keyspaceName : Schema.instance.distributedKeyspaces().names())
         {
             strategy = getStrategy(keyspaceName, tmd, new SimpleSnitch());
 

File: test/unit/org/apache/cassandra/schema/SchemaKeyspaceTest.java
Patch:
@@ -141,7 +141,7 @@ private Collection<Mutation> getSchemaMutations()
     @Test
     public void testConversionsInverses() throws Exception
     {
-        for (String keyspaceName : Schema.instance.getNonSystemKeyspaces().names())
+        for (String keyspaceName : Schema.instance.distributedKeyspaces().names())
         {
             for (ColumnFamilyStore cfs : Keyspace.open(keyspaceName).getColumnFamilyStores())
             {

File: test/unit/org/apache/cassandra/schema/SchemaTest.java
Patch:
@@ -49,7 +49,7 @@ public static void setup()
     @Test
     public void testTransKsMigration() throws IOException
     {
-        assertEquals(0, Schema.instance.getNonSystemKeyspaces().size());
+        assertEquals(0, Schema.instance.distributedKeyspaces().size());
 
         Gossiper.instance.start((int) (System.currentTimeMillis() / 1000));
         try

File: test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest.java
Patch:
@@ -32,6 +32,7 @@
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.Util.PartitionerSwitcher;
+import org.apache.cassandra.config.CassandraRelevantProperties;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.locator.InetAddressAndPort;
 import org.apache.cassandra.schema.Schema;
@@ -62,6 +63,7 @@ public class LeaveAndBootstrapTest
     @BeforeClass
     public static void defineSchema() throws Exception
     {
+        CassandraRelevantProperties.GOSSIPER_QUARANTINE_DELAY.setLong(10000);
         DatabaseDescriptor.daemonInitialization();
         partitionerSwitcher = Util.switchPartitioner(partitioner);
         SchemaLoader.loadSchema();
@@ -123,7 +125,7 @@ public void newTestWriteEndpointsDuringLeave() throws Exception
         PendingRangeCalculatorService.instance.blockUntilFinished();
 
         AbstractReplicationStrategy strategy;
-        for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())
+        for (String keyspaceName : Schema.instance.distributedKeyspaces().names())
         {
             strategy = getStrategy(keyspaceName, tmd);
             for (Token token : keyTokens)

File: test/unit/org/apache/cassandra/service/MoveTest.java
Patch:
@@ -557,7 +557,7 @@ private Map<Range<Token>, EndpointsForRange> generatePendingRanges(Map.Entry<Ran
     private void assertPendingRanges(TokenMetadata tmd, Map<Range<Token>, EndpointsForRange> pendingRanges, String keyspaceName) throws ConfigurationException
     {
         boolean keyspaceFound = false;
-        for (String nonSystemKeyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())
+        for (String nonSystemKeyspaceName : Schema.instance.distributedKeyspaces().names())
         {
             if(!keyspaceName.equals(nonSystemKeyspaceName))
                 continue;
@@ -626,7 +626,7 @@ public void newTestWriteEndpointsDuringMove() throws Exception
         assertTrue(tmd.isMoving(hosts.get(MOVING_NODE)));
 
         AbstractReplicationStrategy strategy;
-        for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())
+        for (String keyspaceName : Schema.instance.distributedKeyspaces().names())
         {
             strategy = getStrategy(keyspaceName, tmd);
             if(strategy instanceof NetworkTopologyStrategy)

File: src/java/org/apache/cassandra/cql3/statements/DescribeStatement.java
Patch:
@@ -132,11 +132,12 @@ public final ResultMessage execute(QueryState state, QueryOptions options, long
     @Override
     public ResultMessage executeLocally(QueryState state, QueryOptions options)
     {
-        Keyspaces keyspaces = Schema.instance.distributedAndLocalKeyspaces();
+        Keyspaces keyspaces = Schema.instance.distributedKeyspaces();
         UUID schemaVersion = Schema.instance.getVersion();
 
         keyspaces = Keyspaces.builder()
                              .add(keyspaces)
+                             .add(Schema.instance.getLocalKeyspaces())
                              .add(VirtualKeyspaceRegistry.instance.virtualKeyspacesMetadata())
                              .build();
 

File: src/java/org/apache/cassandra/cql3/statements/schema/CreateTableStatement.java
Patch:
@@ -140,7 +140,6 @@ public void validate(ClientState state)
         {
             int totalUserTables = Schema.instance.getUserKeyspaces()
                                                  .stream()
-                                                 .map(ksm -> ksm.name)
                                                  .map(Keyspace::open)
                                                  .mapToInt(keyspace -> keyspace.getColumnFamilyStores().size())
                                                  .sum();

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -1257,7 +1257,7 @@ public Future<?> submitValidation(Callable<Object> validation)
     /* Used in tests. */
     public void disableAutoCompaction()
     {
-        for (String ksname : Schema.instance.getNonSystemKeyspaces().names())
+        for (String ksname : Schema.instance.distributedKeyspaces().names())
         {
             for (ColumnFamilyStore cfs : Keyspace.open(ksname).getColumnFamilyStores())
                 cfs.disableAutoCompaction();

File: src/java/org/apache/cassandra/dht/BootStrapper.java
Patch:
@@ -73,7 +73,7 @@ public Future<StreamState> bootstrap(StreamStateStore stateStore, boolean useStr
                                                    stateStore,
                                                    true,
                                                    DatabaseDescriptor.getStreamingConnectionsPerHost());
-        final Collection<String> nonLocalStrategyKeyspaces = Schema.instance.getNonLocalStrategyKeyspaces().names();
+        final Collection<String> nonLocalStrategyKeyspaces = Schema.instance.distributedKeyspaces().names();
         if (nonLocalStrategyKeyspaces.isEmpty())
             logger.debug("Schema does not contain any non-local keyspaces to stream on bootstrap");
         for (String keyspaceName : nonLocalStrategyKeyspaces)

File: src/java/org/apache/cassandra/metrics/TableMetrics.java
Patch:
@@ -280,7 +280,7 @@ private static Pair<Long, Long> totalNonSystemTablesSize(Predicate<SSTableReader
     {
         long total = 0;
         long filtered = 0;
-        for (String keyspace : Schema.instance.getNonSystemKeyspaces().names())
+        for (String keyspace : Schema.instance.distributedKeyspaces().names())
         {
 
             Keyspace k = Schema.instance.getKeyspaceInstance(keyspace);

File: src/java/org/apache/cassandra/repair/consistent/admin/SchemaArgsParser.java
Patch:
@@ -73,7 +73,7 @@ public Iterator<ColumnFamilyStore> iterator()
         if (schemaArgs.isEmpty())
         {
             // iterate over everything
-            Iterator<String> ksNames = Schema.instance.getNonLocalStrategyKeyspaces().names().iterator();
+            Iterator<String> ksNames = Schema.instance.distributedKeyspaces().names().iterator();
 
             return new AbstractIterator<ColumnFamilyStore>()
             {

File: src/java/org/apache/cassandra/schema/SchemaEvent.java
Patch:
@@ -101,9 +101,9 @@ public enum SchemaEventType
         this.viewsDiff = viewsDiff;
         this.indexesDiff = indexesDiff;
 
-        this.keyspaces = schema.distributedAndLocalKeyspaces().names();
+        this.keyspaces = schema.getKeyspaces().immutableCopy();
         this.nonSystemKeyspaces = schema.distributedKeyspaces().names();
-        this.userKeyspaces = schema.getUserKeyspaces().names();
+        this.userKeyspaces = schema.getUserKeyspaces().immutableCopy();
         this.numberOfTables = schema.getNumberOfTables();
         this.version = schema.getVersion();
 

File: src/java/org/apache/cassandra/service/PendingRangeCalculatorService.java
Patch:
@@ -53,7 +53,7 @@ public class PendingRangeCalculatorService
     private final AtLeastOnceTrigger update = executor.atLeastOnceTrigger(() -> {
         PendingRangeCalculatorServiceDiagnostics.taskStarted(1);
         long start = currentTimeMillis();
-        Collection<String> keyspaces = Schema.instance.getNonLocalStrategyKeyspaces().names();
+        Collection<String> keyspaces = Schema.instance.distributedKeyspaces().names();
         for (String keyspaceName : keyspaces)
             calculatePendingRanges(Keyspace.open(keyspaceName).getReplicationStrategy(), keyspaceName);
         if (logger.isTraceEnabled())

File: test/unit/org/apache/cassandra/dht/BootStrapperTest.java
Patch:
@@ -74,7 +74,7 @@ public static void tearDown()
     public void testSourceTargetComputation() throws UnknownHostException
     {
         final int[] clusterSizes = new int[] { 1, 3, 5, 10, 100};
-        for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())
+        for (String keyspaceName : Schema.instance.distributedKeyspaces().names())
         {
             int replicationFactor = Keyspace.open(keyspaceName).getReplicationStrategy().getReplicationFactor().allReplicas;
             for (int clusterSize : clusterSizes)

File: test/unit/org/apache/cassandra/locator/SimpleStrategyTest.java
Patch:
@@ -159,7 +159,7 @@ private void verifyGetNaturalEndpoints(Token[] endpointTokens, Token[] keyTokens
     {
         TokenMetadata tmd;
         AbstractReplicationStrategy strategy;
-        for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())
+        for (String keyspaceName : Schema.instance.distributedKeyspaces().names())
         {
             tmd = new TokenMetadata();
             strategy = getStrategy(keyspaceName, tmd, new SimpleSnitch());
@@ -214,7 +214,7 @@ public void testGetEndpointsDuringBootstrap() throws UnknownHostException
         tmd.addBootstrapToken(bsToken, bootstrapEndpoint);
 
         AbstractReplicationStrategy strategy = null;
-        for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())
+        for (String keyspaceName : Schema.instance.distributedKeyspaces().names())
         {
             strategy = getStrategy(keyspaceName, tmd, new SimpleSnitch());
 

File: test/unit/org/apache/cassandra/schema/SchemaKeyspaceTest.java
Patch:
@@ -138,7 +138,7 @@ private Collection<Mutation> getSchemaMutations()
     @Test
     public void testConversionsInverses() throws Exception
     {
-        for (String keyspaceName : Schema.instance.getNonSystemKeyspaces().names())
+        for (String keyspaceName : Schema.instance.distributedKeyspaces().names())
         {
             for (ColumnFamilyStore cfs : Keyspace.open(keyspaceName).getColumnFamilyStores())
             {

File: test/unit/org/apache/cassandra/schema/SchemaTest.java
Patch:
@@ -49,7 +49,7 @@ public static void setup()
     @Test
     public void testTransKsMigration() throws IOException
     {
-        assertEquals(0, Schema.instance.getNonSystemKeyspaces().size());
+        assertEquals(0, Schema.instance.distributedKeyspaces().size());
 
         Gossiper.instance.start((int) (System.currentTimeMillis() / 1000));
         try

File: test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest.java
Patch:
@@ -32,6 +32,7 @@
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.Util.PartitionerSwitcher;
+import org.apache.cassandra.config.CassandraRelevantProperties;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.locator.InetAddressAndPort;
 import org.apache.cassandra.schema.Schema;
@@ -62,6 +63,7 @@ public class LeaveAndBootstrapTest
     @BeforeClass
     public static void defineSchema() throws Exception
     {
+        CassandraRelevantProperties.GOSSIPER_QUARANTINE_DELAY.setLong(10000);
         DatabaseDescriptor.daemonInitialization();
         partitionerSwitcher = Util.switchPartitioner(partitioner);
         SchemaLoader.loadSchema();
@@ -123,7 +125,7 @@ public void newTestWriteEndpointsDuringLeave() throws Exception
         PendingRangeCalculatorService.instance.blockUntilFinished();
 
         AbstractReplicationStrategy strategy;
-        for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())
+        for (String keyspaceName : Schema.instance.distributedKeyspaces().names())
         {
             strategy = getStrategy(keyspaceName, tmd);
             for (Token token : keyTokens)

File: test/unit/org/apache/cassandra/service/MoveTest.java
Patch:
@@ -557,7 +557,7 @@ private Map<Range<Token>, EndpointsForRange> generatePendingRanges(Map.Entry<Ran
     private void assertPendingRanges(TokenMetadata tmd, Map<Range<Token>, EndpointsForRange> pendingRanges, String keyspaceName) throws ConfigurationException
     {
         boolean keyspaceFound = false;
-        for (String nonSystemKeyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())
+        for (String nonSystemKeyspaceName : Schema.instance.distributedKeyspaces().names())
         {
             if(!keyspaceName.equals(nonSystemKeyspaceName))
                 continue;
@@ -626,7 +626,7 @@ public void newTestWriteEndpointsDuringMove() throws Exception
         assertTrue(tmd.isMoving(hosts.get(MOVING_NODE)));
 
         AbstractReplicationStrategy strategy;
-        for (String keyspaceName : Schema.instance.getNonLocalStrategyKeyspaces().names())
+        for (String keyspaceName : Schema.instance.distributedKeyspaces().names())
         {
             strategy = getStrategy(keyspaceName, tmd);
             if(strategy instanceof NetworkTopologyStrategy)

File: src/java/org/apache/cassandra/index/sasi/SASIIndex.java
Patch:
@@ -186,7 +186,7 @@ public static Map<String, String> validateOptions(Map<String, String> options, T
     @Override
     public void register(IndexRegistry registry)
     {
-        registry.registerIndex(this, this, () -> new SASIIndexGroup(this));
+        registry.registerIndex(this, new Group.Key(this), () -> new SASIIndexGroup(this));
     }
 
     public IndexMetadata getIndexMetadata()

File: test/unit/org/apache/cassandra/index/sai/cql/StorageAttachedIndexDDLTest.java
Patch:
@@ -84,6 +84,7 @@
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.Mockito.when;
@@ -667,8 +668,7 @@ public void shouldReleaseIndexFilesAfterDroppingLastIndex() throws Throwable
 
         dropIndex("DROP INDEX %s." + literalIndexName);
         verifyIndexFiles(numericIndexContext, literalIndexContext, 0, 0);
-        verifySSTableIndexes(numericIndexName, 0);
-        verifySSTableIndexes(literalIndexName, 0);
+        assertNull(getCurrentIndexGroup());
 
         assertEquals("Segment memory limiter should revert to zero on drop.", 0L, getSegmentBufferUsedBytes());
         assertEquals("There should be no segment builders in progress.", 0L, getColumnIndexBuildsInProgress());
@@ -1182,7 +1182,7 @@ public void droppingIndexStopInitialIndexBuild() throws Throwable
 
         delayIndexBuilderCompletion.disable();
 
-        verifySSTableIndexes(indexName, 0);
+        assertNull(getCurrentIndexGroup());
         assertFalse("Expect index not built", SystemKeyspace.isIndexBuilt(KEYSPACE, indexName));
 
         // create index again, it should succeed

File: test/unit/org/apache/cassandra/index/sai/functional/CompactionTest.java
Patch:
@@ -61,8 +61,8 @@
 import org.apache.cassandra.utils.concurrent.Refs;
 
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
-import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -339,8 +339,7 @@ public void testConcurrentIndexDropWithCompaction() throws Throwable
         }
 
         // verify index group metrics are cleared.
-        assertEquals(0, getOpenIndexFiles());
-        assertEquals(0, getDiskUsage());
+        assertNull(getCurrentIndexGroup());
 
         // verify indexes are dropped
         // verify indexes are dropped

File: test/unit/org/apache/cassandra/index/sai/metrics/IndexGroupMetricsTest.java
Patch:
@@ -26,6 +26,7 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNull;
 
 public class IndexGroupMetricsTest extends AbstractMetricsTest
 {
@@ -76,8 +77,7 @@ public void verifyIndexGroupMetrics() throws Throwable
 
         // drop last index, no open index files
         dropIndex("DROP INDEX %s." + v1IndexName);
-        assertEquals(0, getOpenIndexFiles());
-        assertEquals(0, getDiskUsage());
+        assertNull(getCurrentIndexGroup());
     }
 
     protected int getOpenIndexFiles()

File: test/unit/org/apache/cassandra/db/ImportTest.java
Patch:
@@ -43,6 +43,7 @@
 import org.apache.cassandra.io.sstable.format.SSTableFormat.Components;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.io.util.File;
+import org.apache.cassandra.io.util.PathUtils;
 import org.apache.cassandra.locator.InetAddressAndPort;
 import org.apache.cassandra.locator.TokenMetadata;
 import org.apache.cassandra.service.CacheService;
@@ -245,6 +246,7 @@ private File moveToBackupDir(Set<SSTableReader> sstables) throws IOException
                 }
             }
         }
+        PathUtils.deleteRecursiveOnExit(temp);
         return new File(backupdir);
     }
 

File: test/unit/org/apache/cassandra/db/ImportTest.java
Patch:
@@ -43,6 +43,7 @@
 import org.apache.cassandra.io.sstable.format.SSTableFormat.Components;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.io.util.File;
+import org.apache.cassandra.io.util.PathUtils;
 import org.apache.cassandra.locator.InetAddressAndPort;
 import org.apache.cassandra.locator.TokenMetadata;
 import org.apache.cassandra.service.CacheService;
@@ -245,6 +246,7 @@ private File moveToBackupDir(Set<SSTableReader> sstables) throws IOException
                 }
             }
         }
+        PathUtils.deleteRecursiveOnExit(temp);
         return new File(backupdir);
     }
 

File: test/unit/org/apache/cassandra/cql3/functions/masking/ReplaceMaskingFunctionTest.java
Patch:
@@ -19,6 +19,7 @@
 package org.apache.cassandra.cql3.functions.masking;
 
 import java.math.BigInteger;
+import java.nio.ByteBuffer;
 
 import org.junit.Test;
 
@@ -34,15 +35,15 @@
 public class ReplaceMaskingFunctionTest extends MaskingFunctionTester
 {
     @Override
-    protected void testMaskingOnColumn(String name, CQL3Type type, Object value) throws Throwable
+    protected void testMaskingOnColumn(String name, CQL3Type type, Object value)
     {
         // null replacement argument
         assertRows(execute(format("SELECT mask_replace(%s, ?) FROM %%s", name), (Object) null),
                    row((Object) null));
 
         // not-null replacement argument
         AbstractType<?> t = type.getType();
-        Object replacementValue = t.compose(t.getMaskedValue());
+        ByteBuffer replacementValue = t.getMaskedValue();
         String query = format("SELECT mask_replace(%s, ?) FROM %%s", name);
         assertRows(execute(query, replacementValue), row(replacementValue));
     }

File: src/java/org/apache/cassandra/cql3/Constants.java
Patch:
@@ -292,7 +292,7 @@ private ByteBuffer parsedValue(AbstractType<?> validator) throws InvalidRequestE
         public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpecification receiver)
         {
             CQL3Type receiverType = receiver.type.asCQL3Type();
-            if (receiverType.isCollection() || receiverType.isUDT())
+            if (receiverType.isCollection() || receiverType.isUDT() || receiverType.isVector())
                 return AssignmentTestable.TestResult.NOT_ASSIGNABLE;
 
             if (!(receiverType instanceof CQL3Type.Native))

File: src/java/org/apache/cassandra/db/marshal/AbstractType.java
Patch:
@@ -512,7 +512,7 @@ public final boolean isValueLengthFixed()
      */
     public boolean allowsEmpty()
     {
-        return true;
+        return false;
     }
 
     public boolean isNull(ByteBuffer bb)

File: src/java/org/apache/cassandra/auth/AuthCache.java
Patch:
@@ -352,7 +352,7 @@ protected LoadingCache<K, V> initCache(LoadingCache<K, V> existing)
             updatedCache = cache;
             // Always set as mandatory
             cache.policy().refreshAfterWrite().ifPresent(policy ->
-                policy.setExpiresAfter(activeUpdate ? getValidity() : getUpdateInterval(), TimeUnit.MILLISECONDS));
+                policy.setRefreshesAfter(activeUpdate ? getValidity() : getUpdateInterval(), TimeUnit.MILLISECONDS));
             cache.policy().expireAfterWrite().ifPresent(policy -> policy.setExpiresAfter(getValidity(), TimeUnit.MILLISECONDS));
             cache.policy().eviction().ifPresent(policy -> policy.setMaximum(getMaxEntries()));
         }

File: src/java/org/apache/cassandra/auth/CIDRPermissionsCache.java
Patch:
@@ -54,10 +54,11 @@ public CIDRPermissionsCache(Function<RoleResource, CIDRPermissions> loadFunction
      */
     public boolean invalidateCidrPermissions(String roleName)
     {
-        if (cache.getIfPresent(roleName) == null)
+        RoleResource role = RoleResource.role(roleName);
+        if (cache.getIfPresent(role) == null)
             return false;
 
-        invalidate(RoleResource.role(roleName));
+        invalidate(role);
         return true;
     }
 

File: src/java/org/apache/cassandra/metrics/ChunkCacheMetrics.java
Patch:
@@ -21,6 +21,7 @@
 import javax.annotation.Nonnull;
 
 import com.codahale.metrics.Timer;
+import com.github.benmanes.caffeine.cache.RemovalCause;
 import com.github.benmanes.caffeine.cache.stats.CacheStats;
 import com.github.benmanes.caffeine.cache.stats.StatsCounter;
 import org.apache.cassandra.cache.ChunkCache;
@@ -72,14 +73,14 @@ public void recordLoadFailure(long loadTime)
     }
 
     @Override
-    public void recordEviction()
+    public void recordEviction(int weight, RemovalCause cause)
     {
     }
 
     @Nonnull
     @Override
     public CacheStats snapshot()
     {
-        return new CacheStats(hits.getCount(), misses.getCount(), missLatency.getCount(), 0L, missLatency.getCount(), 0L, 0L);
+        return CacheStats.of(hits.getCount(), misses.getCount(), missLatency.getCount(), 0L, missLatency.getCount(), 0L, 0L);
     }
 }

File: test/unit/org/apache/cassandra/tools/nodetool/InvalidateCIDRPermissionsCacheTest.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.cassandra.auth.AuthTestUtils;
 import org.apache.cassandra.auth.AuthenticatedUser;
 import org.apache.cassandra.auth.IRoleManager;
+
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.cql3.CQLTester;
 import org.apache.cassandra.tools.ToolRunner;
@@ -43,6 +44,7 @@ public class InvalidateCIDRPermissionsCacheTest extends CQLTester
     @BeforeClass
     public static void setup() throws Exception
     {
+        DatabaseDescriptor.setRolesValidity(Integer.MAX_VALUE-1);
         CQLTester.setUpClass();
         CQLTester.requireAuthentication();
 
@@ -122,6 +124,7 @@ public void testInvalidateSingleCidrPermission()
         // invalidate cidr permission
         ToolRunner.ToolResult tool = ToolRunner.invokeNodetool("invalidatecidrpermissionscache", ROLE_A.getRoleName());
         tool.assertOnCleanExit();
+        assertThat(tool.getStdout()).contains("Invalidated the role role_a from CIDR permissions cache");
 
         // ensure cidr permission is reloaded
         assertThat(role.hasAccessFromIp(new InetSocketAddress("127.0.0.0", 0))).isTrue();

File: src/java/org/apache/cassandra/cache/AutoSavingCache.java
Patch:
@@ -269,12 +269,12 @@ public int loadSaved()
             catch (CorruptFileException e)
             {
                 JVMStabilityInspector.inspectThrowable(e);
-                logger.warn(String.format("Non-fatal checksum error reading saved cache %s", dataPath.absolutePath()), e);
+                logger.warn("Non-fatal checksum error reading saved cache {}: {}", dataPath.absolutePath(), e.getMessage());
             }
             catch (Throwable t)
             {
                 JVMStabilityInspector.inspectThrowable(t);
-                logger.info(String.format("Harmless error reading saved cache %s", dataPath.absolutePath()), t);
+                logger.info("Harmless error reading saved cache {}: {}", dataPath.absolutePath(), t.getMessage());
             }
             finally
             {

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -65,7 +65,6 @@
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.SystemKeyspace;
 import org.apache.cassandra.dht.Token;
-import org.apache.cassandra.exceptions.RequestFailureReason;
 import org.apache.cassandra.locator.InetAddressAndPort;
 import org.apache.cassandra.net.Message;
 import org.apache.cassandra.net.MessagingService;

File: test/distributed/org/apache/cassandra/distributed/test/guardrails/GuardrailDiskUsageTest.java
Patch:
@@ -39,6 +39,7 @@
 import org.apache.cassandra.distributed.Cluster;
 import org.apache.cassandra.distributed.api.Feature;
 import org.apache.cassandra.distributed.api.IInvokableInstance;
+import org.apache.cassandra.distributed.util.Auth;
 import org.apache.cassandra.locator.InetAddressAndPort;
 import org.apache.cassandra.service.disk.usage.DiskUsageBroadcaster;
 import org.apache.cassandra.service.disk.usage.DiskUsageMonitor;
@@ -76,6 +77,8 @@ public static void setupCluster() throws IOException
                                                 .set("authenticator", "PasswordAuthenticator"))
                               .start(), 1);
 
+        Auth.waitForExistingRoles(cluster.get(1));
+
         // create a regular user, since the default superuser is excluded from guardrails
         com.datastax.driver.core.Cluster.Builder builder = com.datastax.driver.core.Cluster.builder().addContactPoint("127.0.0.1");
         try (com.datastax.driver.core.Cluster c = builder.withCredentials("cassandra", "cassandra").build();

File: test/unit/org/apache/cassandra/cql3/CQLTester.java
Patch:
@@ -385,6 +385,7 @@ public static JMXServiceURL getJMXServiceURL() throws MalformedURLException
     @BeforeClass
     public static void setUpClass()
     {
+        CassandraRelevantProperties.SUPERUSER_SETUP_DELAY_MS.setLong(0);
         ServerTestUtils.daemonInitialization();
 
         if (ROW_CACHE_SIZE_IN_MIB > 0)

File: test/distributed/org/apache/cassandra/distributed/test/guardrails/GuardrailDiskUsageTest.java
Patch:
@@ -39,6 +39,7 @@
 import org.apache.cassandra.distributed.Cluster;
 import org.apache.cassandra.distributed.api.Feature;
 import org.apache.cassandra.distributed.api.IInvokableInstance;
+import org.apache.cassandra.distributed.util.Auth;
 import org.apache.cassandra.locator.InetAddressAndPort;
 import org.apache.cassandra.service.disk.usage.DiskUsageBroadcaster;
 import org.apache.cassandra.service.disk.usage.DiskUsageMonitor;
@@ -76,6 +77,8 @@ public static void setupCluster() throws IOException
                                                 .set("authenticator", "PasswordAuthenticator"))
                               .start(), 1);
 
+        Auth.waitForExistingRoles(cluster.get(1));
+
         // create a regular user, since the default superuser is excluded from guardrails
         com.datastax.driver.core.Cluster.Builder builder = com.datastax.driver.core.Cluster.builder().addContactPoint("127.0.0.1");
         try (com.datastax.driver.core.Cluster c = builder.withCredentials("cassandra", "cassandra").build();

File: test/unit/org/apache/cassandra/cql3/CQLTester.java
Patch:
@@ -385,6 +385,7 @@ public static JMXServiceURL getJMXServiceURL() throws MalformedURLException
     @BeforeClass
     public static void setUpClass()
     {
+        CassandraRelevantProperties.SUPERUSER_SETUP_DELAY_MS.setLong(0);
         ServerTestUtils.daemonInitialization();
 
         if (ROW_CACHE_SIZE_IN_MIB > 0)

File: test/distributed/org/apache/cassandra/distributed/test/guardrails/GuardrailDiskUsageTest.java
Patch:
@@ -39,6 +39,7 @@
 import org.apache.cassandra.distributed.Cluster;
 import org.apache.cassandra.distributed.api.Feature;
 import org.apache.cassandra.distributed.api.IInvokableInstance;
+import org.apache.cassandra.distributed.util.Auth;
 import org.apache.cassandra.locator.InetAddressAndPort;
 import org.apache.cassandra.service.disk.usage.DiskUsageBroadcaster;
 import org.apache.cassandra.service.disk.usage.DiskUsageMonitor;
@@ -76,6 +77,8 @@ public static void setupCluster() throws IOException
                                                 .set("authenticator", "PasswordAuthenticator"))
                               .start(), 1);
 
+        Auth.waitForExistingRoles(cluster.get(1));
+
         // create a regular user, since the default superuser is excluded from guardrails
         com.datastax.driver.core.Cluster.Builder builder = com.datastax.driver.core.Cluster.builder().addContactPoint("127.0.0.1");
         try (com.datastax.driver.core.Cluster c = builder.withCredentials("cassandra", "cassandra").build();

File: test/unit/org/apache/cassandra/cql3/CQLTester.java
Patch:
@@ -318,6 +318,8 @@ public static JMXServiceURL getJMXServiceURL() throws MalformedURLException
     @BeforeClass
     public static void setUpClass()
     {
+        System.setProperty("cassandra.superuser_setup_delay_ms", "0");
+
         if (ROW_CACHE_SIZE_IN_MIB > 0)
             DatabaseDescriptor.setRowCacheSizeInMiB(ROW_CACHE_SIZE_IN_MIB);
         StorageService.instance.setPartitionerUnsafe(Murmur3Partitioner.instance);

File: src/java/org/apache/cassandra/index/sai/StorageAttachedIndex.java
Patch:
@@ -178,6 +178,7 @@ public StorageAttachedIndex(ColumnFamilyStore baseCfs, IndexMetadata config)
         this.indexContext = new IndexContext(tableMetadata.keyspace,
                                              tableMetadata.name,
                                              tableMetadata.partitionKeyType,
+                                             tableMetadata.partitioner,
                                              tableMetadata.comparator,
                                              target.left,
                                              target.right,

File: src/java/org/apache/cassandra/index/sai/StorageAttachedIndexGroup.java
Patch:
@@ -191,7 +191,7 @@ public StorageAttachedIndexQueryPlan queryPlanFor(RowFilter rowFilter)
     @Override
     public SSTableFlushObserver getFlushObserver(Descriptor descriptor, LifecycleNewTracker tracker, TableMetadata tableMetadata)
     {
-        IndexDescriptor indexDescriptor = IndexDescriptor.create(descriptor, tableMetadata.comparator);
+        IndexDescriptor indexDescriptor = IndexDescriptor.create(descriptor, tableMetadata.partitioner, tableMetadata.comparator);
         try
         {
             return StorageAttachedIndexWriter.createFlushObserverWriter(indexDescriptor, indexes, tracker);

File: src/java/org/apache/cassandra/index/sai/disk/PrimaryKeyMap.java
Patch:
@@ -22,6 +22,7 @@
 import java.io.IOException;
 
 import javax.annotation.concurrent.NotThreadSafe;
+import javax.annotation.concurrent.ThreadSafe;
 
 import org.apache.cassandra.index.sai.utils.PrimaryKey;
 
@@ -36,7 +37,7 @@ public interface PrimaryKeyMap extends Closeable
      * A factory for creating {@link PrimaryKeyMap} instances. Implementations of this
      * interface are expected to be threadsafe.
      */
-    @NotThreadSafe
+    @ThreadSafe
     interface Factory extends Closeable
     {
         /**

File: src/java/org/apache/cassandra/index/sai/disk/StorageAttachedIndexWriter.java
Patch:
@@ -247,7 +247,8 @@ public void abort(Throwable accumulator, boolean fromIndex)
 
     private void addRow(Row row) throws IOException, InMemoryTrie.SpaceExhaustedException
     {
-        PrimaryKey primaryKey = indexDescriptor.primaryKeyFactory.create(currentKey, row.clustering());
+        PrimaryKey primaryKey = indexDescriptor.hasClustering() ? indexDescriptor.primaryKeyFactory.create(currentKey, row.clustering())
+                                                                : indexDescriptor.primaryKeyFactory.create(currentKey);
         perSSTableWriter.nextRow(primaryKey);
         rowMapping.add(primaryKey, sstableRowId);
 

File: src/java/org/apache/cassandra/index/sai/disk/v1/keystore/KeyLookup.java
Patch:
@@ -143,10 +143,10 @@ public class Cursor implements AutoCloseable
          * in these cases the internal buffer is cleared.
          *
          * @param pointId point id to lookup
-         * @return The {@link ByteComparable} containing the key
+         * @return The {@link ByteSource} containing the key
          * @throws IndexOutOfBoundsException if the target point id is less than -1 or greater than the number of keys
          */
-        public @Nonnull ByteComparable seekToPointId(long pointId)
+        public @Nonnull ByteSource seekToPointId(long pointId)
         {
             if (pointId < 0 || pointId >= keyLookupMeta.keyCount)
                 throw new IndexOutOfBoundsException(String.format(INDEX_OUT_OF_BOUNDS, pointId, keyLookupMeta.keyCount));
@@ -170,7 +170,7 @@ public class Cursor implements AutoCloseable
                 updateCurrentBlockIndex(currentPointId);
             }
 
-            return ByteComparable.fixedLength(currentKey.bytes, currentKey.offset, currentKey.length);
+            return ByteSource.fixedLength(currentKey.bytes, currentKey.offset, currentKey.length);
         }
 
         /**

File: src/java/org/apache/cassandra/index/sai/memory/TrieMemoryIndex.java
Patch:
@@ -97,7 +97,8 @@ public synchronized long add(DecoratedKey key, Clustering<?> clustering, ByteBuf
         {
             value = TypeUtil.asIndexBytes(value, validator);
             analyzer.reset(value);
-            final PrimaryKey primaryKey = indexContext.keyFactory().create(key, clustering);
+            final PrimaryKey primaryKey = indexContext.hasClustering() ? indexContext.keyFactory().create(key, clustering)
+                                                                       : indexContext.keyFactory().create(key);
             final long initialSizeOnHeap = data.sizeOnHeap();
             final long initialSizeOffHeap = data.sizeOffHeap();
             final long reducerHeapSize = primaryKeysReducer.heapAllocations();

File: test/microbench/org/apache/cassandra/test/microbench/sai/KeyLookupBench.java
Patch:
@@ -117,13 +117,13 @@ public void trialSetup() throws Exception
                                                metadata.name,
                                                Util.newUUIDGen().get());
 
-        indexDescriptor = IndexDescriptor.create(descriptor, metadata.comparator);
+        indexDescriptor = IndexDescriptor.create(descriptor, metadata.partitioner, metadata.comparator);
 
         CassandraRelevantProperties.SAI_SORTED_TERMS_PARTITION_BLOCK_SHIFT.setInt(partitionBlockShift);
         CassandraRelevantProperties.SAI_SORTED_TERMS_CLUSTERING_BLOCK_SHIFT.setInt(clusteringBlockShift);
         SSTableComponentsWriter writer = new SSTableComponentsWriter(indexDescriptor);
 
-        PrimaryKey.Factory factory = new PrimaryKey.Factory(metadata.comparator);
+        PrimaryKey.Factory factory = new PrimaryKey.Factory(metadata.partitioner, metadata.comparator);
 
         PrimaryKey[] primaryKeys = new PrimaryKey[rows];
         int partition = 0;

File: test/unit/org/apache/cassandra/index/sai/SAITester.java
Patch:
@@ -71,6 +71,7 @@
 import org.apache.cassandra.db.compaction.CompactionManager;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.UTF8Type;
+import org.apache.cassandra.dht.Murmur3Partitioner;
 import org.apache.cassandra.index.Index;
 import org.apache.cassandra.index.sai.disk.SSTableIndex;
 import org.apache.cassandra.index.sai.disk.format.IndexComponent;
@@ -141,7 +142,7 @@ public abstract class SAITester extends CQLTester
 
     public static final ClusteringComparator EMPTY_COMPARATOR = new ClusteringComparator();
 
-    public static final PrimaryKey.Factory TEST_FACTORY = new PrimaryKey.Factory(EMPTY_COMPARATOR);
+    public static final PrimaryKey.Factory TEST_FACTORY = new PrimaryKey.Factory(Murmur3Partitioner.instance, EMPTY_COMPARATOR);
 
     @BeforeClass
     public static void setUpClass()
@@ -254,6 +255,7 @@ public static IndexContext createIndexContext(String name, AbstractType<?> valid
         return new IndexContext("test_ks",
                                 "test_cf",
                                 UTF8Type.instance,
+                                Murmur3Partitioner.instance,
                                 new ClusteringComparator(),
                                 ColumnMetadata.regularColumn("sai", "internal", name, validator),
                                 IndexTarget.Type.SIMPLE,

File: test/unit/org/apache/cassandra/index/sai/disk/format/IndexDescriptorTest.java
Patch:
@@ -31,6 +31,7 @@
 
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.marshal.UTF8Type;
+import org.apache.cassandra.dht.Murmur3Partitioner;
 import org.apache.cassandra.index.sai.IndexContext;
 import org.apache.cassandra.index.sai.SAITester;
 import org.apache.cassandra.io.sstable.Descriptor;
@@ -68,7 +69,7 @@ public void versionAAPerSSTableComponentIsParsedCorrectly() throws Throwable
     {
         createFileOnDisk("-SAI+aa+GroupComplete.db");
 
-        IndexDescriptor indexDescriptor = IndexDescriptor.create(descriptor, SAITester.EMPTY_COMPARATOR);
+        IndexDescriptor indexDescriptor = IndexDescriptor.create(descriptor, Murmur3Partitioner.instance, SAITester.EMPTY_COMPARATOR);
 
         assertEquals(Version.AA, indexDescriptor.version);
         assertTrue(indexDescriptor.hasComponent(IndexComponent.GROUP_COMPLETION_MARKER));
@@ -79,7 +80,7 @@ public void versionAAPerIndexComponentIsParsedCorrectly() throws Throwable
     {
         createFileOnDisk("-SAI+aa+test_index+ColumnComplete.db");
 
-        IndexDescriptor indexDescriptor = IndexDescriptor.create(descriptor, SAITester.EMPTY_COMPARATOR);
+        IndexDescriptor indexDescriptor = IndexDescriptor.create(descriptor, Murmur3Partitioner.instance, SAITester.EMPTY_COMPARATOR);
         IndexContext indexContext = SAITester.createIndexContext("test_index", UTF8Type.instance);
 
         assertEquals(Version.AA, indexDescriptor.version);

File: test/unit/org/apache/cassandra/index/sai/disk/v1/WideRowPrimaryKeyTest.java
Patch:
@@ -23,6 +23,7 @@
 import org.junit.Test;
 
 import org.apache.cassandra.db.DecoratedKey;
+import org.apache.cassandra.dht.Murmur3Partitioner;
 import org.apache.cassandra.index.sai.disk.PrimaryKeyMap;
 import org.apache.cassandra.index.sai.disk.format.IndexDescriptor;
 import org.apache.cassandra.index.sai.utils.AbstractPrimaryKeyTester;
@@ -42,7 +43,7 @@ public void randomTest() throws Throwable
 
         SSTableComponentsWriter writer = new SSTableComponentsWriter(indexDescriptor);
 
-        PrimaryKey.Factory factory = new PrimaryKey.Factory(compositePartitionMultipleClusteringAsc.comparator);
+        PrimaryKey.Factory factory = new PrimaryKey.Factory(Murmur3Partitioner.instance, compositePartitionMultipleClusteringAsc.comparator);
 
         int rows = nextInt(1000, 10000);
         PrimaryKey[] keys = new PrimaryKey[rows];

File: test/unit/org/apache/cassandra/index/sai/iterators/KeyRangeConcatIteratorTest.java
Patch:
@@ -35,7 +35,7 @@
 
 public class KeyRangeConcatIteratorTest extends AbstractKeyRangeIteratorTester
 {
-    PrimaryKey.Factory primaryKeyFactory = new PrimaryKey.Factory(null);
+    PrimaryKey.Factory primaryKeyFactory = new PrimaryKey.Factory(Murmur3Partitioner.instance, null);
     @Test
     public void testValidation()
     {
@@ -427,7 +427,7 @@ private KeyRangeIterator.Builder getConcatBuilder()
     private String createErrorMessage(int max, int min)
     {
         return String.format(KeyRangeConcatIterator.MUST_BE_SORTED_ERROR,
-                             primaryKeyFactory.createTokenOnly(new Murmur3Partitioner.LongToken(max)),
-                             primaryKeyFactory.createTokenOnly(new Murmur3Partitioner.LongToken(min)));
+                             primaryKeyFactory.create(new Murmur3Partitioner.LongToken(max)),
+                             primaryKeyFactory.create(new Murmur3Partitioner.LongToken(min)));
     }
 }

File: test/unit/org/apache/cassandra/index/sai/iterators/LongIterator.java
Patch:
@@ -92,7 +92,7 @@ public void close()
 
     public static PrimaryKey fromToken(long token)
     {
-        return SAITester.TEST_FACTORY.createTokenOnly(new Murmur3Partitioner.LongToken(token));
+        return SAITester.TEST_FACTORY.create(new Murmur3Partitioner.LongToken(token));
     }
 
 

File: test/unit/org/apache/cassandra/index/sai/memory/PriorityInMemoryKeyRangeIteratorTest.java
Patch:
@@ -33,8 +33,8 @@ protected KeyRangeIterator makeIterator(long minimumTokenValue, long maximumToke
 
         Arrays.stream(tokens).forEach(t -> queue.add(keyForToken(t)));
 
-        return new InMemoryKeyRangeIterator(primaryKeyFactory.createTokenOnly(new Murmur3Partitioner.LongToken(minimumTokenValue)),
-                                            primaryKeyFactory.createTokenOnly(new Murmur3Partitioner.LongToken(maximumTokenValue)),
+        return new InMemoryKeyRangeIterator(primaryKeyFactory.create(new Murmur3Partitioner.LongToken(minimumTokenValue)),
+                                            primaryKeyFactory.create(new Murmur3Partitioner.LongToken(maximumTokenValue)),
                                             queue);
     }
 }

File: test/unit/org/apache/cassandra/index/sai/memory/TrieMemoryIndexTest.java
Patch:
@@ -245,6 +245,7 @@ private TrieMemoryIndex newTrieMemoryIndex(AbstractType<?> columnType)
         indexContext = new IndexContext(table.keyspace,
                                         table.name,
                                         table.partitionKeyType,
+                                        table.partitioner,
                                         table.comparator,
                                         target.left,
                                         target.right,

File: test/unit/org/apache/cassandra/index/sai/utils/IndexInputLeakDetector.java
Patch:
@@ -41,7 +41,7 @@ public IndexDescriptor newIndexDescriptor(Descriptor descriptor, TableMetadata t
     {
         TrackingIndexFileUtils trackingIndexFileUtils = new TrackingIndexFileUtils(sequentialWriterOption);
         trackedIndexFileUtils.add(trackingIndexFileUtils);
-        return IndexDescriptor.create(descriptor, tableMetadata.comparator);
+        return IndexDescriptor.create(descriptor, tableMetadata.partitioner, tableMetadata.comparator);
     }
 
     @Override

File: src/java/org/apache/cassandra/cql3/functions/UDFunction.java
Patch:
@@ -229,9 +229,7 @@ protected UDFunction(FunctionName name,
         this.argCodecs = UDHelper.codecsFor(argDataTypes);
         this.returnCodec = UDHelper.codecFor(returnDataType);
         this.calledOnNullInput = calledOnNullInput;
-        KeyspaceMetadata keyspaceMetadata = Schema.instance.getKSMetaData(name.keyspace);
-        this.udfContext = new UDFContextImpl(argNames, argCodecs, returnCodec,
-                                             keyspaceMetadata);
+        this.udfContext = new UDFContextImpl(argNames, argCodecs, returnCodec, name.keyspace);
     }
 
     public static UDFunction create(FunctionName name,

File: tools/stress/src/org/apache/cassandra/stress/settings/Command.java
Patch:
@@ -61,7 +61,6 @@ public enum Command
 
     HELP(false, null, "-?", "Print help for a command or option", null),
     PRINT(false, null, "Inspect the output of a distribution definition", null),
-    LEGACY(false, null, "Legacy support mode", null),
     VERSION(false, null, "Print the version of cassandra stress", null)
     ;
 
@@ -123,8 +122,6 @@ public final Runnable helpPrinter()
                 return SettingsMisc.printHelpPrinter();
             case HELP:
                 return SettingsMisc.helpHelpPrinter();
-            case LEGACY:
-                return Legacy.helpPrinter();
         }
         switch (category)
         {

File: tools/stress/src/org/apache/cassandra/stress/settings/StressSettings.java
Patch:
@@ -165,8 +165,6 @@ public static StressSettings parse(String[] args)
     {
         args = repairParams(args);
         final Map<String, String[]> clArgs = parseMap(args);
-        if (clArgs.containsKey("legacy"))
-            return Legacy.build(Arrays.copyOfRange(args, 1, args.length));
         if (SettingsMisc.maybeDoSpecial(clArgs))
             return null;
         return get(clArgs);

File: test/simulator/main/org/apache/cassandra/simulator/ClusterSimulation.java
Patch:
@@ -117,7 +117,8 @@ public class ClusterSimulation<S extends Simulation> implements AutoCloseable
                                             FutureCallback.class,
                                             io.netty.util.concurrent.GenericFutureListener.class,
                                             io.netty.channel.FileRegion.class,
-                                            io.netty.util.ReferenceCounted.class
+                                            io.netty.util.ReferenceCounted.class,
+                                            io.netty.util.concurrent.FastThreadLocal.class
                                         };
 
     public static final Class<?>[] ISOLATE = new Class<?>[0];

File: src/java/org/apache/cassandra/locator/NetworkTopologyStrategy.java
Patch:
@@ -86,7 +86,6 @@ public NetworkTopologyStrategy(String keyspaceName, TokenMetadata tokenMetadata,
 
         datacenters = Collections.unmodifiableMap(newDatacenters);
         aggregateRf = ReplicationFactor.withTransient(replicas, trans);
-        logger.info("Configured datacenter replicas are {}", FBUtilities.toString(datacenters));
     }
 
     /**
@@ -302,6 +301,7 @@ protected void validateExpectedOptions() throws ConfigurationException
 
         // Validate the data center names
         super.validateExpectedOptions();
+        logger.info("Configured datacenter replicas are {}", FBUtilities.toString(datacenters));
     }
 
     @Override

File: src/java/org/apache/cassandra/tools/BulkLoader.java
Patch:
@@ -273,8 +273,9 @@ private static SSLOptions buildSSLOptions(EncryptionOptions clientEncryptionOpti
 
         // Temporarily override newSSLEngine to set accepted protocols until it is added to
         // RemoteEndpointAwareJdkSSLOptions.  See CASSANDRA-13325 and CASSANDRA-16362.
-        RemoteEndpointAwareJdkSSLOptions sslOptions = new RemoteEndpointAwareJdkSSLOptions(sslContext, null)
+        RemoteEndpointAwareJdkSSLOptions sslOptions = new RemoteEndpointAwareJdkSSLOptions(sslContext, clientEncryptionOptions.cipherSuitesArray())
         {
+            @Override
             protected SSLEngine newSSLEngine(SocketChannel channel, InetSocketAddress remoteEndpoint)
             {
                 SSLEngine engine = super.newSSLEngine(channel, remoteEndpoint);

File: test/distributed/org/apache/cassandra/distributed/test/SSTableLoaderEncryptionOptionsTest.java
Patch:
@@ -98,6 +98,7 @@ public void bulkLoaderSuccessfullyStreamsOverSsl() throws Throwable
                                                             "--truststore", validTrustStorePath,
                                                             "--truststore-password", validTrustStorePassword,
                                                             "--conf-path", "test/conf/sstableloader_with_encryption.yaml",
+                                                            "--ssl-ciphers", "TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA",
                                                             sstables_to_upload.absolutePath());
         tool.assertOnCleanExit();
         assertTrue(tool.getStdout().contains("Summary statistics"));

File: tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java
Patch:
@@ -165,8 +165,9 @@ public void connect(ProtocolOptions.Compression compression) throws Exception
 
             // Temporarily override newSSLEngine to set accepted protocols until it is added to
             // RemoteEndpointAwareJdkSSLOptions.  See CASSANDRA-13325 and CASSANDRA-16362.
-            RemoteEndpointAwareJdkSSLOptions sslOptions = new RemoteEndpointAwareJdkSSLOptions(sslContext, null)
+            RemoteEndpointAwareJdkSSLOptions sslOptions = new RemoteEndpointAwareJdkSSLOptions(sslContext, encryptionOptions.cipherSuitesArray())
             {
+                @Override
                 protected SSLEngine newSSLEngine(SocketChannel channel, InetSocketAddress remoteEndpoint)
                 {
                     SSLEngine engine = super.newSSLEngine(channel, remoteEndpoint);

File: src/java/org/apache/cassandra/config/EncryptionOptions.java
Patch:
@@ -288,7 +288,7 @@ public String[] acceptedProtocolsArray()
 
     public String[] cipherSuitesArray()
     {
-        return cipher_suites == null ? new String[0] : cipher_suites.toArray(new String[0]);
+        return cipher_suites == null ? null : cipher_suites.toArray(new String[0]);
     }
 
     public TlsEncryptionPolicy tlsEncryptionPolicy()

File: src/java/org/apache/cassandra/tools/BulkLoader.java
Patch:
@@ -264,8 +264,9 @@ private static SSLOptions buildSSLOptions(EncryptionOptions clientEncryptionOpti
 
         // Temporarily override newSSLEngine to set accepted protocols until it is added to
         // RemoteEndpointAwareJdkSSLOptions.  See CASSANDRA-13325 and CASSANDRA-16362.
-        RemoteEndpointAwareJdkSSLOptions sslOptions = new RemoteEndpointAwareJdkSSLOptions(sslContext, null)
+        RemoteEndpointAwareJdkSSLOptions sslOptions = new RemoteEndpointAwareJdkSSLOptions(sslContext, clientEncryptionOptions.cipherSuitesArray())
         {
+            @Override
             protected SSLEngine newSSLEngine(SocketChannel channel, InetSocketAddress remoteEndpoint)
             {
                 SSLEngine engine = super.newSSLEngine(channel, remoteEndpoint);

File: test/distributed/org/apache/cassandra/distributed/test/SSTableLoaderEncryptionOptionsTest.java
Patch:
@@ -96,6 +96,7 @@ public void bulkLoaderSuccessfullyStreamsOverSsl() throws Throwable
                                                             "--truststore", validTrustStorePath,
                                                             "--truststore-password", validTrustStorePassword,
                                                             "--conf-path", "test/conf/sstableloader_with_encryption.yaml",
+                                                            "--ssl-ciphers", "TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA",
                                                             sstables_to_upload.getAbsolutePath());
         tool.assertOnCleanExit();
         assertTrue(tool.getStdout().contains("Summary statistics"));

File: tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java
Patch:
@@ -165,8 +165,9 @@ public void connect(ProtocolOptions.Compression compression) throws Exception
 
             // Temporarily override newSSLEngine to set accepted protocols until it is added to
             // RemoteEndpointAwareJdkSSLOptions.  See CASSANDRA-13325 and CASSANDRA-16362.
-            RemoteEndpointAwareJdkSSLOptions sslOptions = new RemoteEndpointAwareJdkSSLOptions(sslContext, null)
+            RemoteEndpointAwareJdkSSLOptions sslOptions = new RemoteEndpointAwareJdkSSLOptions(sslContext, encryptionOptions.cipherSuitesArray())
             {
+                @Override
                 protected SSLEngine newSSLEngine(SocketChannel channel, InetSocketAddress remoteEndpoint)
                 {
                     SSLEngine engine = super.newSSLEngine(channel, remoteEndpoint);

File: src/java/org/apache/cassandra/io/sstable/indexsummary/IndexSummary.java
Patch:
@@ -414,8 +414,7 @@ public void serialize(IndexSummary t, DataOutputPlus out) throws IOException
                 int offset = t.offsets.getInt(i * 4) + baseOffset;
                 // our serialization format for this file uses native byte order, so if this is different to the
                 // default Java serialization order (BIG_ENDIAN) we have to reverse our bytes
-                if (ByteOrder.nativeOrder() != ByteOrder.BIG_ENDIAN)
-                    offset = Integer.reverseBytes(offset);
+                offset = Integer.reverseBytes(offset);
                 out.writeInt(offset);
             }
             out.write(t.entries, 0, t.entriesLength);

File: src/java/org/apache/cassandra/io/sstable/indexsummary/IndexSummaryBuilder.java
Patch:
@@ -123,8 +123,8 @@ public IndexSummaryBuilder(long expectedKeys, int minIndexInterval, int sampling
 
         // for initializing data structures, adjust our estimates based on the sampling level
         maxExpectedEntries = Math.max(1, (maxExpectedEntries * samplingLevel) / BASE_SAMPLING_LEVEL);
-        offsets = new SafeMemoryWriter(4 * maxExpectedEntries).order(ByteOrder.nativeOrder());
-        entries = new SafeMemoryWriter(expectedEntrySize * maxExpectedEntries).order(ByteOrder.nativeOrder());
+        offsets = new SafeMemoryWriter(4 * maxExpectedEntries).order(ByteOrder.LITTLE_ENDIAN);
+        entries = new SafeMemoryWriter(expectedEntrySize * maxExpectedEntries).order(ByteOrder.LITTLE_ENDIAN);
 
         // the summary will always contain the first index entry (downsampling will never remove it)
         nextSamplePosition = 0;

File: src/java/org/apache/cassandra/config/CassandraRelevantProperties.java
Patch:
@@ -170,6 +170,7 @@ public enum CassandraRelevantProperties
     CONSISTENT_DIRECTORY_LISTINGS("cassandra.consistent_directory_listings"),
     CONSISTENT_RANGE_MOVEMENT("cassandra.consistent.rangemovement", "true"),
     CONSISTENT_SIMULTANEOUS_MOVES_ALLOW("cassandra.consistent.simultaneousmoves.allow"),
+    CRYPTO_PROVIDER_CLASS_NAME("cassandra.crypto_provider_class_name"),
     CUSTOM_GUARDRAILS_CONFIG_PROVIDER_CLASS("cassandra.custom_guardrails_config_provider_class"),
     CUSTOM_QUERY_HANDLER_CLASS("cassandra.custom_query_handler_class"),
     CUSTOM_TRACING_CLASS("cassandra.custom_tracing_class"),
@@ -212,6 +213,7 @@ public enum CassandraRelevantProperties
     EXPIRATION_DATE_OVERFLOW_POLICY("cassandra.expiration_date_overflow_policy"),
     EXPIRATION_OVERFLOW_WARNING_INTERVAL_MINUTES("cassandra.expiration_overflow_warning_interval_minutes", "5"),
     FAILURE_LOGGING_INTERVAL_SECONDS("cassandra.request_failure_log_interval_seconds", "60"),
+    FAIL_ON_MISSING_CRYPTO_PROVIDER("cassandra.fail_on_missing_crypto_provider", "false"),
     FD_INITIAL_VALUE_MS("cassandra.fd_initial_value_ms"),
     FD_MAX_INTERVAL_MS("cassandra.fd_max_interval_ms"),
     FILE_CACHE_ENABLED("cassandra.file_cache_enabled"),
@@ -528,6 +530,7 @@ public enum CassandraRelevantProperties
     TEST_SIMULATOR_PRINT_ASM_CLASSES("cassandra.test.simulator.print_asm_classes", ""),
     TEST_SIMULATOR_PRINT_ASM_OPTS("cassandra.test.simulator.print_asm_opts", ""),
     TEST_SIMULATOR_PRINT_ASM_TYPES("cassandra.test.simulator.print_asm_types", ""),
+    TEST_SKIP_CRYPTO_PROVIDER_INSTALLATION("cassandra.test.security.skip.provider.installation", "false"),
     TEST_SSTABLE_FORMAT_DEVELOPMENT("cassandra.test.sstableformatdevelopment"),
     TEST_STRICT_LCS_CHECKS("cassandra.test.strict_lcs_checks"),
     /** Turns some warnings into exceptions for testing. */

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -80,6 +80,7 @@ public static Set<String> splitCommaDelimited(String src)
     public String authenticator;
     public String authorizer;
     public String role_manager;
+    public ParameterizedClass crypto_provider;
     public String network_authorizer;
     @Replaces(oldName = "permissions_validity_in_ms", converter = Converters.MILLIS_DURATION_INT, deprecated = true)
     public volatile DurationSpec.IntMillisecondsBound permissions_validity = new DurationSpec.IntMillisecondsBound("2s");

File: test/distributed/org/apache/cassandra/distributed/impl/Instance.java
Patch:
@@ -923,6 +923,8 @@ public Future<Void> shutdown(boolean graceful)
             
             error = parallelRun(error, executor, this::stopJmx);
 
+            error = parallelRun(error, executor, () -> DatabaseDescriptor.getCryptoProvider().uninstall());
+
             // Make sure any shutdown hooks registered for DeleteOnExit are released to prevent
             // references to the instance class loaders from being held
             if (graceful)

File: test/unit/org/apache/cassandra/config/DatabaseDescriptorRefTest.java
Patch:
@@ -263,6 +263,7 @@ public class DatabaseDescriptorRefTest
     "org.apache.cassandra.security.ISslContextFactory",
     "org.apache.cassandra.security.SSLFactory",
     "org.apache.cassandra.service.CacheService$CacheType",
+    "org.apache.cassandra.security.AbstractCryptoProvider",
     "org.apache.cassandra.transport.ProtocolException",
     "org.apache.cassandra.utils.Closeable",
     "org.apache.cassandra.utils.CloseableIterator",

File: test/unit/org/apache/cassandra/index/sai/virtual/SSTablesSystemViewTest.java
Patch:
@@ -73,6 +73,7 @@ public static void setup()
     public void testVirtualTableThroughIndexLifeCycle() throws Throwable
     {
         createTable("CREATE TABLE %s (k text, c text, v1 text, v2 text, PRIMARY KEY (k, c))");
+        disableCompaction();
         String v1IndexName = createIndex("CREATE INDEX ON %s(v1) USING 'sai'");
 
         String insert = "INSERT INTO %s(k, c, v1, v2) VALUES (?, ?, ?, ?)";

File: src/java/org/apache/cassandra/db/PartitionRangeReadCommand.java
Patch:
@@ -530,7 +530,7 @@ public ReadCommand deserialize(DataInputPlus in,
         throws IOException
         {
             DataRange range = DataRange.serializer.deserialize(in, version, metadata);
-            return new PartitionRangeReadCommand(isDigest, digestVersion, acceptsTransient, metadata, nowInSec, columnFilter, rowFilter, limits, range, indexQueryPlan, false);
+            return PartitionRangeReadCommand.create(isDigest, digestVersion, acceptsTransient, metadata, nowInSec, columnFilter, rowFilter, limits, range, indexQueryPlan, false);
         }
     }
 

File: src/java/org/apache/cassandra/db/compaction/UnifiedCompactionStrategy.java
Patch:
@@ -267,7 +267,7 @@ public SSTableMultiWriter createSSTableMultiWriter(Descriptor descriptor,
                                                        IntervalSet<CommitLogPosition> commitLogPositions,
                                                        int sstableLevel,
                                                        SerializationHeader header,
-                                                       Collection<Index> indexes,
+                                                       Collection<Index.Group> indexGroups,
                                                        LifecycleNewTracker lifecycleNewTracker)
     {
         ShardManager shardManager = getShardManager();
@@ -281,7 +281,7 @@ public SSTableMultiWriter createSSTableMultiWriter(Descriptor descriptor,
                                       isTransient,
                                       commitLogPositions,
                                       header,
-                                      indexes,
+                                      indexGroups,
                                       lifecycleNewTracker,
                                       boundaries);
     }

File: src/java/org/apache/cassandra/index/sai/disk/SSTableIndex.java
Patch:
@@ -55,8 +55,8 @@ public abstract class SSTableIndex
     private static final Logger logger = LoggerFactory.getLogger(SSTableIndex.class);
 
     // sort sstable indexes by first key, then last key, then descriptor id
-    public static final Comparator<SSTableIndex> COMPARATOR = Comparator.comparing((SSTableIndex s) -> s.getSSTable().first)
-                                                                        .thenComparing(s -> s.getSSTable().last)
+    public static final Comparator<SSTableIndex> COMPARATOR = Comparator.comparing((SSTableIndex s) -> s.getSSTable().getFirst())
+                                                                        .thenComparing(s -> s.getSSTable().getLast())
                                                                         .thenComparing(s -> s.getSSTable().descriptor.id, SSTableIdFactory.COMPARATOR);
 
     protected final SSTableContext sstableContext;
@@ -123,7 +123,7 @@ public SSTableIndex(SSTableContext sstableContext, IndexContext indexContext)
 
     /**
      * Perform a search on the index for a single expression and keyRange.
-     *
+     * <p>
      * The result is a {@link List} of {@link KeyRangeIterator} because there will
      * be a {@link KeyRangeIterator} for each segment in the index. The result
      * will never be null but may be an empty {@link List}.

File: src/java/org/apache/cassandra/index/sai/plan/QueryViewBuilder.java
Patch:
@@ -187,6 +187,6 @@ private List<SSTableIndex> selectIndexesInRange(List<SSTableIndex> indexes)
     private boolean indexInRange(SSTableIndex index)
     {
         SSTableReader sstable = index.getSSTable();
-        return range.left.compareTo(sstable.last) <= 0 && (range.right.isMinimum() || sstable.first.compareTo(range.right) <= 0);
+        return range.left.compareTo(sstable.getLast()) <= 0 && (range.right.isMinimum() || sstable.getFirst().compareTo(range.right) <= 0);
     }
 }

File: test/unit/org/apache/cassandra/index/sai/iterators/KeyRangeIntersectionIteratorTest.java
Patch:
@@ -145,14 +145,14 @@ public void testMinMaxAndCount()
         builder.add(new LongIterator(new long[]{7L, 8L, 9L}));
 
         assertEquals(9L, builder.getMaximum().token().getLongValue());
-        assertEquals(9L, builder.getCount());
+        assertEquals(3L, builder.getCount());
 
         KeyRangeIterator tokens = builder.build();
 
         assertNotNull(tokens);
         assertEquals(7L, tokens.getMinimum().token().getLongValue());
         assertEquals(9L, tokens.getMaximum().token().getLongValue());
-        assertEquals(9L, tokens.getCount());
+        assertEquals(3L, tokens.getCount());
 
         assertEquals(convert(9L), convert(builder.build()));
     }
@@ -173,7 +173,7 @@ public void testBuilder()
 
         assertEquals(6L, builder.getMinimum().token().getLongValue());
         assertEquals(6L, builder.getMaximum().token().getLongValue());
-        assertEquals(9L, builder.getCount());
+        assertEquals(3L, builder.getCount());
         assertEquals(3L, builder.rangeCount());
         assertFalse(builder.isDisjoint());
 

File: src/java/org/apache/cassandra/index/sai/SSTableContextManager.java
Patch:
@@ -47,12 +47,12 @@ public class SSTableContextManager
      *
      * @param removed SSTables being removed
      * @param added SSTables being added
-     * @param validate if true, header and footer will be validated.
+     * @param validation Controls how indexes should be validated
      *
      * @return a set of contexts for SSTables with valid per-SSTable components, and a set of
      * SSTables with invalid or missing components
      */
-    public Pair<Set<SSTableContext>, Set<SSTableReader>> update(Collection<SSTableReader> removed, Iterable<SSTableReader> added, boolean validate)
+    public Pair<Set<SSTableContext>, Set<SSTableReader>> update(Collection<SSTableReader> removed, Iterable<SSTableReader> added, IndexValidation validation)
     {
         release(removed);
 
@@ -77,7 +77,7 @@ public Pair<Set<SSTableContext>, Set<SSTableReader>> update(Collection<SSTableRe
             try
             {
                 // Only validate on restart or newly refreshed SSTable. Newly built files are unlikely to be corrupted.
-                if (validate && !sstableContexts.containsKey(sstable) && !indexDescriptor.validatePerSSTableComponents())
+                if (!sstableContexts.containsKey(sstable) && !indexDescriptor.validatePerSSTableComponents(validation))
                 {
                     logger.warn(indexDescriptor.logMessage("Invalid per-SSTable component for SSTable {}"), sstable.descriptor);
                     invalid.add(sstable);

File: src/java/org/apache/cassandra/db/lifecycle/Tracker.java
Patch:
@@ -411,11 +411,12 @@ public void replaceFlushed(Memtable memtable, Iterable<SSTableReader> sstables)
         Throwable fail;
         fail = updateSizeTracking(emptySet(), sstables, null);
 
-        notifyDiscarded(memtable);
-
         // TODO: if we're invalidated, should we notifyadded AND removed, or just skip both?
         fail = notifyAdded(sstables, false, memtable, fail);
 
+        // make sure index sees flushed index files before dicarding memtable index
+        notifyDiscarded(memtable);
+
         if (!isDummy() && !cfstore.isValid())
             dropSSTables();
 

File: src/java/org/apache/cassandra/index/sai/QueryContext.java
Patch:
@@ -25,6 +25,8 @@
 import org.apache.cassandra.exceptions.QueryCancelledException;
 import org.apache.cassandra.utils.Clock;
 
+import static org.apache.cassandra.config.CassandraRelevantProperties.SAI_TEST_DISABLE_TIMEOUT;
+
 /**
  * Tracks state relevant to the execution of a single query, including metrics and timeout monitoring.
  *
@@ -33,7 +35,7 @@
 @NotThreadSafe
 public class QueryContext
 {
-    private static final boolean DISABLE_TIMEOUT = Boolean.getBoolean("cassandra.sai.test.disable.timeout");
+    private static final boolean DISABLE_TIMEOUT = SAI_TEST_DISABLE_TIMEOUT.getBoolean();
 
     private final ReadCommand readCommand;
     private final long queryStartTimeNanos;

File: src/java/org/apache/cassandra/index/sai/disk/v1/trie/TriePrefixSearcher.java
Patch:
@@ -28,10 +28,10 @@
 
 /**
  * Thread-unsafe specialized value -> long trie prefix searcher.
- *
+ * <p>
  * This is a specialization of the {@link Walker} that will look for a prefix or
  * a complete term and return the first payload associated with the term.
- *
+ * <p>
  * TODO Make generic to handle any payload type.
  * TODO Extend search to return first payload or all sub-payloads as iterator (LIKE support?)
  */

File: src/java/org/apache/cassandra/io/tries/TrieNode.java
Patch:
@@ -59,7 +59,7 @@
 public abstract class TrieNode
 {
     /** Value used to indicate a branch (e.g. for transition and lastTransition) does not exist. */
-    public static int NONE = -1;
+    public static final int NONE = -1;
 
     // Consumption (read) methods
 

File: src/java/org/apache/cassandra/io/tries/ValueIterator.java
Patch:
@@ -39,7 +39,7 @@ public class ValueIterator<CONCRETE extends ValueIterator<CONCRETE>> extends Wal
     protected IterationPosition stack;
     private long next;
 
-    protected static class IterationPosition
+    public static class IterationPosition
     {
         final long node;
         final int limit;

File: test/unit/org/apache/cassandra/index/sai/plan/OperationTest.java
Patch:
@@ -71,6 +71,7 @@
 import org.apache.cassandra.schema.TableMetadata;
 import org.apache.cassandra.utils.FBUtilities;
 
+import static org.apache.cassandra.config.CassandraRelevantProperties.CASSANDRA_CONFIG;
 import static org.apache.cassandra.db.marshal.Int32Type.instance;
 
 public class OperationTest
@@ -91,7 +92,7 @@ public class OperationTest
     @BeforeClass
     public static void loadSchema() throws ConfigurationException
     {
-        System.setProperty("cassandra.config", "cassandra-murmur.yaml");
+        CASSANDRA_CONFIG.setString("cassandra-murmur.yaml");
 
         SchemaLoader.loadSchema();
 

File: test/unit/org/apache/cassandra/index/sai/virtual/SegmentsSystemViewTest.java
Patch:
@@ -51,6 +51,8 @@
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertTrue;
 
+import static org.apache.cassandra.config.CassandraRelevantProperties.TEST_ENCRYPTION;
+
 /**
  * Tests the virtual table exposing SSTable index segment metadata.
  */
@@ -170,7 +172,7 @@ public void testSegmentsMetadata() throws Throwable
                     indexLengths.put(indexType, value + length);
                 }
             }
-            if (!Boolean.parseBoolean(System.getProperty("cassandra.test.encryption", "false")))
+            if (!TEST_ENCRYPTION.getBoolean())
                 assertEquals(indexFileLengths(), indexLengths);
         }
 

File: test/unit/org/apache/cassandra/io/tries/WalkerTest.java
Patch:
@@ -310,5 +310,4 @@ private ByteComparable longSource(long l, int shift, int size)
         s = StringUtils.leftPad(s, size, '0');
         return source(s);
     }
-
 }

File: test/unit/org/apache/cassandra/io/util/SizedIntsTest.java
Patch:
@@ -35,7 +35,6 @@
 
 public class SizedIntsTest
 {
-
     @Test
     public void nonZeroSize()
     {

File: test/unit/org/apache/cassandra/io/util/TailOverridingRebuffererTest.java
Patch:
@@ -18,7 +18,6 @@
 
 package org.apache.cassandra.io.util;
 
-import java.io.IOException;
 import java.nio.ByteBuffer;
 
 import org.junit.Test;
@@ -32,7 +31,6 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-
 public class TailOverridingRebuffererTest
 {
     ByteBuffer head = ByteBuffer.wrap(new byte[]{ 1, 2, 3, 4, 5, 6, 7, 8 });
@@ -101,7 +99,7 @@ public void testAccessRightToTail()
     }
 
     @Test
-    public void testOtherMethods() throws IOException
+    public void testOtherMethods()
     {
         Rebufferer tor = new TailOverridingRebufferer(r, 8, tail.duplicate());
 

File: src/java/org/apache/cassandra/io/sstable/SSTableIdentityIterator.java
Patch:
@@ -138,7 +138,7 @@ public boolean hasNext()
         {
             return iterator.hasNext();
         }
-        catch (IndexOutOfBoundsException | VIntOutOfRangeException e)
+        catch (IndexOutOfBoundsException | VIntOutOfRangeException | AssertionError e)
         {
             sstable.markSuspect();
             throw new CorruptSSTableException(e, filename);
@@ -163,7 +163,7 @@ public Unfiltered next()
         {
             return doCompute();
         }
-        catch (IndexOutOfBoundsException e)
+        catch (IndexOutOfBoundsException | VIntOutOfRangeException | AssertionError e)
         {
             sstable.markSuspect();
             throw new CorruptSSTableException(e, filename);

File: test/unit/org/apache/cassandra/db/compaction/CorruptedSSTablesCompactionsTest.java
Patch:
@@ -225,7 +225,7 @@ public void testCorruptedSSTables(String tableName) throws Exception
             try
             {
                 cfs.forceMajorCompaction();
-                break;
+                break; // After all corrupted sstables are marked as such, compaction of the rest should succeed.
             }
             catch (Exception e)
             {

File: test/unit/org/apache/cassandra/db/memtable/MemtableSizeHeapBuffersTest.java
Patch:
@@ -25,7 +25,7 @@
 import org.apache.cassandra.utils.memory.MemtablePool;
 import org.apache.cassandra.utils.memory.SlabPool;
 
-public class MemtableSizeHeapBuffersTest extends MemtableSizeTest
+public class MemtableSizeHeapBuffersTest extends MemtableSizeTestBase
 {
     // Overrides CQLTester.setUpClass to run before it
     @BeforeClass

File: test/unit/org/apache/cassandra/db/memtable/MemtableSizeOffheapBuffersTest.java
Patch:
@@ -25,7 +25,7 @@
 import org.apache.cassandra.utils.memory.MemtablePool;
 import org.apache.cassandra.utils.memory.SlabPool;
 
-public class MemtableSizeOffheapBuffersTest extends MemtableSizeTest
+public class MemtableSizeOffheapBuffersTest extends MemtableSizeTestBase
 {
     // Overrides CQLTester.setUpClass to run before it
     @BeforeClass

File: test/unit/org/apache/cassandra/db/memtable/MemtableSizeOffheapObjectsTest.java
Patch:
@@ -25,7 +25,7 @@
 import org.apache.cassandra.utils.memory.MemtablePool;
 import org.apache.cassandra.utils.memory.NativePool;
 
-public class MemtableSizeOffheapObjectsTest extends MemtableSizeTest
+public class MemtableSizeOffheapObjectsTest extends MemtableSizeTestBase
 {
     // Overrides CQLTester.setUpClass to run before it
     @BeforeClass

File: test/unit/org/apache/cassandra/db/memtable/MemtableSizeTestBase.java
Patch:
@@ -44,7 +44,7 @@
 // Note: This test can be run in idea with the allocation type configured in the test yaml and memtable using the
 // value memtableClass is initialized with.
 @RunWith(Parameterized.class)
-public class MemtableSizeTest extends CQLTester
+public abstract class MemtableSizeTestBase extends CQLTester
 {
     // Note: To see a printout of the usage for each object, add .printVisitedTree() here (most useful with smaller number of
     // partitions).
@@ -54,7 +54,7 @@ public class MemtableSizeTest extends CQLTester
 //                                           .printVisitedTreeUpTo(1000)
                                            .build();
 
-    static final Logger logger = LoggerFactory.getLogger(MemtableSizeTest.class);
+    static final Logger logger = LoggerFactory.getLogger(MemtableSizeTestBase.class);
 
     static final int partitions = 50_000;
     static final int rowsPerPartition = 4;

File: test/unit/org/apache/cassandra/db/memtable/MemtableSizeUnslabbedTest.java
Patch:
@@ -25,7 +25,7 @@
 import org.apache.cassandra.utils.memory.HeapPool;
 import org.apache.cassandra.utils.memory.MemtablePool;
 
-public class MemtableSizeUnslabbedTest extends MemtableSizeTest
+public class MemtableSizeUnslabbedTest extends MemtableSizeTestBase
 {
     // Overrides CQLTester.setUpClass to run before it
     @BeforeClass

File: src/java/org/apache/cassandra/utils/MerkleTree.java
Patch:
@@ -741,7 +741,7 @@ private static ByteBuffer allocate(int innerNodeCount, IPartitioner partitioner)
         logger.debug("Allocating direct buffer of size {} for an off-heap merkle tree", size);
         ByteBuffer buffer = ByteBuffer.allocateDirect(size);
         if (Ref.DEBUG_ENABLED)
-            MemoryUtil.setAttachment(buffer, new Ref<>(null, null));
+            MemoryUtil.setAttachment(buffer, new Ref.DirectBufferRef<>(null, null));
         return buffer;
     }
 
@@ -976,8 +976,8 @@ private boolean hashesDiffer(OffHeapNode other)
         void release()
         {
             Object attachment = MemoryUtil.getAttachment(buffer);
-            if (attachment instanceof Ref)
-                ((Ref) attachment).release();
+            if (attachment instanceof Ref.DirectBufferRef)
+                ((Ref.DirectBufferRef) attachment).release();
             FileUtils.clean(buffer);
         }
 

File: src/java/org/apache/cassandra/utils/memory/MemoryUtil.java
Patch:
@@ -207,6 +207,8 @@ public static Object getAttachment(ByteBuffer instance)
         return unsafe.getObject(instance, DIRECT_BYTE_BUFFER_ATTACHMENT_OFFSET);
     }
 
+    // Note: If encryption is used, the Object attached must implement sun.nio.ch.DirectBuffer
+    // @see CASSANDRA-18081
     public static void setAttachment(ByteBuffer instance, Object next)
     {
         assert instance.getClass() == DIRECT_BYTE_BUFFER_CLASS;

File: src/java/org/apache/cassandra/cql3/ColumnIdentifier.java
Patch:
@@ -205,7 +205,7 @@ public long unsharedHeapSize()
     public long unsharedHeapSizeExcludingData()
     {
         return EMPTY_SIZE
-             + ObjectSizes.sizeOnHeapExcludingData(bytes)
+             + ObjectSizes.sizeOnHeapExcludingDataOf(bytes)
              + ObjectSizes.sizeOf(text);
     }
 

File: src/java/org/apache/cassandra/db/BufferClustering.java
Patch:
@@ -52,7 +52,7 @@ public long unsharedHeapSizeExcludingData()
     {
         if (this == Clustering.EMPTY || this == Clustering.STATIC_CLUSTERING)
             return 0;
-        return EMPTY_SIZE + ObjectSizes.sizeOnHeapExcludingData(values);
+        return EMPTY_SIZE + ObjectSizes.sizeOnHeapExcludingDataOf(values);
     }
 
     public static BufferClustering make(ByteBuffer... values)

File: src/java/org/apache/cassandra/db/rows/BufferCell.java
Patch:
@@ -155,7 +155,7 @@ public Cell<?> clone(ByteBufferCloner cloner)
     @Override
     public long unsharedHeapSizeExcludingData()
     {
-        return EMPTY_SIZE + ObjectSizes.sizeOnHeapExcludingData(value) + (path == null ? 0 : path.unsharedHeapSizeExcludingData());
+        return EMPTY_SIZE + ObjectSizes.sizeOnHeapExcludingDataOf(value) + (path == null ? 0 : path.unsharedHeapSizeExcludingData());
     }
 
     @Override

File: src/java/org/apache/cassandra/db/rows/CellPath.java
Patch:
@@ -138,7 +138,7 @@ public long unsharedHeapSize()
         @Override
         public long unsharedHeapSizeExcludingData()
         {
-            return EMPTY_SIZE + ObjectSizes.sizeOnHeapExcludingData(value);
+            return EMPTY_SIZE + ObjectSizes.sizeOnHeapExcludingDataOf(value);
         }
     }
 

File: test/unit/org/apache/cassandra/db/CellSpecTest.java
Patch:
@@ -121,7 +121,7 @@ else if (value instanceof byte[])
     private static long valuePtrSize(Object value)
     {
         if (value instanceof ByteBuffer)
-            return ObjectSizes.sizeOnHeapExcludingData((ByteBuffer) value);
+            return ObjectSizes.sizeOnHeapExcludingDataOf((ByteBuffer) value);
         else if (value instanceof byte[])
             return ObjectSizes.sizeOfArray((byte[]) value) - ((byte[]) value).length;
         throw new IllegalArgumentException("Unsupported type: " + value.getClass());

File: test/unit/org/apache/cassandra/db/memtable/MemtableSizeHeapBuffersTest.java
Patch:
@@ -25,7 +25,7 @@
 import org.apache.cassandra.utils.memory.MemtablePool;
 import org.apache.cassandra.utils.memory.SlabPool;
 
-public class MemtableSizeHeapBuffersTest extends MemtableSizeTestBase
+public class MemtableSizeHeapBuffersTest extends MemtableSizeTest
 {
     // Overrides CQLTester.setUpClass to run before it
     @BeforeClass

File: test/unit/org/apache/cassandra/db/memtable/MemtableSizeOffheapBuffersTest.java
Patch:
@@ -25,7 +25,7 @@
 import org.apache.cassandra.utils.memory.MemtablePool;
 import org.apache.cassandra.utils.memory.SlabPool;
 
-public class MemtableSizeOffheapBuffersTest extends MemtableSizeTestBase
+public class MemtableSizeOffheapBuffersTest extends MemtableSizeTest
 {
     // Overrides CQLTester.setUpClass to run before it
     @BeforeClass

File: test/unit/org/apache/cassandra/db/memtable/MemtableSizeOffheapObjectsTest.java
Patch:
@@ -25,7 +25,7 @@
 import org.apache.cassandra.utils.memory.MemtablePool;
 import org.apache.cassandra.utils.memory.NativePool;
 
-public class MemtableSizeOffheapObjectsTest extends MemtableSizeTestBase
+public class MemtableSizeOffheapObjectsTest extends MemtableSizeTest
 {
     // Overrides CQLTester.setUpClass to run before it
     @BeforeClass

File: test/unit/org/apache/cassandra/db/memtable/MemtableSizeTest.java
Patch:
@@ -43,14 +43,14 @@
 // Note: This test can be run in idea with the allocation type configured in the test yaml and memtable using the
 // value memtableClass is initialized with.
 @RunWith(Parameterized.class)
-public abstract class MemtableSizeTestBase extends CQLTester
+public class MemtableSizeTest extends CQLTester
 {
     // Note: To see a printout of the usage for each object, add .enableDebug() here (most useful with smaller number of
     // partitions).
     static MemoryMeter meter = new MemoryMeter().ignoreKnownSingletons()
                                                 .withGuessing(MemoryMeter.Guess.FALLBACK_UNSAFE);
 
-    static final Logger logger = LoggerFactory.getLogger(MemtableSizeTestBase.class);
+    static final Logger logger = LoggerFactory.getLogger(MemtableSizeTest.class);
 
     static final int partitions = 50_000;
     static final int rowsPerPartition = 4;

File: test/unit/org/apache/cassandra/db/memtable/MemtableSizeUnslabbedTest.java
Patch:
@@ -25,7 +25,7 @@
 import org.apache.cassandra.utils.memory.HeapPool;
 import org.apache.cassandra.utils.memory.MemtablePool;
 
-public class MemtableSizeUnslabbedTest extends MemtableSizeTestBase
+public class MemtableSizeUnslabbedTest extends MemtableSizeTest
 {
     // Overrides CQLTester.setUpClass to run before it
     @BeforeClass

File: src/java/org/apache/cassandra/db/AbstractCompactionController.java
Patch:
@@ -44,7 +44,7 @@ public AbstractCompactionController(final ColumnFamilyStore cfs, final long gcBe
 
     public String getKeyspace()
     {
-        return cfs.keyspace.getName();
+        return cfs.getKeyspaceName();
     }
 
     public String getColumnFamily()

File: src/java/org/apache/cassandra/db/DiskBoundaries.java
Patch:
@@ -109,7 +109,7 @@ public int getDiskIndex(SSTableReader sstable)
             return getBoundariesFromSSTableDirectory(sstable.descriptor);
         }
 
-        int pos = Collections.binarySearch(positions, sstable.first);
+        int pos = Collections.binarySearch(positions, sstable.getFirst());
         assert pos < 0; // boundaries are .minkeybound and .maxkeybound so they should never be equal
         return -pos - 1;
     }
@@ -146,7 +146,7 @@ public boolean isInCorrectLocation(SSTableReader sstable, Directories.DataDirect
     {
         int diskIndex = getDiskIndex(sstable);
         PartitionPosition diskLast = positions.get(diskIndex);
-        return directories.get(diskIndex).equals(currentLocation) && sstable.last.compareTo(diskLast) <= 0;
+        return directories.get(diskIndex).equals(currentLocation) && sstable.getLast().compareTo(diskLast) <= 0;
     }
 
     private int getDiskIndex(DecoratedKey key)

File: src/java/org/apache/cassandra/db/DiskBoundaryManager.java
Patch:
@@ -51,10 +51,10 @@ public DiskBoundaries getDiskBoundaries(ColumnFamilyStore cfs)
             {
                 if (diskBoundaries == null || diskBoundaries.isOutOfDate())
                 {
-                    logger.debug("Refreshing disk boundary cache for {}.{}", cfs.keyspace.getName(), cfs.getTableName());
+                    logger.debug("Refreshing disk boundary cache for {}.{}", cfs.getKeyspaceName(), cfs.getTableName());
                     DiskBoundaries oldBoundaries = diskBoundaries;
                     diskBoundaries = getDiskBoundaryValue(cfs);
-                    logger.debug("Updating boundaries from {} to {} for {}.{}", oldBoundaries, diskBoundaries, cfs.keyspace.getName(), cfs.getTableName());
+                    logger.debug("Updating boundaries from {} to {} for {}.{}", oldBoundaries, diskBoundaries, cfs.getKeyspaceName(), cfs.getTableName());
                 }
             }
         }
@@ -128,7 +128,7 @@ private static RangesAtEndpoint getLocalRanges(ColumnFamilyStore cfs, TokenMetad
         && !StorageService.isReplacingSameAddress()) // When replacing same address, the node marks itself as UN locally
         {
             PendingRangeCalculatorService.instance.blockUntilFinished();
-            localRanges = tmd.getPendingRanges(cfs.keyspace.getName(), FBUtilities.getBroadcastAddressAndPort());
+            localRanges = tmd.getPendingRanges(cfs.getKeyspaceName(), FBUtilities.getBroadcastAddressAndPort());
         }
         else
         {

File: src/java/org/apache/cassandra/db/compaction/CompactionIterator.java
Patch:
@@ -743,6 +743,6 @@ public Row applyToRow(Row row)
 
     private static boolean isPaxos(ColumnFamilyStore cfs)
     {
-        return cfs.name.equals(SystemKeyspace.PAXOS) && cfs.keyspace.getName().equals(SchemaConstants.SYSTEM_KEYSPACE_NAME);
+        return cfs.name.equals(SystemKeyspace.PAXOS) && cfs.getKeyspaceName().equals(SchemaConstants.SYSTEM_KEYSPACE_NAME);
     }
 }
\ No newline at end of file

File: src/java/org/apache/cassandra/db/compaction/CompactionLogger.java
Patch:
@@ -228,7 +228,7 @@ private void describeStrategy(ObjectNode node)
         ColumnFamilyStore cfs = cfsRef.get();
         if (cfs == null)
             return;
-        node.put("keyspace", cfs.keyspace.getName());
+        node.put("keyspace", cfs.getKeyspaceName());
         node.put("table", cfs.getTableName());
         node.put("time", currentTimeMillis());
     }

File: src/java/org/apache/cassandra/db/compaction/CompactionTask.java
Patch:
@@ -252,7 +252,7 @@ public boolean apply(SSTableReader sstable)
             for (int i = 0; i < mergedRowCounts.length; i++)
                 totalSourceRows += mergedRowCounts[i] * (i + 1);
 
-            String mergeSummary = updateCompactionHistory(taskId, cfs.keyspace.getName(), cfs.getTableName(), mergedRowCounts, startsize, endsize,
+            String mergeSummary = updateCompactionHistory(taskId, cfs.getKeyspaceName(), cfs.getTableName(), mergedRowCounts, startsize, endsize,
                                                           ImmutableMap.of(COMPACTION_TYPE_PROPERTY, compactionType.type));
 
             logger.info(String.format("Compacted (%s) %d sstables to [%s] to level=%d.  %s to %s (~%d%% of original) in %,dms.  Read Throughput = %s, Write Throughput = %s, Row Throughput = ~%,d/s.  %,d total partitions merged to %,d.  Partition merge counts were {%s}. Time spent writing keys = %,dms",
@@ -417,7 +417,7 @@ protected boolean buildCompactionCandidatesForAvailableDiskSpace(final Set<SSTab
 
                 String msg = String.format("Not enough space for compaction (%s) of %s.%s, estimated sstables = %d, expected write size = %d",
                                            taskId,
-                                           cfs.keyspace.getName(),
+                                           cfs.getKeyspaceName(),
                                            cfs.name,
                                            Math.max(1, writeSize / strategy.getMaxSSTableBytes()),
                                            writeSize);

File: src/java/org/apache/cassandra/db/lifecycle/SSTableIntervalTree.java
Patch:
@@ -54,7 +54,7 @@ public static List<Interval<PartitionPosition, SSTableReader>> buildIntervals(It
     {
         List<Interval<PartitionPosition, SSTableReader>> intervals = new ArrayList<>(Iterables.size(sstables));
         for (SSTableReader sstable : sstables)
-            intervals.add(Interval.<PartitionPosition, SSTableReader>create(sstable.first, sstable.last, sstable));
+            intervals.add(Interval.<PartitionPosition, SSTableReader>create(sstable.getFirst(), sstable.getLast(), sstable));
         return intervals;
     }
 }

File: src/java/org/apache/cassandra/db/lifecycle/Tracker.java
Patch:
@@ -176,7 +176,7 @@ Throwable updateSizeTracking(Iterable<SSTableReader> oldSSTables, Iterable<SSTab
         for (SSTableReader sstable : newSSTables)
         {
             if (logger.isTraceEnabled())
-                logger.trace("adding {} to list of files tracked for {}.{}", sstable.descriptor, cfstore.keyspace.getName(), cfstore.name);
+                logger.trace("adding {} to list of files tracked for {}.{}", sstable.descriptor, cfstore.getKeyspaceName(), cfstore.name);
             try
             {
                 add += sstable.bytesOnDisk();
@@ -194,7 +194,7 @@ Throwable updateSizeTracking(Iterable<SSTableReader> oldSSTables, Iterable<SSTab
         for (SSTableReader sstable : oldSSTables)
         {
             if (logger.isTraceEnabled())
-                logger.trace("removing {} from list of files tracked for {}.{}", sstable.descriptor, cfstore.keyspace.getName(), cfstore.name);
+                logger.trace("removing {} from list of files tracked for {}.{}", sstable.descriptor, cfstore.getKeyspaceName(), cfstore.name);
             try
             {
                 subtract += sstable.bytesOnDisk();

File: src/java/org/apache/cassandra/db/repair/CassandraTableRepairManager.java
Patch:
@@ -79,7 +79,7 @@ public boolean apply(SSTableReader sstable)
                         {
                             return sstable != null &&
                                    !sstable.metadata().isIndex() && // exclude SSTables from 2i
-                                   new Bounds<>(sstable.first.getToken(), sstable.last.getToken()).intersects(ranges);
+                                   new Bounds<>(sstable.getFirst().getToken(), sstable.getLast().getToken()).intersects(ranges);
                         }
                     }, true, false); //ephemeral snapshot, if repair fails, it will be cleaned next startup
                 }

File: src/java/org/apache/cassandra/db/repair/CassandraValidationIterator.java
Patch:
@@ -140,7 +140,7 @@ else if (isIncremental)
         {
             for (SSTableReader sstable : sstableCandidates.sstables)
             {
-                if (new Bounds<>(sstable.first.getToken(), sstable.last.getToken()).intersects(ranges) && predicate.apply(sstable))
+                if (new Bounds<>(sstable.getFirst().getToken(), sstable.getLast().getToken()).intersects(ranges) && predicate.apply(sstable))
                 {
                     sstablesToValidate.add(sstable);
                 }
@@ -213,7 +213,7 @@ public CassandraValidationIterator(ColumnFamilyStore cfs, Collection<Range<Token
                     prs.previewKind.logPrefix(sessionID),
                     parentId,
                     sstables.size(),
-                    cfs.keyspace.getName(),
+                    cfs.getKeyspaceName(),
                     cfs.getTableName());
 
         controller = new ValidationCompactionController(cfs, getDefaultGcBefore(cfs, nowInSec));

File: src/java/org/apache/cassandra/db/streaming/CassandraCompressedStreamReader.java
Patch:
@@ -67,7 +67,7 @@ public SSTableMultiWriter read(DataInputPlus inputPlus) throws Throwable
         }
 
         logger.debug("[Stream #{}] Start receiving file #{} from {}, repairedAt = {}, size = {}, ks = '{}', pendingRepair = '{}', table = '{}'.",
-                     session.planId(), fileSeqNum, session.peer, repairedAt, totalSize, cfs.keyspace.getName(), pendingRepair,
+                     session.planId(), fileSeqNum, session.peer, repairedAt, totalSize, cfs.getKeyspaceName(), pendingRepair,
                      cfs.getTableName());
 
         StreamDeserializer deserializer = null;
@@ -110,7 +110,7 @@ public SSTableMultiWriter read(DataInputPlus inputPlus) throws Throwable
         {
             Object partitionKey = deserializer != null ? deserializer.partitionKey() : "";
             logger.warn("[Stream {}] Error while reading partition {} from stream on ks='{}' and table='{}'.",
-                        session.planId(), partitionKey, cfs.keyspace.getName(), cfs.getTableName());
+                        session.planId(), partitionKey, cfs.getKeyspaceName(), cfs.getTableName());
             if (writer != null)
                 e = writer.abort(e);
             throw e;

File: src/java/org/apache/cassandra/db/streaming/CassandraOutgoingFile.java
Patch:
@@ -89,7 +89,7 @@ private static CassandraStreamHeader makeHeader(SSTableReader sstable,
                                     .withSerializationHeader(sstable.header.toComponent())
                                     .isEntireSSTable(shouldStreamEntireSSTable)
                                     .withComponentManifest(manifest)
-                                    .withFirstKey(sstable.first)
+                                    .withFirstKey(sstable.getFirst())
                                     .withTableId(sstable.metadata().id)
                                     .build();
     }

File: src/java/org/apache/cassandra/db/streaming/CassandraStreamReader.java
Patch:
@@ -114,7 +114,7 @@ public SSTableMultiWriter read(DataInputPlus inputPlus) throws Throwable
             throw new IllegalStateException("Table " + tableId + " was dropped during streaming");
 
         logger.debug("[Stream #{}] Start receiving file #{} from {}, repairedAt = {}, size = {}, ks = '{}', table = '{}', pendingRepair = '{}'.",
-                     session.planId(), fileSeqNum, session.peer, repairedAt, totalSize, cfs.keyspace.getName(),
+                     session.planId(), fileSeqNum, session.peer, repairedAt, totalSize, cfs.getKeyspaceName(),
                      cfs.getTableName(), pendingRepair);
 
         StreamDeserializer deserializer = null;
@@ -143,7 +143,7 @@ public SSTableMultiWriter read(DataInputPlus inputPlus) throws Throwable
         {
             Object partitionKey = deserializer != null ? deserializer.partitionKey() : "";
             logger.warn("[Stream {}] Error while reading partition {} from stream on ks='{}' and table='{}'.",
-                        session.planId(), partitionKey, cfs.keyspace.getName(), cfs.getTableName(), e);
+                        session.planId(), partitionKey, cfs.getKeyspaceName(), cfs.getTableName(), e);
             if (writer != null)
                 e = writer.abort(e);
             throw e;

File: src/java/org/apache/cassandra/db/streaming/CassandraStreamReceiver.java
Patch:
@@ -252,7 +252,7 @@ public void finished()
                 if (cfs.isRowCacheEnabled() || cfs.metadata().isCounter())
                 {
                     List<Bounds<Token>> boundsToInvalidate = new ArrayList<>(readers.size());
-                    readers.forEach(sstable -> boundsToInvalidate.add(new Bounds<Token>(sstable.first.getToken(), sstable.last.getToken())));
+                    readers.forEach(sstable -> boundsToInvalidate.add(new Bounds<Token>(sstable.getFirst().getToken(), sstable.getLast().getToken())));
                     Set<Bounds<Token>> nonOverlappingBounds = Bounds.getNonOverlappingBounds(boundsToInvalidate);
 
                     if (cfs.isRowCacheEnabled())
@@ -261,7 +261,7 @@ public void finished()
                         if (invalidatedKeys > 0)
                             logger.debug("[Stream #{}] Invalidated {} row cache entries on table {}.{} after stream " +
                                          "receive task completed.", session.planId(), invalidatedKeys,
-                                         cfs.keyspace.getName(), cfs.getTableName());
+                                         cfs.getKeyspaceName(), cfs.getTableName());
                     }
 
                     if (cfs.metadata().isCounter())
@@ -270,7 +270,7 @@ public void finished()
                         if (invalidatedKeys > 0)
                             logger.debug("[Stream #{}] Invalidated {} counter cache entries on table {}.{} after stream " +
                                          "receive task completed.", session.planId(), invalidatedKeys,
-                                         cfs.keyspace.getName(), cfs.getTableName());
+                                         cfs.getKeyspaceName(), cfs.getTableName());
                     }
                 }
             }

File: src/java/org/apache/cassandra/db/view/View.java
Patch:
@@ -169,7 +169,7 @@ SelectStatement getSelectStatement()
                                                false);
 
             SelectStatement.RawStatement rawSelect =
-                new SelectStatement.RawStatement(new QualifiedName(baseCfs.keyspace.getName(), baseCfs.name),
+                new SelectStatement.RawStatement(new QualifiedName(baseCfs.getKeyspaceName(), baseCfs.name),
                                                  parameters,
                                                  selectClause(),
                                                  definition.whereClause,

File: src/java/org/apache/cassandra/db/view/ViewBuilderTask.java
Patch:
@@ -135,7 +135,7 @@ public Long call()
          */
         boolean schemaConverged = Gossiper.instance.waitForSchemaAgreement(10, TimeUnit.SECONDS, () -> this.isStopped);
         if (!schemaConverged)
-            logger.warn("Failed to get schema to converge before building view {}.{}", baseCfs.keyspace.getName(), view.name);
+            logger.warn("Failed to get schema to converge before building view {}.{}", baseCfs.getKeyspaceName(), view.name);
 
         Function<org.apache.cassandra.db.lifecycle.View, Iterable<SSTableReader>> function;
         function = org.apache.cassandra.db.lifecycle.View.select(SSTableSet.CANONICAL, s -> range.intersects(s.getBounds()));
@@ -175,7 +175,7 @@ public Long call()
 
     private void finish()
     {
-        String ksName = baseCfs.keyspace.getName();
+        String ksName = baseCfs.getKeyspaceName();
         if (!isStopped)
         {
             // Save the completed status using the end of the range as last token. This way it will be possible for

File: src/java/org/apache/cassandra/db/virtual/TableMetricTables.java
Patch:
@@ -195,7 +195,7 @@ public DataSet data()
                 Metric metric = func.apply(cfs.metric);
 
                 // set new partition for this table
-                result.row(cfs.keyspace.getName(), cfs.name);
+                result.row(cfs.getKeyspaceName(), cfs.name);
 
                 // extract information by metric type and put it in row based on implementation of `add`
                 if (metric instanceof Counting)

File: src/java/org/apache/cassandra/dht/ByteOrderedPartitioner.java
Patch:
@@ -136,7 +136,7 @@ public double size(Token next)
         }
 
         @Override
-        public Token increaseSlightly()
+        public Token nextValidToken()
         {
             throw new UnsupportedOperationException(String.format("Token type %s does not support token allocation.",
                                                                   getClass().getSimpleName()));

File: src/java/org/apache/cassandra/dht/ComparableObjectToken.java
Patch:
@@ -75,7 +75,7 @@ public double size(Token next)
     }
 
     @Override
-    public Token increaseSlightly()
+    public Token nextValidToken()
     {
         throw new UnsupportedOperationException(String.format("Token type %s does not support token allocation.",
                                                               getClass().getSimpleName()));

File: src/java/org/apache/cassandra/dht/Murmur3Partitioner.java
Patch:
@@ -213,7 +213,7 @@ public double size(Token next)
         }
 
         @Override
-        public LongToken increaseSlightly()
+        public LongToken nextValidToken()
         {
             return new LongToken(token + 1);
         }

File: src/java/org/apache/cassandra/dht/RandomPartitioner.java
Patch:
@@ -271,7 +271,7 @@ public long getHeapSize()
             return HEAP_SIZE;
         }
 
-        public Token increaseSlightly()
+        public Token nextValidToken()
         {
             return new BigIntegerToken(token.add(BigInteger.ONE));
         }

File: src/java/org/apache/cassandra/dht/tokenallocator/TokenAllocation.java
Patch:
@@ -161,7 +161,7 @@ final Collection<Token> adjustForCrossDatacenterClashes(Collection<Token> tokens
                     InetAddressAndPort other = tokenMetadata.getEndpoint(t);
                     if (inAllocationRing(other))
                         throw new ConfigurationException(String.format("Allocated token %s already assigned to node %s. Is another node also allocating tokens?", t, other));
-                    t = t.increaseSlightly();
+                    t = t.nextValidToken();
                 }
                 filtered.add(t);
             }

File: src/java/org/apache/cassandra/index/internal/CassandraIndex.java
Patch:
@@ -667,7 +667,7 @@ private void invalidate()
 
     private boolean isBuilt()
     {
-        return SystemKeyspace.isIndexBuilt(baseCfs.keyspace.getName(), metadata.name);
+        return SystemKeyspace.isIndexBuilt(baseCfs.getKeyspaceName(), metadata.name);
     }
 
     private boolean isPrimaryKeyIndex()

File: src/java/org/apache/cassandra/index/sasi/plan/QueryController.java
Patch:
@@ -254,7 +254,7 @@ private Set<SSTableIndex> applyScope(Set<SSTableIndex> indexes)
     {
         return Sets.filter(indexes, index -> {
             SSTableReader sstable = index.getSSTable();
-            return range.startKey().compareTo(sstable.last) <= 0 && (range.stopKey().isMinimum() || sstable.first.compareTo(range.stopKey()) <= 0);
+            return range.startKey().compareTo(sstable.getLast()) <= 0 && (range.stopKey().isMinimum() || sstable.getFirst().compareTo(range.stopKey()) <= 0);
         });
     }
 }

File: src/java/org/apache/cassandra/io/sstable/AbstractSSTableSimpleWriter.java
Patch:
@@ -72,15 +72,14 @@ protected SSTableTxnWriter createWriter(SSTable.Owner owner) throws IOException
         SerializationHeader header = new SerializationHeader(true, metadata.get(), columns, EncodingStats.NO_STATS);
 
         if (makeRangeAware)
-            return SSTableTxnWriter.createRangeAware(metadata, 0, ActiveRepairService.UNREPAIRED_SSTABLE, ActiveRepairService.NO_PENDING_REPAIR, false, format, 0, header);
+            return SSTableTxnWriter.createRangeAware(metadata, 0, ActiveRepairService.UNREPAIRED_SSTABLE, ActiveRepairService.NO_PENDING_REPAIR, false, format, header);
 
         return SSTableTxnWriter.create(metadata,
                                        createDescriptor(directory, metadata.keyspace, metadata.name, format),
                                        0,
                                        ActiveRepairService.UNREPAIRED_SSTABLE,
                                        ActiveRepairService.NO_PENDING_REPAIR,
                                        false,
-                                       0,
                                        header,
                                        Collections.emptySet(),
                                        owner);

File: src/java/org/apache/cassandra/io/sstable/SSTableMultiWriter.java
Patch:
@@ -34,16 +34,16 @@ public interface SSTableMultiWriter extends Transactional
      * @param partition the partition to append
      * @return true if the partition was written, false otherwise
      */
-    boolean append(UnfilteredRowIterator partition);
+    void append(UnfilteredRowIterator partition);
 
-    Collection<SSTableReader> finish(long repairedAt, long maxDataAge, boolean openResult);
     Collection<SSTableReader> finish(boolean openResult);
     Collection<SSTableReader> finished();
 
     SSTableMultiWriter setOpenResult(boolean openResult);
 
     String getFilename();
-    long getFilePointer();
+    long getBytesWritten();
+    long getOnDiskBytesWritten();
     TableId getTableId();
 
     static void abortOrDie(SSTableMultiWriter writer)

File: src/java/org/apache/cassandra/io/sstable/format/SortedTableScrubber.java
Patch:
@@ -114,7 +114,7 @@ protected SortedTableScrubber(ColumnFamilyStore cfs,
     {
         this.sstable = (R) transaction.onlyOne();
         Preconditions.checkNotNull(sstable.metadata());
-        assert sstable.metadata().keyspace.equals(cfs.keyspace.getName());
+        assert sstable.metadata().keyspace.equals(cfs.getKeyspaceName());
         if (!sstable.descriptor.cfname.equals(cfs.metadata().name))
         {
             logger.warn("Descriptor points to a different table {} than metadata {}", sstable.descriptor.cfname, cfs.metadata().name);

File: src/java/org/apache/cassandra/io/sstable/format/SortedTableVerifier.java
Patch:
@@ -388,7 +388,7 @@ private void deserializeIndex(SSTableReader sstable) throws IOException
         {
             ByteBuffer last = it.key();
             while (it.advance()) last = it.key(); // no-op, just check if index is readable
-            if (!Objects.equals(last, sstable.last.getKey()))
+            if (!Objects.equals(last, sstable.getLast().getKey()))
                 throw new CorruptSSTableException(new IOException("Failed to read partition index"), it.toString());
         }
     }

File: src/java/org/apache/cassandra/repair/RepairRunnable.java
Patch:
@@ -298,7 +298,7 @@ private TraceState maybeCreateTraceState(Iterable<ColumnFamilyStore> columnFamil
 
         StringBuilder cfsb = new StringBuilder();
         for (ColumnFamilyStore cfs : columnFamilyStores)
-            cfsb.append(", ").append(cfs.keyspace.getName()).append(".").append(cfs.name);
+            cfsb.append(", ").append(cfs.getKeyspaceName()).append(".").append(cfs.name);
 
         TimeUUID sessionId = Tracing.instance.newSession(Tracing.TraceType.REPAIR);
         TraceState traceState = Tracing.instance.begin("repair", ImmutableMap.of("keyspace", state.keyspace, "columnFamilies",

File: src/java/org/apache/cassandra/repair/consistent/LocalSessions.java
Patch:
@@ -301,7 +301,7 @@ public PendingStats getPendingStats(TableId tid, Collection<Range<Token>> ranges
             }
         }
 
-        return new PendingStats(cfs.keyspace.getName(), cfs.name, pending.build(), finalized.build(), failed.build());
+        return new PendingStats(cfs.getKeyspaceName(), cfs.name, pending.build(), finalized.build(), failed.build());
     }
 
     public CleanupSummary cleanup(TableId tid, Collection<Range<Token>> ranges, boolean force)

File: src/java/org/apache/cassandra/repair/consistent/admin/CleanupSummary.java
Patch:
@@ -76,7 +76,7 @@ public CleanupSummary(String keyspace, String table, Set<TimeUUID> successful, S
 
     public CleanupSummary(ColumnFamilyStore cfs, Set<TimeUUID> successful, Set<TimeUUID> unsuccessful)
     {
-        this(cfs.keyspace.getName(), cfs.name, successful, unsuccessful);
+        this(cfs.getKeyspaceName(), cfs.name, successful, unsuccessful);
     }
 
     public static CleanupSummary add(CleanupSummary l, CleanupSummary r)

File: src/java/org/apache/cassandra/service/ActiveRepairService.java
Patch:
@@ -345,7 +345,7 @@ public List<CompositeData> getRepairStats(List<String> schemaArgs, String rangeS
 
         for (ColumnFamilyStore cfs : SchemaArgsParser.parse(schemaArgs))
         {
-            String keyspace = cfs.keyspace.getName();
+            String keyspace = cfs.getKeyspaceName();
             Collection<Range<Token>> ranges = userRanges != null
                                               ? userRanges
                                               : StorageService.instance.getLocalReplicas(keyspace).ranges();
@@ -365,7 +365,7 @@ public List<CompositeData> getPendingStats(List<String> schemaArgs, String range
                                               : null;
         for (ColumnFamilyStore cfs : SchemaArgsParser.parse(schemaArgs))
         {
-            String keyspace = cfs.keyspace.getName();
+            String keyspace = cfs.getKeyspaceName();
             Collection<Range<Token>> ranges = userRanges != null
                                               ? userRanges
                                               : StorageService.instance.getLocalReplicas(keyspace).ranges();
@@ -385,7 +385,7 @@ public List<CompositeData> cleanupPending(List<String> schemaArgs, String rangeS
                                               : null;
         for (ColumnFamilyStore cfs : SchemaArgsParser.parse(schemaArgs))
         {
-            String keyspace = cfs.keyspace.getName();
+            String keyspace = cfs.getKeyspaceName();
             Collection<Range<Token>> ranges = userRanges != null
                                               ? userRanges
                                               : StorageService.instance.getLocalReplicas(keyspace).ranges();

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -455,7 +455,7 @@ protected void setup()
                         }
                         else
                         {
-                            logger.info("Not enabling compaction for {}.{}; autocompaction_on_startup_enabled is set to false", store.keyspace.getName(), store.name);
+                            logger.info("Not enabling compaction for {}.{}; autocompaction_on_startup_enabled is set to false", store.getKeyspaceName(), store.name);
                         }
                     }
                 }

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1342,7 +1342,7 @@ else if (isBootstrapMode())
     private void executePreJoinTasks(boolean bootstrap)
     {
         StreamSupport.stream(ColumnFamilyStore.all().spliterator(), false)
-                .filter(cfs -> Schema.instance.getUserKeyspaces().names().contains(cfs.keyspace.getName()))
+                .filter(cfs -> Schema.instance.getUserKeyspaces().names().contains(cfs.getKeyspaceName()))
                 .forEach(cfs -> cfs.indexManager.executePreJoinTasksBlocking(bootstrap));
     }
 

File: src/java/org/apache/cassandra/service/paxos/uncommitted/UncommittedTableData.java
Patch:
@@ -184,7 +184,7 @@ List<Range<Token>> getReplicatedRanges()
             if (table == null)
                 return Range.normalize(FULL_RANGE);
 
-            String ksName = table.keyspace.getName();
+            String ksName = table.getKeyspaceName();
             List<Range<Token>> ranges = StorageService.instance.getLocalAndPendingRanges(ksName);
 
             // don't filter anything if we're not aware of any locally replicated ranges

File: src/java/org/apache/cassandra/streaming/StreamSession.java
Patch:
@@ -881,7 +881,7 @@ static boolean checkDiskSpace(Map<TableId, Long> perTableIdIncomingBytes,
             Set<FileStore> allWriteableFileStores = cfs.getDirectories().allFileStores(fileStoreMapper);
             if (allWriteableFileStores.isEmpty())
             {
-                logger.error("[Stream #{}] Could not get any writeable FileStores for {}.{}", planId, cfs.keyspace.getName(), cfs.getTableName());
+                logger.error("[Stream #{}] Could not get any writeable FileStores for {}.{}", planId, cfs.getKeyspaceName(), cfs.getTableName());
                 continue;
             }
             allFileStores.addAll(allWriteableFileStores);
@@ -906,7 +906,7 @@ static boolean checkDiskSpace(Map<TableId, Long> perTableIdIncomingBytes,
                          newStreamBytesToWritePerFileStore,
                          perTableIdIncomingBytes.keySet().stream()
                                                 .map(ColumnFamilyStore::getIfExists).filter(Objects::nonNull)
-                                                .map(cfs -> cfs.keyspace.getName() + '.' + cfs.name)
+                                                .map(cfs -> cfs.getKeyspaceName() + '.' + cfs.name)
                                                 .collect(Collectors.joining(",")),
                          totalStreamRemaining,
                          totalCompactionWriteRemaining,
@@ -943,7 +943,7 @@ static boolean checkPendingCompactions(Map<TableId, Long> perTableIdIncomingByte
                     tasksStreamed = csm.getEstimatedRemainingTasks(perTableIdIncomingFiles.get(tableId),
                                                                    perTableIdIncomingBytes.get(tableId),
                                                                    isForIncremental);
-                    tables.add(String.format("%s.%s", cfs.keyspace.getName(), cfs.name));
+                    tables.add(String.format("%s.%s", cfs.getKeyspaceName(), cfs.name));
                 }
                 pendingCompactionsBeforeStreaming += tasksOther;
                 pendingCompactionsAfterStreaming += tasksStreamed;

File: src/java/org/apache/cassandra/tools/SSTableExpiredBlockers.java
Patch:
@@ -108,13 +108,13 @@ public static Multimap<SSTableReader, SSTableReader> checkForExpiredSSTableBlock
         Multimap<SSTableReader, SSTableReader> blockers = ArrayListMultimap.create();
         for (SSTableReader sstable : sstables)
         {
-            if (sstable.getSSTableMetadata().maxLocalDeletionTime < gcBefore)
+            if (sstable.getMaxLocalDeletionTime() < gcBefore)
             {
                 for (SSTableReader potentialBlocker : sstables)
                 {
                     if (!potentialBlocker.equals(sstable) &&
                         potentialBlocker.getMinTimestamp() <= sstable.getMaxTimestamp() &&
-                        potentialBlocker.getSSTableMetadata().maxLocalDeletionTime > gcBefore)
+                        potentialBlocker.getMaxLocalDeletionTime() > gcBefore)
                         blockers.put(potentialBlocker, sstable);
                 }
             }
@@ -127,7 +127,7 @@ private static String formatForExpiryTracing(Iterable<SSTableReader> sstables)
         StringBuilder sb = new StringBuilder();
 
         for (SSTableReader sstable : sstables)
-            sb.append(String.format("[%s (minTS = %d, maxTS = %d, maxLDT = %d)]", sstable, sstable.getMinTimestamp(), sstable.getMaxTimestamp(), sstable.getSSTableMetadata().maxLocalDeletionTime)).append(", ");
+            sb.append(String.format("[%s (minTS = %d, maxTS = %d, maxLDT = %d)]", sstable, sstable.getMinTimestamp(), sstable.getMaxTimestamp(), sstable.getMaxLocalDeletionTime())).append(", ");
 
         return sb.toString();
     }

File: src/java/org/apache/cassandra/tools/SSTableMetadataViewer.java
Patch:
@@ -392,6 +392,7 @@ private void printSStableMetadata(File file, boolean scan) throws IOException
                                                         String::valueOf,
                                                         String::valueOf);
             cellCount.printHistogram(out, color, unicode);
+            field("Local token space coverage", stats.tokenSpaceCoverage);
         }
         if (compaction != null)
         {

File: src/java/org/apache/cassandra/tools/SSTableOfflineRelevel.java
Patch:
@@ -179,7 +179,7 @@ public void relevel(boolean dryRun) throws IOException
                 @Override
                 public int compare(SSTableReader o1, SSTableReader o2)
                 {
-                    return o1.last.compareTo(o2.last);
+                    return o1.getLast().compareTo(o2.getLast());
                 }
             });
 
@@ -193,10 +193,10 @@ public int compare(SSTableReader o1, SSTableReader o2)
                 while (it.hasNext())
                 {
                     SSTableReader sstable = it.next();
-                    if (lastLast == null || lastLast.compareTo(sstable.first) < 0)
+                    if (lastLast == null || lastLast.compareTo(sstable.getFirst()) < 0)
                     {
                         level.add(sstable);
-                        lastLast = sstable.last;
+                        lastLast = sstable.getLast();
                         it.remove();
                     }
                 }

File: src/java/org/apache/cassandra/tools/SSTablePartitions.java
Patch:
@@ -427,7 +427,7 @@ private static void processSSTable(String[] keys,
 
     private static String prettyPrintMemory(long bytes)
     {
-        return FBUtilities.prettyPrintMemory(bytes, true);
+        return FBUtilities.prettyPrintMemory(bytes, " ");
     }
 
     private static ISSTableScanner buildScanner(SSTableReader sstable,

File: src/java/org/apache/cassandra/utils/DiagnosticSnapshotService.java
Patch:
@@ -210,8 +210,8 @@ public void run()
                 {
                     cfs.snapshot(command.snapshot_name,
                                  (sstable) -> checkIntersection(ranges,
-                                                                sstable.first.getToken(),
-                                                                sstable.last.getToken()),
+                                                                sstable.getFirst().getToken(),
+                                                                sstable.getLast().getToken()),
                                  false, false);
                 }
             }

File: src/java/org/apache/cassandra/utils/StatusLogger.java
Patch:
@@ -119,7 +119,7 @@ private static void logStatus()
         for (ColumnFamilyStore cfs : ColumnFamilyStore.all())
         {
             logger.info(String.format("%-25s%20s",
-                                      cfs.keyspace.getName() + "." + cfs.name,
+                                      cfs.getKeyspaceName() + "." + cfs.name,
                                       cfs.metric.memtableColumnsCount.getValue() + "," + cfs.metric.memtableLiveDataSize.getValue()));
         }
     }

File: test/distributed/org/apache/cassandra/distributed/test/PreviewRepairSnapshotTest.java
Patch:
@@ -137,7 +137,7 @@ private IIsolatedExecutor.SerializableRunnable checkSnapshot(Set<Token> mismatch
 
             for (SSTableReader sstable : cfs.getLiveSSTables())
             {
-                Bounds<Token> sstableBounds = new Bounds<>(sstable.first.getToken(), sstable.last.getToken());
+                Bounds<Token> sstableBounds = new Bounds<>(sstable.getFirst().getToken(), sstable.getLast().getToken());
                 boolean shouldBeInSnapshot = false;
                 for (Token mismatchingToken : mismatchingTokens)
                 {

File: test/long/org/apache/cassandra/db/compaction/LongLeveledCompactionStrategyTest.java
Patch:
@@ -126,7 +126,7 @@ public void run()
 
                 if (level > 0)
                 {// overlap check for levels greater than 0
-                    Set<SSTableReader> overlaps = LeveledManifest.overlapping(sstable.first.getToken(), sstable.last.getToken(), sstables);
+                    Set<SSTableReader> overlaps = LeveledManifest.overlapping(sstable.getFirst().getToken(), sstable.getLast().getToken(), sstables);
                     assert overlaps.size() == 1 && overlaps.contains(sstable);
                 }
             }

File: test/microbench/org/apache/cassandra/test/microbench/ZeroCopyStreamingBenchmark.java
Patch:
@@ -141,7 +141,7 @@ public void setupBenchmark() throws IOException
                                      .withSerializationHeader(sstable.header.toComponent())
                                      .withComponentManifest(context.manifest())
                                      .isEntireSSTable(true)
-                                     .withFirstKey(sstable.first)
+                                     .withFirstKey(sstable.getFirst())
                                      .withTableId(sstable.metadata().id)
                                      .build();
 
@@ -150,7 +150,7 @@ public void setupBenchmark() throws IOException
                                                                                                0, 0, 0,
                                                                                                null), entireSSTableStreamHeader, session);
 
-            List<Range<Token>> requestedRanges = Arrays.asList(new Range<>(sstable.first.minValue().getToken(), sstable.last.getToken()));
+            List<Range<Token>> requestedRanges = Arrays.asList(new Range<>(sstable.getFirst().minValue().getToken(), sstable.getLast().getToken()));
             CassandraStreamHeader partialSSTableStreamHeader =
             CassandraStreamHeader.builder()
                                  .withSSTableVersion(sstable.descriptor.version)

File: test/unit/org/apache/cassandra/db/DiskBoundaryManagerTest.java
Patch:
@@ -160,8 +160,8 @@ public void testGetDataDirectoriesForFiles()
         SSTableReader containedDisk2 = MockSchema.sstable(gen++, (long)sstableFirstDisk2.getTokenValue(), (long)sstableEndDisk2.getTokenValue(), 0, mock);
 
         SSTableReader disk1Boundary = MockSchema.sstable(gen++, (long)sstableFirstDisk1.getTokenValue(), (long)tokens.get(0).getTokenValue(), 0, mock);
-        SSTableReader disk2Full = MockSchema.sstable(gen++, (long)tokens.get(0).increaseSlightly().getTokenValue(), (long)tokens.get(1).getTokenValue(), 0, mock);
-        SSTableReader disk3Full = MockSchema.sstable(gen++, (long)tokens.get(1).increaseSlightly().getTokenValue(), (long)partitioner.getMaximumToken().getTokenValue(), 0, mock);
+        SSTableReader disk2Full = MockSchema.sstable(gen++, (long)tokens.get(0).nextValidToken().getTokenValue(), (long)tokens.get(1).getTokenValue(), 0, mock);
+        SSTableReader disk3Full = MockSchema.sstable(gen++, (long)tokens.get(1).nextValidToken().getTokenValue(), (long)partitioner.getMaximumToken().getTokenValue(), 0, mock);
 
         Assert.assertEquals(tableDirs, mock.getDirectoriesForFiles(ImmutableSet.of()));
         Assert.assertEquals(Lists.newArrayList(tableDirs.get(0)), mock.getDirectoriesForFiles(ImmutableSet.of(containedDisk1)));

File: test/unit/org/apache/cassandra/db/compaction/CancelCompactionsTest.java
Patch:
@@ -361,7 +361,7 @@ public boolean hasNext()
 
     long first(SSTableReader sstable)
     {
-        return (long)sstable.first.getToken().getTokenValue();
+        return (long) sstable.getFirst().getToken().getTokenValue();
     }
 
     Token token(long t)
@@ -468,7 +468,8 @@ public void testStandardCompactionTaskCancellation() throws Throwable
 
         for (int i = 0; i < 10; i++)
         {
-            execute("insert into %s (id, something) values (?,?)", i, i);
+            for (int j = 0; j < 3; ++j) // write more than once to ensure overlap for UCS
+                execute("insert into %s (id, something) values (?,?)", i * (j+1), i + j);
             flush();
         }
         AbstractCompactionTask ct = null;

File: test/unit/org/apache/cassandra/db/compaction/CompactionsBytemanTest.java
Patch:
@@ -120,7 +120,7 @@ public void testRuntimeExceptionWhenNoDiskSpaceForCompaction() throws Throwable
             targetClass = "CompactionManager",
             targetMethod = "submitBackground",
             targetLocation = "AT INVOKE java.util.concurrent.Future.isCancelled",
-            condition = "!$cfs.keyspace.getName().contains(\"system\")",
+            condition = "!$cfs.getKeyspaceName().contains(\"system\")",
             action = "Thread.sleep(5000)")
     public void testCompactingCFCounting() throws Throwable
     {

File: test/unit/org/apache/cassandra/db/compaction/LeveledGenerationsTest.java
Patch:
@@ -167,8 +167,8 @@ private void assertIter(Iterator<SSTableReader> iter, long first, long last, int
     {
         List<SSTableReader> drained = Lists.newArrayList(iter);
         assertEquals(expectedCount, drained.size());
-        assertEquals(dk(first).getToken(), first(drained).first.getToken());
-        assertEquals(dk(last).getToken(), last(drained).first.getToken()); // we sort by first token, so this is the first token of the last sstable in iter
+        assertEquals(dk(first).getToken(), first(drained).getFirst().getToken());
+        assertEquals(dk(last).getToken(), last(drained).getFirst().getToken()); // we sort by first token, so this is the first token of the last sstable in iter
     }
 
     private SSTableReader last(Iterable<SSTableReader> iter)
@@ -194,6 +194,6 @@ private SSTableReader sst(int gen, ColumnFamilyStore cfs, long first, long last)
 
     private void print(SSTableReader sstable)
     {
-        System.out.println(String.format("%d %s %s %d", sstable.descriptor.id, sstable.first, sstable.last, sstable.getSSTableLevel()));
+        System.out.println(String.format("%d %s %s %d", sstable.descriptor.id, sstable.getFirst(), sstable.getLast(), sstable.getSSTableLevel()));
     }
 }

File: test/unit/org/apache/cassandra/db/lifecycle/LogTransactionTest.java
Patch:
@@ -1263,7 +1263,7 @@ public void testGetTemporaryFilesThrowsIfCompletingAfterObsoletion() throws Thro
 
     private static SSTableReader sstable(File dataFolder, ColumnFamilyStore cfs, int generation, int size) throws IOException
     {
-        Descriptor descriptor = new Descriptor(dataFolder, cfs.keyspace.getName(), cfs.getTableName(), new SequenceBasedSSTableId(generation), DatabaseDescriptor.getSelectedSSTableFormat());
+        Descriptor descriptor = new Descriptor(dataFolder, cfs.getKeyspaceName(), cfs.getTableName(), new SequenceBasedSSTableId(generation), DatabaseDescriptor.getSelectedSSTableFormat());
         if (BigFormat.isSelected())
         {
             Set<Component> components = ImmutableSet.of(Components.DATA, Components.PRIMARY_INDEX, Components.FILTER, Components.TOC);

File: test/unit/org/apache/cassandra/db/lifecycle/RealTransactionsTest.java
Patch:
@@ -134,8 +134,8 @@ private void createSSTable(ColumnFamilyStore cfs, int numPartitions) throws IOEx
 
         try (CQLSSTableWriter writer = CQLSSTableWriter.builder()
                                                        .inDirectory(cfs.getDirectories().getDirectoryForNewSSTables())
-                                                       .forTable(String.format(schema, cfs.keyspace.getName(), cfs.name))
-                                                       .using(String.format(query, cfs.keyspace.getName(), cfs.name))
+                                                       .forTable(String.format(schema, cfs.getKeyspaceName(), cfs.name))
+                                                       .using(String.format(query, cfs.getKeyspaceName(), cfs.name))
                                                        .build())
         {
             for (int j = 0; j < numPartitions; j ++)

File: test/unit/org/apache/cassandra/db/repair/PendingAntiCompactionBytemanTest.java
Patch:
@@ -63,7 +63,7 @@ public void testExceptionAnticompaction() throws InterruptedException
 
         for (SSTableReader sstable : cfs.getLiveSSTables())
         {
-            ranges.add(new Range<>(sstable.first.getToken(), sstable.last.getToken()));
+            ranges.add(new Range<>(sstable.getFirst().getToken(), sstable.getLast().getToken()));
         }
         TimeUUID prsid = prepareSession();
         try

File: test/unit/org/apache/cassandra/db/repair/PendingAntiCompactionTest.java
Patch:
@@ -176,7 +176,7 @@ public void acquisitionSuccess() throws Exception
         Collection<Range<Token>> ranges = new HashSet<>();
         for (SSTableReader sstable : expected)
         {
-            ranges.add(new Range<>(sstable.first.getToken(), sstable.last.getToken()));
+            ranges.add(new Range<>(sstable.getFirst().getToken(), sstable.getLast().getToken()));
         }
 
         PendingAntiCompaction.AcquisitionCallable acquisitionCallable = new PendingAntiCompaction.AcquisitionCallable(cfs, ranges, nextTimeUUID(), 0, 0);
@@ -400,8 +400,8 @@ public void cancelledAntiCompaction() throws Exception
 
         // attempt to anti-compact the sstable in half
         SSTableReader sstable = Iterables.getOnlyElement(cfs.getLiveSSTables());
-        Token left = cfs.getPartitioner().midpoint(sstable.first.getToken(), sstable.last.getToken());
-        Token right = sstable.last.getToken();
+        Token left = cfs.getPartitioner().midpoint(sstable.getFirst().getToken(), sstable.getLast().getToken());
+        Token right = sstable.getLast().getToken();
         CompactionManager.instance.performAnticompaction(result.cfs,
                                                          atEndpoint(Collections.singleton(new Range<>(left, right)), NO_RANGES),
                                                          result.refs, result.txn, sessionID, () -> true);

File: test/unit/org/apache/cassandra/db/streaming/CassandraEntireSSTableStreamWriterTest.java
Patch:
@@ -156,7 +156,7 @@ public void testBlockReadingAndWritingOverWire() throws Throwable
                                  .withSerializationHeader(sstable.header.toComponent())
                                  .withComponentManifest(context.manifest())
                                  .isEntireSSTable(true)
-                                 .withFirstKey(sstable.first)
+                                 .withFirstKey(sstable.getFirst())
                                  .withTableId(sstable.metadata().id)
                                  .build();
 

File: test/unit/org/apache/cassandra/db/streaming/CassandraOutgoingFileTest.java
Patch:
@@ -89,7 +89,7 @@ public static void defineSchemaAndPrepareSSTable()
     @Test
     public void validateFullyContainedIn_SingleContiguousRange_Succeeds()
     {
-        List<Range<Token>> requestedRanges = Arrays.asList(new Range<>(store.getPartitioner().getMinimumToken(), sstable.last.getToken()));
+        List<Range<Token>> requestedRanges = Arrays.asList(new Range<>(store.getPartitioner().getMinimumToken(), sstable.getLast().getToken()));
 
         List<SSTableReader.PartitionPositionBounds> sections = sstable.getPositionsForRanges(requestedRanges);
         CassandraOutgoingFile cof = new CassandraOutgoingFile(StreamOperation.BOOTSTRAP, sstable.ref(),
@@ -117,7 +117,7 @@ public void validateFullyContainedIn_SplitRange_Succeeds()
     {
         List<Range<Token>> requestedRanges = Arrays.asList(new Range<>(store.getPartitioner().getMinimumToken(), getTokenAtIndex(4)),
                                                          new Range<>(getTokenAtIndex(2), getTokenAtIndex(6)),
-                                                         new Range<>(getTokenAtIndex(5), sstable.last.getToken()));
+                                                         new Range<>(getTokenAtIndex(5), sstable.getLast().getToken()));
         requestedRanges = Range.normalize(requestedRanges);
 
         List<SSTableReader.PartitionPositionBounds> sections = sstable.getPositionsForRanges(requestedRanges);

File: test/unit/org/apache/cassandra/db/streaming/CassandraStreamHeaderTest.java
Patch:
@@ -133,7 +133,7 @@ public void transferedSizeWithoutCompressionTest()
 
     private CassandraStreamHeader header(boolean entireSSTable, boolean compressed)
     {
-        List<Range<Token>> requestedRanges = Collections.singletonList(new Range<>(store.getPartitioner().getMinimumToken(), sstable.last.getToken()));
+        List<Range<Token>> requestedRanges = Collections.singletonList(new Range<>(store.getPartitioner().getMinimumToken(), sstable.getLast().getToken()));
         requestedRanges = Range.normalize(requestedRanges);
 
         List<SSTableReader.PartitionPositionBounds> sections = sstable.getPositionsForRanges(requestedRanges);
@@ -143,7 +143,7 @@ private CassandraStreamHeader header(boolean entireSSTable, boolean compressed)
         TableMetadata metadata = store.metadata();
         SerializationHeader.Component serializationHeader = SerializationHeader.makeWithoutStats(metadata).toComponent();
         ComponentManifest componentManifest = entireSSTable ? ComponentManifest.create(sstable.descriptor) : null;
-        DecoratedKey firstKey = entireSSTable ? sstable.first : null;
+        DecoratedKey firstKey = entireSSTable ? sstable.getFirst() : null;
 
         return CassandraStreamHeader.builder()
                                     .withSSTableVersion(sstable.descriptor.version)

File: test/unit/org/apache/cassandra/db/streaming/CassandraStreamManagerTest.java
Patch:
@@ -210,7 +210,7 @@ public void testSSTableSectionsForRanges() throws Exception
 
         Collection<SSTableReader> allSSTables = cfs.getLiveSSTables();
         Assert.assertEquals(1, allSSTables.size());
-        final Token firstToken = allSSTables.iterator().next().first.getToken();
+        final Token firstToken = allSSTables.iterator().next().getFirst().getToken();
         DatabaseDescriptor.setSSTablePreemptiveOpenIntervalInMiB(1);
 
         Set<SSTableReader> sstablesBeforeRewrite = getReadersForRange(new Range<>(firstToken, firstToken));

File: test/unit/org/apache/cassandra/index/internal/CustomCassandraIndex.java
Patch:
@@ -605,7 +605,7 @@ private void invalidate()
 
     private boolean isBuilt()
     {
-        return SystemKeyspace.isIndexBuilt(baseCfs.keyspace.getName(), metadata.name);
+        return SystemKeyspace.isIndexBuilt(baseCfs.getKeyspaceName(), metadata.name);
     }
 
     private boolean isPrimaryKeyIndex()

File: test/unit/org/apache/cassandra/io/sstable/RangeAwareSSTableWriterTest.java
Patch:
@@ -85,7 +85,7 @@ public void testAccessWriterBeforeAppend() throws IOException
                                                                      SerializationHeader.make(cfs.metadata(),
                                                                                               cfs.getLiveSSTables()));
         assertEquals(cfs.metadata.id, writer.getTableId());
-        assertEquals(0L, writer.getFilePointer());
-
+        assertEquals(0L, writer.getBytesWritten());
+        assertEquals(0L, writer.getOnDiskBytesWritten());
     }
 }

File: test/unit/org/apache/cassandra/io/sstable/SSTableUtils.java
Patch:
@@ -233,7 +233,7 @@ public Collection<SSTableReader> write(int expectedSize, Appender appender) thro
             TableMetadata metadata = Schema.instance.getTableMetadata(ksname, cfname);
             ColumnFamilyStore cfs = Schema.instance.getColumnFamilyStoreInstance(metadata.id);
             SerializationHeader header = appender.header();
-            SSTableTxnWriter writer = SSTableTxnWriter.create(cfs, Descriptor.fromFileWithComponent(datafile, false).left, expectedSize, UNREPAIRED_SSTABLE, NO_PENDING_REPAIR, false, 0, header);
+            SSTableTxnWriter writer = SSTableTxnWriter.create(cfs, Descriptor.fromFileWithComponent(datafile, false).left, expectedSize, UNREPAIRED_SSTABLE, NO_PENDING_REPAIR, false, header);
             while (appender.append(writer)) { /* pass */ }
             Collection<SSTableReader> readers = writer.finish(true);
 

File: test/unit/org/apache/cassandra/io/sstable/SSTableWriterTest.java
Patch:
@@ -78,7 +78,7 @@ public void testAbortTxnWithOpenEarlyShouldRemoveSSTable()
                 }
                 writer.setMaxDataAge(1000);
                 writer.openEarly(s2 -> {
-                    assertTrue(s.last.compareTo(s2.last) < 0);
+                    assertTrue(s.getLast().compareTo(s2.getLast()) < 0);
                     assertFileCounts(dir.tryListNames());
                     s.selfRef().release();
                     s2.selfRef().release();

File: test/unit/org/apache/cassandra/io/sstable/metadata/MetadataSerializerTest.java
Patch:
@@ -142,6 +142,8 @@ public Map<MetadataType, MetadataComponent> constructMetadata(boolean withNulls)
                                          .build();
         MetadataCollector collector = new MetadataCollector(cfm.comparator)
                                       .commitLogIntervals(new IntervalSet<>(cllb, club));
+        if (DatabaseDescriptor.getSelectedSSTableFormat().getLatestVersion().hasTokenSpaceCoverage())
+            collector.tokenSpaceCoverage(0.7);
 
         String partitioner = RandomPartitioner.class.getCanonicalName();
         double bfFpChance = 0.1;

File: test/unit/org/apache/cassandra/metrics/TrieMemtableMetricsTest.java
Patch:
@@ -180,7 +180,7 @@ public void testMetricsCleanupOnDrop()
 
     private TrieMemtableMetricsView getMemtableMetrics(ColumnFamilyStore cfs)
     {
-        return new TrieMemtableMetricsView(cfs.keyspace.getName(), cfs.name);
+        return new TrieMemtableMetricsView(cfs.getKeyspaceName(), cfs.name);
     }
 
     private void writeAndFlush(int rows) throws IOException, ExecutionException, InterruptedException

File: test/unit/org/apache/cassandra/schema/MockSchema.java
Patch:
@@ -179,7 +179,7 @@ public static SSTableReader sstable(int generation, int size, boolean keepRef, l
     {
         SSTableFormat<?, ?> format = DatabaseDescriptor.getSelectedSSTableFormat();
         Descriptor descriptor = new Descriptor(cfs.getDirectories().getDirectoryForNewSSTables(),
-                                               cfs.keyspace.getName(),
+                                               cfs.getKeyspaceName(),
                                                cfs.getTableName(),
                                                sstableId(generation),
                                                format);

File: test/unit/org/apache/cassandra/service/reads/DataResolverTest.java
Patch:
@@ -118,7 +118,7 @@ private EndpointsForRange makeReplicas(int num)
             {
                 InetAddressAndPort endpoint = InetAddressAndPort.getByAddress(new byte[]{ 127, 0, 0, (byte) (i + 1) });
                 replicas.add(ReplicaUtils.full(endpoint));
-                StorageService.instance.getTokenMetadata().updateNormalToken(token = token.increaseSlightly(), endpoint);
+                StorageService.instance.getTokenMetadata().updateNormalToken(token = token.nextValidToken(), endpoint);
                 Gossiper.instance.initializeNodeUnsafe(endpoint, UUID.randomUUID(), 1);
             }
             catch (UnknownHostException e)

File: test/unit/org/apache/cassandra/streaming/StreamTransferTaskTest.java
Patch:
@@ -108,7 +108,7 @@ public void testScheduleTimeout() throws Exception
         for (SSTableReader sstable : cfs.getLiveSSTables())
         {
             List<Range<Token>> ranges = new ArrayList<>();
-            ranges.add(new Range<>(sstable.first.getToken(), sstable.last.getToken()));
+            ranges.add(new Range<>(sstable.getFirst().getToken(), sstable.getLast().getToken()));
             task.addTransferStream(new CassandraOutgoingFile(StreamOperation.BOOTSTRAP, sstable.selfRef(), sstable.getPositionsForRanges(ranges), ranges, 1));
         }
         assertEquals(14, task.getTotalNumberOfFiles());
@@ -159,7 +159,7 @@ public void testFailSessionDuringTransferShouldNotReleaseReferences() throws Exc
         for (SSTableReader sstable : cfs.getLiveSSTables())
         {
             List<Range<Token>> ranges = new ArrayList<>();
-            ranges.add(new Range<>(sstable.first.getToken(), sstable.last.getToken()));
+            ranges.add(new Range<>(sstable.getFirst().getToken(), sstable.getLast().getToken()));
             Ref<SSTableReader> ref = sstable.selfRef();
             refs.add(ref);
             task.addTransferStream(new CassandraOutgoingFile(StreamOperation.BOOTSTRAP, ref, sstable.getPositionsForRanges(ranges), ranges, 1));

File: test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java
Patch:
@@ -241,13 +241,13 @@ private void transferRanges(ColumnFamilyStore cfs) throws Exception
         List<Range<Token>> ranges = new ArrayList<>();
         // wrapped range
         ranges.add(new Range<Token>(p.getToken(ByteBufferUtil.bytes("key1")), p.getToken(ByteBufferUtil.bytes("key0"))));
-        StreamPlan streamPlan = new StreamPlan(StreamOperation.OTHER).transferRanges(LOCAL, cfs.keyspace.getName(), RangesAtEndpoint.toDummyList(ranges), cfs.getTableName());
+        StreamPlan streamPlan = new StreamPlan(StreamOperation.OTHER).transferRanges(LOCAL, cfs.getKeyspaceName(), RangesAtEndpoint.toDummyList(ranges), cfs.getTableName());
         streamPlan.execute().get();
 
         //cannot add ranges after stream session is finished
         try
         {
-            streamPlan.transferRanges(LOCAL, cfs.keyspace.getName(), RangesAtEndpoint.toDummyList(ranges), cfs.getTableName());
+            streamPlan.transferRanges(LOCAL, cfs.getKeyspaceName(), RangesAtEndpoint.toDummyList(ranges), cfs.getTableName());
             fail("Should have thrown exception");
         }
         catch (RuntimeException e)

File: test/unit/org/apache/cassandra/tools/nodetool/CompactionHistoryTest.java
Patch:
@@ -85,7 +85,8 @@ public void testCompactionProperties() throws Throwable
         // write SSTables for the specific key
         for (int i = 0; i < 10; i++)
         {
-            execute("INSERT INTO %s (id, value) VALUES (?, ?)", "key" + i, "value" + i);
+            for (int j = 0; j < 3; j++) // write more than once to ensure overlap for UCS
+                execute("INSERT INTO %s (id, value) VALUES (?, ?)", "key" + i + j, "value" + i + j);
             flush(keyspace());
         }
 

File: tools/stress/src/org/apache/cassandra/stress/report/StressMetrics.java
Patch:
@@ -420,7 +420,7 @@ public void summarise()
         output.println(String.format("Total partitions          : %,10d %s",   history.partitionCount, opHistory.partitionCounts()));
         output.println(String.format("Total errors              : %,10d %s",   history.errorCount, opHistory.errorCounts()));
         output.println(String.format("Total GC count            : %,1.0f", totalGcStats.count));
-        output.println(String.format("Total GC memory           : %s", FBUtilities.prettyPrintMemory((long)totalGcStats.bytes, true)));
+        output.println(String.format("Total GC memory           : %s", FBUtilities.prettyPrintMemory((long)totalGcStats.bytes, " ")));
         output.println(String.format("Total GC time             : %,6.1f seconds", totalGcStats.summs / 1000));
         output.println(String.format("Avg GC time               : %,6.1f ms", totalGcStats.summs / totalGcStats.count));
         output.println(String.format("StdDev GC time            : %,6.1f ms", totalGcStats.sdvms));

File: src/java/org/apache/cassandra/io/sstable/format/bti/BtiTableReaderLoadingBuilder.java
Patch:
@@ -122,7 +122,7 @@ protected void openComponents(BtiTableReader.Builder builder, SSTable.Owner owne
 
             if (builder.getComponents().contains(Components.PARTITION_INDEX))
             {
-                builder.setPartitionIndex(openPartitionIndex(builder.getFilter().isInformative()));
+                builder.setPartitionIndex(openPartitionIndex(!builder.getFilter().isInformative()));
                 if (builder.getFirst() == null || builder.getLast() == null)
                 {
                     builder.setFirst(builder.getPartitionIndex().firstKey());

File: test/unit/org/apache/cassandra/cql3/functions/CastFctsTest.java
Patch:
@@ -157,7 +157,7 @@ public void testNumericCastsInSelectionClause() throws Throwable
                        BigDecimal.valueOf(2),
                        BigDecimal.valueOf(3),
                        BigDecimal.valueOf(4),
-                       BigDecimal.valueOf(5.2F),
+                       new BigDecimal("5.2"),
                        BigDecimal.valueOf(6.3),
                        BigDecimal.valueOf(6.3),
                        BigDecimal.valueOf(4),

File: src/java/org/apache/cassandra/cql3/Terms.java
Patch:
@@ -24,6 +24,7 @@
 import org.apache.cassandra.cql3.Term.Terminal;
 import org.apache.cassandra.cql3.functions.Function;
 import org.apache.cassandra.db.marshal.*;
+import org.apache.cassandra.schema.SchemaConstants;
 import org.apache.cassandra.transport.ProtocolVersion;
 
 /**
@@ -263,7 +264,7 @@ public static void addFunctions(Iterable<Term> terms, List<Function> functions)
 
     public static ByteBuffer asBytes(String keyspace, String term, AbstractType type)
     {
-        ColumnSpecification receiver = new ColumnSpecification(keyspace, "--dummy--", new ColumnIdentifier("(dummy)", true), type);
+        ColumnSpecification receiver = new ColumnSpecification(keyspace, SchemaConstants.DUMMY_KEYSPACE_OR_TABLE_NAME, new ColumnIdentifier("(dummy)", true), type);
         Term.Raw rawTerm = CQLFragmentParser.parseAny(CqlParser::term, term, "CQL term");
         return rawTerm.prepare(keyspace, receiver).bindAndGet(QueryOptions.DEFAULT);
     }

File: src/java/org/apache/cassandra/cql3/functions/ArgumentDeserializer.java
Patch:
@@ -25,6 +25,7 @@
 /**
  * Utility used to deserialize function arguments.
  */
+@FunctionalInterface
 public interface ArgumentDeserializer
 {
     /**

File: src/java/org/apache/cassandra/cql3/functions/CastFcts.java
Patch:
@@ -390,7 +390,7 @@ public Arguments newArguments(ProtocolVersion version)
                 if (buffer == null || (!buffer.hasRemaining() && argType.isEmptyValueMeaningless()))
                     return null;
 
-                return argType.getSerializer().toCQLLiteral(buffer);
+                return argType.getSerializer().toCQLLiteralNoQuote(buffer);
             });
         }
 

File: src/java/org/apache/cassandra/cql3/functions/UDAggregate.java
Patch:
@@ -370,7 +370,7 @@ public String toCqlString(boolean withInternals, boolean ifNotExists)
         if (initialCondition() != null)
             builder.newLine()
                    .append("INITCOND ")
-                   .append(stateType().asCQL3Type().toCQLLiteral(initialCondition(), ProtocolVersion.CURRENT));
+                   .append(stateType().asCQL3Type().toCQLLiteral(initialCondition()));
 
         return builder.append(";")
                       .toString();

File: src/java/org/apache/cassandra/cql3/functions/masking/ColumnMask.java
Patch:
@@ -181,7 +181,7 @@ public String toString()
         {
             CQL3Type type = types.get(i).asCQL3Type();
             ByteBuffer value = partialArgumentValues[i];
-            arguments.add(type.toCQLLiteral(value, ProtocolVersion.CURRENT));
+            arguments.add(type.toCQLLiteral(value));
         }
         return format("%s(%s)", function.name(), StringUtils.join(arguments, ", "));
     }

File: src/java/org/apache/cassandra/cql3/selection/ListSelector.java
Patch:
@@ -68,7 +68,7 @@ protected Selector deserialize(DataInputPlus in, int version, TableMetadata meta
 
     public static Factory newFactory(final AbstractType<?> type, final SelectorFactories factories)
     {
-        return new CollectionFactory(type, factories)
+        return new MultiElementFactory(type, factories)
         {
             protected String getColumnName()
             {

File: src/java/org/apache/cassandra/cql3/selection/Selector.java
Patch:
@@ -91,7 +91,8 @@ public enum Kind
         SCALAR_FUNCTION_SELECTOR(ScalarFunctionSelector.deserializer),
         AGGREGATE_FUNCTION_SELECTOR(AggregateFunctionSelector.deserializer),
         ELEMENT_SELECTOR(ElementsSelector.ElementSelector.deserializer),
-        SLICE_SELECTOR(ElementsSelector.SliceSelector.deserializer);
+        SLICE_SELECTOR(ElementsSelector.SliceSelector.deserializer),
+        VECTOR_SELECTOR(VectorSelector.deserializer);
 
         private final SelectorDeserializer deserializer;
 

File: src/java/org/apache/cassandra/cql3/selection/SetSelector.java
Patch:
@@ -70,7 +70,7 @@ protected Selector deserialize(DataInputPlus in, int version, TableMetadata meta
 
     public static Factory newFactory(final AbstractType<?> type, final SelectorFactories factories)
     {
-        return new CollectionFactory(type, factories)
+        return new MultiElementFactory(type, factories)
         {
             protected String getColumnName()
             {

File: src/java/org/apache/cassandra/cql3/selection/TupleSelector.java
Patch:
@@ -68,7 +68,7 @@ protected Selector deserialize(DataInputPlus in, int version, TableMetadata meta
 
     public static Factory newFactory(final AbstractType<?> type, final SelectorFactories factories)
     {
-        return new CollectionFactory(type, factories)
+        return new MultiElementFactory(type, factories)
         {
             protected String getColumnName()
             {

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -949,6 +949,8 @@ private ResultSet process(PartitionIterator partitions,
     public static ByteBuffer[] getComponents(TableMetadata metadata, DecoratedKey dk)
     {
         ByteBuffer key = dk.getKey();
+        if (metadata.partitionKeyColumns().size() == 1)
+            return new ByteBuffer[]{ key };
         if (metadata.partitionKeyType instanceof CompositeType)
         {
             return ((CompositeType)metadata.partitionKeyType).split(key);

File: src/java/org/apache/cassandra/cql3/statements/schema/CreateFunctionStatement.java
Patch:
@@ -96,11 +96,11 @@ public Keyspaces apply(Keyspaces schema)
             throw ire("Duplicate argument names for given function %s with argument names %s", functionName, argumentNames);
 
         rawArgumentTypes.stream()
-                        .filter(raw -> !raw.isTuple() && raw.isFrozen())
+                        .filter(raw -> !raw.isImplicitlyFrozen() && raw.isFrozen())
                         .findFirst()
                         .ifPresent(t -> { throw ire("Argument '%s' cannot be frozen; remove frozen<> modifier from '%s'", t, t); });
 
-        if (!rawReturnType.isTuple() && rawReturnType.isFrozen())
+        if (!rawReturnType.isImplicitlyFrozen() && rawReturnType.isFrozen())
             throw ire("Return type '%s' cannot be frozen; remove frozen<> modifier from '%s'", rawReturnType, rawReturnType);
 
         KeyspaceMetadata keyspace = schema.getNullable(keyspaceName);

File: src/java/org/apache/cassandra/cql3/statements/schema/DropAggregateStatement.java
Patch:
@@ -91,7 +91,7 @@ public Keyspaces apply(Keyspaces schema)
         }
 
         arguments.stream()
-                 .filter(raw -> !raw.isTuple() && raw.isFrozen())
+                 .filter(raw -> !raw.isImplicitlyFrozen() && raw.isFrozen())
                  .findFirst()
                  .ifPresent(t -> { throw ire("Argument '%s' cannot be frozen; remove frozen<> modifier from '%s'", t, t); });
 

File: src/java/org/apache/cassandra/cql3/statements/schema/DropFunctionStatement.java
Patch:
@@ -92,7 +92,7 @@ public Keyspaces apply(Keyspaces schema)
         }
 
         arguments.stream()
-                 .filter(raw -> !raw.isTuple() && raw.isFrozen())
+                 .filter(raw -> !raw.isImplicitlyFrozen() && raw.isFrozen())
                  .findFirst()
                  .ifPresent(t -> { throw ire("Argument '%s' cannot be frozen; remove frozen<> modifier from '%s'", t, t); });
 

File: src/java/org/apache/cassandra/db/NativeClustering.java
Patch:
@@ -23,6 +23,7 @@
 
 import org.apache.cassandra.db.marshal.ByteBufferAccessor;
 import org.apache.cassandra.db.marshal.ValueAccessor;
+import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.ObjectSizes;
 import org.apache.cassandra.utils.concurrent.OpOrder;
 import org.apache.cassandra.utils.memory.HeapCloner;
@@ -45,7 +46,7 @@ public NativeClustering(NativeAllocator allocator, OpOrder.Group writeOp, Cluste
         int bitmapSize = ((count + 7) >>> 3);
 
         assert count < 64 << 10;
-        assert dataSize < 64 << 10;
+        assert dataSize <= FBUtilities.MAX_UNSIGNED_SHORT : String.format("Data size %d >= %d", dataSize, FBUtilities.MAX_UNSIGNED_SHORT + 1);
 
         peer = allocator.allocate(metadataSize + dataSize + bitmapSize, writeOp);
         long bitmapStart = peer + metadataSize;

File: src/java/org/apache/cassandra/schema/SchemaConstants.java
Patch:
@@ -47,6 +47,8 @@ public final class SchemaConstants
 
     public static final String VIRTUAL_VIEWS = "system_views";
 
+    public static final String DUMMY_KEYSPACE_OR_TABLE_NAME = "--dummy--";
+
     /* system keyspace names (the ones with LocalStrategy replication strategy) */
     public static final Set<String> LOCAL_SYSTEM_KEYSPACE_NAMES =
         ImmutableSet.of(SYSTEM_KEYSPACE_NAME, SCHEMA_KEYSPACE_NAME);

File: src/java/org/apache/cassandra/schema/SchemaKeyspace.java
Patch:
@@ -47,7 +47,6 @@
 import org.apache.cassandra.schema.ColumnMetadata.ClusteringOrder;
 import org.apache.cassandra.schema.Keyspaces.KeyspacesDiff;
 import org.apache.cassandra.service.reads.repair.ReadRepairStrategy;
-import org.apache.cassandra.transport.ProtocolVersion;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.Simulate;
@@ -913,7 +912,7 @@ private static void addAggregateToSchemaMutation(UDAggregate aggregate, Mutation
                .add("final_func", aggregate.finalFunction() != null ? aggregate.finalFunction().name().name : null)
                .add("initcond", aggregate.initialCondition() != null
                                 // must use the frozen state type here, as 'null' for unfrozen collections may mean 'empty'
-                                ? aggregate.stateType().freeze().asCQL3Type().toCQLLiteral(aggregate.initialCondition(), ProtocolVersion.CURRENT)
+                                ? aggregate.stateType().freeze().asCQL3Type().toCQLLiteral(aggregate.initialCondition())
                                 : null);
     }
 

File: src/java/org/apache/cassandra/schema/TableMetadata.java
Patch:
@@ -65,7 +65,6 @@
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.service.reads.SpeculativeRetryPolicy;
-import org.apache.cassandra.transport.ProtocolVersion;
 import org.apache.cassandra.utils.AbstractIterator;
 import org.github.jamm.Unmetered;
 
@@ -1530,7 +1529,7 @@ public String primaryKeyAsCQLLiteral(ByteBuffer partitionKey, Clustering<?> clus
 
     private static String asCQLLiteral(AbstractType<?> type, ByteBuffer value)
     {
-        return type.asCQL3Type().toCQLLiteral(value, ProtocolVersion.CURRENT);
+        return type.asCQL3Type().toCQLLiteral(value);
     }
 
     public static class CompactTableMetadata extends TableMetadata

File: src/java/org/apache/cassandra/serializers/CounterSerializer.java
Patch:
@@ -19,4 +19,5 @@
 
 public class CounterSerializer extends LongSerializer
 {
+    public static final CounterSerializer instance = new CounterSerializer();
 }

File: src/java/org/apache/cassandra/serializers/ListSerializer.java
Patch:
@@ -72,6 +72,8 @@ public int getElementCount(List<T> value)
     @Override
     public <V> void validate(V input, ValueAccessor<V> accessor)
     {
+        if (accessor.isEmpty(input))
+            throw new MarshalException("Not enough bytes to read a list");
         try
         {
             int n = readCollectionSize(input, accessor);

File: src/java/org/apache/cassandra/serializers/MapSerializer.java
Patch:
@@ -87,6 +87,8 @@ public int getElementCount(Map<K, V> value)
     @Override
     public <T> void validate(T input, ValueAccessor<T> accessor)
     {
+        if (accessor.isEmpty(input))
+            throw new MarshalException("Not enough bytes to read a map");
         try
         {
             // Empty values are still valid.

File: src/java/org/apache/cassandra/serializers/SetSerializer.java
Patch:
@@ -76,6 +76,8 @@ public int getElementCount(Set<T> value)
     @Override
     public <V> void validate(V input, ValueAccessor<V> accessor)
     {
+        if (accessor.isEmpty(input))
+            throw new MarshalException("Not enough bytes to read a set");
         try
         {
             // Empty values are still valid.

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -66,7 +66,6 @@
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.exceptions.StartupException;
 import org.apache.cassandra.gms.Gossiper;
-import org.apache.cassandra.io.sstable.SSTableHeaderFix;
 import org.apache.cassandra.io.util.File;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.locator.InetAddressAndPort;
@@ -295,8 +294,6 @@ protected void setup()
 
         setupVirtualKeyspaces();
 
-        SSTableHeaderFix.fixNonFrozenUDTIfUpgradeFrom30();
-
         try
         {
             scrubDataDirectories();

File: src/java/org/apache/cassandra/transport/messages/ExecuteMessage.java
Patch:
@@ -224,7 +224,7 @@ private void traceQuery(QueryState state, QueryHandler.Prepared prepared)
         {
             ColumnSpecification cs = prepared.statement.getBindVariables().get(i);
             String boundName = cs.name.toString();
-            String boundValue = cs.type.asCQL3Type().toCQLLiteral(options.getValues().get(i), options.getProtocolVersion());
+            String boundValue = cs.type.asCQL3Type().toCQLLiteral(options.getValues().get(i));
             if (boundValue.length() > 1000)
                 boundValue = boundValue.substring(0, 1000) + "...'";
 

File: src/java/org/apache/cassandra/utils/ByteBufferUtil.java
Patch:
@@ -734,6 +734,8 @@ public static int readShortLength(ByteBuffer bb)
     // changes bb position
     public static void writeShortLength(ByteBuffer bb, int length)
     {
+        if (length > FBUtilities.MAX_UNSIGNED_SHORT)
+            throw new IllegalArgumentException(String.format("Length %d > max length %d", length, FBUtilities.MAX_UNSIGNED_SHORT));
         bb.put((byte) ((length >> 8) & 0xFF));
         bb.put((byte) (length & 0xFF));
     }

File: test/unit/org/apache/cassandra/cql3/ViewAbstractParameterizedTest.java
Patch:
@@ -54,7 +54,7 @@ public void beforeTest() throws Throwable
     }
 
     @Override
-    protected com.datastax.driver.core.ResultSet executeNet(String query, Object... values) throws Throwable
+    protected com.datastax.driver.core.ResultSet executeNet(String query, Object... values)
     {
         return executeNet(version, query, values);
     }

File: test/unit/org/apache/cassandra/cql3/validation/operations/AggregationTest.java
Patch:
@@ -1981,7 +1981,7 @@ public void testCustomTypeInitcond() throws Throwable
 
             AbstractType<?> compositeType = TypeParser.parse(type);
             ByteBuffer compositeTypeValue = compositeType.fromString("s@foo:i@32");
-            String compositeTypeString = compositeType.asCQL3Type().toCQLLiteral(compositeTypeValue, ProtocolVersion.CURRENT);
+            String compositeTypeString = compositeType.asCQL3Type().toCQLLiteral(compositeTypeValue);
             // ensure that the composite type is serialized using the 'blob syntax'
             assertTrue(compositeTypeString.startsWith("0x"));
 

File: test/unit/org/apache/cassandra/net/MessageSerializationPropertyTest.java
Patch:
@@ -69,7 +69,7 @@ public void serializeSizeProperty()
     {
         try (DataOutputBuffer out = new DataOutputBuffer(1024))
         {
-            qt().forAll(MESSAGE_GEN).checkAssert(orFail(message -> {
+            qt().withShrinkCycles(0).forAll(MESSAGE_GEN).checkAssert(orFail(message -> {
                 for (MessagingService.Version version : MessagingService.Version.values())
                 {
                     out.clear();
@@ -97,7 +97,7 @@ public void testMessageSerialization() throws Exception
         try (DataOutputBuffer first = new DataOutputBuffer(1024);
              DataOutputBuffer second = new DataOutputBuffer(1024))
         {
-            qt().forAll(MESSAGE_GEN).checkAssert(orFail(message -> {
+            qt().withShrinkCycles(0).forAll(MESSAGE_GEN).checkAssert(orFail(message -> {
                 withTable(schema, message, orFail(ignore -> {
                     for (MessagingService.Version version : MessagingService.Version.values())
                     {

File: src/java/org/apache/cassandra/cql3/statements/DescribeStatement.java
Patch:
@@ -472,7 +472,7 @@ public static DescribeStatement<SchemaElement> table(String keyspace, String nam
     {
         return new Element(keyspace, name, (ks, t) -> {
 
-            TableMetadata table = checkNotNull(ks.getTableOrViewNullable(t),
+            TableMetadata table = checkNotNull(ks.getTableNullable(t),
                                                "Table '%s' not found in keyspace '%s'", t, ks.name);
 
             return Stream.concat(Stream.of(table), table.indexes.stream()

File: src/java/org/apache/cassandra/db/marshal/AbstractCompositeType.java
Patch:
@@ -266,6 +266,7 @@ public Term fromJSONObject(Object parsed)
     @Override
     public String toJSONString(ByteBuffer buffer, ProtocolVersion protocolVersion)
     {
+        // TODO: suport toJSONString (CASSANDRA-18177)
         throw new UnsupportedOperationException();
     }
 

File: src/java/org/apache/cassandra/tools/SSTableExport.java
Patch:
@@ -50,6 +50,8 @@
 import org.apache.cassandra.schema.TableMetadataRef;
 import org.apache.cassandra.utils.FBUtilities;
 
+import static org.apache.cassandra.config.CassandraRelevantProperties.TEST_UTIL_ALLOW_TOOL_REINIT_FOR_TEST;
+
 /**
  * Export SSTables to JSON format.
  */
@@ -72,7 +74,7 @@ public class SSTableExport
 
     static
     {
-        DatabaseDescriptor.toolInitialization();
+        DatabaseDescriptor.toolInitialization(!TEST_UTIL_ALLOW_TOOL_REINIT_FOR_TEST.getBoolean());
 
         Option optKey = new Option(KEY_OPTION, true, "List of included partition keys");
         // Number of times -k <key> can be passed on the command line.

File: test/unit/org/apache/cassandra/utils/FBUtilitiesTest.java
Patch:
@@ -158,7 +158,7 @@ public void testNewPartitionerLocalPartitioner()
                 IPartitioner partitioner = FBUtilities.newPartitioner(name, Optional.of(type));
                 Assert.assertTrue(String.format("%s != LocalPartitioner", partitioner.toString()),
                                   LocalPartitioner.class.isInstance(partitioner));
-                Assert.assertEquals(partitioner.partitionOrdering(), type);
+                Assert.assertEquals(partitioner.partitionOrdering(null), type);
             }
     }
 

File: test/unit/org/apache/cassandra/utils/bytecomparable/AbstractTypeByteSourceTest.java
Patch:
@@ -687,7 +687,7 @@ public void testPartitionerDefinedOrder()
         );
         for (IPartitioner partitioner : partitioners)
         {
-            AbstractType<?> partitionOrdering = partitioner.partitionOrdering();
+            AbstractType<?> partitionOrdering = partitioner.partitionOrdering(null);
             Assert.assertTrue(partitionOrdering instanceof PartitionerDefinedOrder);
             for (ByteBuffer input : byteBuffers)
             {

File: src/java/org/apache/cassandra/db/TypeSizes.java
Patch:
@@ -29,6 +29,7 @@ private TypeSizes(){}
 
     public static final int BOOL_SIZE = 1;
     public static final int BYTE_SIZE = 1;
+    public static final int CHAR_SIZE = 2;
     public static final int SHORT_SIZE = 2;
     public static final int INT_SIZE = 4;
     public static final int LONG_SIZE = 8;

File: src/java/org/apache/cassandra/tools/nodetool/DescribeCluster.java
Patch:
@@ -119,7 +119,7 @@ public void execute(NodeProbe probe)
             for (InetAddressAndPort endpoint : hostToTokens.keySet())
             {
                 totalNodes++;
-                if (unreachableNodes.contains(endpoint.toString()))
+                if (unreachableNodes.contains(endpoint.getHostAddressAndPort()))
                     downNodes++;
             }
             out.print(" #Nodes: " + totalNodes);

File: src/java/org/apache/cassandra/db/ClusteringComparator.java
Patch:
@@ -351,7 +351,7 @@ public String toString()
      */
     public <V> Clustering<V> clusteringFromByteComparable(ValueAccessor<V> accessor, ByteComparable comparable)
     {
-        ByteComparable.Version version = ByteComparable.Version.OSS42;
+        ByteComparable.Version version = ByteComparable.Version.OSS50;
         ByteSource.Peekable orderedBytes = ByteSource.peekable(comparable.asComparableBytes(version));
 
         // First check for special cases (partition key only, static clustering) that can do without buffers.
@@ -415,7 +415,7 @@ public <V> ClusteringBound<V> boundFromByteComparable(ValueAccessor<V> accessor,
                                                           ByteComparable comparable,
                                                           boolean isEnd)
     {
-        ByteComparable.Version version = ByteComparable.Version.OSS42;
+        ByteComparable.Version version = ByteComparable.Version.OSS50;
         ByteSource.Peekable orderedBytes = ByteSource.peekable(comparable.asComparableBytes(version));
 
         int sep = orderedBytes.next();
@@ -472,7 +472,7 @@ public <V> ClusteringBound<V> boundFromByteComparable(ValueAccessor<V> accessor,
      */
     public <V> ClusteringBoundary<V> boundaryFromByteComparable(ValueAccessor<V> accessor, ByteComparable comparable)
     {
-        ByteComparable.Version version = ByteComparable.Version.OSS42;
+        ByteComparable.Version version = ByteComparable.Version.OSS50;
         ByteSource.Peekable orderedBytes = ByteSource.peekable(comparable.asComparableBytes(version));
 
         int sep = orderedBytes.next();

File: src/java/org/apache/cassandra/db/marshal/TupleType.java
Patch:
@@ -209,7 +209,7 @@ public <V> ByteSource asComparableBytes(ValueAccessor<V> accessor, V data, ByteC
         {
             case LEGACY:
                 return asComparableBytesLegacy(accessor, data);
-            case OSS42:
+            case OSS50:
                 return asComparableBytesNew(accessor, data, version);
             default:
                 throw new AssertionError();
@@ -255,7 +255,7 @@ private <V> ByteSource asComparableBytesNew(ValueAccessor<V> accessor, V data, B
     @Override
     public <V> V fromComparableBytes(ValueAccessor<V> accessor, ByteSource.Peekable comparableBytes, ByteComparable.Version version)
     {
-        assert version == ByteComparable.Version.OSS42; // Reverse translation is not supported for the legacy version.
+        assert version == ByteComparable.Version.OSS50; // Reverse translation is not supported for the legacy version.
         if (comparableBytes == null)
             return accessor.empty();
 

File: src/java/org/apache/cassandra/db/memtable/TrieMemtable.java
Patch:
@@ -115,7 +115,7 @@ public class TrieMemtable extends AbstractShardedMemtable
     public static final int MAX_RECURSIVE_KEY_LENGTH = 128;
 
     /** The byte-ordering conversion version to use for memtables. */
-    public static final ByteComparable.Version BYTE_COMPARABLE_VERSION = ByteComparable.Version.OSS42;
+    public static final ByteComparable.Version BYTE_COMPARABLE_VERSION = ByteComparable.Version.OSS50;
 
     // Set to true when the memtable requests a switch (e.g. for trie size limit being reached) to ensure only one
     // thread calls cfs.switchMemtableIfCurrent.

File: src/java/org/apache/cassandra/db/tries/Trie.java
Patch:
@@ -270,7 +270,7 @@ protected interface Walker<T, R> extends ResettingTransitionsReceiver
     }
 
     // Version of the byte comparable conversion to use for all operations
-    protected static final ByteComparable.Version BYTE_COMPARABLE_VERSION = ByteComparable.Version.OSS42;
+    protected static final ByteComparable.Version BYTE_COMPARABLE_VERSION = ByteComparable.Version.OSS50;
 
     /**
      * Adapter interface providing the methods a {@link Walker} to a {@link Consumer}, so that the latter can be used

File: src/java/org/apache/cassandra/io/tries/Walker.java
Patch:
@@ -58,7 +58,7 @@ public class Walker<CONCRETE extends Walker<CONCRETE>> implements AutoCloseable
     protected long lesserBranch;
 
     // Version of the byte comparable conversion to use
-    public static final ByteComparable.Version BYTE_COMPARABLE_VERSION = ByteComparable.Version.OSS42;
+    public static final ByteComparable.Version BYTE_COMPARABLE_VERSION = ByteComparable.Version.OSS50;
 
     /**
      * Creates a walker. Rebufferer must be aligned and with a buffer size that is at least 4k.

File: src/java/org/apache/cassandra/utils/bytecomparable/ByteComparable.java
Patch:
@@ -37,7 +37,7 @@ public interface ByteComparable
     enum Version
     {
         LEGACY, // Encoding used in legacy sstable format; forward (value to byte-comparable) translation only
-        OSS42,  // CASSANDRA 4.2 encoding
+        OSS50,  // CASSANDRA 5.0 encoding
     }
 
     ByteComparable EMPTY = (Version version) -> ByteSource.EMPTY;

File: test/microbench/org/apache/cassandra/test/microbench/AbstractTypeByteSourceDecodingBench.java
Patch:
@@ -61,7 +61,7 @@
 public class AbstractTypeByteSourceDecodingBench
 {
 
-    private static final ByteComparable.Version LATEST = ByteComparable.Version.OSS42;
+    private static final ByteComparable.Version LATEST = ByteComparable.Version.OSS50;
 
     private static final Map<AbstractType, BiFunction<Random, Integer, ByteSource.Peekable>> PEEKABLE_GENERATOR_BY_TYPE = new HashMap<>();
     static
@@ -135,6 +135,6 @@ public int baseline()
     public ByteBuffer fromComparableBytes()
     {
         ByteSource.Peekable peekableBytes = randomPeekableBytes();
-        return abstractType.fromComparableBytes(peekableBytes, ByteComparable.Version.OSS42);
+        return abstractType.fromComparableBytes(peekableBytes, ByteComparable.Version.OSS50);
     }
 }

File: test/unit/org/apache/cassandra/utils/bytecomparable/ByteSourceConversionTest.java
Patch:
@@ -58,7 +58,7 @@
 public class ByteSourceConversionTest extends ByteSourceTestBase
 {
     private final static Logger logger = LoggerFactory.getLogger(ByteSourceConversionTest.class);
-    public static final Version VERSION = Version.OSS42;
+    public static final Version VERSION = Version.OSS50;
 
     @Rule
     public final ExpectedException expectedException = ExpectedException.none();

File: test/unit/org/apache/cassandra/utils/bytecomparable/ByteSourceInverseTest.java
Patch:
@@ -47,7 +47,7 @@ public class ByteSourceInverseTest
     @Parameterized.Parameters(name = "version={0}")
     public static Iterable<ByteComparable.Version> versions()
     {
-        return ImmutableList.of(ByteComparable.Version.OSS42);
+        return ImmutableList.of(ByteComparable.Version.OSS50);
     }
 
     private final ByteComparable.Version version;
@@ -218,7 +218,7 @@ public void testBadByteSourceForVariableLengthNumbers()
             ArrayList<ByteSource> sources = new ArrayList<>();
             sources.add(null);
             sources.add(ByteSource.EMPTY);
-            int length = ByteComparable.length(version -> ByteSource.variableLengthInteger(value), ByteComparable.Version.OSS42);
+            int length = ByteComparable.length(version -> ByteSource.variableLengthInteger(value), ByteComparable.Version.OSS50);
             for (int i = 0; i < length; ++i)
                 sources.add(ByteSource.cut(ByteSource.variableLengthInteger(value), i));
 

File: test/unit/org/apache/cassandra/utils/bytecomparable/ByteSourceSequenceTest.java
Patch:
@@ -56,7 +56,7 @@ public class ByteSourceSequenceTest
     @Parameterized.Parameters(name = "version={0}")
     public static Iterable<ByteComparable.Version> versions()
     {
-        return ImmutableList.of(ByteComparable.Version.OSS42);
+        return ImmutableList.of(ByteComparable.Version.OSS50);
     }
 
     private final ByteComparable.Version version;

File: test/unit/org/apache/cassandra/utils/bytecomparable/DecoratedKeyByteSourceTest.java
Patch:
@@ -39,7 +39,7 @@ public class DecoratedKeyByteSourceTest
     @Parameterized.Parameters(name = "version={0}")
     public static Iterable<ByteComparable.Version> versions()
     {
-        return ImmutableList.of(ByteComparable.Version.OSS42);
+        return ImmutableList.of(ByteComparable.Version.OSS50);
     }
 
     private final ByteComparable.Version version;

File: test/unit/org/apache/cassandra/fql/FullQueryLoggerTest.java
Patch:
@@ -680,6 +680,7 @@ public void testJMXArchiveCommand()
 
         try
         {
+            DatabaseDescriptor.getFullQueryLogOptions().allow_nodetool_archive_command = false;
             StorageService.instance.enableFullQueryLogger(options.log_dir, options.roll_cycle, false, 1000, 1000, "/xyz/not/null", 0);
             fail("not allowed");
         }
@@ -688,6 +689,7 @@ public void testJMXArchiveCommand()
             assertTrue(e.getMessage().contains("Can't enable full query log archiving via nodetool"));
         }
 
+        options.allow_nodetool_archive_command = true;
         options.archive_command = "/xyz/not/null";
         options.log_dir = "/tmp/abc";
         DatabaseDescriptor.setFullQueryLogOptions(options);

File: test/unit/org/apache/cassandra/fql/FullQueryLoggerTest.java
Patch:
@@ -680,6 +680,7 @@ public void testJMXArchiveCommand()
 
         try
         {
+            DatabaseDescriptor.getFullQueryLogOptions().allow_nodetool_archive_command = false;
             StorageService.instance.enableFullQueryLogger(options.log_dir, options.roll_cycle, false, 1000, 1000, "/xyz/not/null", 0);
             fail("not allowed");
         }
@@ -688,6 +689,7 @@ public void testJMXArchiveCommand()
             assertTrue(e.getMessage().contains("Can't enable full query log archiving via nodetool"));
         }
 
+        options.allow_nodetool_archive_command = true;
         options.archive_command = "/xyz/not/null";
         options.log_dir = "/tmp/abc";
         DatabaseDescriptor.setFullQueryLogOptions(options);

File: test/unit/org/apache/cassandra/fql/FullQueryLoggerTest.java
Patch:
@@ -680,6 +680,7 @@ public void testJMXArchiveCommand()
 
         try
         {
+            DatabaseDescriptor.getFullQueryLogOptions().allow_nodetool_archive_command = false;
             StorageService.instance.enableFullQueryLogger(options.log_dir, options.roll_cycle, false, 1000, 1000, "/xyz/not/null", 0);
             fail("not allowed");
         }
@@ -688,6 +689,7 @@ public void testJMXArchiveCommand()
             assertTrue(e.getMessage().contains("Can't enable full query log archiving via nodetool"));
         }
 
+        options.allow_nodetool_archive_command = true;
         options.archive_command = "/xyz/not/null";
         options.log_dir = "/tmp/abc";
         DatabaseDescriptor.setFullQueryLogOptions(options);

File: src/java/org/apache/cassandra/config/YamlConfigurationLoader.java
Patch:
@@ -200,6 +200,8 @@ private static void verifyReplacements(Map<Class<?>, Map<String, Replacement>> r
         Yaml rawYaml = new Yaml(loaderOptions);
 
         Map<String, Object> rawConfig = rawYaml.load(new ByteArrayInputStream(configBytes));
+        if (rawConfig == null)
+            rawConfig = new HashMap<>();
         verifyReplacements(replacements, rawConfig);
 
     }

File: src/java/org/apache/cassandra/db/streaming/CassandraCompressedStreamReader.java
Patch:
@@ -76,7 +76,7 @@ public SSTableMultiWriter read(DataInputPlus inputPlus) throws Throwable
         {
             TrackedDataInputPlus in = new TrackedDataInputPlus(cis);
             deserializer = new StreamDeserializer(cfs.metadata(), in, inputVersion, getHeader(cfs.metadata()));
-            writer = createWriter(cfs, totalSize, repairedAt, pendingRepair, format);
+            writer = createWriter(cfs, totalSize, repairedAt, pendingRepair, inputVersion.format);
             String filename = writer.getFilename();
             String sectionName = filename + '-' + fileSeqNum;
             int sectionIdx = 0;

File: src/java/org/apache/cassandra/db/streaming/CassandraEntireSSTableStreamReader.java
Patch:
@@ -178,7 +178,7 @@ protected SSTableZeroCopyWriter createWriter(ColumnFamilyStore cfs, long totalSi
 
         LifecycleNewTracker lifecycleNewTracker = CassandraStreamReceiver.fromReceiver(session.getAggregator(tableId)).createLifecycleNewTracker();
 
-        Descriptor desc = cfs.newSSTableDescriptor(dataDir, header.version, header.format);
+        Descriptor desc = cfs.newSSTableDescriptor(dataDir, header.version);
 
         IOOptions ioOptions = new IOOptions(DatabaseDescriptor.getDiskOptimizationStrategy(),
                                             DatabaseDescriptor.getDiskAccessMode(),

File: src/java/org/apache/cassandra/db/streaming/CassandraOutgoingFile.java
Patch:
@@ -31,9 +31,9 @@
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.schema.TableId;
 import org.apache.cassandra.streaming.OutgoingStream;
-import org.apache.cassandra.streaming.StreamingDataOutputPlus;
 import org.apache.cassandra.streaming.StreamOperation;
 import org.apache.cassandra.streaming.StreamSession;
+import org.apache.cassandra.streaming.StreamingDataOutputPlus;
 import org.apache.cassandra.utils.TimeUUID;
 import org.apache.cassandra.utils.concurrent.Ref;
 
@@ -81,7 +81,6 @@ private static CassandraStreamHeader makeHeader(SSTableReader sstable,
                 : null;
 
         return CassandraStreamHeader.builder()
-                                    .withSSTableFormat(sstable.descriptor.formatType)
                                     .withSSTableVersion(sstable.descriptor.version)
                                     .withSSTableLevel(operation.keepSSTableLevel() ? sstable.getSSTableLevel() : 0)
                                     .withEstimatedKeys(estimatedKeys)

File: src/java/org/apache/cassandra/gms/ApplicationState.java
Patch:
@@ -52,7 +52,7 @@ public enum ApplicationState
      * which new sstables are written), but may contain more on newly upgraded nodes before `upgradesstable` has been
      * run.
      *
-     * <p>The value (a set of sstable {@link org.apache.cassandra.io.sstable.format.VersionAndType}) is serialized as
+     * <p>The value (a set of sstable {@link org.apache.cassandra.io.sstable.format.Version}) is serialized as
      * a comma-separated list.
      **/
     SSTABLE_VERSIONS,

File: src/java/org/apache/cassandra/io/sstable/RangeAwareSSTableWriter.java
Patch:
@@ -45,7 +45,7 @@ public class RangeAwareSSTableWriter implements SSTableMultiWriter
     private final long repairedAt;
     private final TimeUUID pendingRepair;
     private final boolean isTransient;
-    private final SSTableFormat.Type format;
+    private final SSTableFormat<?, ?> format;
     private final SerializationHeader header;
     private final LifecycleNewTracker lifecycleNewTracker;
     private int currentIndex = -1;
@@ -54,7 +54,7 @@ public class RangeAwareSSTableWriter implements SSTableMultiWriter
     private final List<SSTableReader> finishedReaders = new ArrayList<>();
     private SSTableMultiWriter currentWriter = null;
 
-    public RangeAwareSSTableWriter(ColumnFamilyStore cfs, long estimatedKeys, long repairedAt, TimeUUID pendingRepair, boolean isTransient, SSTableFormat.Type format, int sstableLevel, long totalSize, LifecycleNewTracker lifecycleNewTracker, SerializationHeader header) throws IOException
+    public RangeAwareSSTableWriter(ColumnFamilyStore cfs, long estimatedKeys, long repairedAt, TimeUUID pendingRepair, boolean isTransient, SSTableFormat<?, ?> format, int sstableLevel, long totalSize, LifecycleNewTracker lifecycleNewTracker, SerializationHeader header) throws IOException
     {
         DiskBoundaries db = cfs.getDiskBoundaries();
         directories = db.directories;

File: src/java/org/apache/cassandra/io/sstable/SSTable.java
Patch:
@@ -290,7 +290,7 @@ public static Descriptor tryDescriptorFromFile(File file)
     @Override
     public String toString()
     {
-        return String.format("%s:%s(path='%s')", getClass().getSimpleName(), descriptor.formatType.name, getFilename());
+        return String.format("%s:%s(path='%s')", getClass().getSimpleName(), descriptor.version.format.name(), getFilename());
     }
 
     public static void validateRepairedMetadata(long repairedAt, TimeUUID pendingRepair, boolean isTransient)
@@ -349,7 +349,7 @@ public B setComponents(Collection<Component> components)
         {
             if (components != null)
             {
-                components.forEach(c -> Preconditions.checkState(c.isValidFor(descriptor), "Invalid component type for sstable format " + descriptor.formatType.name));
+                components.forEach(c -> Preconditions.checkState(c.isValidFor(descriptor), "Invalid component type for sstable format " + descriptor.version.format.name()));
                 this.components = ImmutableSet.copyOf(components);
             }
             else

File: src/java/org/apache/cassandra/io/sstable/SSTableSimpleUnsortedWriter.java
Patch:
@@ -83,7 +83,7 @@ PartitionUpdate.Builder getUpdateFor(DecoratedKey key)
         {
             // todo: inefficient - we create and serialize a PU just to get its size, then recreate it
             // todo: either allow PartitionUpdateBuilder to have .build() called several times or pre-calculate the size
-            currentSize += PartitionUpdate.serializer.serializedSize(createPartitionUpdateBuilder(key).build(), formatType.info.getLatestVersion().correspondingMessagingVersion());
+            currentSize += PartitionUpdate.serializer.serializedSize(createPartitionUpdateBuilder(key).build(), format.getLatestVersion().correspondingMessagingVersion());
             previous = createPartitionUpdateBuilder(key);
             buffer.put(key, previous);
         }
@@ -97,7 +97,7 @@ private void countRow(Row row)
         // improve that. In particular, what we count is closer to the serialized value, but it's debatable that it's the right thing
         // to count since it will take a lot more space in memory and the bufferSize if first and foremost used to avoid OOM when
         // using this writer.
-        currentSize += UnfilteredSerializer.serializer.serializedSize(row, helper, 0, formatType.info.getLatestVersion().correspondingMessagingVersion());
+        currentSize += UnfilteredSerializer.serializer.serializedSize(row, helper, 0, format.getLatestVersion().correspondingMessagingVersion());
     }
 
     private void maybeSync() throws SyncException

File: src/java/org/apache/cassandra/io/sstable/SSTableTxnWriter.java
Patch:
@@ -112,7 +112,7 @@ public static SSTableTxnWriter createRangeAware(TableMetadataRef metadata,
                                                     long repairedAt,
                                                     TimeUUID pendingRepair,
                                                     boolean isTransient,
-                                                    SSTableFormat.Type type,
+                                                    SSTableFormat<?, ?> type,
                                                     int sstableLevel,
                                                     SerializationHeader header)
     {

File: src/java/org/apache/cassandra/io/sstable/format/TOCComponent.java
Patch:
@@ -68,7 +68,7 @@ public static Set<Component> loadTOC(Descriptor descriptor, boolean skipMissing)
         Set<Component> components = Sets.newHashSetWithExpectedSize(componentNames.size());
         for (String componentName : componentNames)
         {
-            Component component = Component.parse(componentName, descriptor.formatType);
+            Component component = Component.parse(componentName, descriptor.version.format);
             if (skipMissing && !descriptor.fileFor(component).exists())
                 logger.error("Missing component: {}", descriptor.fileFor(component));
             else

File: src/java/org/apache/cassandra/io/sstable/format/big/RowIndexEntry.java
Patch:
@@ -137,6 +137,7 @@
  */
 public class RowIndexEntry extends AbstractRowIndexEntry
 {
+    private static final BigFormat FORMAT = BigFormat.getInstance();
     private static final long EMPTY_SIZE = ObjectSizes.measure(new RowIndexEntry(0));
 
     // constants for type of row-index-entry as serialized for saved-cache
@@ -192,7 +193,7 @@ public int columnsIndexCount()
     @Override
     public BigFormat getSSTableFormat()
     {
-        return BigFormat.getInstance();
+        return FORMAT;
     }
 
     @Override

File: src/java/org/apache/cassandra/io/sstable/indexsummary/IndexSummarySupport.java
Patch:
@@ -30,8 +30,8 @@ public interface IndexSummarySupport<T extends SSTableReader & IndexSummarySuppo
 
     T cloneWithNewSummarySamplingLevel(ColumnFamilyStore cfs, int newSamplingLevel) throws IOException;
 
-    static boolean isSupportedBy(SSTableFormat.Type formatType)
+    static boolean isSupportedBy(SSTableFormat<?, ?> format)
     {
-        return IndexSummarySupport.class.isAssignableFrom(formatType.info.getReaderFactory().getReaderClass());
+        return IndexSummarySupport.class.isAssignableFrom(format.getReaderFactory().getReaderClass());
     }
 }

File: src/java/org/apache/cassandra/tools/SSTableMetadataViewer.java
Patch:
@@ -327,7 +327,7 @@ private void printSStableMetadata(File file, boolean scan) throws IOException
         }
 
         field("SSTable", descriptor);
-        if (scan && descriptor.version.getVersion().compareTo("ma") >= 0)
+        if (scan && descriptor.version.version.compareTo("ma") >= 0)
         {
             printScannedOverview(descriptor, stats);
         }

File: src/java/org/apache/cassandra/tools/StandaloneUpgrader.java
Patch:
@@ -39,7 +39,6 @@
 import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
 import org.apache.cassandra.io.sstable.Component;
 import org.apache.cassandra.io.sstable.Descriptor;
-import org.apache.cassandra.io.sstable.format.SSTableFormat;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.schema.Schema;
 import org.apache.cassandra.utils.JVMStabilityInspector;
@@ -95,7 +94,7 @@ public static void main(String args[])
                 try
                 {
                     SSTableReader sstable = SSTableReader.openNoValidation(entry.getKey(), components, cfs);
-                    if (sstable.descriptor.version.equals(SSTableFormat.Type.current().info.getLatestVersion()))
+                    if (sstable.descriptor.version.equals(DatabaseDescriptor.getSelectedSSTableFormat().getLatestVersion()))
                     {
                         sstable.selfRef().release();
                         continue;

File: src/java/org/apache/cassandra/tools/Util.java
Patch:
@@ -309,7 +309,7 @@ public static <T> Stream<T> iterToStream(Iterator<T> iter)
     public static TableMetadata metadataFromSSTable(Descriptor desc) throws IOException
     {
         if (!desc.version.isCompatible())
-            throw new IOException("Unsupported SSTable version " + desc.getFormat().getType().name + "/" + desc.version);
+            throw new IOException("Unsupported SSTable version " + desc.getFormat().name() + "/" + desc.version);
 
         StatsComponent statsComponent = StatsComponent.load(desc, MetadataType.STATS, MetadataType.HEADER);
         SerializationHeader.Component header = statsComponent.serializationHeader();

File: test/microbench/org/apache/cassandra/test/microbench/ZeroCopyStreamingBenchmark.java
Patch:
@@ -54,7 +54,6 @@
 import org.apache.cassandra.net.AsyncStreamingOutputPlus;
 import org.apache.cassandra.schema.CachingParams;
 import org.apache.cassandra.schema.KeyspaceParams;
-import org.apache.cassandra.streaming.async.NettyStreamingConnectionFactory;
 import org.apache.cassandra.streaming.PreviewKind;
 import org.apache.cassandra.streaming.SessionInfo;
 import org.apache.cassandra.streaming.StreamCoordinator;
@@ -63,6 +62,7 @@
 import org.apache.cassandra.streaming.StreamResultFuture;
 import org.apache.cassandra.streaming.StreamSession;
 import org.apache.cassandra.streaming.StreamSummary;
+import org.apache.cassandra.streaming.async.NettyStreamingConnectionFactory;
 import org.apache.cassandra.streaming.messages.StreamMessageHeader;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
@@ -134,7 +134,6 @@ public void setupBenchmark() throws IOException
 
             CassandraStreamHeader entireSSTableStreamHeader =
                 CassandraStreamHeader.builder()
-                                     .withSSTableFormat(sstable.descriptor.formatType)
                                      .withSSTableVersion(sstable.descriptor.version)
                                      .withSSTableLevel(0)
                                      .withEstimatedKeys(sstable.estimatedKeys())
@@ -154,7 +153,6 @@ public void setupBenchmark() throws IOException
             List<Range<Token>> requestedRanges = Arrays.asList(new Range<>(sstable.first.minValue().getToken(), sstable.last.getToken()));
             CassandraStreamHeader partialSSTableStreamHeader =
             CassandraStreamHeader.builder()
-                                 .withSSTableFormat(sstable.descriptor.formatType)
                                  .withSSTableVersion(sstable.descriptor.version)
                                  .withSSTableLevel(0)
                                  .withEstimatedKeys(sstable.estimatedKeys())

File: test/unit/org/apache/cassandra/Util.java
Patch:
@@ -115,7 +115,6 @@
 import org.apache.cassandra.io.sstable.SSTableLoader;
 import org.apache.cassandra.io.sstable.SequenceBasedSSTableId;
 import org.apache.cassandra.io.sstable.UUIDBasedSSTableId;
-import org.apache.cassandra.io.sstable.format.SSTableFormat;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.io.sstable.format.SSTableReaderWithFilter;
 import org.apache.cassandra.io.util.DataInputPlus;
@@ -1260,6 +1259,6 @@ public static DataInputStreamPlus wrap(InputStream in)
 
     public static RuntimeException testMustBeImplementedForSSTableFormat()
     {
-        return new UnsupportedOperationException("Test must be implemented for sstable format " + SSTableFormat.Type.current().info.getClass().getName());
+        return new UnsupportedOperationException("Test must be implemented for sstable format " + DatabaseDescriptor.getSelectedSSTableFormat().getClass().getName());
     }
 }

File: test/unit/org/apache/cassandra/cache/AutoSavingCacheTest.java
Patch:
@@ -31,7 +31,6 @@
 import org.apache.cassandra.db.marshal.AsciiType;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.io.sstable.AbstractRowIndexEntry;
-import org.apache.cassandra.io.sstable.format.SSTableFormat;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.io.sstable.keycache.KeyCacheSupport;
 import org.apache.cassandra.schema.ColumnMetadata;
@@ -51,7 +50,7 @@ public class AutoSavingCacheTest
     public static void defineSchema() throws ConfigurationException
     {
         DatabaseDescriptor.daemonInitialization();
-        Assume.assumeTrue(KeyCacheSupport.isSupportedBy(SSTableFormat.Type.current()));
+        Assume.assumeTrue(KeyCacheSupport.isSupportedBy(DatabaseDescriptor.getSelectedSSTableFormat()));
         SchemaLoader.prepareServer();
         SchemaLoader.createKeyspace(KEYSPACE1,
                                     KeyspaceParams.simple(1),

File: test/unit/org/apache/cassandra/cql3/KeyCacheCqlTest.java
Patch:
@@ -34,7 +34,6 @@
 import org.apache.cassandra.db.Keyspace;
 import org.apache.cassandra.index.Index;
 import org.apache.cassandra.io.sstable.filter.BloomFilterMetrics;
-import org.apache.cassandra.io.sstable.format.SSTableFormat;
 import org.apache.cassandra.io.sstable.keycache.KeyCacheSupport;
 import org.apache.cassandra.metrics.CacheMetrics;
 import org.apache.cassandra.metrics.CassandraMetricsRegistry;
@@ -102,7 +101,7 @@ public static void setUpClass()
     {
         CachingParams.DEFAULT = CachingParams.CACHE_NOTHING;
         CQLTester.setUpClass();
-        sstableImplCachesKeys = KeyCacheSupport.isSupportedBy(SSTableFormat.Type.current());
+        sstableImplCachesKeys = KeyCacheSupport.isSupportedBy(DatabaseDescriptor.getSelectedSSTableFormat());
     }
 
     /**
@@ -619,7 +618,7 @@ private static void triggerBlockingFlush(Index index) throws Exception
 
     private long recentBloomFilterFalsePositives()
     {
-        return getCurrentColumnFamilyStore(KEYSPACE_PER_TEST).metric.formatSpecificGauges.get(SSTableFormat.Type.current())
+        return getCurrentColumnFamilyStore(KEYSPACE_PER_TEST).metric.formatSpecificGauges.get(DatabaseDescriptor.getSelectedSSTableFormat())
                                                                                          .get(BloomFilterMetrics.instance.recentBloomFilterFalsePositives.name)
                                                                                          .getValue()
                                                                                          .longValue();

File: test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
Patch:
@@ -349,7 +349,7 @@ public void testBackupAfterFlush() throws Throwable
                                              KEYSPACE2,
                                              CF_STANDARD1,
                                              liveSSTable.descriptor.id,
-                                             liveSSTable.descriptor.formatType);
+                                             liveSSTable.descriptor.version.format);
             for (Component c : liveSSTable.getComponents())
                 assertTrue("Cannot find backed-up file:" + desc.fileFor(c), desc.fileFor(c).exists());
         }

File: test/unit/org/apache/cassandra/db/SerializationHeaderTest.java
Patch:
@@ -66,7 +66,7 @@ public class SerializationHeaderTest
     @Test
     public void testWrittenAsDifferentKind() throws Exception
     {
-        SSTableFormat<?, ?> format = SSTableFormat.Type.current().info;
+        SSTableFormat<?, ?> format = DatabaseDescriptor.getSelectedSSTableFormat();
         final String tableName = "testWrittenAsDifferentKind";
         ColumnIdentifier v = ColumnIdentifier.getInterned("v", false);
         TableMetadata schemaWithStatic = TableMetadata.builder(KEYSPACE, tableName)
@@ -91,7 +91,7 @@ public void testWrittenAsDifferentKind() throws Exception
         try
         {
             BiFunction<TableMetadata, Function<ByteBuffer, Clustering<?>>, Callable<Descriptor>> writer = (schema, clusteringFunction) -> () -> {
-                Descriptor descriptor = new Descriptor(format.getLatestVersion(), dir, schema.keyspace, schema.name, id.get(), format.getType());
+                Descriptor descriptor = new Descriptor(format.getLatestVersion(), dir, schema.keyspace, schema.name, id.get());
 
                 SerializationHeader header = SerializationHeader.makeWithoutStats(schema);
                 try (LifecycleTransaction txn = LifecycleTransaction.offline(OperationType.WRITE);

File: test/unit/org/apache/cassandra/db/lifecycle/LogTransactionTest.java
Patch:
@@ -41,6 +41,7 @@
 import org.junit.Test;
 
 import org.apache.cassandra.Util;
+import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.db.Directories;
@@ -49,7 +50,6 @@
 import org.apache.cassandra.io.sstable.Component;
 import org.apache.cassandra.io.sstable.Descriptor;
 import org.apache.cassandra.io.sstable.SequenceBasedSSTableId;
-import org.apache.cassandra.io.sstable.format.SSTableFormat;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.io.sstable.format.big.BigFormat;
 import org.apache.cassandra.io.sstable.format.big.BigFormat.Components;
@@ -1262,7 +1262,7 @@ private static SSTableReader sstable(File dataFolder, ColumnFamilyStore cfs, int
     {
         if (BigFormat.isDefault())
         {
-            Descriptor descriptor = new Descriptor(dataFolder, cfs.keyspace.getName(), cfs.getTableName(), new SequenceBasedSSTableId(generation), SSTableFormat.Type.current());
+            Descriptor descriptor = new Descriptor(dataFolder, cfs.keyspace.getName(), cfs.getTableName(), new SequenceBasedSSTableId(generation), DatabaseDescriptor.getSelectedSSTableFormat());
             Set<Component> components = ImmutableSet.of(Components.DATA, Components.PRIMARY_INDEX, Components.FILTER, Components.TOC);
             for (Component component : components)
             {
@@ -1297,7 +1297,7 @@ private static SSTableReader sstable(File dataFolder, ColumnFamilyStore cfs, int
         }
         else
         {
-            throw new UnsupportedOperationException("Please implement this method for sstable format: " + SSTableFormat.Type.current().info.getClass().getName());
+            throw new UnsupportedOperationException("Please implement this method for sstable format: " + DatabaseDescriptor.getSelectedSSTableFormat().getClass().getName());
         }
     }
 

File: test/unit/org/apache/cassandra/db/streaming/ComponentManifestTest.java
Patch:
@@ -41,7 +41,7 @@ public static void beforeClass()
     public void testSerialization()
     {
         ComponentManifest expected = new ComponentManifest(new LinkedHashMap<Component, Long>() {{ put(Components.DATA, 100L); }});
-        SerializationUtils.assertSerializationCycle(expected, ComponentManifest.serializers.get(BigFormat.getInstance().getType()));
+        SerializationUtils.assertSerializationCycle(expected, ComponentManifest.serializers.get(BigFormat.getInstance().name()));
     }
 
     // Propose removing this test which now fails on VIntOutOfRange

File: test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java
Patch:
@@ -226,7 +226,7 @@ public void testSASIComponentsAddedToSnapshot() throws Throwable
                                                             sstable.getKeyspaceName(),
                                                             sstable.getColumnFamilyName(),
                                                             sstable.descriptor.id,
-                                                            sstable.descriptor.formatType);
+                                                            sstable.descriptor.version.format);
 
                 Set<Component> components = snapshotSSTables.get(snapshotSSTable);
 
@@ -236,7 +236,7 @@ public void testSASIComponentsAddedToSnapshot() throws Throwable
                 for (Component c : components)
                 {
                     long componentSize = snapshotSSTable.fileFor(c).length();
-                    if (Component.Type.fromRepresentation(c.name, sstable.descriptor.formatType) == Components.Types.SECONDARY_INDEX)
+                    if (Component.Type.fromRepresentation(c.name, sstable.descriptor.version.format) == Components.Types.SECONDARY_INDEX)
                         indexSize += componentSize;
                     else
                         tableSize += componentSize;

File: test/unit/org/apache/cassandra/io/DiskSpaceMetricsTest.java
Patch:
@@ -31,13 +31,13 @@
 import org.junit.Test;
 
 import org.apache.cassandra.Util;
+import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.cql3.CQLTester;
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.compaction.CompactionInterruptedException;
 import org.apache.cassandra.db.compaction.OperationType;
 import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
 import org.apache.cassandra.db.lifecycle.SSTableSet;
-import org.apache.cassandra.io.sstable.format.SSTableFormat;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.io.sstable.indexsummary.IndexSummaryManager;
 import org.apache.cassandra.io.sstable.indexsummary.IndexSummaryRedistribution;
@@ -75,7 +75,7 @@ public void baseline() throws Throwable
     @Test
     public void summaryRedistribution() throws Throwable
     {
-        Assume.assumeTrue(IndexSummarySupport.isSupportedBy(SSTableFormat.Type.current()));
+        Assume.assumeTrue(IndexSummarySupport.isSupportedBy(DatabaseDescriptor.getSelectedSSTableFormat()));
         createTable("CREATE TABLE %s (pk bigint, PRIMARY KEY (pk)) WITH min_index_interval=1");
         ColumnFamilyStore cfs = getCurrentColumnFamilyStore();
 

File: test/unit/org/apache/cassandra/io/sstable/LegacySSTableTest.java
Patch:
@@ -592,7 +592,7 @@ private static void loadLegacyTable(String tablePattern, String legacyVersion) t
     /**
      * Generates sstables for 8 CQL tables (see {@link #createTables(String)}) in <i>current</i>
      * sstable format (version) into {@code test/data/legacy-sstables/VERSION}, where
-     * {@code VERSION} matches {@link Version#getVersion() BigFormat.latestVersion.getVersion()}.
+     * {@code VERSION} matches {@link Version#version BigFormat.latestVersion.getVersion()}.
      * <p>
      * Run this test alone (e.g. from your IDE) when a new version is introduced or format changed
      * during development. I.e. remove the {@code @Ignore} annotation temporarily.
@@ -602,7 +602,7 @@ private static void loadLegacyTable(String tablePattern, String legacyVersion) t
     @Test
     public void testGenerateSstables() throws Throwable
     {
-        SSTableFormat<?, ?> format = SSTableFormat.Type.current().info;
+        SSTableFormat<?, ?> format = DatabaseDescriptor.getSelectedSSTableFormat();
         Random rand = new Random();
         StringBuilder sb = new StringBuilder();
         for (int i = 0; i < 128; i++)

File: test/unit/org/apache/cassandra/io/sstable/RangeAwareSSTableWriterTest.java
Patch:
@@ -32,7 +32,6 @@
 import org.apache.cassandra.db.compaction.OperationType;
 import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
 import org.apache.cassandra.dht.Murmur3Partitioner;
-import org.apache.cassandra.io.sstable.format.SSTableFormat;
 import org.apache.cassandra.schema.KeyspaceParams;
 import org.apache.cassandra.service.StorageService;
 
@@ -79,7 +78,7 @@ public void testAccessWriterBeforeAppend() throws IOException
                                                                      0,
                                                                      null,
                                                                      false,
-                                                                     SSTableFormat.Type.current(),
+                                                                     DatabaseDescriptor.getSelectedSSTableFormat(),
                                                                      0,
                                                                      0,
                                                                      txn,

File: test/unit/org/apache/cassandra/io/sstable/SSTableHeaderFixTest.java
Patch:
@@ -830,7 +830,7 @@ private File buildFakeSSTable(File dir, int generation, TableMetadata.Builder co
         try
         {
 
-            Descriptor desc = new Descriptor(version, dir, "ks", "cf", MockSchema.sstableId(generation), BigFormat.getInstance().getType());
+            Descriptor desc = new Descriptor(version, dir, "ks", "cf", MockSchema.sstableId(generation));
 
             // Just create the component files - we don't really need those.
             for (Component component : requiredComponents)

File: test/unit/org/apache/cassandra/io/sstable/SSTableUtils.java
Patch:
@@ -93,7 +93,7 @@ public static File tempSSTableFile(String keyspaceName, String cfname, SSTableId
         File cfDir = new File(tempdir, keyspaceName + File.pathSeparator() + cfname);
         cfDir.tryCreateDirectories();
         cfDir.deleteOnExit();
-        File datafile = new Descriptor(cfDir, keyspaceName, cfname, id, BigFormat.getInstance().getType()).fileFor(Components.DATA);
+        File datafile = new Descriptor(cfDir, keyspaceName, cfname, id, BigFormat.getInstance()).fileFor(Components.DATA);
         if (!datafile.createFileIfNotExists())
             throw new IOException("unable to create file " + datafile);
         datafile.deleteOnExit();

File: test/unit/org/apache/cassandra/io/sstable/VerifyTest.java
Patch:
@@ -57,7 +57,6 @@
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.exceptions.WriteTimeoutException;
 import org.apache.cassandra.io.FSWriteError;
-import org.apache.cassandra.io.sstable.format.SSTableFormat;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.io.sstable.format.SSTableReaderWithFilter;
 import org.apache.cassandra.io.sstable.format.SortedTableVerifier.RangeOwnHelper;
@@ -559,7 +558,7 @@ public void testVerifyIndex() throws IOException
     @Test
     public void testVerifyBf() throws IOException
     {
-        Assume.assumeTrue(SSTableReaderWithFilter.class.isAssignableFrom(SSTableFormat.Type.current().info.getReaderFactory().getReaderClass()));
+        Assume.assumeTrue(SSTableReaderWithFilter.class.isAssignableFrom(DatabaseDescriptor.getSelectedSSTableFormat().getReaderFactory().getReaderClass()));
         testBrokenComponentHelper(Components.FILTER);
     }
 

File: test/unit/org/apache/cassandra/io/sstable/indexsummary/IndexSummaryManagerTest.java
Patch:
@@ -59,7 +59,6 @@
 import org.apache.cassandra.db.rows.Cell;
 import org.apache.cassandra.db.rows.Row;
 import org.apache.cassandra.exceptions.ConfigurationException;
-import org.apache.cassandra.io.sstable.format.SSTableFormat;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.metrics.RestorableMeter;
 import org.apache.cassandra.schema.CachingParams;
@@ -98,7 +97,7 @@ public static void defineSchema() throws ConfigurationException
     {
         DatabaseDescriptor.daemonInitialization();
         Assume.assumeTrue("This test make sense only if the default SSTable format support index summary",
-                          IndexSummarySupport.isSupportedBy(SSTableFormat.Type.current()));
+                          IndexSummarySupport.isSupportedBy(DatabaseDescriptor.getSelectedSSTableFormat()));
 
         SchemaLoader.prepareServer();
         SchemaLoader.createKeyspace(KEYSPACE1,

File: test/unit/org/apache/cassandra/io/sstable/indexsummary/IndexSummaryRedistributionTest.java
Patch:
@@ -37,7 +37,6 @@
 import org.apache.cassandra.db.RowUpdateBuilder;
 import org.apache.cassandra.db.commitlog.CommitLogPosition;
 import org.apache.cassandra.exceptions.ConfigurationException;
-import org.apache.cassandra.io.sstable.format.SSTableFormat;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.metrics.RestorableMeter;
 import org.apache.cassandra.metrics.StorageMetrics;
@@ -57,7 +56,7 @@ public static void defineSchema() throws ConfigurationException
     {
         DatabaseDescriptor.daemonInitialization();
         Assume.assumeTrue("This test make sense only if the default SSTable format support index summary",
-                          IndexSummarySupport.isSupportedBy(SSTableFormat.Type.current()));
+                          IndexSummarySupport.isSupportedBy(DatabaseDescriptor.getSelectedSSTableFormat()));
         SchemaLoader.prepareServer();
         SchemaLoader.createKeyspace(KEYSPACE1,
                                     KeyspaceParams.simple(1),

File: test/unit/org/apache/cassandra/schema/MockSchema.java
Patch:
@@ -163,14 +163,14 @@ public static SSTableReader sstable(int generation, int size, boolean keepRef, l
 
     public static SSTableReader sstable(int generation, int size, boolean keepRef, long firstToken, long lastToken, int level, ColumnFamilyStore cfs, int minLocalDeletionTime, long timestamp)
     {
-        SSTableFormat<?, ?> format = SSTableFormat.Type.current().info;
+        SSTableFormat<?, ?> format = DatabaseDescriptor.getSelectedSSTableFormat();
         Descriptor descriptor = new Descriptor(cfs.getDirectories().getDirectoryForNewSSTables(),
                                                cfs.keyspace.getName(),
                                                cfs.getTableName(),
                                                sstableId(generation),
-                                               format.getType());
+                                               format);
 
-        if (format == BigFormat.getInstance())
+        if (BigFormat.is(format))
         {
             Set<Component> components = ImmutableSet.of(Components.DATA, Components.PRIMARY_INDEX, Components.FILTER, Components.TOC);
             for (Component component : components)

File: src/java/org/apache/cassandra/cql3/functions/UDAggregate.java
Patch:
@@ -349,15 +349,15 @@ public String toCqlString(boolean withInternals, boolean ifNotExists)
                .newLine()
                .increaseIndent()
                .append("SFUNC ")
-               .append(stateFunction().name().name)
+               .appendQuotingIfNeeded(stateFunction().name().name)
                .newLine()
                .append("STYPE ")
                .append(toCqlString(stateType()));
 
         if (finalFunction() != null)
             builder.newLine()
                    .append("FINALFUNC ")
-                   .append(finalFunction().name().name);
+                   .appendQuotingIfNeeded(finalFunction().name().name);
 
         if (initialCondition() != null)
             builder.newLine()

File: src/java/org/apache/cassandra/db/marshal/UserType.java
Patch:
@@ -495,7 +495,7 @@ public String toCqlString(boolean withInternals, boolean ifNotExists)
                 builder.append(",")
                        .newLine();
 
-            builder.append(fieldNameAsString(i))
+            builder.appendQuotingIfNeeded(fieldNameAsString(i))
                    .append(' ')
                    .append(fieldType(i));
         }

File: src/java/org/apache/cassandra/tools/nodetool/stats/TableStatsHolder.java
Patch:
@@ -64,6 +64,7 @@ public Map<String, Object> convert2Map()
             {
                 Map<String, Object> mpTable = new HashMap<>();
 
+                mpTable.put("sstable_count", table.sstableCount);
                 mpTable.put("sstables_in_each_level", table.sstablesInEachLevel);
                 mpTable.put("space_used_live", table.spaceUsedLive);
                 mpTable.put("space_used_total", table.spaceUsedTotal);

File: test/unit/org/apache/cassandra/transport/MessagePayloadTest.java
Patch:
@@ -85,7 +85,7 @@ public static void resetCqlQueryHandlerField()
             return;
         try
         {
-            Field modifiersField = Field.class.getDeclaredField("modifiers");
+            Field modifiersField = ReflectionUtils.getModifiersField();
             modifiersField.setAccessible(true);
             modifiersField.setInt(cqlQueryHandlerField, cqlQueryHandlerField.getModifiers() | Modifier.FINAL);
 

File: src/java/org/apache/cassandra/utils/concurrent/Ref.java
Patch:
@@ -687,7 +687,7 @@ public void run()
                 List<String> names = new ArrayList<>(this.candidates.size());
                 for (Tidy tidy : this.candidates)
                     names.add(tidy.name());
-                logger.warn("Strong reference leak candidates detected: {}", names);
+                logger.error("Strong reference leak candidates detected: {}", names);
             }
             this.candidates = candidates;
         }

File: src/java/org/apache/cassandra/auth/CassandraRoleManager.java
Patch:
@@ -82,7 +82,7 @@ public class CassandraRoleManager implements IRoleManager
     private static final Logger logger = LoggerFactory.getLogger(CassandraRoleManager.class);
 
     public static final String DEFAULT_SUPERUSER_NAME = "cassandra";
-    static final String DEFAULT_SUPERUSER_PASSWORD = "cassandra";
+    public static final String DEFAULT_SUPERUSER_PASSWORD = "cassandra";
 
     /**
      * We need to treat the default superuser as a special case since during initial node startup, we may end up with

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -618,6 +618,8 @@ public MemtableOptions()
      */
     public boolean allow_extra_insecure_udfs = false;
 
+    public boolean dynamic_data_masking_enabled = false;
+
     /**
      * Time in milliseconds after a warning will be emitted to the log and to the client that a UDF runs too long.
      * (Only valid, if user_defined_functions_threads_enabled==true)

File: src/java/org/apache/cassandra/cql3/UntypedResultSet.java
Patch:
@@ -221,7 +221,7 @@ protected Row computeNext()
                         try (ReadExecutionController executionController = pager.executionController();
                              PartitionIterator iter = pager.fetchPageInternal(pageSize, executionController))
                         {
-                            currentPage = select.process(iter, nowInSec).rows.iterator();
+                            currentPage = select.process(iter, nowInSec, true).rows.iterator();
                         }
                     }
                     return new Row(metadata, currentPage.next());
@@ -286,7 +286,7 @@ protected Row computeNext()
 
                         try (PartitionIterator iter = pager.fetchPage(pageSize, cl, clientState, nanoTime()))
                         {
-                            currentPage = select.process(iter, nowInSec).rows.iterator();
+                            currentPage = select.process(iter, nowInSec, true).rows.iterator();
                         }
                     }
                     return new Row(metadata, currentPage.next());

File: src/java/org/apache/cassandra/cql3/selection/SelectorFactories.java
Patch:
@@ -147,7 +147,7 @@ public int indexOfSimpleSelectorFactory(int columnIndex)
      */
     public void addSelectorForOrdering(ColumnMetadata def, int index)
     {
-        factories.add(SimpleSelector.newFactory(def, index));
+        factories.add(SimpleSelector.newFactory(def, index, true));
     }
 
     /**

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -659,7 +659,7 @@ private static ResultSet buildCasFailureResultSet(RowIterator partition,
         }
 
         Selectors selectors = selection.newSelectors(options);
-        ResultSetBuilder builder = new ResultSetBuilder(selection.getResultMetadata(), selectors);
+        ResultSetBuilder builder = new ResultSetBuilder(selection.getResultMetadata(), selectors, false);
         SelectStatement.forSelection(metadata, selection)
                        .processPartition(partition, options, builder, nowInSeconds);
 

File: src/java/org/apache/cassandra/db/aggregation/GroupMaker.java
Patch:
@@ -172,7 +172,7 @@ public SelectorGroupMaker(ClusteringComparator comparator,
         {
             super(comparator, clusteringPrefixSize, state);
             this.selector = selector;
-            this.input = new Selector.InputRow(ProtocolVersion.CURRENT, columns);
+            this.input = new Selector.InputRow(ProtocolVersion.CURRENT, columns, false);
             this.lastOutput = lastClustering == null ? null :
                                                        executeSelector(lastClustering.bufferAt(clusteringPrefixSize - 1));
         }
@@ -184,7 +184,7 @@ public SelectorGroupMaker(ClusteringComparator comparator,
         {
             super(comparator, clusteringPrefixSize);
             this.selector = selector;
-            this.input = new Selector.InputRow(ProtocolVersion.CURRENT, columns);
+            this.input = new Selector.InputRow(ProtocolVersion.CURRENT, columns, false);
         }
 
         @Override

File: src/java/org/apache/cassandra/schema/SchemaKeyspaceTables.java
Patch:
@@ -24,6 +24,7 @@ public class SchemaKeyspaceTables
     public static final String KEYSPACES = "keyspaces";
     public static final String TABLES = "tables";
     public static final String COLUMNS = "columns";
+    public static final String COLUMN_MASKS = "column_masks";
     public static final String DROPPED_COLUMNS = "dropped_columns";
     public static final String TRIGGERS = "triggers";
     public static final String VIEWS = "views";
@@ -45,7 +46,8 @@ public class SchemaKeyspaceTables
      *
      * See CASSANDRA-12213 for more details.
      */
-    public static final ImmutableList<String> ALL = ImmutableList.of(COLUMNS,
+    public static final ImmutableList<String> ALL = ImmutableList.of(COLUMN_MASKS,
+                                                                     COLUMNS,
                                                                      DROPPED_COLUMNS,
                                                                      TRIGGERS,
                                                                      TYPES,

File: src/java/org/apache/cassandra/utils/NativeSSTableLoaderClient.java
Patch:
@@ -212,15 +212,15 @@ private static ColumnMetadata createDefinitionFromRow(Row row, String keyspace,
 
         int position = row.getInt("position");
         org.apache.cassandra.schema.ColumnMetadata.Kind kind = ColumnMetadata.Kind.valueOf(row.getString("kind").toUpperCase());
-        return new ColumnMetadata(keyspace, table, name, type, position, kind);
+        return new ColumnMetadata(keyspace, table, name, type, position, kind, null);
     }
 
     private static DroppedColumn createDroppedColumnFromRow(Row row, String keyspace, String table)
     {
         String name = row.getString("column_name");
         AbstractType<?> type = CQLTypeParser.parse(keyspace, row.getString("type"), Types.none());
         ColumnMetadata.Kind kind = ColumnMetadata.Kind.valueOf(row.getString("kind").toUpperCase());
-        ColumnMetadata column = new ColumnMetadata(keyspace, table, ColumnIdentifier.getInterned(name, true), type, ColumnMetadata.NO_POSITION, kind);
+        ColumnMetadata column = new ColumnMetadata(keyspace, table, ColumnIdentifier.getInterned(name, true), type, ColumnMetadata.NO_POSITION, kind, null);
         long droppedTime = row.getTimestamp("dropped_time").getTime();
         return new DroppedColumn(column, droppedTime);
     }

File: test/unit/org/apache/cassandra/db/CellTest.java
Patch:
@@ -76,7 +76,8 @@ private static ColumnMetadata fakeColumn(String name, AbstractType<?> type)
                                   ColumnIdentifier.getInterned(name, false),
                                   type,
                                   ColumnMetadata.NO_POSITION,
-                                  ColumnMetadata.Kind.REGULAR);
+                                  ColumnMetadata.Kind.REGULAR,
+                                  null);
     }
 
     @Test

File: test/unit/org/apache/cassandra/db/ColumnsTest.java
Patch:
@@ -496,7 +496,7 @@ private static void addComplex(List<String> names, List<ColumnMetadata> results)
 
     private static ColumnMetadata def(String name, AbstractType<?> type, ColumnMetadata.Kind kind)
     {
-        return new ColumnMetadata(TABLE_METADATA, bytes(name), type, ColumnMetadata.NO_POSITION, kind);
+        return new ColumnMetadata(TABLE_METADATA, bytes(name), type, ColumnMetadata.NO_POSITION, kind, null);
     }
 
     private static TableMetadata mock(Columns columns)

File: test/unit/org/apache/cassandra/db/NativeCellTest.java
Patch:
@@ -118,7 +118,8 @@ private static ColumnMetadata rndcol()
                                   ColumnIdentifier.getInterned(uuid.toString(), false),
                                     isComplex ? new SetType<>(BytesType.instance, true) : BytesType.instance,
                                   -1,
-                                  ColumnMetadata.Kind.REGULAR);
+                                  ColumnMetadata.Kind.REGULAR,
+                                  null);
     }
 
     private static Cell<?> rndcell(ColumnMetadata col)

File: test/unit/org/apache/cassandra/db/compaction/CompactionIteratorTest.java
Patch:
@@ -19,7 +19,7 @@
 
 import static org.apache.cassandra.db.transform.DuplicateRowCheckerTest.assertCommandIssued;
 import static org.apache.cassandra.db.transform.DuplicateRowCheckerTest.makeRow;
-import static org.apache.cassandra.db.transform.DuplicateRowCheckerTest.rows;
+import static org.apache.cassandra.db.transform.DuplicateRowCheckerTest.partition;
 import static org.junit.Assert.*;
 
 import java.util.*;
@@ -494,7 +494,7 @@ private void iterate(Unfiltered...unfiltereds)
         ColumnFamilyStore cfs = getCurrentColumnFamilyStore();
         DecoratedKey key = cfs.getPartitioner().decorateKey(ByteBufferUtil.bytes("key"));
         try (CompactionController controller = new CompactionController(cfs, Integer.MAX_VALUE);
-             UnfilteredRowIterator rows = rows(cfs.metadata(), key, false, unfiltereds);
+             UnfilteredRowIterator rows = partition(cfs.metadata(), key, false, unfiltereds);
              ISSTableScanner scanner = new Scanner(Collections.singletonList(rows));
              CompactionIterator iter = new CompactionIterator(OperationType.COMPACTION,
                                                               Collections.singletonList(scanner),

File: test/unit/org/apache/cassandra/io/sstable/SSTableHeaderFixTest.java
Patch:
@@ -394,7 +394,7 @@ public void complexTypeDroppedColumnsMatchTest() throws Exception
             ColumnMetadata cd = getColDef(col);
             AbstractType<?> dropType = cd.type.expandUserTypes();
             cols.removeRegularOrStaticColumn(ci)
-                .recordColumnDrop(new ColumnMetadata(cd.ksName, cd.cfName, cd.name, dropType, cd.position(), cd.kind), FBUtilities.timestampMicros());
+                .recordColumnDrop(new ColumnMetadata(cd.ksName, cd.cfName, cd.name, dropType, cd.position(), cd.kind, cd.getMask()), FBUtilities.timestampMicros());
         }
         tableMetadata = cols.build();
 

File: test/unit/org/apache/cassandra/schema/SchemaKeyspaceTest.java
Patch:
@@ -254,7 +254,7 @@ private static void checkInverses(TableMetadata metadata) throws Exception
                                                                 UnfilteredRowIterators.filter(serializedCD.unfilteredIterator(), FBUtilities.nowInSeconds()));
         Set<ColumnMetadata> columns = new HashSet<>();
         for (UntypedResultSet.Row row : columnsRows)
-            columns.add(SchemaKeyspace.createColumnFromRow(row, Types.none()));
+            columns.add(SchemaKeyspace.createColumnFromRow(row, Types.none(), UserFunctions.none()));
 
         assertEquals(metadata.params, params);
         assertEquals(new HashSet<>(metadata.columns()), columns);

File: test/unit/org/apache/cassandra/utils/CassandraGenerators.java
Patch:
@@ -212,7 +212,7 @@ private static ColumnMetadata createColumnDefinition(String ks, String table,
         }
         ColumnIdentifier name = new ColumnIdentifier(str, true);
         int position = !kind.isPrimaryKeyKind() ? -1 : (int) rnd.next(Constraint.between(0, 30));
-        return new ColumnMetadata(ks, table, name, typeGen.generate(rnd), position, kind);
+        return new ColumnMetadata(ks, table, name, typeGen.generate(rnd), position, kind, null);
     }
 
     public static Gen<ByteBuffer> partitionKeyDataGen(TableMetadata metadata)

File: src/java/org/apache/cassandra/tools/StandaloneUpgrader.java
Patch:
@@ -84,8 +84,8 @@ public static void main(String args[])
 
             Collection<SSTableReader> readers = new ArrayList<>();
 
-            // Upgrade sstables
-            for (Map.Entry<Descriptor, Set<Component>> entry : lister.list().entrySet())
+            // Upgrade sstables in id order
+            for (Map.Entry<Descriptor, Set<Component>> entry : lister.sortedList())
             {
                 Set<Component> components = entry.getValue();
                 if (!components.containsAll(entry.getKey().getFormat().primaryComponents()))

File: src/java/org/apache/cassandra/tools/StandaloneUpgrader.java
Patch:
@@ -76,8 +76,8 @@ public static void main(String args[])
 
             Collection<SSTableReader> readers = new ArrayList<>();
 
-            // Upgrade sstables
-            for (Map.Entry<Descriptor, Set<Component>> entry : lister.list().entrySet())
+            // Upgrade sstables in id order
+            for (Map.Entry<Descriptor, Set<Component>> entry : lister.sortedList())
             {
                 Set<Component> components = entry.getValue();
                 if (!components.contains(Component.DATA) || !components.contains(Component.PRIMARY_INDEX))

File: src/java/org/apache/cassandra/tools/StandaloneUpgrader.java
Patch:
@@ -76,8 +76,8 @@ public static void main(String args[])
 
             Collection<SSTableReader> readers = new ArrayList<>();
 
-            // Upgrade sstables
-            for (Map.Entry<Descriptor, Set<Component>> entry : lister.list().entrySet())
+            // Upgrade sstables in id order
+            for (Map.Entry<Descriptor, Set<Component>> entry : lister.sortedList())
             {
                 Set<Component> components = entry.getValue();
                 if (!components.contains(Component.DATA) || !components.contains(Component.PRIMARY_INDEX))

File: src/java/org/apache/cassandra/tools/StandaloneUpgrader.java
Patch:
@@ -72,8 +72,8 @@ public static void main(String args[])
 
             Collection<SSTableReader> readers = new ArrayList<>();
 
-            // Upgrade sstables
-            for (Map.Entry<Descriptor, Set<Component>> entry : lister.list().entrySet())
+            // Upgrade sstables in id order
+            for (Map.Entry<Descriptor, Set<Component>> entry : lister.sortedList())
             {
                 Set<Component> components = entry.getValue();
                 if (!components.contains(Component.DATA) || !components.contains(Component.PRIMARY_INDEX))

File: src/java/org/apache/cassandra/tools/StandaloneUpgrader.java
Patch:
@@ -72,8 +72,8 @@ public static void main(String args[])
 
             Collection<SSTableReader> readers = new ArrayList<>();
 
-            // Upgrade sstables
-            for (Map.Entry<Descriptor, Set<Component>> entry : lister.list().entrySet())
+            // Upgrade sstables in id order
+            for (Map.Entry<Descriptor, Set<Component>> entry : lister.sortedList())
             {
                 Set<Component> components = entry.getValue();
                 if (!components.contains(Component.DATA) || !components.contains(Component.PRIMARY_INDEX))

File: src/java/org/apache/cassandra/service/DefaultFSErrorHandler.java
Patch:
@@ -44,6 +44,7 @@ public void handleCorruptSSTable(CorruptSSTableException e)
 
         switch (DatabaseDescriptor.getDiskFailurePolicy())
         {
+            case die:
             case stop_paranoid:
                 // exception not logged here on purpose as it is already logged
                 logger.error("Stopping transports as disk_failure_policy is " + DatabaseDescriptor.getDiskFailurePolicy());
@@ -60,6 +61,7 @@ public void handleFSError(FSError e)
 
         switch (DatabaseDescriptor.getDiskFailurePolicy())
         {
+            case die:
             case stop_paranoid:
             case stop:
                 // exception not logged here on purpose as it is already logged

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -211,7 +211,6 @@ public class MessagingService extends MessagingServiceMBeanImpl
     public static final int VERSION_30 = 10;
     public static final int VERSION_3014 = 11;
     public static final int VERSION_40 = 12;
-    public static final int VERSION_41 = 13;
     public static final int minimum_version = VERSION_30;
     public static final int current_version = VERSION_40;
     static AcceptVersions accept_messaging = new AcceptVersions(minimum_version, current_version);

File: test/distributed/org/apache/cassandra/distributed/upgrade/CompactStorageColumnDeleteTest.java
Patch:
@@ -33,7 +33,7 @@ public void testColumnDeleteWithCompactStorage() throws Throwable
         new TestCase()
         .nodes(2)
         .nodesToUpgrade(2)
-        .upgradesToCurrentFrom(v30)
+        .upgradesToCurrentFrom(v40)
         .setup((cluster) -> {
             cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck int, v int, PRIMARY KEY (pk, ck)) WITH COMPACT STORAGE");
         })

File: test/distributed/org/apache/cassandra/distributed/upgrade/CompactStorageHiddenColumnTest.java
Patch:
@@ -33,7 +33,7 @@ public void testHiddenColumnWithCompactStorage() throws Throwable
         new TestCase()
         .nodes(2)
         .nodesToUpgrade(2)
-        .upgradesToCurrentFrom(v30)
+        .upgradesToCurrentFrom(v40)
         .setup((cluster) -> {
             cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck int, PRIMARY KEY (pk, ck)) WITH COMPACT STORAGE");
         })

File: test/distributed/org/apache/cassandra/distributed/upgrade/CompactStorageImplicitNullInClusteringTest.java
Patch:
@@ -33,7 +33,7 @@ public void testImplicitNullInClusteringWithCompactStorage() throws Throwable
         new TestCase()
         .nodes(2)
         .nodesToUpgrade(2)
-        .upgradesToCurrentFrom(v30)
+        .upgradesToCurrentFrom(v40)
         .setup((cluster) -> {
             cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck1 int, ck2 int, v int, PRIMARY KEY (pk, ck1, ck2)) WITH COMPACT STORAGE");
         })

File: test/distributed/org/apache/cassandra/distributed/upgrade/CompactStoragePagingTest.java
Patch:
@@ -33,7 +33,7 @@ public void testPagingWithCompactStorage() throws Throwable
         new TestCase()
         .nodes(2)
         .nodesToUpgrade(2)
-        .upgradesToCurrentFrom(v30)
+        .upgradesToCurrentFrom(v40)
         .setup((cluster) -> {
             cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck int, v int, PRIMARY KEY (pk, ck)) WITH COMPACT STORAGE");
             for (int i = 1; i < 10; i++)

File: test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeMessageForwardTest.java
Patch:
@@ -103,7 +103,7 @@ public void checkWritesForwardedToOtherDcTest() throws Throwable
         .withConfig(c -> c.with(Feature.GOSSIP, Feature.NETWORK))
         .withBuilder(b -> b.withRacks(numDCs, 1, nodesPerDc))
         .nodes(numDCs * nodesPerDc)
-        .singleUpgradeToCurrentFrom(v30)
+        .upgradesToCurrentFrom(v40)
         .setup(cluster -> {
             cluster.schemaChange("ALTER KEYSPACE " + KEYSPACE +
                 " WITH replication = {'class': 'NetworkTopologyStrategy', " + ntsArgs + " };");

File: test/distributed/org/apache/cassandra/distributed/upgrade/Pre40MessageFilterTest.java
Patch:
@@ -34,9 +34,7 @@ public void reserializePre40RequestPaxosTest(Consumer<IInstanceConfig> configCon
         .nodes(2)
         .withConfig(configConsumer)
         .nodesToUpgrade(1)
-        // all upgrades from v30 up, excluding v30->v3X
-        .singleUpgradeToCurrentFrom(v30)
-        .upgradesToCurrentFrom(v3X)
+        .upgradesToCurrentFrom(v40)
         .setup((cluster) -> {
             cluster.filters().outbound().allVerbs().messagesMatching((f,t,m) -> false).drop();
             cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck int, v int, PRIMARY KEY (pk, ck))");

File: test/unit/org/apache/cassandra/AbstractSerializationsTester.java
Patch:
@@ -29,12 +29,11 @@
 
 public class AbstractSerializationsTester
 {
-    protected static final String CUR_VER = System.getProperty("cassandra.version", "4.1");
+    protected static final String CUR_VER = System.getProperty("cassandra.version", "4.0");
     protected static final Map<String, Integer> VERSION_MAP = new HashMap<String, Integer> ()
     {{
         put("3.0", MessagingService.VERSION_30);
         put("4.0", MessagingService.VERSION_40);
-        put("4.1", MessagingService.VERSION_41);
     }};
 
     protected static final boolean EXECUTE_WRITES = Boolean.getBoolean("cassandra.test-serialization-writes");

File: src/java/org/apache/cassandra/db/StorageHook.java
Patch:
@@ -23,8 +23,8 @@
 import org.apache.cassandra.db.partitions.PartitionUpdate;
 import org.apache.cassandra.db.rows.UnfilteredRowIterator;
 import org.apache.cassandra.db.rows.UnfilteredRowIteratorWithLowerBound;
+import org.apache.cassandra.io.sstable.SSTableReadsListener;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
-import org.apache.cassandra.io.sstable.format.SSTableReadsListener;
 import org.apache.cassandra.schema.TableId;
 import org.apache.cassandra.utils.FBUtilities;
 

File: src/java/org/apache/cassandra/db/compaction/CompactionInfo.java
Patch:
@@ -57,7 +57,7 @@ public final class CompactionInfo
     private final ImmutableSet<SSTableReader> sstables;
     private final String targetDirectory;
 
-    public CompactionInfo(TableMetadata metadata, OperationType tasktype, long completed, long total, Unit unit, TimeUUID compactionId, Collection<SSTableReader> sstables, String targetDirectory)
+    public CompactionInfo(TableMetadata metadata, OperationType tasktype, long completed, long total, Unit unit, TimeUUID compactionId, Collection<? extends SSTableReader> sstables, String targetDirectory)
     {
         this.tasktype = tasktype;
         this.completed = completed;
@@ -74,7 +74,7 @@ public CompactionInfo(TableMetadata metadata, OperationType tasktype, long compl
         this(metadata, tasktype, completed, total, Unit.BYTES, compactionId, sstables, targetDirectory);
     }
 
-    public CompactionInfo(TableMetadata metadata, OperationType tasktype, long completed, long total, TimeUUID compactionId, Collection<SSTableReader> sstables)
+    public CompactionInfo(TableMetadata metadata, OperationType tasktype, long completed, long total, TimeUUID compactionId, Collection<? extends SSTableReader> sstables)
     {
         this(metadata, tasktype, completed, total, Unit.BYTES, compactionId, sstables, null);
     }

File: src/java/org/apache/cassandra/db/compaction/CompactionStrategyManager.java
Patch:
@@ -58,11 +58,11 @@
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.index.Index;
-import org.apache.cassandra.io.sstable.Component;
 import org.apache.cassandra.io.sstable.Descriptor;
 import org.apache.cassandra.io.sstable.ISSTableScanner;
 import org.apache.cassandra.io.sstable.SSTable;
 import org.apache.cassandra.io.sstable.SSTableMultiWriter;
+import org.apache.cassandra.io.sstable.format.SSTableFormat.Components;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.io.sstable.metadata.MetadataCollector;
 import org.apache.cassandra.io.sstable.metadata.StatsMetadata;
@@ -252,8 +252,8 @@ AbstractCompactionTask findUpgradeSSTableTask()
                                                   .stream()
                                                   .filter(s -> !compacting.contains(s) && !s.descriptor.version.isLatestVersion())
                                                   .sorted((o1, o2) -> {
-                                                      File f1 = new File(o1.descriptor.filenameFor(Component.DATA));
-                                                      File f2 = new File(o2.descriptor.filenameFor(Component.DATA));
+                                                      File f1 = o1.descriptor.fileFor(Components.DATA);
+                                                      File f2 = o2.descriptor.fileFor(Components.DATA);
                                                       return Longs.compare(f1.lastModified(), f2.lastModified());
                                                   }).collect(Collectors.toList());
         for (SSTableReader sstable : potentialUpgrade)

File: src/java/org/apache/cassandra/db/compaction/CompactionTask.java
Patch:
@@ -241,7 +241,7 @@ public boolean apply(SSTableReader sstable)
 
             StringBuilder newSSTableNames = new StringBuilder();
             for (SSTableReader reader : newSStables)
-                newSSTableNames.append(reader.descriptor.baseFilename()).append(",");
+                newSSTableNames.append(reader.descriptor.baseFile()).append(",");
             long totalSourceRows = 0;
             for (int i = 0; i < mergedRowCounts.length; i++)
                 totalSourceRows += mergedRowCounts[i] * (i + 1);

File: src/java/org/apache/cassandra/db/compaction/SingleSSTableLCSTask.java
Patch:
@@ -27,8 +27,8 @@
 import org.apache.cassandra.db.Directories;
 import org.apache.cassandra.db.compaction.writers.CompactionAwareWriter;
 import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
-import org.apache.cassandra.io.sstable.Component;
 import org.apache.cassandra.io.sstable.CorruptSSTableException;
+import org.apache.cassandra.io.sstable.format.SSTableFormat.Components;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.io.sstable.metadata.StatsMetadata;
 
@@ -82,7 +82,7 @@ protected void runMayThrow()
             catch (Throwable t)
             {
                 transaction.abort();
-                throw new CorruptSSTableException(t, sstable.descriptor.filenameFor(Component.DATA));
+                throw new CorruptSSTableException(t, sstable.descriptor.fileFor(Components.DATA));
             }
             cfs.getTracker().notifySSTableMetadataChanged(sstable, metadataBefore);
         }

File: src/java/org/apache/cassandra/db/memtable/ShardedSkipListMemtable.java
Patch:
@@ -52,7 +52,7 @@
 import org.apache.cassandra.dht.IncludingExcludingBounds;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.index.transactions.UpdateTransaction;
-import org.apache.cassandra.io.sstable.format.SSTableReadsListener;
+import org.apache.cassandra.io.sstable.SSTableReadsListener;
 import org.apache.cassandra.schema.TableMetadata;
 import org.apache.cassandra.schema.TableMetadataRef;
 import org.apache.cassandra.utils.concurrent.OpOrder;

File: src/java/org/apache/cassandra/db/memtable/SkipListMemtable.java
Patch:
@@ -51,7 +51,7 @@
 import org.apache.cassandra.dht.Murmur3Partitioner.LongToken;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.index.transactions.UpdateTransaction;
-import org.apache.cassandra.io.sstable.format.SSTableReadsListener;
+import org.apache.cassandra.io.sstable.SSTableReadsListener;
 import org.apache.cassandra.schema.TableMetadata;
 import org.apache.cassandra.schema.TableMetadataRef;
 import org.apache.cassandra.utils.ObjectSizes;

File: src/java/org/apache/cassandra/db/memtable/TrieMemtable.java
Patch:
@@ -63,7 +63,7 @@
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.index.transactions.UpdateTransaction;
 import org.apache.cassandra.io.compress.BufferType;
-import org.apache.cassandra.io.sstable.format.SSTableReadsListener;
+import org.apache.cassandra.io.sstable.SSTableReadsListener;
 import org.apache.cassandra.metrics.TableMetrics;
 import org.apache.cassandra.metrics.TrieMemtableMetricsView;
 import org.apache.cassandra.schema.TableMetadata;

File: src/java/org/apache/cassandra/db/rows/UnfilteredSource.java
Patch:
@@ -23,7 +23,7 @@
 import org.apache.cassandra.db.Slices;
 import org.apache.cassandra.db.filter.ColumnFilter;
 import org.apache.cassandra.db.partitions.UnfilteredPartitionIterator;
-import org.apache.cassandra.io.sstable.format.SSTableReadsListener;
+import org.apache.cassandra.io.sstable.SSTableReadsListener;
 
 /**
  * Common data access interface for sstables and memtables.

File: src/java/org/apache/cassandra/db/streaming/CassandraCompressedStreamWriter.java
Patch:
@@ -27,12 +27,12 @@
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.io.compress.CompressionMetadata;
-import org.apache.cassandra.io.sstable.Component;
+import org.apache.cassandra.io.sstable.format.SSTableFormat.Components;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.io.util.ChannelProxy;
 import org.apache.cassandra.streaming.ProgressInfo;
-import org.apache.cassandra.streaming.StreamingDataOutputPlus;
 import org.apache.cassandra.streaming.StreamSession;
+import org.apache.cassandra.streaming.StreamingDataOutputPlus;
 import org.apache.cassandra.utils.FBUtilities;
 
 /**
@@ -71,7 +71,7 @@ public void write(StreamingDataOutputPlus out) throws IOException
             int sectionIdx = 0;
 
             // stream each of the required sections of the file
-            String filename = sstable.descriptor.filenameFor(Component.DATA);
+            String filename = sstable.descriptor.fileFor(Components.DATA).toString();
             for (Section section : sections)
             {
                 // length of the section to stream

File: src/java/org/apache/cassandra/db/streaming/CassandraEntireSSTableStreamWriter.java
Patch:
@@ -27,9 +27,9 @@
 import org.apache.cassandra.io.sstable.Component;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.streaming.ProgressInfo;
-import org.apache.cassandra.streaming.StreamingDataOutputPlus;
 import org.apache.cassandra.streaming.StreamManager;
 import org.apache.cassandra.streaming.StreamSession;
+import org.apache.cassandra.streaming.StreamingDataOutputPlus;
 
 import static org.apache.cassandra.streaming.StreamManager.StreamRateLimiter;
 import static org.apache.cassandra.utils.FBUtilities.prettyPrintMemory;
@@ -93,7 +93,7 @@ public void write(StreamingDataOutputPlus out) throws IOException
             long bytesWritten = out.writeFileToChannel(channel, limiter);
             progress += bytesWritten;
 
-            session.progress(sstable.descriptor.filenameFor(component), ProgressInfo.Direction.OUT, bytesWritten, bytesWritten, length);
+            session.progress(sstable.descriptor.fileFor(component).toString(), ProgressInfo.Direction.OUT, bytesWritten, bytesWritten, length);
 
             logger.debug("[Stream #{}] Finished streaming {}.{} gen {} component {} to {}, xfered = {}, length = {}, totalSize = {}",
                          session.planId(),

File: src/java/org/apache/cassandra/db/streaming/CassandraStreamReader.java
Patch:
@@ -39,9 +39,9 @@
 import org.apache.cassandra.db.rows.Unfiltered;
 import org.apache.cassandra.db.rows.UnfilteredRowIterator;
 import org.apache.cassandra.exceptions.UnknownColumnException;
+import org.apache.cassandra.io.sstable.RangeAwareSSTableWriter;
 import org.apache.cassandra.io.sstable.SSTableMultiWriter;
 import org.apache.cassandra.io.sstable.SSTableSimpleIterator;
-import org.apache.cassandra.io.sstable.format.RangeAwareSSTableWriter;
 import org.apache.cassandra.io.sstable.format.SSTableFormat;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.io.sstable.format.Version;

File: src/java/org/apache/cassandra/db/transform/BasePartitions.java
Patch:
@@ -20,8 +20,6 @@
  */
 package org.apache.cassandra.db.transform;
 
-import java.util.Collections;
-
 import org.apache.cassandra.db.partitions.BasePartitionIterator;
 import org.apache.cassandra.db.rows.BaseRowIterator;
 import org.apache.cassandra.utils.Throwables;
@@ -112,7 +110,7 @@ public final boolean hasNext()
         catch (Throwable t)
         {
             if (next != null)
-                Throwables.close(t, Collections.singleton(next));
+                Throwables.close(t, next);
             throw t;
         }
     }

File: src/java/org/apache/cassandra/io/sstable/RangeAwareSSTableWriter.java
Patch:
@@ -15,7 +15,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.cassandra.io.sstable.format;
+package org.apache.cassandra.io.sstable;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -30,8 +30,8 @@
 import org.apache.cassandra.db.SerializationHeader;
 import org.apache.cassandra.db.lifecycle.LifecycleNewTracker;
 import org.apache.cassandra.db.rows.UnfilteredRowIterator;
-import org.apache.cassandra.io.sstable.Descriptor;
-import org.apache.cassandra.io.sstable.SSTableMultiWriter;
+import org.apache.cassandra.io.sstable.format.SSTableFormat;
+import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.schema.TableId;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.TimeUUID;

File: src/java/org/apache/cassandra/io/sstable/SSTableId.java
Patch:
@@ -33,7 +33,7 @@
  * A new implementation must adhere to the following invariants:
  * - Must be locally sortable - that is, the comparison must reflect the comparison of generation times of identifiers
  * generated on the same node
- * - String representation must *not* include the {@link Descriptor#FILENAME_SEPARATOR} character, see {@link Descriptor#fromFilenameWithComponent(File)}
+ * - String representation must *not* include the {@link Descriptor#FILENAME_SEPARATOR} character, see {@link Descriptor#fromFileWithComponent(File)}
  * - must be case-insensitive because the sstables can be stored on case-insensitive file system
  * <p>
  */
@@ -50,7 +50,7 @@ public interface SSTableId
      * {@link Builder#fromString(String)}
      * <p>
      * Must not contain any {@link Descriptor#FILENAME_SEPARATOR} character as it is used in the Descriptor
-     * see {@link Descriptor#fromFilenameWithComponent(File)}
+     * see {@link Descriptor#fromFileWithComponent(File)}
      */
     @Override
     String toString();

File: src/java/org/apache/cassandra/io/sstable/SSTableSimpleUnsortedWriter.java
Patch:
@@ -214,7 +214,7 @@ public void run()
                     if (b == SENTINEL)
                         return;
 
-                        try (SSTableTxnWriter writer = createWriter())
+                    try (SSTableTxnWriter writer = createWriter(null))
                     {
                         for (Map.Entry<DecoratedKey, PartitionUpdate.Builder> entry : b.entrySet())
                             writer.append(entry.getValue().build().unfilteredIterator());

File: src/java/org/apache/cassandra/io/sstable/SSTableSimpleWriter.java
Patch:
@@ -21,7 +21,8 @@
 
 import com.google.common.base.Throwables;
 
-import org.apache.cassandra.db.*;
+import org.apache.cassandra.db.DecoratedKey;
+import org.apache.cassandra.db.RegularAndStaticColumns;
 import org.apache.cassandra.db.partitions.PartitionUpdate;
 import org.apache.cassandra.io.util.File;
 import org.apache.cassandra.schema.TableMetadataRef;
@@ -51,7 +52,7 @@ protected SSTableSimpleWriter(File directory, TableMetadataRef metadata, Regular
     private SSTableTxnWriter getOrCreateWriter() throws IOException
     {
         if (writer == null)
-            writer = createWriter();
+            writer = createWriter(null);
 
         return writer;
     }

File: src/java/org/apache/cassandra/io/sstable/SSTableTxnWriter.java
Patch:
@@ -28,7 +28,6 @@
 import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
 import org.apache.cassandra.db.rows.UnfilteredRowIterator;
 import org.apache.cassandra.index.Index;
-import org.apache.cassandra.io.sstable.format.RangeAwareSSTableWriter;
 import org.apache.cassandra.io.sstable.format.SSTableFormat;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.io.sstable.metadata.MetadataCollector;
@@ -144,12 +143,13 @@ public static SSTableTxnWriter create(TableMetadataRef metadata,
                                           boolean isTransient,
                                           int sstableLevel,
                                           SerializationHeader header,
-                                          Collection<Index> indexes)
+                                          Collection<Index> indexes,
+                                          SSTable.Owner owner)
     {
         // if the column family store does not exist, we create a new default SSTableMultiWriter to use:
         LifecycleTransaction txn = LifecycleTransaction.offline(OperationType.WRITE);
         MetadataCollector collector = new MetadataCollector(metadata.get().comparator).sstableLevel(sstableLevel);
-        SSTableMultiWriter writer = SimpleSSTableMultiWriter.create(descriptor, keyCount, repairedAt, pendingRepair, isTransient, metadata, collector, header, indexes, txn);
+        SSTableMultiWriter writer = SimpleSSTableMultiWriter.create(descriptor, keyCount, repairedAt, pendingRepair, isTransient, metadata, collector, header, indexes, txn, owner);
         return new SSTableTxnWriter(txn, writer);
     }
 

File: src/java/org/apache/cassandra/io/sstable/format/Version.java
Patch:
@@ -40,8 +40,8 @@ public abstract class Version
 
     protected Version(SSTableFormat format, String version)
     {
-        this.format = format;
-        this.version = version;
+        this.format = Objects.requireNonNull(format);
+        this.version = Objects.requireNonNull(version);
     }
 
     public abstract boolean isLatestVersion();

File: src/java/org/apache/cassandra/io/sstable/format/VersionAndType.java
Patch:
@@ -31,6 +31,7 @@
  * <p>Note that both information are currently necessary to identify the exact "format" of an sstable (without having
  * its {@link Descriptor}). In particular, while {@link Version} contains its {{@link SSTableFormat}}, you cannot get
  * the {{@link SSTableFormat.Type}} from that.
+ * @deprecated TODO remove this class - Version contains SSTableFormat and you _can_ get its type from it
  */
 public final class VersionAndType
 {
@@ -80,7 +81,7 @@ public static VersionAndType fromString(String versionAndType)
         if (components.size() != 2)
             throw new IllegalArgumentException("Invalid VersionAndType string: " + versionAndType + " (should be of the form 'big-bc')");
 
-        SSTableFormat.Type formatType = SSTableFormat.Type.validate(components.get(0));
+        SSTableFormat.Type formatType = SSTableFormat.Type.getByName(components.get(0));
         Version version = formatType.info.getVersion(components.get(1));
         return new VersionAndType(version, formatType);
     }

File: src/java/org/apache/cassandra/io/sstable/indexsummary/IndexSummaryBuilder.java
Patch:
@@ -15,7 +15,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.cassandra.io.sstable;
+package org.apache.cassandra.io.sstable.indexsummary;
 
 import java.io.IOException;
 import java.nio.ByteOrder;
@@ -29,6 +29,7 @@
 import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.dht.IPartitioner;
+import org.apache.cassandra.io.sstable.Downsampling;
 import org.apache.cassandra.io.util.Memory;
 import org.apache.cassandra.io.util.SafeMemoryWriter;
 

File: src/java/org/apache/cassandra/io/sstable/indexsummary/IndexSummaryManagerMBean.java
Patch:
@@ -15,7 +15,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.cassandra.io.sstable;
+package org.apache.cassandra.io.sstable.indexsummary;
 
 import java.io.IOException;
 import java.util.Map;

File: src/java/org/apache/cassandra/db/PartitionRangeReadCommand.java
Patch:
@@ -316,6 +316,7 @@ protected void recordLatency(TableMetrics metric, long latencyNanos)
     }
 
     @VisibleForTesting
+    @SuppressWarnings("resource")
     public UnfilteredPartitionIterator queryStorage(final ColumnFamilyStore cfs, ReadExecutionController controller)
     {
         ColumnFamilyStore.ViewFragment view = cfs.select(View.selectLive(dataRange().keyRange()));

File: src/java/org/apache/cassandra/db/AbstractReadQuery.java
Patch:
@@ -118,4 +118,4 @@ public String toCQLString()
     }
 
     protected abstract void appendCQLWhereClause(StringBuilder sb);
-}
+}
\ No newline at end of file

File: src/java/org/apache/cassandra/db/partitions/UnfilteredPartitionIterators.java
Patch:
@@ -386,4 +386,4 @@ public void close()
             };
         }
     }
-}
+}
\ No newline at end of file

File: src/java/org/apache/cassandra/io/sstable/format/SSTableWriter.java
Patch:
@@ -327,7 +327,9 @@ protected Map<MetadataType, MetadataComponent> finalizeMetadata()
                                                   repairedAt,
                                                   pendingRepair,
                                                   isTransient,
-                                                  header);
+                                                  header,
+                                                  SSTable.getMinimalKey(first).getKey(),
+                                                  SSTable.getMinimalKey(last).getKey());
     }
 
     protected StatsMetadata statsMetadata()

File: src/java/org/apache/cassandra/io/sstable/format/big/BigTableWriter.java
Patch:
@@ -304,7 +304,7 @@ public Row applyToRow(Row row)
         @Override
         public RangeTombstoneMarker applyToMarker(RangeTombstoneMarker marker)
         {
-            collector.updateClusteringValues(marker.clustering());
+            collector.updateClusteringValuesByBoundOrBoundary(marker.clustering());
             if (marker.isBoundary())
             {
                 RangeTombstoneBoundaryMarker bm = (RangeTombstoneBoundaryMarker)marker;
@@ -327,7 +327,7 @@ public void onPartitionClose()
         @Override
         public DeletionTime applyToDeletion(DeletionTime deletionTime)
         {
-            collector.update(deletionTime);
+            collector.updatePartitionDeletion(deletionTime);
             return deletionTime;
         }
     }
@@ -662,4 +662,4 @@ protected Throwable doPostCleanup(Throwable accumulate)
             return accumulate;
         }
     }
-}
+}
\ No newline at end of file

File: src/java/org/apache/cassandra/utils/MergeIterator.java
Patch:
@@ -395,10 +395,11 @@ public int compareTo(Candidate<In> that)
 
         private boolean isLowerBound()
         {
+            assert item != null;
             return item == lowerBound;
         }
 
-        public void consume(Reducer reducer)
+        public <Out> void consume(Reducer<In, Out> reducer)
         {
             if (isLowerBound())
             {
@@ -488,4 +489,4 @@ protected Out computeNext()
             return (Out) source.next();
         }
     }
-}
+}
\ No newline at end of file

File: test/unit/org/apache/cassandra/db/compaction/CompactionsTest.java
Patch:
@@ -363,8 +363,8 @@ public void testRangeTombstones()
         for (SSTableReader sstable : cfs.getLiveSSTables())
         {
             StatsMetadata stats = sstable.getSSTableMetadata();
-            assertEquals(ByteBufferUtil.bytes("0"), stats.minClusteringValues.get(0));
-            assertEquals(ByteBufferUtil.bytes("b"), stats.maxClusteringValues.get(0));
+            assertEquals(ByteBufferUtil.bytes("0"), stats.coveredClustering.start().bufferAt(0));
+            assertEquals(ByteBufferUtil.bytes("b"), stats.coveredClustering.end().bufferAt(0));
         }
 
         assertEquals(keys, k);
@@ -565,4 +565,4 @@ public void testConcurrencySettings()
         CompactionManager.instance.setConcurrentCompactors(1);
         assertEquals(1, CompactionManager.instance.getCoreCompactorThreads());
     }
-}
+}
\ No newline at end of file

File: test/unit/org/apache/cassandra/io/sstable/LegacySSTableTest.java
Patch:
@@ -94,7 +94,7 @@ public class LegacySSTableTest
      * See {@link #testGenerateSstables()} to generate sstables.
      * Take care on commit as you need to add the sstable files using {@code git add -f}
      */
-    public static final String[] legacyVersions = {"nb", "na", "me", "md", "mc", "mb", "ma"};
+    public static final String[] legacyVersions = {"nc", "nb", "na", "me", "md", "mc", "mb", "ma"};
 
     // 1200 chars
     static final String longString = "0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" +

File: src/java/org/apache/cassandra/net/OutboundConnectionInitiator.java
Patch:
@@ -147,7 +147,8 @@ private Future<Result<SuccessType>> initiate(EventLoop eventLoop)
         {
             // interrupt other connections, so they must attempt to re-authenticate
             MessagingService.instance().interruptOutbound(settings.to);
-            return ImmediateFuture.failure(new IOException("authentication failed to " + settings.connectToId()));
+            logger.error("Authentication failed to " + settings.connectToId());
+            return ImmediateFuture.failure(new IOException("Authentication failed to " + settings.connectToId()));
         }
 
 
@@ -281,7 +282,7 @@ protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteB
             {
                 // interrupt other connections, so they must attempt to re-authenticate
                 MessagingService.instance().interruptOutbound(settings.to);
-                logger.error("authentication failed to " + settings.connectToId());
+                logger.error("Authentication failed to " + settings.connectToId());
 
                 // To release all the pending buffered data, replace authentication handler with discard handler.
                 // This avoids pending inbound data to be fired through the pipeline

File: examples/ssl-factory/test/unit/org/apache/cassandra/security/KubernetesSecretsSslContextFactoryTest.java
Patch:
@@ -38,7 +38,7 @@
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.config.EncryptionOptions;
-import org.apache.cassandra.io.util.PathUtils;
+import org.apache.cassandra.io.util.File;
 
 import static org.apache.cassandra.security.KubernetesSecretsSslContextFactory.ConfigKeys.KEYSTORE_PASSWORD_ENV_VAR;
 import static org.apache.cassandra.security.KubernetesSecretsSslContextFactory.ConfigKeys.KEYSTORE_UPDATED_TIMESTAMP_PATH;
@@ -64,7 +64,7 @@ public static void prepare()
     private static void deleteFileIfExists(String file)
     {
         Path filePath = Paths.get(file);
-        boolean deleted = PathUtils.tryDelete(filePath);
+        boolean deleted = new File(filePath).toJavaIOFile().delete();
         if (!deleted)
         {
             logger.warn("File {} could not be deleted.", filePath);

File: test/distributed/org/apache/cassandra/distributed/impl/Instance.java
Patch:
@@ -701,6 +701,7 @@ else if (cluster instanceof Cluster)
                     StorageService.instance.setUpDistributedSystemKeyspaces();
                     StorageService.instance.setNormalModeUnsafe();
                     Gossiper.instance.register(StorageService.instance);
+                    StorageService.instance.startSnapshotManager();
                 }
 
                 // Populate tokenMetadata for the second time,

File: test/unit/org/apache/cassandra/service/snapshot/SnapshotLoaderTest.java
Patch:
@@ -203,7 +203,7 @@ public void testInvalidSnapshotsAreNotLoaded() throws IOException
     @Test
     public void testParseUUID()
     {
-        assertThat(SnapshotLoader.parseUUID("c7e513243f0711ec9bbc0242ac130002")).isEqualTo(UUID.fromString("c7e51324-3f07-11ec-9bbc-0242ac130002"));
+        assertThat(SnapshotLoader.Visitor.parseUUID("c7e513243f0711ec9bbc0242ac130002")).isEqualTo(UUID.fromString("c7e51324-3f07-11ec-9bbc-0242ac130002"));
     }
 
     private void writeManifest(File snapshotDir, Instant creationTime, DurationSpec.IntSecondsBound ttl) throws IOException

File: test/anttasks/org/apache/cassandra/anttasks/JdkProperties.java
Patch:
@@ -27,7 +27,7 @@ public class JdkProperties extends Task
     public void execute()
     {
         Project project = getProject();
-        project.setNewProperty("java.version." + project.getProperty("ant.java.version"), "true");
-        project.setNewProperty("use-jdk" + project.getProperty("ant.java.version"), "true");
+        project.setNewProperty("java.version." + project.getProperty("ant.java.version").replace("1.", ""), "true");
+        project.setNewProperty("use-jdk" + project.getProperty("ant.java.version").replace("1.", ""), "true");
     }
 }

File: src/java/org/apache/cassandra/utils/memory/BufferPool.java
Patch:
@@ -427,8 +427,8 @@ private Chunk allocateMoreChunks()
                 {
                     if (memoryUsageThreshold > 0)
                     {
-                        noSpamLogger.info("Maximum memory usage reached ({}), cannot allocate chunk of {}",
-                                          readableMemoryUsageThreshold, READABLE_MACRO_CHUNK_SIZE);
+                        noSpamLogger.info("Maximum memory usage reached ({}) for {} buffer pool, cannot allocate chunk of {}",
+                                          readableMemoryUsageThreshold, name, READABLE_MACRO_CHUNK_SIZE);
                     }
                     return null;
                 }

File: src/java/org/apache/cassandra/transport/Message.java
Patch:
@@ -36,6 +36,7 @@
 import org.apache.cassandra.tracing.Tracing;
 import org.apache.cassandra.transport.messages.*;
 import org.apache.cassandra.service.QueryState;
+import org.apache.cassandra.utils.ReflectionUtils;
 import org.apache.cassandra.utils.TimeUUID;
 
 import static org.apache.cassandra.utils.TimeUUID.Generator.nextTimeUUID;
@@ -132,7 +133,7 @@ public Codec<?> unsafeSetCodec(Codec<?> codec) throws NoSuchFieldException, Ille
             Codec<?> original = this.codec;
             Field field = Type.class.getDeclaredField("codec");
             field.setAccessible(true);
-            Field modifiers = Field.class.getDeclaredField("modifiers");
+            Field modifiers = ReflectionUtils.getModifiersField();
             modifiers.setAccessible(true);
             modifiers.setInt(field, field.getModifiers() & ~Modifier.FINAL);
             field.set(this, codec);

File: test/unit/org/apache/cassandra/transport/MessagePayloadTest.java
Patch:
@@ -47,6 +47,7 @@
 import org.apache.cassandra.transport.messages.QueryMessage;
 import org.apache.cassandra.transport.messages.ResultMessage;
 import org.apache.cassandra.utils.MD5Digest;
+import org.apache.cassandra.utils.ReflectionUtils;
 
 import static org.apache.cassandra.utils.ByteBufferUtil.bytes;
 
@@ -66,7 +67,7 @@ public static void makeCqlQueryHandlerAccessible()
             cqlQueryHandlerField = ClientState.class.getDeclaredField("cqlQueryHandler");
             cqlQueryHandlerField.setAccessible(true);
 
-            Field modifiersField = Field.class.getDeclaredField("modifiers");
+            Field modifiersField = ReflectionUtils.getModifiersField();
             modifiersAccessible = modifiersField.isAccessible();
             modifiersField.setAccessible(true);
             modifiersField.setInt(cqlQueryHandlerField, cqlQueryHandlerField.getModifiers() & ~Modifier.FINAL);

File: test/unit/org/apache/cassandra/tools/NodeProbeTest.java
Patch:
@@ -37,6 +37,7 @@ public class NodeProbeTest extends CQLTester
     @BeforeClass
     public static void setup() throws Exception
     {
+        requireNetwork();
         startJMXServer();
         probe = new NodeProbe(jmxHost, jmxPort);
     }

File: test/unit/org/apache/cassandra/tools/nodetool/ClearSnapshotTest.java
Patch:
@@ -61,6 +61,7 @@ public class ClearSnapshotTest extends CQLTester
     public static void setup() throws Exception
     {
         startJMXServer();
+        requireNetwork();
         probe = new NodeProbe(jmxHost, jmxPort);
     }
 

File: test/unit/org/apache/cassandra/tools/nodetool/CompactTest.java
Patch:
@@ -35,6 +35,7 @@ public class CompactTest extends CQLTester
     @BeforeClass
     public static void setup() throws Throwable
     {
+        requireNetwork();
         startJMXServer();
     }
 

File: test/unit/org/apache/cassandra/tools/nodetool/GetAuditLogTest.java
Patch:
@@ -32,6 +32,7 @@ public class GetAuditLogTest extends CQLTester
     @BeforeClass
     public static void setup() throws Exception
     {
+        requireNetwork();
         startJMXServer();
     }
 

File: test/unit/org/apache/cassandra/tools/nodetool/GetAuthCacheConfigTest.java
Patch:
@@ -42,6 +42,7 @@ public static void setup() throws Exception
     {
         CQLTester.setUpClass();
         CQLTester.requireAuthentication();
+        requireNetwork();
         startJMXServer();
     }
 

File: test/unit/org/apache/cassandra/tools/nodetool/GetFullQueryLogTest.java
Patch:
@@ -38,6 +38,7 @@ public class GetFullQueryLogTest extends CQLTester
     @BeforeClass
     public static void setup() throws Exception
     {
+        requireNetwork();
         startJMXServer();
     }
 

File: test/unit/org/apache/cassandra/tools/nodetool/InvalidateCredentialsCacheTest.java
Patch:
@@ -62,6 +62,7 @@ public static void setup() throws Exception
                 .newAuthenticator((EndPoint) null, null)
                 .initialResponse());
 
+        requireNetwork();
         startJMXServer();
     }
 

File: test/unit/org/apache/cassandra/tools/nodetool/InvalidateJmxPermissionsCacheTest.java
Patch:
@@ -65,6 +65,7 @@ public static void setup() throws Exception
 
         AuthCacheService.initializeAndRegisterCaches();
 
+        requireNetwork();
         startJMXServer();
     }
 

File: test/unit/org/apache/cassandra/tools/nodetool/InvalidateNetworkPermissionsCacheTest.java
Patch:
@@ -47,6 +47,7 @@ public static void setup() throws Exception
         roleManager.createRole(AuthenticatedUser.SYSTEM_USER, ROLE_B, AuthTestUtils.getLoginRoleOptions());
         AuthCacheService.initializeAndRegisterCaches();
 
+        requireNetwork();
         startJMXServer();
     }
 

File: test/unit/org/apache/cassandra/tools/nodetool/InvalidatePermissionsCacheTest.java
Patch:
@@ -85,6 +85,7 @@ public static void setup() throws Exception
             authorizer.grant(AuthenticatedUser.SYSTEM_USER, permissions, resource, ROLE_B);
         }
 
+        requireNetwork();
         startJMXServer();
     }
 

File: test/unit/org/apache/cassandra/tools/nodetool/InvalidateRolesCacheTest.java
Patch:
@@ -47,6 +47,7 @@ public static void setup() throws Exception
         roleManager.createRole(AuthenticatedUser.SYSTEM_USER, ROLE_B, AuthTestUtils.getLoginRoleOptions());
         AuthCacheService.initializeAndRegisterCaches();
 
+        requireNetwork();
         startJMXServer();
     }
 

File: test/unit/org/apache/cassandra/tools/nodetool/SetAuthCacheConfigTest.java
Patch:
@@ -42,6 +42,7 @@ public static void setup() throws Exception
     {
         CQLTester.setUpClass();
         CQLTester.requireAuthentication();
+        requireNetwork();
         startJMXServer();
     }
 

File: test/unit/org/apache/cassandra/tools/nodetool/SetGetColumnIndexSizeTest.java
Patch:
@@ -36,6 +36,7 @@ public class SetGetColumnIndexSizeTest extends CQLTester
     @BeforeClass
     public static void setup() throws Exception
     {
+        requireNetwork();
         startJMXServer();
     }
 

File: test/unit/org/apache/cassandra/tools/nodetool/SetGetCompactionThroughputTest.java
Patch:
@@ -38,6 +38,7 @@ public class SetGetCompactionThroughputTest extends CQLTester
     @BeforeClass
     public static void setup() throws Exception
     {
+        requireNetwork();
         startJMXServer();
     }
 

File: test/unit/org/apache/cassandra/tools/nodetool/SetGetEntireSSTableInterDCStreamThroughputTest.java
Patch:
@@ -39,6 +39,7 @@ public class SetGetEntireSSTableInterDCStreamThroughputTest extends CQLTester
     @BeforeClass
     public static void setup() throws Exception
     {
+        requireNetwork();
         startJMXServer();
     }
 

File: test/unit/org/apache/cassandra/tools/nodetool/SetGetEntireSSTableStreamThroughputTest.java
Patch:
@@ -39,6 +39,7 @@ public class SetGetEntireSSTableStreamThroughputTest extends CQLTester
     @BeforeClass
     public static void setup() throws Exception
     {
+        requireNetwork();
         startJMXServer();
     }
 

File: test/unit/org/apache/cassandra/tools/nodetool/SetGetInterDCStreamThroughputTest.java
Patch:
@@ -46,6 +46,7 @@ public class SetGetInterDCStreamThroughputTest extends CQLTester
     @BeforeClass
     public static void setup() throws Exception
     {
+        requireNetwork();
         startJMXServer();
     }
 

File: test/unit/org/apache/cassandra/tools/nodetool/SetGetStreamThroughputTest.java
Patch:
@@ -47,6 +47,7 @@ public class SetGetStreamThroughputTest extends CQLTester
     @BeforeClass
     public static void setup() throws Exception
     {
+        requireNetwork();
         startJMXServer();
     }
 

File: test/unit/org/apache/cassandra/tools/nodetool/SnapshotTest.java
Patch:
@@ -36,6 +36,7 @@ public class SnapshotTest extends CQLTester
     @BeforeClass
     public static void setup() throws Exception
     {
+        requireNetwork();
         startJMXServer();
     }
 

File: src/java/org/apache/cassandra/auth/CassandraRoleManager.java
Patch:
@@ -364,7 +364,7 @@ private static void setupDefaultRole()
             if (!hasExistingRoles())
             {
                 QueryProcessor.process(String.format("INSERT INTO %s.%s (role, is_superuser, can_login, salted_hash) " +
-                                                     "VALUES ('%s', true, true, '%s')",
+                                                     "VALUES ('%s', true, true, '%s') USING TIMESTAMP 0",
                                                      AuthKeyspace.NAME,
                                                      AuthKeyspace.ROLES,
                                                      DEFAULT_SUPERUSER_NAME,
@@ -380,7 +380,8 @@ private static void setupDefaultRole()
         }
     }
 
-    private static boolean hasExistingRoles() throws RequestExecutionException
+    @VisibleForTesting
+    public static boolean hasExistingRoles() throws RequestExecutionException
     {
         // Try looking up the 'cassandra' default role first, to avoid the range query if possible.
         String defaultSUQuery = String.format("SELECT * FROM %s.%s WHERE role = '%s'", AuthKeyspace.NAME, AuthKeyspace.ROLES, DEFAULT_SUPERUSER_NAME);

File: src/java/org/apache/cassandra/db/ColumnFamilyStoreMBean.java
Patch:
@@ -168,7 +168,7 @@ public interface ColumnFamilyStoreMBean
      * @param hexFormat
      * @return list of filenames and levels containing the key
      */
-    public Map<Integer, Collection<String>> getSSTablesForKeyWithLevel(String key, boolean hexFormat);
+    public Map<Integer, Set<String>> getSSTablesForKeyWithLevel(String key, boolean hexFormat);
 
     /**
      * Load new sstables from the given directory

File: src/java/org/apache/cassandra/tools/NodeProbe.java
Patch:
@@ -30,7 +30,6 @@
 import java.rmi.server.RMISocketFactory;
 import java.util.AbstractMap;
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
@@ -1045,7 +1044,7 @@ public List<String> getSSTables(String keyspace, String cf, String key, boolean
         return cfsProxy.getSSTablesForKey(key, hexFormat);
     }
 
-    public Map<Integer, Collection<String>> getSSTablesWithLevel(String keyspace, String cf, String key, boolean hexFormat)
+    public Map<Integer, Set<String>> getSSTablesWithLevel(String keyspace, String cf, String key, boolean hexFormat)
     {
         ColumnFamilyStoreMBean cfsProxy = getCfsProxy(keyspace, cf);
         return cfsProxy.getSSTablesForKeyWithLevel(key, hexFormat);

File: src/java/org/apache/cassandra/tools/nodetool/GetSSTables.java
Patch:
@@ -22,9 +22,9 @@
 import io.airlift.airline.Command;
 
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 import io.airlift.airline.Option;
 import org.apache.cassandra.tools.NodeProbe;
@@ -54,7 +54,7 @@ public void execute(NodeProbe probe)
 
         if (showLevels && probe.isLeveledCompaction(ks, cf))
         {
-            Map<Integer, Collection<String>> sstables = probe.getSSTablesWithLevel(ks, cf, key, hexFormat);
+            Map<Integer, Set<String>> sstables = probe.getSSTablesWithLevel(ks, cf, key, hexFormat);
             for (Integer level : sstables.keySet())
                 for (String sstable : sstables.get(level))
                     probe.output().out.println(level + ": " + sstable);

File: src/java/org/apache/cassandra/service/paxos/ContentionStrategy.java
Patch:
@@ -373,7 +373,7 @@ public enum Type
         }
     }
 
-    private long computeWaitUntilForContention(int attempts, TableMetadata table, DecoratedKey partitionKey, ConsistencyLevel consistency, Type type)
+    long computeWaitUntilForContention(int attempts, TableMetadata table, DecoratedKey partitionKey, ConsistencyLevel consistency, Type type)
     {
         if (attempts >= traceAfterAttempts && !Tracing.isTracing())
         {
@@ -409,10 +409,10 @@ private long computeWaitUntilForContention(int attempts, TableMetadata table, De
         }
 
         long wait = waitRandomizer.wait(minWaitMicros, maxWaitMicros, attempts);
-        return nanoTime() + wait;
+        return nanoTime() + MICROSECONDS.toNanos(wait);
     }
 
-    private boolean doWaitForContention(long deadline, int attempts, TableMetadata table, DecoratedKey partitionKey, ConsistencyLevel consistency, Type type)
+    boolean doWaitForContention(long deadline, int attempts, TableMetadata table, DecoratedKey partitionKey, ConsistencyLevel consistency, Type type)
     {
         long until = computeWaitUntilForContention(attempts, table, partitionKey, consistency, type);
         if (until >= deadline)

File: src/java/org/apache/cassandra/utils/Clock.java
Patch:
@@ -136,7 +136,7 @@ public long currentTimeMillis()
     @Intercept
     public static void waitUntil(long deadlineNanos) throws InterruptedException
     {
-        long waitNanos = Clock.Global.nanoTime() - deadlineNanos;
+        long waitNanos = deadlineNanos - Clock.Global.nanoTime();
         if (waitNanos > 0)
             TimeUnit.NANOSECONDS.sleep(waitNanos);
     }

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -985,7 +985,10 @@ protected void runMayThrow()
                 {
                     for (AbstractCompactionTask task : tasks)
                         if (task != null)
+                        {
+                            task.setCompactionType(OperationType.MAJOR_COMPACTION);
                             task.execute(active);
+                        }
                 }
             };
 

File: src/java/org/apache/cassandra/cql3/statements/CreateAggregateStatement.java
Patch:
@@ -80,6 +80,9 @@ public CreateAggregateStatement(FunctionName functionName,
 
     public Prepared prepare(ClientState clientState)
     {
+        if (!FunctionName.isNameValid(functionName.name))
+            throw new InvalidRequestException(String.format("Aggregate name '%s' is invalid", functionName.name));
+
         argTypes = new ArrayList<>(argRawTypes.size());
         for (CQL3Type.Raw rawType : argRawTypes)
             argTypes.add(prepareType("arguments", rawType));

File: src/java/org/apache/cassandra/cql3/statements/CreateFunctionStatement.java
Patch:
@@ -78,6 +78,9 @@ public CreateFunctionStatement(FunctionName functionName,
 
     public Prepared prepare(ClientState clientState) throws InvalidRequestException
     {
+        if (!FunctionName.isNameValid(functionName.name))
+            throw new InvalidRequestException(String.format("Function name '%s' is invalid", functionName.name));
+
         if (new HashSet<>(argNames).size() != argNames.size())
             throw new InvalidRequestException(String.format("duplicate argument names for given function %s with argument names %s",
                                                             functionName, argNames));

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -869,6 +869,8 @@ public static void setClientMode(boolean clientMode)
     public volatile int minimum_replication_factor_fail_threshold = -1;
     public volatile int maximum_replication_factor_warn_threshold = -1;
     public volatile int maximum_replication_factor_fail_threshold = -1;
+    public volatile boolean zero_ttl_on_twcs_warned = true;
+    public volatile boolean zero_ttl_on_twcs_enabled = true;
 
     public volatile DurationSpec.LongNanosecondsBound streaming_state_expires = new DurationSpec.LongNanosecondsBound("3d");
     public volatile DataStorageSpec.LongBytesBound streaming_state_size = new DataStorageSpec.LongBytesBound("40MiB");

File: src/java/org/apache/cassandra/cql3/statements/schema/AlterTableStatement.java
Patch:
@@ -443,6 +443,8 @@ public void validate(ClientState state)
             super.validate(state);
 
             Guardrails.tableProperties.guard(attrs.updatedProperties(), attrs::removeProperty, state);
+
+            validateDefaultTimeToLive(attrs.asNewTableParams());
         }
 
         public KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table)

File: src/java/org/apache/cassandra/cql3/statements/schema/CreateTableStatement.java
Patch:
@@ -149,6 +149,8 @@ public void validate(ClientState state)
         // Guardrail to check whether creation of new COMPACT STORAGE tables is allowed
         if (useCompactStorage)
             Guardrails.compactTablesEnabled.ensureEnabled(state);
+
+        validateDefaultTimeToLive(attrs.asNewTableParams());
     }
 
     SchemaChange schemaChangeEvent(KeyspacesDiff diff)

File: src/java/org/apache/cassandra/cql3/functions/NativeFunctions.java
Patch:
@@ -41,6 +41,7 @@ public class NativeFunctions
             OperationFcts.addFunctionsTo(this);
             AggregateFcts.addFunctionsTo(this);
             BytesConversionFcts.addFunctionsTo(this);
+            MathFcts.addFunctionsTo(this);
         }
     };
 

File: src/java/org/apache/cassandra/cql3/statements/BatchStatement.java
Patch:
@@ -647,7 +647,7 @@ public String keyspace()
         public BatchStatement prepare(ClientState state)
         {
             List<ModificationStatement> statements = new ArrayList<>(parsedStatements.size());
-            parsedStatements.forEach(s -> statements.add(s.prepare(bindVariables)));
+            parsedStatements.forEach(s -> statements.add(s.prepare(state, bindVariables)));
 
             Attributes prepAttrs = attrs.prepare("[batch]", "[batch]");
             prepAttrs.collectMarkerSpecification(bindVariables);

File: src/java/org/apache/cassandra/cql3/statements/schema/CreateViewStatement.java
Patch:
@@ -272,7 +272,8 @@ public Keyspaces apply(Keyspaces schema)
             throw ire("WHERE clause for materialized view '%s' cannot contain custom index expressions", viewName);
 
         StatementRestrictions restrictions =
-            new StatementRestrictions(StatementType.SELECT,
+            new StatementRestrictions(state,
+                                      StatementType.SELECT,
                                       table,
                                       whereClause,
                                       VariableSpecifications.empty(),

File: src/java/org/apache/cassandra/db/guardrails/Predicates.java
Patch:
@@ -56,16 +56,18 @@ public interface MessageProvider<T>
      * Creates a new {@link Predicates} guardrail.
      *
      * @param name             the identifying name of the guardrail
+     * @param reason           the optional description of the reason for guarding the operation
      * @param warnPredicate    a {@link ClientState}-based predicate provider that is used to check if given value should trigger a warning.
      * @param failurePredicate a {@link ClientState}-based predicate provider that is used to check if given value should trigger a failure.
      * @param messageProvider  a function to generate the warning or error message if the guardrail is triggered
      */
     Predicates(String name,
+               @Nullable String reason,
                Function<ClientState, Predicate<T>> warnPredicate,
                Function<ClientState, Predicate<T>> failurePredicate,
                MessageProvider<T> messageProvider)
     {
-        super(name);
+        super(name, reason);
         this.warnPredicate = warnPredicate;
         this.failurePredicate = failurePredicate;
         this.messageProvider = messageProvider;

File: src/java/org/apache/cassandra/db/guardrails/Threshold.java
Patch:
@@ -41,16 +41,18 @@ public abstract class Threshold extends Guardrail
      * Creates a new threshold guardrail.
      *
      * @param name            the identifying name of the guardrail
+     * @param reason          the optional description of the reason for guarding the operation
      * @param warnThreshold   a {@link ClientState}-based provider of the value above which a warning should be triggered.
      * @param failThreshold   a {@link ClientState}-based provider of the value above which the operation should be aborted.
      * @param messageProvider a function to generate the warning or error message if the guardrail is triggered
      */
     public Threshold(String name,
+                     @Nullable String reason,
                      ToLongFunction<ClientState> warnThreshold,
                      ToLongFunction<ClientState> failThreshold,
                      ErrorMessageProvider messageProvider)
     {
-        super(name);
+        super(name, reason);
         this.warnThreshold = warnThreshold;
         this.failThreshold = failThreshold;
         this.messageProvider = messageProvider;

File: src/java/org/apache/cassandra/db/guardrails/Values.java
Patch:
@@ -47,18 +47,20 @@ public class Values<T> extends Guardrail
      * Creates a new values guardrail.
      *
      * @param name             the identifying name of the guardrail
+     * @param reason           the optional description of the reason for guarding the operation
      * @param warnedValues     a {@link ClientState}-based provider of the values for which a warning is triggered.
      * @param ignoredValues    a {@link ClientState}-based provider of the values that are ignored.
      * @param disallowedValues a {@link ClientState}-based provider of the values that are disallowed.
      * @param what             The feature that is guarded by this guardrail (for reporting in error messages).
      */
     public Values(String name,
+                  @Nullable String reason,
                   Function<ClientState, Set<T>> warnedValues,
                   Function<ClientState, Set<T>> ignoredValues,
                   Function<ClientState, Set<T>> disallowedValues,
                   String what)
     {
-        super(name);
+        super(name, reason);
         this.warnedValues = warnedValues;
         this.ignoredValues = ignoredValues;
         this.disallowedValues = disallowedValues;

File: src/java/org/apache/cassandra/db/view/View.java
Patch:
@@ -35,6 +35,7 @@
 import org.apache.cassandra.schema.Schema;
 import org.apache.cassandra.schema.TableMetadataRef;
 import org.apache.cassandra.schema.ViewMetadata;
+import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.utils.FBUtilities;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -177,7 +178,7 @@ SelectStatement getSelectStatement()
 
             rawSelect.setBindVariables(Collections.emptyList());
 
-            select = rawSelect.prepare(true);
+            select = rawSelect.prepare(ClientState.forInternalCalls(), true);
         }
 
         return select;

File: test/distributed/org/apache/cassandra/distributed/fuzz/SSTableGenerator.java
Patch:
@@ -306,7 +306,8 @@ Mutation delete(long lts, long pd, Query query)
                                                  new AbstractMarker.Raw(values.size() - 1)));
         }
 
-        StatementRestrictions restrictions = new StatementRestrictions(StatementType.DELETE,
+        StatementRestrictions restrictions = new StatementRestrictions(null,
+                                                                       StatementType.DELETE,
                                                                        metadata,
                                                                        builder.build(),
                                                                        new VariableSpecifications(variableNames),

File: test/unit/org/apache/cassandra/db/guardrails/GuardrailsConfigProviderTest.java
Patch:
@@ -37,6 +37,7 @@ public void testBuildCustom() throws Throwable
         String name = getClass().getCanonicalName() + '$' + CustomProvider.class.getSimpleName();
         GuardrailsConfigProvider provider = GuardrailsConfigProvider.build(name);
         MaxThreshold guard = new MaxThreshold("test_guardrail",
+                                        "Some reason",
                                         state -> provider.getOrCreate(state).getTablesWarnThreshold(),
                                         state -> provider.getOrCreate(state).getTablesFailThreshold(),
                                         (isWarn, what, v, t) -> format("%s: for %s, %s > %s",

File: src/java/org/apache/cassandra/cql3/functions/FunctionResolver.java
Patch:
@@ -177,7 +177,7 @@ private static Function pickBestMatch(String keyspace,
                             return toTest;
                     }
                 }
-                throw invalidRequest("Ambiguous '%s' operation with args %s and %s: use type casts to disambiguate",
+                throw invalidRequest("Ambiguous '%s' operation with args %s and %s: use type hint to disambiguate, example '(int) ?'",
                                      OperationFcts.getOperator(name), providedArgs.get(0), providedArgs.get(1));
             }
 

File: src/java/org/apache/cassandra/service/paxos/PaxosCommit.java
Patch:
@@ -260,7 +260,7 @@ public void onResponse(NoPayload response, InetAddressAndPort from)
      */
     private void response(boolean success, InetAddressAndPort from)
     {
-        if (consistencyForCommit.isDatacenterLocal() && InOurDc.endpoints().test(from))
+        if (consistencyForCommit.isDatacenterLocal() && !InOurDc.endpoints().test(from))
             return;
 
         long responses = responsesUpdater.addAndGet(this, success ? 0x1L : 0x100000000L);

File: src/java/org/apache/cassandra/tools/NodeProbe.java
Patch:
@@ -2005,6 +2005,8 @@ public void resumeBootstrap(PrintStream out) throws IOException
             {
                 out.println("Resuming bootstrap");
                 monitor.awaitCompletion();
+                if (monitor.getError() != null)
+                    throw monitor.getError();
             }
             else
             {

File: test/distributed/org/apache/cassandra/distributed/test/BootstrapBinaryDisabledTest.java
Patch:
@@ -131,6 +131,7 @@ private static void bootstrap(Cluster cluster,
             .failure()
             .errorContains("Cannot join the ring until bootstrap completes");
 
+        node.nodetoolResult("bootstrap", "resume").asserts().failure();
         RewriteEnabled.disable();
         node.nodetoolResult("bootstrap", "resume").asserts().success();
         if (isWriteSurvey)

File: src/java/org/apache/cassandra/locator/Replica.java
Patch:
@@ -191,6 +191,5 @@ public static Replica transientReplica(InetAddressAndPort endpoint, Token start,
     {
         return transientReplica(endpoint, new Range<>(start, end));
     }
-
 }
 

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1946,7 +1946,7 @@ public boolean bootstrap(final Collection<Token> tokens, long bootstrapTimeoutMi
         if (Boolean.getBoolean("cassandra.reset_bootstrap_progress"))
         {
             logger.info("Resetting bootstrap progress to start fresh");
-            SystemKeyspace.resetAvailableRanges();
+            SystemKeyspace.resetAvailableStreamedRanges();
         }
 
         // Force disk boundary invalidation now that local tokens are set

File: src/java/org/apache/cassandra/db/Columns.java
Patch:
@@ -436,7 +436,7 @@ public long unsharedHeapSize()
         if(this == NONE)
             return 0;
 
-        return EMPTY_SIZE;
+        return EMPTY_SIZE + BTree.sizeOfStructureOnHeap(columns);
     }
 
     @Override

File: src/java/org/apache/cassandra/db/memtable/AbstractMemtable.java
Patch:
@@ -33,6 +33,7 @@
 import org.apache.cassandra.schema.ColumnMetadata;
 import org.apache.cassandra.schema.TableMetadata;
 import org.apache.cassandra.schema.TableMetadataRef;
+import org.github.jamm.Unmetered;
 
 public abstract class AbstractMemtable implements Memtable
 {
@@ -46,6 +47,7 @@ public abstract class AbstractMemtable implements Memtable
     // Note: statsCollector has corresponding statistics to the two above, but starts with an epoch value which is not
     // correct for their usage.
 
+    @Unmetered
     protected TableMetadataRef metadata;
 
     public AbstractMemtable(TableMetadataRef metadataRef)

File: src/java/org/apache/cassandra/utils/btree/BTree.java
Patch:
@@ -947,6 +947,9 @@ public static int size(Object[] tree)
 
     public static long sizeOfStructureOnHeap(Object[] tree)
     {
+        if (tree == EMPTY_LEAF)
+            return 0;
+
         long size = ObjectSizes.sizeOfArray(tree);
         if (isLeaf(tree))
             return size;

File: test/unit/org/apache/cassandra/db/memtable/MemtableQuickTest.java
Patch:
@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-package org.apache.cassandra.cql3;
+package org.apache.cassandra.db.memtable;
 
 import java.util.List;
 
@@ -30,6 +30,8 @@
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.Util;
+import org.apache.cassandra.cql3.CQLTester;
+import org.apache.cassandra.cql3.UntypedResultSet;
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.Keyspace;
 

File: src/java/org/apache/cassandra/cql3/functions/UDFByteCodeVerifier.java
Patch:
@@ -160,7 +160,7 @@ private class ExecuteImplVisitor extends MethodVisitor
 
         ExecuteImplVisitor(Set<String> errors)
         {
-            super(Opcodes.ASM5);
+            super(Opcodes.ASM7);
             this.errors = errors;
         }
 
@@ -210,7 +210,7 @@ private static class ConstructorVisitor extends MethodVisitor
 
         ConstructorVisitor(Set<String> errors)
         {
-            super(Opcodes.ASM5);
+            super(Opcodes.ASM7);
             this.errors = errors;
         }
 

File: test/distributed/org/apache/cassandra/distributed/impl/Instance.java
Patch:
@@ -114,7 +114,6 @@
 import org.apache.cassandra.schema.MigrationCoordinator;
 import org.apache.cassandra.schema.Schema;
 import org.apache.cassandra.schema.SchemaConstants;
-import org.apache.cassandra.security.ThreadAwareSecurityManager;
 import org.apache.cassandra.service.ActiveRepairService;
 import org.apache.cassandra.service.CassandraDaemon;
 import org.apache.cassandra.service.ClientState;
@@ -147,6 +146,7 @@
 import org.apache.cassandra.utils.JVMStabilityInspector;
 import org.apache.cassandra.utils.Throwables;
 import org.apache.cassandra.utils.concurrent.Ref;
+import org.apache.cassandra.utils.logging.LoggingSupportFactory;
 import org.apache.cassandra.utils.memory.BufferPools;
 import org.apache.cassandra.utils.progress.jmx.JMXBroadcastExecutor;
 
@@ -591,7 +591,8 @@ public void startup(ICluster cluster)
                 DistributedTestSnitch.assign(config.networkTopology());
 
                 DatabaseDescriptor.daemonInitialization();
-                ThreadAwareSecurityManager.install();
+                LoggingSupportFactory.getLoggingSupport().onStartup();
+
                 FileUtils.setFSErrorHandler(new DefaultFSErrorHandler());
                 DatabaseDescriptor.createAllDirectories();
                 CassandraDaemon.getInstanceForTesting().migrateSystemDataIfNeeded();

File: test/unit/org/apache/cassandra/config/DatabaseDescriptorTest.java
Patch:
@@ -415,7 +415,7 @@ public void testRepairSessionMemorySizeToggles()
             try
             {
                 DatabaseDescriptor.setRepairSessionSpaceInMiB(0);
-                fail("Should have received a ConfigurationException for depth of 9");
+                fail("Should have received a ConfigurationException for depth of 0");
             }
             catch (ConfigurationException ignored) { }
 

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -5636,7 +5636,7 @@ public void rebuildSecondaryIndex(String ksName, String cfName, String... idxNam
         ColumnFamilyStore.rebuildSecondaryIndex(ksName, cfName, indices);
     }
 
-    public void resetLocalSchema() throws IOException
+    public void resetLocalSchema()
     {
         MigrationManager.resetLocalSchema();
     }

File: src/java/org/apache/cassandra/utils/vint/VIntCoding.java
Patch:
@@ -97,6 +97,9 @@ public static long getUnsignedVInt(ByteBuffer input, int readerIndex)
 
     public static long getUnsignedVInt(ByteBuffer input, int readerIndex, int readerLimit)
     {
+        if (readerIndex < 0)
+            throw new IllegalArgumentException("Reader index should be non-negative, but was " + readerIndex);
+
         if (readerIndex >= readerLimit)
             return -1;
 

File: src/java/org/apache/cassandra/db/compaction/Upgrader.java
Patch:
@@ -93,8 +93,8 @@ public void upgrade(boolean keepOriginals)
              CompactionIterator iter = new CompactionIterator(transaction.opType(), scanners.scanners, controller, nowInSec, nextTimeUUID()))
         {
             writer.switchWriter(createCompactionWriter(sstable.getSSTableMetadata()));
+            iter.setTargetDirectory(writer.currentWriter().getFilename());
             while (iter.hasNext())
-                iter.setTargetDirectory(writer.currentWriter().getFilename());
                 writer.append(iter.next());
 
             writer.finish();

File: src/java/org/apache/cassandra/io/sstable/metadata/MetadataCollector.java
Patch:
@@ -58,8 +58,9 @@ static EstimatedHistogram defaultCellPerPartitionCountHistogram()
 
     static EstimatedHistogram defaultPartitionSizeHistogram()
     {
-        // EH of 150 can track a max value of 1697806495183, i.e., > 1.5PB
-        return new EstimatedHistogram(150);
+        // EH of 155 can track a max value of 3520571548412 i.e. 3.5TB
+        return new EstimatedHistogram(155);
+
     }
 
     static TombstoneHistogram defaultTombstoneDropTimeHistogram()

File: test/distributed/org/apache/cassandra/distributed/test/IncRepairCoordinatorErrorTest.java
Patch:
@@ -18,14 +18,13 @@
 
 package org.apache.cassandra.distributed.test;
 
-import java.util.UUID;
-
 import org.junit.Test;
 
 import org.apache.cassandra.distributed.Cluster;
 import org.apache.cassandra.distributed.api.ConsistencyLevel;
 import org.apache.cassandra.distributed.api.Feature;
 import org.apache.cassandra.service.ActiveRepairService;
+import org.apache.cassandra.utils.TimeUUID;
 
 import static org.apache.cassandra.net.Verb.FINALIZE_COMMIT_MSG;
 import static org.assertj.core.api.Assertions.assertThat;
@@ -47,7 +46,7 @@ public void errorTest() throws Exception
                    .to(3)
                    .messagesMatching((from, to, msg) -> msg.verb() == FINALIZE_COMMIT_MSG.id).drop();
             cluster.get(1).nodetoolResult("repair", KEYSPACE).asserts().success();
-            UUID result = (UUID) cluster.get(1).executeInternal("select parent_id from system_distributed.repair_history")[0][0];
+            TimeUUID result = (TimeUUID) cluster.get(1).executeInternal("select parent_id from system_distributed.repair_history")[0][0];
             cluster.get(3).runOnInstance(() -> {
                 ActiveRepairService.instance.failSession(result.toString(), true);
             });

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegmentManagerStandard.java
Patch:
@@ -61,7 +61,8 @@ public CommitLogSegment.Allocation allocate(Mutation mutation, int size)
         return alloc;
     }
 
-   public CommitLogSegment createSegment()
+    @Override
+    public CommitLogSegment createSegment()
     {
         return CommitLogSegment.createSegment(commitLog, this);
     }

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -283,7 +283,7 @@ public static void clientInitialization(boolean failIfDaemonOrTool)
         if (clientInitialized)
             return;
         clientInitialized = true;
-
+        setDefaultFailureDetector();
         Config.setClientMode(true);
         conf = new Config();
         diskOptimizationStrategy = new SpinningDiskOptimizationStrategy();

File: test/unit/org/apache/cassandra/io/sstable/CQLSSTableWriterClientTest.java
Patch:
@@ -41,7 +41,6 @@ public class CQLSSTableWriterClientTest
     public void setUp()
     {
         this.testDirectory = new File(Files.createTempDir());
-        DatabaseDescriptor.setDefaultFailureDetector();
         DatabaseDescriptor.clientInitialization();
     }
 

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -220,7 +220,7 @@ public class Config
     public volatile int batch_size_fail_threshold_in_kb = 50;
     public Integer unlogged_batch_across_partitions_warn_threshold = 10;
     public volatile Integer concurrent_compactors;
-    public volatile int compaction_throughput_mb_per_sec = 16;
+    public volatile int compaction_throughput_mb_per_sec = 64;
     public volatile int compaction_large_partition_warning_threshold_mb = 100;
     public int min_free_space_per_drive_in_mb = 50;
 

File: test/unit/org/apache/cassandra/config/DatabaseDescriptorRefTest.java
Patch:
@@ -106,7 +106,7 @@ public class DatabaseDescriptorRefTest
     "org.apache.cassandra.config.DataStorageSpec$LongBytesBound",
     "org.apache.cassandra.config.DataStorageSpec$LongMebibytesBound",
     "org.apache.cassandra.config.DurationSpec",
-    "org.apache.cassandra.config.DataRateSpec$IntMebibytesPerSecondBound",
+    "org.apache.cassandra.config.DataRateSpec$LongBytesPerSecondBound",
     "org.apache.cassandra.config.DurationSpec$LongMillisecondsBound",
     "org.apache.cassandra.config.DurationSpec$LongNanosecondsBound",
     "org.apache.cassandra.config.DurationSpec$LongSecondsBound",

File: test/unit/org/apache/cassandra/config/ParseAndConvertUnitsTest.java
Patch:
@@ -112,8 +112,8 @@ public void testConfigurationLoaderParser()
         assertEquals(new DataStorageSpec.IntBytesBound(1, MEBIBYTES), config.native_transport_receive_queue_capacity);
 
         //Confirm rate parameters were successfully parsed with the default values in cassandra.yaml
-        assertEquals(new DataRateSpec.IntMebibytesPerSecondBound(0), config.compaction_throughput);
-        assertEquals(new DataRateSpec.IntMebibytesPerSecondBound(23841858), config.stream_throughput_outbound);
-        assertEquals(new DataRateSpec.IntMebibytesPerSecondBound(24), config.inter_dc_stream_throughput_outbound);
+        assertEquals(new DataRateSpec.LongBytesPerSecondBound(0), config.compaction_throughput);
+        assertEquals(new DataRateSpec.LongBytesPerSecondBound(23841858, DataRateSpec.DataRateUnit.MEBIBYTES_PER_SECOND), config.stream_throughput_outbound);
+        assertEquals(new DataRateSpec.LongBytesPerSecondBound(24, DataRateSpec.DataRateUnit.MEBIBYTES_PER_SECOND), config.inter_dc_stream_throughput_outbound);
     }
 }

File: test/unit/org/apache/cassandra/db/KeyCacheTest.java
Patch:
@@ -74,6 +74,7 @@ public class KeyCacheTest
     private static final String COLUMN_FAMILY7 = "Standard7";
     private static final String COLUMN_FAMILY8 = "Standard8";
     private static final String COLUMN_FAMILY9 = "Standard9";
+    private static final String COLUMN_FAMILY10 = "Standard10";
 
     private static final String COLUMN_FAMILY_K2_1 = "Standard1";
 
@@ -92,7 +93,8 @@ public static void defineSchema() throws ConfigurationException
                                     SchemaLoader.standardCFMD(KEYSPACE1, COLUMN_FAMILY6),
                                     SchemaLoader.standardCFMD(KEYSPACE1, COLUMN_FAMILY7),
                                     SchemaLoader.standardCFMD(KEYSPACE1, COLUMN_FAMILY8),
-                                    SchemaLoader.standardCFMD(KEYSPACE1, COLUMN_FAMILY9));
+                                    SchemaLoader.standardCFMD(KEYSPACE1, COLUMN_FAMILY9),
+                                    SchemaLoader.standardCFMD(KEYSPACE1, COLUMN_FAMILY10));
 
         SchemaLoader.createKeyspace(KEYSPACE2,
                                     KeyspaceParams.simple(1),

File: tools/stress/src/org/apache/cassandra/stress/CompactionStress.java
Patch:
@@ -36,7 +36,6 @@
 import org.apache.cassandra.cql3.statements.schema.CreateTableStatement;
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.Directories;
-import org.apache.cassandra.db.SystemKeyspace;
 import org.apache.cassandra.db.commitlog.CommitLog;
 import org.apache.cassandra.db.compaction.CompactionManager;
 import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
@@ -218,7 +217,7 @@ public void run()
             //Setup
             CompactionManager.instance.setMaximumCompactorThreads(threads);
             CompactionManager.instance.setCoreCompactorThreads(threads);
-            CompactionManager.instance.setRate(0);
+            CompactionManager.instance.setRateInBytes(0);
 
             StressProfile stressProfile = getStressProfile();
             ColumnFamilyStore cfs = initCf(stressProfile, true);

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -6010,11 +6010,13 @@ public String getPartitionerName()
         return DatabaseDescriptor.getPartitionerName();
     }
 
+    /** Negative number for disabled */
     public void setSSTablePreemptiveOpenIntervalInMB(int intervalInMB)
     {
         DatabaseDescriptor.setSSTablePreemptiveOpenIntervalInMiB(intervalInMB);
     }
 
+    /** This method can return negative number for disabled */
     public int getSSTablePreemptiveOpenIntervalInMB()
     {
         return DatabaseDescriptor.getSSTablePreemptiveOpenIntervalInMiB();

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -356,8 +356,8 @@ public class Config
     public volatile Long index_summary_capacity_in_mb;
     public volatile int index_summary_resize_interval_in_minutes = 60;
 
-    public int gc_log_threshold_in_ms = 200;
-    public int gc_warn_threshold_in_ms = 1000;
+    public volatile int gc_log_threshold_in_ms = 200;
+    public volatile int gc_warn_threshold_in_ms = 1000;
 
     // TTL for different types of trace events.
     public int tracetype_query_ttl = (int) TimeUnit.DAYS.toSeconds(1);

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -346,7 +346,7 @@ public void stopGossiping()
     {
         if (initialized)
         {
-            if (!isNormal())
+            if (!isNormal() && joinRing)
                 throw new IllegalStateException("Unable to stop gossip because the node is not in the normal state. Try to stop the node instead.");
 
             logger.warn("Stopping gossip by operator request");
@@ -4489,7 +4489,7 @@ synchronized void checkServiceAllowedToStart(String service)
         if (isShutdown()) // do not rely on operationMode in case it gets changed to decomissioned or other
             throw new IllegalStateException(String.format("Unable to start %s because the node was drained.", service));
 
-        if (!isNormal())
+        if (!isNormal() && joinRing) // if the node is not joining the ring, it is gossipping-only member which is in STARTING state forever
             throw new IllegalStateException(String.format("Unable to start %s because the node is not in the normal state.", service));
     }
 

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -777,7 +777,7 @@ public static boolean isClientMode()
     public volatile boolean auto_optimise_preview_repair_streams = false;
 
     // see CASSANDRA-17048 and the comment in cassandra.yaml
-    public boolean enable_uuid_sstable_identifiers = false;
+    public boolean uuid_sstable_identifiers_enabled = false;
 
     /**
      * Client mode means that the process is a pure client, that uses C* code base but does

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -4156,7 +4156,7 @@ public static void setStreamingStateSize(DataStorageSpec.LongBytesBound duration
 
     public static boolean isUUIDSSTableIdentifiersEnabled()
     {
-        return conf.enable_uuid_sstable_identifiers;
+        return conf.uuid_sstable_identifiers_enabled;
     }
 
     public static DurationSpec.LongNanosecondsBound getRepairStateExpires()

File: src/java/org/apache/cassandra/service/StartupChecks.java
Patch:
@@ -605,7 +605,7 @@ public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) th
                                            "UUID sstable identifiers are disabled but some sstables have been " +
                                            "created with UUID identifiers. You have to either delete those " +
                                            "sstables or enable UUID based sstable identifers in cassandra.yaml " +
-                                           "(enable_uuid_sstable_identifiers). The list of affected sstables is: " +
+                                           "(uuid_sstable_identifiers_enabled). The list of affected sstables is: " +
                                            Joiner.on(", ").join(withIllegalGenId) + ". If you decide to delete sstables, " +
                                            "and have that data replicated over other healthy nodes, those will be brought" +
                                            "back during repair");

File: src/java/org/apache/cassandra/service/paxos/Paxos.java
Patch:
@@ -1201,6 +1201,7 @@ public static void setPaxosVariant(Config.PaxosVariant paxosVariant)
     {
         Preconditions.checkNotNull(paxosVariant);
         PAXOS_VARIANT = paxosVariant;
+        DatabaseDescriptor.setPaxosVariant(paxosVariant);
     }
 
     public static Config.PaxosVariant getPaxosVariant()

File: test/distributed/org/apache/cassandra/distributed/test/SSTableIdGenerationTest.java
Patch:
@@ -71,7 +71,7 @@
 
 public class SSTableIdGenerationTest extends TestBaseImpl
 {
-    private final static String ENABLE_UUID_FIELD_NAME = "enable_uuid_sstable_identifiers";
+    private final static String ENABLE_UUID_FIELD_NAME = "uuid_sstable_identifiers_enabled";
     private final static String SNAPSHOT_TAG = "test";
 
     private int v;

File: test/simulator/asm/org/apache/cassandra/simulator/asm/InterceptClasses.java
Patch:
@@ -131,12 +131,12 @@ public InterceptClasses(int api, ChanceSupplier monitorDelayChance, ChanceSuppli
     }
 
     @Override
-    public synchronized byte[] apply(String name, byte[] bytes)
+    public byte[] apply(String name, byte[] bytes)
     {
         return transformTransitiveClosure(name, bytes, null);
     }
 
-    private byte[] transformTransitiveClosure(String externalName, byte[] input, Map<String, byte[]> isolatedCache)
+    private synchronized byte[] transformTransitiveClosure(String externalName, byte[] input, Map<String, byte[]> isolatedCache)
     {
         if (input == null)
             return maybeSynthetic(externalName);

File: test/simulator/main/org/apache/cassandra/simulator/package-info.java
Patch:
@@ -65,6 +65,7 @@
  *    -XX:ActiveProcessorCount=???
  *    -Xmx???
  *    -XX:-BackgroundCompilation
+ *    -XX:CICompilerCount=1
  *
  * For performance reasons the following parameters are recommended:
  *    -XX:Tier4CompileThreshold=1000

File: test/simulator/test/org/apache/cassandra/simulator/test/SimulationTestBase.java
Patch:
@@ -194,6 +194,9 @@ public static void simulate(IIsolatedExecutor.SerializableRunnable[] runnables,
     {
         Failures failures = new Failures();
         RandomSource random = new RandomSource.Default();
+        long seed = System.currentTimeMillis();
+        System.out.println("Using seed: " + seed);
+        random.reset(seed);
         SimulatedTime time = new SimulatedTime(1, random, 1577836800000L /*Jan 1st UTC*/, new LongRange(1, 100, MILLISECONDS, NANOSECONDS),
                                                UNIFORM, UNIFORM.period(new LongRange(10L, 60L, SECONDS, NANOSECONDS), random), (i1, i2) -> {});
         SimulatedExecution execution = new SimulatedExecution();

File: src/java/org/apache/cassandra/utils/ExpiringMemoizingSupplier.java
Patch:
@@ -71,8 +71,7 @@ public T get() {
                     else
                         return t.value();
 
-                    nanos = now + this.durationNanos;
-                    this.expirationNanos = nanos == 0L ? 1L : nanos;
+                    this.expirationNanos = now + this.durationNanos;
                     return t.value();
                 }
             }
@@ -81,7 +80,7 @@ public T get() {
     }
 
     @VisibleForTesting
-    public void expire()
+    public synchronized void expire()
     {
         this.expirationNanos = 0;
     }

File: src/java/org/apache/cassandra/db/rows/AbstractCell.java
Patch:
@@ -205,11 +205,11 @@ public String toString()
         AbstractType<?> type = column().type;
         if (type instanceof CollectionType && type.isMultiCell())
         {
-            CollectionType ct = (CollectionType)type;
+            CollectionType<?> ct = (CollectionType<?>) type;
             return String.format("[%s[%s]=%s %s]",
                                  column().name,
                                  ct.nameComparator().getString(path().get(0)),
-                                 ct.valueComparator().getString(value(), accessor()),
+                                 isTombstone() ? "<tombstone>" : ct.valueComparator().getString(value(), accessor()),
                                  livenessInfoString());
         }
         if (isTombstone())

File: src/java/org/apache/cassandra/cql3/CQL3Type.java
Patch:
@@ -201,7 +201,7 @@ public String toCQLLiteral(ByteBuffer buffer, ProtocolVersion version)
 
             StringBuilder target = new StringBuilder();
             buffer = buffer.duplicate();
-            int size = CollectionSerializer.readCollectionSize(buffer, version);
+            int size = CollectionSerializer.readCollectionSize(buffer, ByteBufferAccessor.instance, version);
             buffer.position(buffer.position() + CollectionSerializer.sizeOfCollectionSize(size, version));
 
             switch (type.kind)

File: src/java/org/apache/cassandra/cql3/UserTypes.java
Patch:
@@ -217,7 +217,7 @@ public Value(UserType type, ByteBuffer[] elements)
         public static Value fromSerialized(ByteBuffer bytes, UserType type)
         {
             type.validate(bytes);
-            return new Value(type, type.split(bytes));
+            return new Value(type, type.split(ByteBufferAccessor.instance, bytes));
         }
 
         public ByteBuffer get(ProtocolVersion protocolVersion)

File: src/java/org/apache/cassandra/cql3/conditions/ColumnCondition.java
Patch:
@@ -650,8 +650,8 @@ private ByteBuffer rowValue(Row row)
 
             Cell<?> cell = getCell(row, column);
             return cell == null
-                      ? null
-                      : userType.split(cell.buffer())[userType.fieldPosition(field)];
+                   ? null
+                   : userType.split(ByteBufferAccessor.instance, cell.buffer())[userType.fieldPosition(field)];
         }
 
         private boolean isSatisfiedBy(ByteBuffer rowValue)

File: src/java/org/apache/cassandra/cql3/selection/FieldSelector.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.db.filter.ColumnFilter;
 import org.apache.cassandra.db.marshal.AbstractType;
+import org.apache.cassandra.db.marshal.ByteBufferAccessor;
 import org.apache.cassandra.db.marshal.UserType;
 import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.io.util.DataInputPlus;
@@ -108,7 +109,7 @@ public ByteBuffer getOutput(ProtocolVersion protocolVersion)
         ByteBuffer value = selected.getOutput(protocolVersion);
         if (value == null)
             return null;
-        ByteBuffer[] buffers = type.split(value);
+        ByteBuffer[] buffers = type.split(ByteBufferAccessor.instance, value);
         return field < buffers.length ? buffers[field] : null;
     }
 

File: src/java/org/apache/cassandra/db/SystemKeyspace.java
Patch:
@@ -65,6 +65,7 @@
 import org.apache.cassandra.cql3.statements.schema.CreateTableStatement;
 import org.apache.cassandra.db.commitlog.CommitLogPosition;
 import org.apache.cassandra.db.compaction.CompactionHistoryTabularData;
+import org.apache.cassandra.db.marshal.ByteBufferAccessor;
 import org.apache.cassandra.db.marshal.BytesType;
 import org.apache.cassandra.db.marshal.LongType;
 import org.apache.cassandra.db.marshal.TimeUUIDType;
@@ -1875,7 +1876,7 @@ public static TopPartitionTracker.StoredTopPartitions getTopPartitions(TableMeta
             TupleType tupleType = new TupleType(Lists.newArrayList(UTF8Type.instance, LongType.instance));
             for (ByteBuffer bb : top)
             {
-                ByteBuffer[] components = tupleType.split(bb);
+                ByteBuffer[] components = tupleType.split(ByteBufferAccessor.instance, bb);
                 String keyStr = UTF8Type.instance.compose(components[0]);
                 long value = LongType.instance.compose(components[1]);
                 topPartitions.add(new TopPartitionTracker.TopPartition(metadata.partitioner.decorateKey(metadata.partitionKeyType.fromString(keyStr)), value));

File: src/java/org/apache/cassandra/db/columniterator/SSTableIterator.java
Patch:
@@ -48,6 +48,7 @@ public SSTableIterator(SSTableReader sstable,
         super(sstable, file, key, indexEntry, slices, columns, ifile);
     }
 
+    @SuppressWarnings("resource") // caller to close
     protected Reader createReaderInternal(RowIndexEntry indexEntry, FileDataInput file, boolean shouldCloseFile)
     {
         return indexEntry.isIndexed()

File: src/java/org/apache/cassandra/db/columniterator/SSTableReversedIterator.java
Patch:
@@ -52,6 +52,7 @@ public SSTableReversedIterator(SSTableReader sstable,
         super(sstable, file, key, indexEntry, slices, columns, ifile);
     }
 
+    @SuppressWarnings("resource") // caller to close
     protected Reader createReaderInternal(RowIndexEntry indexEntry, FileDataInput file, boolean shouldCloseFile)
     {
         return indexEntry.isIndexed()

File: src/java/org/apache/cassandra/db/marshal/UserType.java
Patch:
@@ -258,7 +258,7 @@ public Term fromJSONObject(Object parsed) throws MarshalException
     @Override
     public String toJSONString(ByteBuffer buffer, ProtocolVersion protocolVersion)
     {
-        ByteBuffer[] buffers = split(buffer);
+        ByteBuffer[] buffers = split(ByteBufferAccessor.instance, buffer);
         StringBuilder sb = new StringBuilder("{");
         for (int i = 0; i < types.size(); i++)
         {

File: src/java/org/apache/cassandra/db/rows/EncodingStats.java
Patch:
@@ -67,7 +67,7 @@ public class EncodingStats implements IMeasurableMemory
 
     // We should use this sparingly obviously
     public static final EncodingStats NO_STATS = new EncodingStats(TIMESTAMP_EPOCH, DELETION_TIME_EPOCH, TTL_EPOCH);
-    public static long HEAP_SIZE = ObjectSizes.measure(NO_STATS);
+    public static final long HEAP_SIZE = ObjectSizes.measure(NO_STATS);
 
     public static final Serializer serializer = new Serializer();
 

File: src/java/org/apache/cassandra/serializers/BooleanSerializer.java
Patch:
@@ -24,8 +24,8 @@
 
 public class BooleanSerializer extends TypeSerializer<Boolean>
 {
-    private static final ByteBuffer TRUE = ByteBuffer.wrap(new byte[] {1});
-    private static final ByteBuffer FALSE = ByteBuffer.wrap(new byte[] {0});
+    public static final ByteBuffer TRUE = ByteBuffer.wrap(new byte[] {1});
+    public static final ByteBuffer FALSE = ByteBuffer.wrap(new byte[] {0});
 
     public static final BooleanSerializer instance = new BooleanSerializer();
 

File: src/java/org/apache/cassandra/serializers/MapSerializer.java
Patch:
@@ -148,7 +148,7 @@ public ByteBuffer getSerializedValue(ByteBuffer collection, ByteBuffer key, Abst
         try
         {
             ByteBuffer input = collection.duplicate();
-            int n = readCollectionSize(input, ProtocolVersion.V3);
+            int n = readCollectionSize(input, ByteBufferAccessor.instance, ProtocolVersion.V3);
             int offset = sizeOfCollectionSize(n, ProtocolVersion.V3);
             for (int i = 0; i < n; i++)
             {
@@ -184,7 +184,7 @@ public ByteBuffer getSliceFromSerialized(ByteBuffer collection,
         try
         {
             ByteBuffer input = collection.duplicate();
-            int n = readCollectionSize(input, ProtocolVersion.V3);
+            int n = readCollectionSize(input, ByteBufferAccessor.instance, ProtocolVersion.V3);
             input.position(input.position() + sizeOfCollectionSize(n, ProtocolVersion.V3));
             int startPos = input.position();
             int count = 0;

File: src/java/org/apache/cassandra/serializers/SetSerializer.java
Patch:
@@ -156,7 +156,7 @@ public ByteBuffer getSerializedValue(ByteBuffer input, ByteBuffer key, AbstractT
     {
         try
         {
-            int n = readCollectionSize(input, ProtocolVersion.V3);
+            int n = readCollectionSize(input, ByteBufferAccessor.instance, ProtocolVersion.V3);
             int offset = sizeOfCollectionSize(n, ProtocolVersion.V3);
 
             for (int i = 0; i < n; i++)
@@ -192,7 +192,7 @@ public ByteBuffer getSliceFromSerialized(ByteBuffer collection,
         try
         {
             ByteBuffer input = collection.duplicate();
-            int n = readCollectionSize(input, ProtocolVersion.V3);
+            int n = readCollectionSize(input, ByteBufferAccessor.instance, ProtocolVersion.V3);
             input.position(input.position() + sizeOfCollectionSize(n, ProtocolVersion.V3));
             int startPos = input.position();
             int count = 0;

File: src/java/org/apache/cassandra/service/paxos/PaxosRepairHistory.java
Patch:
@@ -29,6 +29,7 @@
 
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.TypeSizes;
+import org.apache.cassandra.db.marshal.ByteBufferAccessor;
 import org.apache.cassandra.db.marshal.BytesType;
 import org.apache.cassandra.db.marshal.TimeUUIDType;
 import org.apache.cassandra.db.marshal.TupleType;
@@ -181,7 +182,7 @@ public static PaxosRepairHistory fromTupleBufferList(List<ByteBuffer> tuples)
         Ballot[] ballotLowBounds = new Ballot[tuples.size()];
         for (int i = 0 ; i < tuples.size() ; ++i)
         {
-            ByteBuffer[] split = TYPE.split(tuples.get(i));
+            ByteBuffer[] split = TYPE.split(ByteBufferAccessor.instance, tuples.get(i));
             if (i < tokenInclusiveUpperBounds.length)
                 tokenInclusiveUpperBounds[i] = TOKEN_FACTORY.fromByteArray(split[0]);
             ballotLowBounds[i] = Ballot.deserialize(split[1]);

File: test/unit/org/apache/cassandra/db/marshal/TypeValidationTest.java
Patch:
@@ -204,7 +204,7 @@ private static void buildAndSplit(Gen<? extends TupleType> baseGen)
         qt().forAll(tupleWithValueGen(baseGen)).checkAssert(pair -> {
             TupleType tuple = pair.left;
             ByteBuffer value = pair.right;
-            Assertions.assertThat(TupleType.buildValue(tuple.split(value)))
+            Assertions.assertThat(TupleType.buildValue(tuple.split(ByteBufferAccessor.instance, value)))
                       .as("TupleType.buildValue(split(value)) == value")
                       .isEqualTo(value);
         });

File: test/unit/org/apache/cassandra/transport/SerDeserTest.java
Patch:
@@ -238,7 +238,7 @@ public void udtSerDeserTest(ProtocolVersion version) throws Exception
 
         ByteBuffer serialized = t.bindAndGet(options);
 
-        ByteBuffer[] fields = udt.split(serialized);
+        ByteBuffer[] fields = udt.split(ByteBufferAccessor.instance, serialized);
 
         assertEquals(4, fields.length);
 

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1103,7 +1103,7 @@ public CommitLogPosition call()
             // If a flush errored out but the error was ignored, make sure we don't discard the commit log.
             if (flushFailure == null && mainMemtable != null)
             {
-                commitLogUpperBound = mainMemtable.getCommitLogUpperBound();
+                commitLogUpperBound = mainMemtable.getFinalCommitLogUpperBound();
                 CommitLog.instance.discardCompletedSegments(metadata.id, mainMemtable.getCommitLogLowerBound(), commitLogUpperBound);
             }
 

File: src/java/org/apache/cassandra/db/memtable/AbstractMemtable.java
Patch:
@@ -28,7 +28,6 @@
 
 import org.apache.cassandra.db.RegularAndStaticColumns;
 import org.apache.cassandra.db.commitlog.CommitLogPosition;
-import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
 import org.apache.cassandra.db.partitions.Partition;
 import org.apache.cassandra.db.rows.EncodingStats;
 import org.apache.cassandra.schema.ColumnMetadata;
@@ -204,9 +203,9 @@ public CommitLogPosition commitLogLowerBound()
             return AbstractMemtable.this.getCommitLogLowerBound();
         }
 
-        public CommitLogPosition commitLogUpperBound()
+        public LastCommitLogPosition commitLogUpperBound()
         {
-            return AbstractMemtable.this.getCommitLogUpperBound();
+            return AbstractMemtable.this.getFinalCommitLogUpperBound();
         }
 
         public EncodingStats encodingStats()

File: src/java/org/apache/cassandra/db/memtable/Flushing.java
Patch:
@@ -171,7 +171,7 @@ private void writeSortedContents()
                 logger.info("Completed flushing {} ({}) for commitlog position {}",
                             writer.getFilename(),
                             FBUtilities.prettyPrintMemory(bytesFlushed),
-                            toFlush.memtable().getCommitLogUpperBound());
+                            toFlush.memtable().getFinalCommitLogUpperBound());
                 // Update the metrics
                 metrics.bytesFlushed.inc(bytesFlushed);
             }

File: src/java/org/apache/cassandra/db/memtable/Memtable.java
Patch:
@@ -369,7 +369,7 @@ default boolean isEmpty()
     CommitLogPosition getCommitLogLowerBound();
 
     /** The commit log position at the time that this memtable was switched out */
-    CommitLogPosition getCommitLogUpperBound();
+    LastCommitLogPosition getFinalCommitLogUpperBound();
 
     /** True if the memtable can contain any data that was written before the given commit log position */
     boolean mayContainDataBefore(CommitLogPosition position);

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -1966,7 +1966,7 @@ public static void setCompactionThroughputMebibytesPerSec(int value)
         conf.compaction_throughput = new DataRateSpec.IntMebibytesPerSecondBound(value);
     }
 
-    public static long getCompactionLargePartitionWarningThreshold() { return conf.compaction_large_partition_warning_threshold.toBytes(); }
+    public static long getCompactionLargePartitionWarningThreshold() { return conf.compaction_large_partition_warning_threshold.toBytesInLong(); }
 
     public static int getCompactionTombstoneWarningThreshold()
     {
@@ -2001,7 +2001,7 @@ public static void setConcurrentViewBuilders(int value)
 
     public static long getMinFreeSpacePerDriveInBytes()
     {
-        return conf.min_free_space_per_drive.toBytes();
+        return conf.min_free_space_per_drive.toBytesInLong();
     }
 
     public static boolean getDisableSTCSInL0()
@@ -2977,7 +2977,7 @@ public static int getHintsFlushPeriodInMS()
 
     public static long getMaxHintsFileSize()
     {
-        return  conf.max_hints_file_size.toBytes();
+        return  conf.max_hints_file_size.toBytesInLong();
     }
 
     public static ParameterizedClass getHintsCompression()

File: test/unit/org/apache/cassandra/net/ProxyHandlerConnectionsTest.java
Patch:
@@ -50,6 +50,7 @@
 import org.apache.cassandra.utils.Pair;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.MINUTES;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.apache.cassandra.net.ConnectionTest.SETTINGS;
 import static org.apache.cassandra.net.OutboundConnectionSettings.Framing.CRC;
@@ -276,7 +277,7 @@ private static void waitForCondition(Supplier<Boolean> cond) throws Throwable
     {
         CompletableFuture.runAsync(() -> {
             while (!cond.get()) {}
-        }).get(30, SECONDS);
+        }).get(1, MINUTES);
     }
 
     private static void waitForCondition(Supplier<Boolean> cond, Supplier<String> s) throws Throwable

File: src/java/org/apache/cassandra/auth/AuthConfig.java
Patch:
@@ -57,7 +57,7 @@ public static void applyAuth()
         // is in use and non-default values are detected
         if (!(authenticator instanceof PasswordAuthenticator)
             && (conf.credentials_update_interval != null
-                || conf.credentials_validity.toMillisecondsAsInt() != 2000
+                || conf.credentials_validity.toMilliseconds() != 2000
                 || conf.credentials_cache_max_entries != 1000))
         {
             logger.info("Configuration options credentials_update_interval, credentials_validity and " +

File: src/java/org/apache/cassandra/cql3/QueryOptions.java
Patch:
@@ -296,7 +296,7 @@ private static class DefaultReadThresholds implements ReadThresholds
         private final long warnThresholdBytes;
         private final long abortThresholdBytes;
 
-        public DefaultReadThresholds(DataStorageSpec warnThreshold, DataStorageSpec abortThreshold)
+        public DefaultReadThresholds(DataStorageSpec.LongBytesBound warnThreshold, DataStorageSpec.LongBytesBound abortThreshold)
         {
             this.warnThresholdBytes = warnThreshold == null ? -1 : warnThreshold.toBytes();
             this.abortThresholdBytes = abortThreshold == null ? -1 : abortThreshold.toBytes();

File: src/java/org/apache/cassandra/db/Keyspace.java
Patch:
@@ -230,7 +230,7 @@ public boolean hasColumnFamilyStore(TableId id)
      * @param rateLimiter Rate limiter for hardlinks-per-second
      * @throws IOException if the column family doesn't exist
      */
-    public void snapshot(String snapshotName, String columnFamilyName, boolean skipFlush, DurationSpec ttl, RateLimiter rateLimiter, Instant creationTime) throws IOException
+    public void snapshot(String snapshotName, String columnFamilyName, boolean skipFlush, DurationSpec.IntSecondsBound ttl, RateLimiter rateLimiter, Instant creationTime) throws IOException
     {
         assert snapshotName != null;
         boolean tookSnapShot = false;

File: src/java/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -653,7 +653,7 @@ private void maybeDelayForTesting()
         }
     }
 
-    private boolean shouldTrackSize(DataStorageSpec warnThresholdBytes, DataStorageSpec abortThresholdBytes)
+    private boolean shouldTrackSize(DataStorageSpec.LongBytesBound warnThresholdBytes, DataStorageSpec.LongBytesBound abortThresholdBytes)
     {
         return trackWarnings
                && !SchemaConstants.isSystemKeyspace(metadata().keyspace)
@@ -662,8 +662,8 @@ private boolean shouldTrackSize(DataStorageSpec warnThresholdBytes, DataStorageS
 
     private UnfilteredPartitionIterator withQuerySizeTracking(UnfilteredPartitionIterator iterator)
     {
-        DataStorageSpec warnThreshold = DatabaseDescriptor.getLocalReadSizeWarnThreshold();
-        DataStorageSpec failThreshold = DatabaseDescriptor.getLocalReadSizeFailThreshold();
+        DataStorageSpec.LongBytesBound warnThreshold = DatabaseDescriptor.getLocalReadSizeWarnThreshold();
+        DataStorageSpec.LongBytesBound failThreshold = DatabaseDescriptor.getLocalReadSizeFailThreshold();
         if (!shouldTrackSize(warnThreshold, failThreshold))
             return iterator;
         final long warnBytes = warnThreshold == null ? -1 : warnThreshold.toBytes();

File: src/java/org/apache/cassandra/db/RowIndexEntry.java
Patch:
@@ -356,8 +356,8 @@ private void checkSize(int entries, int bytes)
             if (command == null || SchemaConstants.isSystemKeyspace(command.metadata().keyspace) || !DatabaseDescriptor.getReadThresholdsEnabled())
                 return;
 
-            DataStorageSpec warnThreshold = DatabaseDescriptor.getRowIndexReadSizeWarnThreshold();
-            DataStorageSpec failThreshold = DatabaseDescriptor.getRowIndexReadSizeFailThreshold();
+            DataStorageSpec.LongBytesBound warnThreshold = DatabaseDescriptor.getRowIndexReadSizeWarnThreshold();
+            DataStorageSpec.LongBytesBound failThreshold = DatabaseDescriptor.getRowIndexReadSizeFailThreshold();
             if (warnThreshold == null && failThreshold == null)
                 return;
 

File: src/java/org/apache/cassandra/db/guardrails/Guardrails.java
Patch:
@@ -900,7 +900,7 @@ private static Set<ConsistencyLevel> fromJmx(Set<String> set)
         return set.stream().map(ConsistencyLevel::valueOf).collect(Collectors.toSet());
     }
 
-    private static Long sizeToBytes(@Nullable DataStorageSpec size)
+    private static Long sizeToBytes(@Nullable DataStorageSpec.LongBytesBound size)
     {
         return size == null ? -1 : size.toBytes();
     }
@@ -910,8 +910,8 @@ private static String sizeToString(@Nullable DataStorageSpec size)
         return size == null ? null : size.toString();
     }
 
-    private static DataStorageSpec sizeFromString(@Nullable String size)
+    private static DataStorageSpec.LongBytesBound sizeFromString(@Nullable String size)
     {
-        return StringUtils.isEmpty(size) ? null : new DataStorageSpec(size);
+        return StringUtils.isEmpty(size) ? null : new DataStorageSpec.LongBytesBound(size);
     }
 }

File: src/java/org/apache/cassandra/db/guardrails/GuardrailsConfig.java
Patch:
@@ -220,13 +220,13 @@ public interface GuardrailsConfig
      * @return The threshold to warn when encountering a collection with larger data size than threshold.
      */
     @Nullable
-    DataStorageSpec getCollectionSizeWarnThreshold();
+    DataStorageSpec.LongBytesBound getCollectionSizeWarnThreshold();
 
     /**
      * @return The threshold to prevent collections with larger data size than threshold.
      */
     @Nullable
-    DataStorageSpec getCollectionSizeFailThreshold();
+    DataStorageSpec.LongBytesBound getCollectionSizeFailThreshold();
 
     /**
      * @return The threshold to warn when encountering more elements in a collection than threshold.
@@ -265,7 +265,7 @@ public interface GuardrailsConfig
      * disabled.
      */
     @Nullable
-    DataStorageSpec getDataDiskUsageMaxDiskSize();
+    DataStorageSpec.LongBytesBound getDataDiskUsageMaxDiskSize();
 
     /**
      * @return The threshold to warn when replication factor is lesser than threshold.

File: src/java/org/apache/cassandra/db/virtual/SettingsTable.java
Patch:
@@ -20,7 +20,6 @@
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
-
 import com.google.common.collect.ImmutableMap;
 
 import org.apache.cassandra.config.Config;

File: src/java/org/apache/cassandra/service/ActiveRepairService.java
Patch:
@@ -234,7 +234,7 @@ public ActiveRepairService(IFailureDetector failureDetector, Gossiper gossiper)
                                              .maximumSize(Long.getLong("cassandra.parent_repair_status_cache_size", 100_000))
                                              .build();
 
-        DurationSpec duration = getRepairStateExpires();
+        DurationSpec.LongNanosecondsBound duration = getRepairStateExpires();
         int numElements = getRepairStateSize();
         logger.info("Storing repair state for {} or for {} elements", duration, numElements);
         repairs = CacheBuilder.newBuilder()

File: src/java/org/apache/cassandra/service/disk/usage/DiskUsageMonitor.java
Patch:
@@ -140,7 +140,7 @@ public double getDiskUsage()
         BigInteger total = used.add(usable);
 
         // That total space can be limited by the config property data_disk_usage_max_disk_size.
-        DataStorageSpec diskUsageMaxSize = guardrailsConfigSupplier.get().getDataDiskUsageMaxDiskSize();
+        DataStorageSpec.LongBytesBound diskUsageMaxSize = guardrailsConfigSupplier.get().getDataDiskUsageMaxDiskSize();
         if (diskUsageMaxSize != null)
             total = total.min(BigInteger.valueOf(diskUsageMaxSize.toBytes()));
 

File: src/java/org/apache/cassandra/service/snapshot/SnapshotManifest.java
Patch:
@@ -54,11 +54,11 @@ private SnapshotManifest() {
         this.expiresAt = null;
     }
 
-    public SnapshotManifest(List<String> files, DurationSpec ttl, Instant creationTime)
+    public SnapshotManifest(List<String> files, DurationSpec.IntSecondsBound ttl, Instant creationTime)
     {
         this.files = files;
         this.createdAt = creationTime;
-        this.expiresAt = ttl == null ? null : createdAt.plusMillis(ttl.toMilliseconds());
+        this.expiresAt = ttl == null ? null : createdAt.plusSeconds(ttl.toSeconds());
     }
 
     public List<String> getFiles()

File: src/java/org/apache/cassandra/streaming/StreamManager.java
Patch:
@@ -253,7 +253,7 @@ public void onRegister(StreamResultFuture result)
 
     public StreamManager()
     {
-        DurationSpec duration = DatabaseDescriptor.getStreamingStateExpires();
+        DurationSpec.LongNanosecondsBound duration = DatabaseDescriptor.getStreamingStateExpires();
         long sizeBytes = DatabaseDescriptor.getStreamingStateSize().toBytes();
         long numElements = sizeBytes / StreamingState.ELEMENT_SIZE;
         logger.info("Storing streaming state for {} or for {} elements", duration, numElements);

File: src/java/org/apache/cassandra/tools/nodetool/Snapshot.java
Patch:
@@ -70,7 +70,7 @@ public void execute(NodeProbe probe)
             Map<String, String> options = new HashMap<String,String>();
             options.put("skipFlush", Boolean.toString(skipFlush));
             if (null != ttl) {
-                DurationSpec d = new DurationSpec(ttl);
+                DurationSpec.LongNanosecondsBound d = new DurationSpec.LongNanosecondsBound(ttl);
                 options.put("ttl", d.toString());
             }
 

File: test/distributed/org/apache/cassandra/distributed/test/thresholds/CoordinatorReadSizeWarningTest.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.cassandra.config.DataStorageSpec;
 import org.apache.cassandra.config.DatabaseDescriptor;
 
+import static org.apache.cassandra.config.DataStorageSpec.DataStorageUnit.KIBIBYTES;
 import static org.assertj.core.api.Assertions.assertThat;
 
 /**
@@ -42,8 +43,8 @@ public static void setupClass() throws IOException
         // setup threshold after init to avoid driver issues loading
         // the test uses a rather small limit, which causes driver to fail while loading metadata
         CLUSTER.stream().forEach(i -> i.runOnInstance(() -> {
-            DatabaseDescriptor.setCoordinatorReadSizeWarnThreshold(DataStorageSpec.inKibibytes(1));
-            DatabaseDescriptor.setCoordinatorReadSizeFailThreshold(DataStorageSpec.inKibibytes(2));
+            DatabaseDescriptor.setCoordinatorReadSizeWarnThreshold(new DataStorageSpec.LongBytesBound(1, KIBIBYTES));
+            DatabaseDescriptor.setCoordinatorReadSizeFailThreshold(new DataStorageSpec.LongBytesBound(2, KIBIBYTES));
         }));
     }
 

File: test/distributed/org/apache/cassandra/distributed/test/thresholds/LocalReadSizeWarningTest.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.cassandra.config.DataStorageSpec;
 import org.apache.cassandra.config.DatabaseDescriptor;
 
+import static org.apache.cassandra.config.DataStorageSpec.DataStorageUnit.KIBIBYTES;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class LocalReadSizeWarningTest extends AbstractClientSizeWarning
@@ -42,8 +43,8 @@ public static void setupClass() throws IOException
             DatabaseDescriptor.setCoordinatorReadSizeWarnThreshold(null);
             DatabaseDescriptor.setCoordinatorReadSizeFailThreshold(null);
 
-            DatabaseDescriptor.setLocalReadSizeWarnThreshold(DataStorageSpec.inKibibytes(1));
-            DatabaseDescriptor.setLocalReadSizeFailThreshold(DataStorageSpec.inKibibytes(2));
+            DatabaseDescriptor.setLocalReadSizeWarnThreshold(new DataStorageSpec.LongBytesBound(1, KIBIBYTES));
+            DatabaseDescriptor.setLocalReadSizeFailThreshold(new DataStorageSpec.LongBytesBound(2, KIBIBYTES));
         }));
     }
 

File: test/distributed/org/apache/cassandra/distributed/test/thresholds/RowIndexSizeWarningTest.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.cassandra.config.DataStorageSpec;
 import org.apache.cassandra.config.DatabaseDescriptor;
 
+import static org.apache.cassandra.config.DataStorageSpec.DataStorageUnit.KIBIBYTES;
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class RowIndexSizeWarningTest extends AbstractClientSizeWarning
@@ -37,8 +38,8 @@ public static void setupClass() throws IOException
         AbstractClientSizeWarning.setupClass();
 
         CLUSTER.stream().forEach(i -> i.runOnInstance(() -> {
-            DatabaseDescriptor.setRowIndexReadSizeWarnThreshold(DataStorageSpec.inKibibytes(1));
-            DatabaseDescriptor.setRowIndexReadSizeFailThreshold(DataStorageSpec.inKibibytes(2));
+            DatabaseDescriptor.setRowIndexReadSizeWarnThreshold(new DataStorageSpec.LongBytesBound(1, KIBIBYTES));
+            DatabaseDescriptor.setRowIndexReadSizeFailThreshold(new DataStorageSpec.LongBytesBound(2, KIBIBYTES));
 
             // hack to force multiple index entries
             DatabaseDescriptor.setColumnIndexCacheSize(1 << 20);

File: test/unit/org/apache/cassandra/config/PropertiesTest.java
Patch:
@@ -73,7 +73,7 @@ public void configMutate() throws Exception
         ps.get("cluster_name").set(config, "properties testing");
         assertThat(config.cluster_name).isEqualTo("properties testing");
 
-        ps.get("permissions_validity").set(config, SmallestDurationMilliseconds.inMilliseconds(42));
+        ps.get("permissions_validity").set(config, new DurationSpec.IntMillisecondsBound(42));
         assertThat(config.permissions_validity.toMilliseconds()).isEqualTo(42);
 
         ps.get("hinted_handoff_disabled_datacenters").set(config, Sets.newHashSet("a", "b", "c"));

File: test/unit/org/apache/cassandra/cql3/CQLTester.java
Patch:
@@ -68,8 +68,8 @@
 import org.apache.cassandra.auth.IRoleManager;
 import org.apache.cassandra.concurrent.ScheduledExecutors;
 import org.apache.cassandra.concurrent.Stage;
+import org.apache.cassandra.config.DataStorageSpec;
 import org.apache.cassandra.config.EncryptionOptions;
-import org.apache.cassandra.config.SmallestDataStorageMebibytes;
 import org.apache.cassandra.db.virtual.VirtualKeyspaceRegistry;
 import org.apache.cassandra.db.virtual.VirtualSchemaKeyspace;
 import org.apache.cassandra.exceptions.InvalidRequestException;
@@ -131,7 +131,7 @@ public abstract class CQLTester
     public static final String KEYSPACE_PER_TEST = "cql_test_keyspace_alt";
     protected static final boolean USE_PREPARED_VALUES = Boolean.valueOf(System.getProperty("cassandra.test.use_prepared", "true"));
     protected static final boolean REUSE_PREPARED = Boolean.valueOf(System.getProperty("cassandra.test.reuse_prepared", "true"));
-    protected static final long ROW_CACHE_SIZE_IN_MIB = new SmallestDataStorageMebibytes(System.getProperty("cassandra.test.row_cache_size", "0MiB")).toMebibytes();
+    protected static final long ROW_CACHE_SIZE_IN_MIB = new DataStorageSpec.LongMebibytesBound(System.getProperty("cassandra.test.row_cache_size", "0MiB")).toMebibytes();
     private static final AtomicInteger seqNumber = new AtomicInteger();
     protected static final ByteBuffer TOO_BIG = ByteBuffer.allocate(FBUtilities.MAX_UNSIGNED_SHORT + 1024);
     public static final String DATA_CENTER = ServerTestUtils.DATA_CENTER;

File: test/unit/org/apache/cassandra/db/DirectoriesTest.java
Patch:
@@ -225,7 +225,7 @@ public FakeSnapshot createFakeSnapshot(TableMetadata table, String tag, boolean
         if (createManifest)
         {
             File manifestFile = Directories.getSnapshotManifestFile(snapshotDir);
-            manifest = new SnapshotManifest(Collections.singletonList(sstableDesc.filenameFor(Component.DATA)), new DurationSpec("1m"), now());
+            manifest = new SnapshotManifest(Collections.singletonList(sstableDesc.filenameFor(Component.DATA)), new DurationSpec.IntSecondsBound("1m"), now());
             manifest.serializeToJsonFile(manifestFile);
         }
 
@@ -353,7 +353,7 @@ public void testMaybeManifestLoading() throws Exception {
 
             File manifestFile = directories.getSnapshotManifestFile(tag);
 
-            SnapshotManifest manifest = new SnapshotManifest(files, new DurationSpec("1m"), now());
+            SnapshotManifest manifest = new SnapshotManifest(files, new DurationSpec.IntSecondsBound("1m"), now());
             manifest.serializeToJsonFile(manifestFile);
 
             Set<File> dirs = new HashSet<>();

File: test/unit/org/apache/cassandra/db/virtual/CredentialsCacheKeysTableTest.java
Patch:
@@ -74,7 +74,7 @@ public void config()
     @AfterClass
     public static void tearDownClass()
     {
-        DatabaseDescriptor.setCredentialsValidity(DatabaseDescriptor.getRawConfig().credentials_validity.toMillisecondsAsInt());
+        DatabaseDescriptor.setCredentialsValidity(DatabaseDescriptor.getRawConfig().credentials_validity.toMilliseconds());
     }
 
     @Test

File: test/unit/org/apache/cassandra/db/virtual/JmxPermissionsCacheKeysTableTest.java
Patch:
@@ -95,7 +95,7 @@ public void config()
     @AfterClass
     public static void tearDownClass()
     {
-        DatabaseDescriptor.setPermissionsValidity(DatabaseDescriptor.getRawConfig().permissions_validity.toMillisecondsAsInt());
+        DatabaseDescriptor.setPermissionsValidity(DatabaseDescriptor.getRawConfig().permissions_validity.toMilliseconds());
     }
 
     @Test

File: test/unit/org/apache/cassandra/db/virtual/NetworkPermissionsCacheKeysTableTest.java
Patch:
@@ -75,7 +75,7 @@ public void config()
     @AfterClass
     public static void tearDownClass()
     {
-        DatabaseDescriptor.setPermissionsValidity(DatabaseDescriptor.getRawConfig().permissions_validity.toMillisecondsAsInt());
+        DatabaseDescriptor.setPermissionsValidity(DatabaseDescriptor.getRawConfig().permissions_validity.toMilliseconds());
     }
 
     @Test

File: test/unit/org/apache/cassandra/db/virtual/PermissionsCacheKeysTableTest.java
Patch:
@@ -90,7 +90,7 @@ public void config()
     @AfterClass
     public static void tearDownClass()
     {
-        DatabaseDescriptor.setPermissionsValidity(DatabaseDescriptor.getRawConfig().permissions_validity.toMillisecondsAsInt());
+        DatabaseDescriptor.setPermissionsValidity(DatabaseDescriptor.getRawConfig().permissions_validity.toMilliseconds());
     }
 
     @Test

File: test/unit/org/apache/cassandra/db/virtual/RolesCacheKeysTableTest.java
Patch:
@@ -75,7 +75,7 @@ public void config()
     @AfterClass
     public static void tearDownClass()
     {
-        DatabaseDescriptor.setRolesValidity(DatabaseDescriptor.getRawConfig().roles_validity.toMillisecondsAsInt());
+        DatabaseDescriptor.setRolesValidity(DatabaseDescriptor.getRawConfig().roles_validity.toMilliseconds());
     }
 
     @Test

File: test/unit/org/apache/cassandra/service/snapshot/SnapshotLoaderTest.java
Patch:
@@ -154,7 +154,7 @@ public void testSnapshotsWithManifests() throws IOException
 
         // Write manifest for snapshot tag2 on random location
         Instant tag2Ts = Instant.now().plusSeconds(10);
-        DurationSpec tag2Ttl = new DurationSpec("10h");
+        DurationSpec.IntSecondsBound tag2Ttl = new DurationSpec.IntSecondsBound("10h");
         File tag2ManifestLocation = tag2Files.toArray(new File[0])[ThreadLocalRandom.current().nextInt(tag2Files.size())];
         writeManifest(tag2ManifestLocation, tag2Ts, tag2Ttl);
 
@@ -206,7 +206,7 @@ public void testParseUUID()
         assertThat(SnapshotLoader.parseUUID("c7e513243f0711ec9bbc0242ac130002")).isEqualTo(UUID.fromString("c7e51324-3f07-11ec-9bbc-0242ac130002"));
     }
 
-    private void writeManifest(File snapshotDir, Instant creationTime, DurationSpec ttl) throws IOException
+    private void writeManifest(File snapshotDir, Instant creationTime, DurationSpec.IntSecondsBound ttl) throws IOException
     {
         SnapshotManifest manifest = new SnapshotManifest(Lists.newArrayList("f1", "f2", "f3"), ttl, creationTime);
         manifest.serializeToJsonFile(getManifestFile(snapshotDir));

File: test/unit/org/apache/cassandra/service/snapshot/SnapshotManifestTest.java
Patch:
@@ -108,7 +108,7 @@ public void testIngoredFields() throws IOException {
 
     @Test
     public void testSerializeAndDeserialize() throws Exception {
-        SnapshotManifest manifest = new SnapshotManifest(Arrays.asList("db1", "db2", "db3"), new DurationSpec("2m"), Instant.ofEpochMilli(currentTimeMillis()));
+        SnapshotManifest manifest = new SnapshotManifest(Arrays.asList("db1", "db2", "db3"), new DurationSpec.IntSecondsBound("2m"), Instant.ofEpochMilli(currentTimeMillis()));
         File manifestFile = new File(tempFolder.newFile("manifest.json"));
 
         manifest.serializeToJsonFile(manifestFile);

File: test/unit/org/apache/cassandra/tools/nodetool/SetGetColumnIndexSizeTest.java
Patch:
@@ -66,13 +66,13 @@ public void testZero()
     @Test
     public void testNegative()
     {
-        assertSetInvalidColumnIndexSize("-7", "Invalid data storage: value must be positive, but was -7", 1);
+        assertSetInvalidColumnIndexSize("-7", "Invalid data storage: value must be non-negative", 1);
     }
 
     @Test
     public void testInvalidValue()
     {
-        assertSetInvalidColumnIndexSize("2097152", "column_index_size must be positive value <= 2147483647B, but was 2147483648B", 2);
+        assertSetInvalidColumnIndexSize("2097152", "column_index_size must be positive value <= 2147483646B, but was 2147483647B", 2);
     }
 
     @Test

File: test/unit/org/apache/cassandra/tools/nodetool/SetGetCompactionThroughputTest.java
Patch:
@@ -53,7 +53,7 @@ public void testPositive()
     @Test
     public void testMaxValue()
     {
-        assertSetGetValidThroughput(Integer.MAX_VALUE);
+        assertSetGetValidThroughput(Integer.MAX_VALUE - 1);
     }
 
     @Test

File: test/unit/org/apache/cassandra/tools/nodetool/SetGetEntireSSTableInterDCStreamThroughputTest.java
Patch:
@@ -55,7 +55,7 @@ public void testPositive()
     @Test
     public void testMaxValue()
     {
-        assertSetGetValidThroughput(Integer.MAX_VALUE, Integer.MAX_VALUE * StreamRateLimiter.BYTES_PER_MEBIBYTE);
+        assertSetGetValidThroughput(Integer.MAX_VALUE - 1, (Integer.MAX_VALUE - 1) * StreamRateLimiter.BYTES_PER_MEBIBYTE);
     }
 
     @Test

File: test/unit/org/apache/cassandra/tools/nodetool/SetGetEntireSSTableStreamThroughputTest.java
Patch:
@@ -55,7 +55,7 @@ public void testPositive()
     @Test
     public void testMaxValue()
     {
-        assertSetGetValidThroughput(Integer.MAX_VALUE, Integer.MAX_VALUE * StreamRateLimiter.BYTES_PER_MEBIBYTE);
+        assertSetGetValidThroughput(Integer.MAX_VALUE - 1, (Integer.MAX_VALUE - 1) * StreamRateLimiter.BYTES_PER_MEBIBYTE);
     }
 
     @Test

File: test/unit/org/apache/cassandra/transport/RateLimitingTest.java
Patch:
@@ -60,6 +60,8 @@ public class RateLimitingTest extends CQLTester
     private static final int LARGE_PAYLOAD_THRESHOLD_BYTES = 1000;
     private static final int OVERLOAD_PERMITS_PER_SECOND = 1;
 
+    private static final long MAX_LONG_CONFIG_VALUE = Long.MAX_VALUE - 1;
+
     @Parameterized.Parameter
     public ProtocolVersion version;
 
@@ -99,7 +101,7 @@ public long read()
             }
         };
 
-        ClientResourceLimits.setGlobalLimit(Long.MAX_VALUE);
+        ClientResourceLimits.setGlobalLimit(MAX_LONG_CONFIG_VALUE);
     }
 
     @Test

File: src/java/org/apache/cassandra/cql3/Sets.java
Patch:
@@ -72,7 +72,7 @@ public Term prepare(String keyspace, ColumnSpecification receiver) throws Invali
             // We've parsed empty maps as a set literal to break the ambiguity so
             // handle that case now
             if (receiver.type instanceof MapType && elements.isEmpty())
-                return new Maps.Value(Collections.<ByteBuffer, ByteBuffer>emptyMap());
+                return new Maps.Value(Collections.emptySortedMap());
 
             ColumnSpecification valueSpec = Sets.valueSpecOf(receiver);
             Set<Term> values = new HashSet<>(elements.size());

File: test/unit/org/apache/cassandra/cql3/ColumnConditionTest.java
Patch:
@@ -443,7 +443,7 @@ public void testMapCollectionBoundIsSatisfiedByValue() throws InvalidRequestExce
     {
         ColumnDefinition definition = ColumnDefinition.regularDef("ks", "cf", "c", ListType.getInstance(Int32Type.instance, true));
 
-        Map<ByteBuffer, ByteBuffer> placeholderMap = new TreeMap<>();
+        SortedMap<ByteBuffer, ByteBuffer> placeholderMap = new TreeMap<>();
         placeholderMap.put(ONE, ONE);
         Maps.Value placeholder = new Maps.Value(placeholderMap);
 

File: test/unit/org/apache/cassandra/config/SmallestDataStorageKibibytesTest.java
Patch:
@@ -20,8 +20,6 @@
 
 import org.junit.Test;
 
-import org.apache.cassandra.exceptions.ConfigurationException;
-
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.junit.Assert.assertEquals;
 
@@ -30,7 +28,7 @@ public class SmallestDataStorageKibibytesTest
     @Test
     public void testInvalidUnits()
     {
-        assertThatThrownBy(() -> new SmallestDataStorageKibibytes("10B")).isInstanceOf(ConfigurationException.class)
+        assertThatThrownBy(() -> new SmallestDataStorageKibibytes("10B")).isInstanceOf(IllegalArgumentException.class)
                                                                           .hasMessageContaining("Invalid data storage: 10B");
     }
 

File: test/unit/org/apache/cassandra/config/SmallestDataStorageMebibytesTest.java
Patch:
@@ -20,8 +20,6 @@
 
 import org.junit.Test;
 
-import org.apache.cassandra.exceptions.ConfigurationException;
-
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.junit.Assert.assertEquals;
 
@@ -30,7 +28,7 @@ public class SmallestDataStorageMebibytesTest
     @Test
     public void testInvalidUnits()
     {
-        assertThatThrownBy(() -> new SmallestDataStorageMebibytes("10B")).isInstanceOf(ConfigurationException.class)
+        assertThatThrownBy(() -> new SmallestDataStorageMebibytes("10B")).isInstanceOf(IllegalArgumentException.class)
                                                                          .hasMessageContaining("Invalid data storage: 10B");
     }
 

File: test/unit/org/apache/cassandra/db/guardrails/GuardrailMinimumReplicationFactorTest.java
Patch:
@@ -264,7 +264,7 @@ public void testMinRFGreaterThanDefaultRF()
             DatabaseDescriptor.setDefaultKeyspaceRF(1);
             guardrails().setMinimumReplicationFactorThreshold(MINIMUM_REPLICATION_FACTOR_WARN_THRESHOLD, MINIMUM_REPLICATION_FACTOR_FAIL_THRESHOLD);
         }
-        catch (ConfigurationException e)
+        catch (IllegalArgumentException e)
         {
             String expectedMessage = "";
 

File: test/unit/org/apache/cassandra/tools/nodetool/SetGetColumnIndexSizeTest.java
Patch:
@@ -66,7 +66,7 @@ public void testZero()
     @Test
     public void testNegative()
     {
-        assertSetInvalidColumnIndexSize("-7", "Invalid data storage: value must be positive, but was -7", 2);
+        assertSetInvalidColumnIndexSize("-7", "Invalid data storage: value must be positive, but was -7", 1);
     }
 
     @Test

File: test/unit/org/apache/cassandra/tools/nodetool/SnapshotTest.java
Patch:
@@ -111,8 +111,8 @@ public void testTTLOption()
     public void testInvalidTTLOption()
     {
         ToolRunner.ToolResult tool = invokeNodetool("snapshot", "-t", "ttl", "--ttl", "infinity");
-        assertThat(tool.getExitCode()).isEqualTo(2);
-        assertThat(tool.getStderr()).contains("Invalid duration: infinity");
+        assertThat(tool.getExitCode()).isEqualTo(1);
+        assertThat(tool.getStdout()).contains("Invalid duration: infinity");
     }
 
     @Test

File: src/java/org/apache/cassandra/service/StorageServiceMBean.java
Patch:
@@ -952,9 +952,6 @@ public void enableAuditLog(String loggerName, String includedKeyspaces, String e
     String getSkipPaxosRepairOnTopologyChangeKeyspaces();
     void setSkipPaxosRepairOnTopologyChangeKeyspaces(String v);
 
-    int getPaxosAutoRepairThresholdMb();
-    void setPaxosAutoRepairThresholdMb(int threshold);
-
     boolean getPaxosAutoRepairsEnabled();
     void setPaxosAutoRepairsEnabled(boolean enabled);
 

File: src/java/org/apache/cassandra/db/filter/RowIndexEntryReadSizeTooLargeException.java
Patch:
@@ -20,9 +20,9 @@
 
 import org.apache.cassandra.db.RejectException;
 
-public class RowIndexEntryTooLargeException extends RejectException
+public class RowIndexEntryReadSizeTooLargeException extends RejectException
 {
-    public RowIndexEntryTooLargeException(String message)
+    public RowIndexEntryReadSizeTooLargeException(String message)
     {
         super(message);
     }

File: src/java/org/apache/cassandra/exceptions/TombstoneAbortException.java
Patch:
@@ -23,7 +23,7 @@
 import org.apache.cassandra.db.ConsistencyLevel;
 import org.apache.cassandra.locator.InetAddressAndPort;
 
-import static org.apache.cassandra.service.reads.trackwarnings.WarningsSnapshot.tombstoneAbortMessage;
+import static org.apache.cassandra.service.reads.thresholds.WarningsSnapshot.tombstoneAbortMessage;
 
 public class TombstoneAbortException extends ReadAbortException
 {

File: src/java/org/apache/cassandra/service/reads/ReadCallback.java
Patch:
@@ -42,9 +42,9 @@
 import org.apache.cassandra.net.ParamType;
 import org.apache.cassandra.net.RequestCallback;
 import org.apache.cassandra.net.Verb;
-import org.apache.cassandra.service.reads.trackwarnings.CoordinatorWarnings;
-import org.apache.cassandra.service.reads.trackwarnings.WarningContext;
-import org.apache.cassandra.service.reads.trackwarnings.WarningsSnapshot;
+import org.apache.cassandra.service.reads.thresholds.CoordinatorWarnings;
+import org.apache.cassandra.service.reads.thresholds.WarningContext;
+import org.apache.cassandra.service.reads.thresholds.WarningsSnapshot;
 import org.apache.cassandra.tracing.Tracing;
 import org.apache.cassandra.utils.concurrent.UncheckedInterruptedException;
 

File: src/java/org/apache/cassandra/service/reads/thresholds/WarnAbortCounter.java
Patch:
@@ -15,7 +15,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.cassandra.service.reads.trackwarnings;
+package org.apache.cassandra.service.reads.thresholds;
 
 import java.util.Collections;
 import java.util.Set;

File: src/java/org/apache/cassandra/transport/Dispatcher.java
Patch:
@@ -36,7 +36,7 @@
 import org.apache.cassandra.net.FrameEncoder;
 import org.apache.cassandra.service.ClientWarn;
 import org.apache.cassandra.service.QueryState;
-import org.apache.cassandra.service.reads.trackwarnings.CoordinatorWarnings;
+import org.apache.cassandra.service.reads.thresholds.CoordinatorWarnings;
 import org.apache.cassandra.transport.ClientResourceLimits.Overload;
 import org.apache.cassandra.transport.Flusher.FlushItem;
 import org.apache.cassandra.transport.messages.ErrorMessage;

File: test/distributed/org/apache/cassandra/distributed/impl/Coordinator.java
Patch:
@@ -42,7 +42,7 @@
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.ClientWarn;
 import org.apache.cassandra.service.QueryState;
-import org.apache.cassandra.service.reads.trackwarnings.CoordinatorWarnings;
+import org.apache.cassandra.service.reads.thresholds.CoordinatorWarnings;
 import org.apache.cassandra.transport.ProtocolVersion;
 import org.apache.cassandra.tracing.Tracing;
 import org.apache.cassandra.transport.messages.ResultMessage;

File: test/distributed/org/apache/cassandra/distributed/impl/Instance.java
Patch:
@@ -120,7 +120,7 @@
 import org.apache.cassandra.service.StorageServiceMBean;
 import org.apache.cassandra.service.paxos.PaxosRepair;
 import org.apache.cassandra.service.paxos.PaxosState;
-import org.apache.cassandra.service.reads.trackwarnings.CoordinatorWarnings;
+import org.apache.cassandra.service.reads.thresholds.CoordinatorWarnings;
 import org.apache.cassandra.service.snapshot.SnapshotManager;
 import org.apache.cassandra.streaming.StreamManager;
 import org.apache.cassandra.service.paxos.uncommitted.UncommittedTableData;

File: test/distributed/org/apache/cassandra/distributed/test/thresholds/AbstractClientSizeWarning.java
Patch:
@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-package org.apache.cassandra.distributed.test.trackwarnings;
+package org.apache.cassandra.distributed.test.thresholds;
 
 import java.io.IOException;
 import java.net.InetAddress;
@@ -51,7 +51,7 @@
 import org.apache.cassandra.exceptions.RequestFailureReason;
 import org.apache.cassandra.service.ClientWarn;
 import org.apache.cassandra.service.QueryState;
-import org.apache.cassandra.service.reads.trackwarnings.CoordinatorWarnings;
+import org.apache.cassandra.service.reads.thresholds.CoordinatorWarnings;
 import org.assertj.core.api.Condition;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -319,7 +319,7 @@ public void failThresholdDisabled(String cql) throws UnknownHostException
 
     protected static void enable(boolean value)
     {
-        CLUSTER.stream().forEach(i -> i.runOnInstance(() -> DatabaseDescriptor.setTrackWarningsEnabled(value)));
+        CLUSTER.stream().forEach(i -> i.runOnInstance(() -> DatabaseDescriptor.setReadThresholdsEnabled(value)));
     }
 
     protected static ByteBuffer bytes(int size)

File: test/distributed/org/apache/cassandra/distributed/test/thresholds/TombstoneCountWarningTest.java
Patch:
@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-package org.apache.cassandra.distributed.test.trackwarnings;
+package org.apache.cassandra.distributed.test.thresholds;
 
 import java.io.IOException;
 import java.net.InetAddress;
@@ -51,7 +51,7 @@
 import org.apache.cassandra.exceptions.TombstoneAbortException;
 import org.apache.cassandra.service.ClientWarn;
 import org.apache.cassandra.service.QueryState;
-import org.apache.cassandra.service.reads.trackwarnings.CoordinatorWarnings;
+import org.apache.cassandra.service.reads.thresholds.CoordinatorWarnings;
 import org.assertj.core.api.Assertions;
 import org.assertj.core.api.Condition;
 
@@ -96,7 +96,7 @@ public void setup()
 
     private static void enable(boolean value)
     {
-        CLUSTER.stream().forEach(i -> i.runOnInstance(() -> DatabaseDescriptor.setTrackWarningsEnabled(value)));
+        CLUSTER.stream().forEach(i -> i.runOnInstance(() -> DatabaseDescriptor.setReadThresholdsEnabled(value)));
     }
 
     @Test

File: test/unit/org/apache/cassandra/service/reads/thresholds/WarningsSnapshotTest.java
Patch:
@@ -15,7 +15,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.cassandra.service.reads.trackwarnings;
+package org.apache.cassandra.service.reads.thresholds;
 
 import java.net.InetAddress;
 import java.net.UnknownHostException;
@@ -28,7 +28,7 @@
 import org.quicktheories.generators.SourceDSL;
 import org.quicktheories.impl.Constraint;
 
-import static org.apache.cassandra.service.reads.trackwarnings.WarningsSnapshot.*;
+import static org.apache.cassandra.service.reads.thresholds.WarningsSnapshot.*;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.quicktheories.QuickTheory.qt;
 

File: src/java/org/apache/cassandra/auth/AuthConfig.java
Patch:
@@ -56,7 +56,7 @@ public static void applyAuth()
         // work with PasswordAuthenticator, so log a message if some other authenticator
         // is in use and non-default values are detected
         if (!(authenticator instanceof PasswordAuthenticator)
-            && (conf.credentials_update_interval.toMillisecondsAsInt() != 0
+            && (conf.credentials_update_interval != null
                 || conf.credentials_validity.toMillisecondsAsInt() != 2000
                 || conf.credentials_cache_max_entries != 1000))
         {

File: src/java/org/apache/cassandra/config/DataRateSpec.java
Patch:
@@ -58,7 +58,7 @@ public DataRateSpec(String value)
     DataRateSpec(double quantity, DataRateUnit unit)
     {
         if (quantity < 0)
-            throw new ConfigurationException("Invalid bit rare: value must be non-negative");
+            throw new ConfigurationException("Invalid bit rate: value must be non-negative");
 
         if (quantity > Long.MAX_VALUE)
             throw new NumberFormatException("Invalid bit rate: value must be between 0 and Long.MAX_VALUE = 9223372036854775807");

File: src/java/org/apache/cassandra/db/virtual/SettingsTable.java
Patch:
@@ -60,7 +60,7 @@ final class SettingsTable extends AbstractVirtualTable
 
     // CASSANDRA-15234 - a few configuration parameters kept their names but added unit to their value, only the
     // new value format is displayed for them
-    private final List<String> EXCLUDED_CONFIG = new ArrayList<String>()
+    private static final List<String> EXCLUDED_CONFIG = new ArrayList<String>()
     {
         {
             add("key_cache_save_period");

File: test/unit/org/apache/cassandra/tools/nodetool/SetGetColumnIndexSizeTest.java
Patch:
@@ -72,7 +72,7 @@ public void testNegative()
     @Test
     public void testInvalidValue()
     {
-        assertSetInvalidColumnIndexSize("2097152", "column_index_size must be positive value < 2097151B, but was 2147483648B", 2);
+        assertSetInvalidColumnIndexSize("2097152", "column_index_size must be positive value <= 2147483647B, but was 2147483648B", 2);
     }
 
     @Test

File: src/java/org/apache/cassandra/db/marshal/AbstractCompositeType.java
Patch:
@@ -190,8 +190,8 @@ public String getString(ByteBuffer bytes)
     public ByteBuffer fromString(String source)
     {
         List<String> parts = split(source);
-        List<ByteBuffer> components = new ArrayList<ByteBuffer>(parts.size());
-        List<ParsedComparator> comparators = new ArrayList<ParsedComparator>(parts.size());
+        List<ByteBuffer> components = new ArrayList<>(parts.size());
+        List<ParsedComparator> comparators = new ArrayList<>(parts.size());
         int totalLength = 0, i = 0;
         boolean lastByteIsOne = false;
         boolean lastByteIsMinusOne = false;
@@ -226,7 +226,7 @@ else if (part.equals("_"))
         {
             comparators.get(i).serializeComparator(bb);
             ByteBufferUtil.writeShortLength(bb, component.remaining());
-            bb.put(component); // it's ok to consume component as we won't use it anymore
+            bb.put(component.duplicate()); // it's not ok to consume component as we did not create it (CASSANDRA-14752)
             bb.put((byte)0);
             ++i;
         }

File: src/java/org/apache/cassandra/db/DisallowedDirectoriesMBean.java
Patch:
@@ -17,9 +17,9 @@
  */
 package org.apache.cassandra.db;
 
+import java.io.File; //checkstyle: permit this import
 import java.util.Set;
 
-import org.apache.cassandra.io.util.File;
 public interface DisallowedDirectoriesMBean
 {
     public Set<File> getUnreadableDirectories();

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -6105,7 +6105,7 @@ public void enableAuditLog(String loggerName, String includedKeyspaces, String e
 
     public void enableAuditLog(String loggerName, String includedKeyspaces, String excludedKeyspaces, String includedCategories, String excludedCategories,
                                String includedUsers, String excludedUsers, Integer maxArchiveRetries, Boolean block, String rollCycle,
-                               Long maxLogSize, Integer maxQueueWeight, String archiveCommand) throws ConfigurationException, IllegalStateException
+                               Long maxLogSize, Integer maxQueueWeight, String archiveCommand) throws IllegalStateException
     {
         enableAuditLog(loggerName, Collections.emptyMap(), includedKeyspaces, excludedKeyspaces, includedCategories, excludedCategories, includedUsers, excludedUsers,
                        maxArchiveRetries, block, rollCycle, maxLogSize, maxQueueWeight, archiveCommand);
@@ -6121,7 +6121,7 @@ public void enableAuditLog(String loggerName, Map<String, String> parameters, St
 
     public void enableAuditLog(String loggerName, Map<String, String> parameters, String includedKeyspaces, String excludedKeyspaces, String includedCategories, String excludedCategories,
                                String includedUsers, String excludedUsers, Integer maxArchiveRetries, Boolean block, String rollCycle,
-                               Long maxLogSize, Integer maxQueueWeight, String archiveCommand) throws ConfigurationException, IllegalStateException
+                               Long maxLogSize, Integer maxQueueWeight, String archiveCommand) throws IllegalStateException
     {
         final AuditLogOptions options = new AuditLogOptions.Builder(DatabaseDescriptor.getAuditLoggingOptions())
                                         .withEnabled(true)

File: test/unit/org/apache/cassandra/cql3/validation/operations/CompactStorageTest.java
Patch:
@@ -47,10 +47,10 @@
 
 import static org.apache.cassandra.utils.ByteBufferUtil.EMPTY_BYTE_BUFFER;
 import static org.apache.cassandra.utils.ByteBufferUtil.bytes;
+import static org.apache.commons.lang3.StringUtils.isEmpty;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
-import static org.reflections.util.Utils.isEmpty;
 
 public class CompactStorageTest extends CQLTester
 {

File: test/unit/org/apache/cassandra/cql3/validation/operations/AlterTest.java
Patch:
@@ -279,7 +279,7 @@ public void testCreateAlterNetworkTopologyWithDefaults() throws Throwable
         assertRowsIgnoringOrderAndExtra(execute("SELECT keyspace_name, durable_writes, replication FROM system_schema.keyspaces"),
                                         row(KEYSPACE, true, map("class", "org.apache.cassandra.locator.SimpleStrategy", "replication_factor", "1")),
                                         row(KEYSPACE_PER_TEST, true, map("class", "org.apache.cassandra.locator.SimpleStrategy", "replication_factor", "1")),
-                                        row(ks1, true, map("class", "org.apache.cassandra.locator.NetworkTopologyStrategy", DATA_CENTER, "0", DATA_CENTER_REMOTE, "3")));
+                                        row(ks1, true, map("class", "org.apache.cassandra.locator.NetworkTopologyStrategy", DATA_CENTER_REMOTE, "3")));
 
         schemaChange("ALTER KEYSPACE " + ks1 + " WITH replication = { 'class' : 'NetworkTopologyStrategy', '" + DATA_CENTER_REMOTE + "': 3 }");
 

File: src/java/org/apache/cassandra/serializers/TimestampSerializer.java
Patch:
@@ -53,9 +53,10 @@ private static List<DateTimeFormatter> generateFormatters()
         final String[] offsetFormats = new String[]
                                          {
                                          " z",
-                                         "X",
                                          " zzzz",
-                                         "XXX"
+                                         " X",
+                                         "X",
+                                         "XXX",
                                          };
 
         for (String dateTimeFormat: dateTimeFormats)

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1344,7 +1344,7 @@ public static Future<Boolean> flushLargestMemtable()
             float flushingOffHeap = Memtable.MEMORY_POOL.offHeap.reclaimingRatio();
             float thisOnHeap = largest.getAllocator().onHeap().ownershipRatio();
             float thisOffHeap = largest.getAllocator().offHeap().ownershipRatio();
-            logger.debug("Flushing largest {} to free up room. Used total: {}, live: {}, flushing: {}, this: {}",
+            logger.info("Flushing largest {} to free up room. Used total: {}, live: {}, flushing: {}, this: {}",
                          largest.cfs, ratio(usedOnHeap, usedOffHeap), ratio(liveOnHeap, liveOffHeap),
                          ratio(flushingOnHeap, flushingOffHeap), ratio(thisOnHeap, thisOffHeap));
 

File: src/java/org/apache/cassandra/io/util/PathUtils.java
Patch:
@@ -59,7 +59,7 @@ public final class PathUtils
     private static final boolean consistentDirectoryListings = CassandraRelevantProperties.DETERMINISM_CONSISTENT_DIRECTORY_LISTINGS.getBoolean();
 
     private static final Set<StandardOpenOption> READ_OPTIONS = unmodifiableSet(EnumSet.of(READ));
-    private static final Set<StandardOpenOption> WRITE_OPTIONS = unmodifiableSet(EnumSet.of(WRITE, CREATE));
+    private static final Set<StandardOpenOption> WRITE_OPTIONS = unmodifiableSet(EnumSet.of(WRITE, CREATE, TRUNCATE_EXISTING));
     private static final Set<StandardOpenOption> WRITE_APPEND_OPTIONS = unmodifiableSet(EnumSet.of(WRITE, CREATE, APPEND));
     private static final Set<StandardOpenOption> READ_WRITE_OPTIONS = unmodifiableSet(EnumSet.of(READ, WRITE, CREATE));
     private static final FileAttribute<?>[] NO_ATTRIBUTES = new FileAttribute[0];

File: src/java/org/apache/cassandra/db/guardrails/DisableFlag.java
Patch:
@@ -38,13 +38,15 @@ public class DisableFlag extends Guardrail
     /**
      * Creates a new {@link DisableFlag} guardrail.
      *
+     * @param name     the identifying name of the guardrail
      * @param disabled a {@link ClientState}-based supplier of boolean indicating whether the feature guarded by this
      *                 guardrail must be disabled.
      * @param what     The feature that is guarded by this guardrail (for reporting in error messages),
      *                 {@link DisableFlag#ensureEnabled(String, ClientState)} can specify a different {@code what}.
      */
-    public DisableFlag(Predicate<ClientState> disabled, String what)
+    public DisableFlag(String name, Predicate<ClientState> disabled, String what)
     {
+        super(name);
         this.disabled = disabled;
         this.what = what;
     }

File: test/unit/org/apache/cassandra/db/guardrails/GuardrailColumnsPerTableTest.java
Patch:
@@ -34,7 +34,7 @@ public GuardrailColumnsPerTableTest()
     {
         super(COLUMNS_PER_TABLE_WARN_THRESHOLD,
               COLUMNS_PER_TABLE_FAIL_THRESHOLD,
-              "columns_per_table",
+              Guardrails.columnsPerTable,
               Guardrails::setColumnsPerTableThreshold,
               Guardrails::getColumnsPerTableWarnThreshold,
               Guardrails::getColumnsPerTableFailThreshold);

File: test/unit/org/apache/cassandra/db/guardrails/GuardrailConsistencyLevelsTester.java
Patch:
@@ -49,6 +49,7 @@ public abstract class GuardrailConsistencyLevelsTester extends GuardrailTester
 
     public GuardrailConsistencyLevelsTester(String warnedPropertyName,
                                             String disallowePropertyName,
+                                            Values<ConsistencyLevel> guardrail,
                                             Function<Guardrails, Set<ConsistencyLevel>> warnedGetter,
                                             Function<Guardrails, Set<ConsistencyLevel>> disallowedGetter,
                                             Function<Guardrails, String> warnedCSVGetter,
@@ -58,6 +59,7 @@ public GuardrailConsistencyLevelsTester(String warnedPropertyName,
                                             BiConsumer<Guardrails, String> warnedCSVSetter,
                                             BiConsumer<Guardrails, String> disallowedCSVSetter)
     {
+        super(guardrail);
         this.warnedPropertyName = warnedPropertyName;
         this.disallowePropertyName = disallowePropertyName;
         this.warnedGetter = warnedGetter;

File: test/unit/org/apache/cassandra/db/guardrails/GuardrailInSelectCartesianProductTest.java
Patch:
@@ -46,7 +46,7 @@ public GuardrailInSelectCartesianProductTest()
     {
         super(WARN_THRESHOLD,
               FAIL_THRESHOLD,
-              "in_select_cartesian_product",
+              Guardrails.inSelectCartesianProduct,
               Guardrails::setInSelectCartesianProductThreshold,
               Guardrails::getInSelectCartesianProductWarnThreshold,
               Guardrails::getInSelectCartesianProductFailThreshold);

File: test/unit/org/apache/cassandra/db/guardrails/GuardrailKeyspacesTest.java
Patch:
@@ -36,7 +36,7 @@ public GuardrailKeyspacesTest()
     {
         super(WARN_THRESHOLD,
               FAIL_THRESHOLD,
-              "keyspaces",
+              Guardrails.keyspaces,
               Guardrails::setKeyspacesThreshold,
               Guardrails::getKeyspacesWarnThreshold,
               Guardrails::getKeyspacesFailThreshold);

File: test/unit/org/apache/cassandra/db/guardrails/GuardrailPageSizeTest.java
Patch:
@@ -45,7 +45,7 @@ public GuardrailPageSizeTest()
     {
         super(PAGE_SIZE_WARN_THRESHOLD,
               PAGE_SIZE_FAIL_THRESHOLD,
-              "page_size",
+              Guardrails.pageSize,
               Guardrails::setPageSizeThreshold,
               Guardrails::getPageSizeWarnThreshold,
               Guardrails::getPageSizeFailThreshold);

File: test/unit/org/apache/cassandra/db/guardrails/GuardrailPartitionKeysInSelectTest.java
Patch:
@@ -31,7 +31,7 @@ public GuardrailPartitionKeysInSelectTest()
     {
         super(PARTITION_KEYS_SELECT_WARN_THRESHOLD,
               PARTITION_KEYS_SELECT_FAIL_THRESHOLD,
-              "partition_keys_in_select",
+              Guardrails.partitionKeysInSelect,
               Guardrails::setPartitionKeysInSelectThreshold,
               Guardrails::getPartitionKeysInSelectWarnThreshold,
               Guardrails::getPartitionKeysInSelectFailThreshold);

File: test/unit/org/apache/cassandra/db/guardrails/GuardrailReadConsistencyLevelsTest.java
Patch:
@@ -39,6 +39,7 @@ public GuardrailReadConsistencyLevelsTest()
     {
         super("read_consistency_levels_warned",
               "read_consistency_levels_disallowed",
+              Guardrails.readConsistencyLevels,
               Guardrails::getReadConsistencyLevelsWarned,
               Guardrails::getReadConsistencyLevelsDisallowed,
               Guardrails::getReadConsistencyLevelsWarnedCSV,

File: test/unit/org/apache/cassandra/db/guardrails/GuardrailSecondaryIndexesPerTable.java
Patch:
@@ -35,7 +35,7 @@ public GuardrailSecondaryIndexesPerTable()
     {
         super(INDEXES_PER_TABLE_WARN_THRESHOLD,
               INDEXES_PER_TABLE_FAIL_THRESHOLD,
-              "secondary_indexes_per_table",
+              Guardrails.secondaryIndexesPerTable,
               Guardrails::setSecondaryIndexesPerTableThreshold,
               Guardrails::getSecondaryIndexesPerTableWarnThreshold,
               Guardrails::getSecondaryIndexesPerTableFailThreshold);

File: test/unit/org/apache/cassandra/db/guardrails/GuardrailTablesTest.java
Patch:
@@ -36,7 +36,7 @@ public GuardrailTablesTest()
     {
         super(TABLES_LIMIT_WARN_THRESHOLD,
               TABLES_LIMIT_FAIL_THRESHOLD,
-              "tables",
+              Guardrails.tables,
               Guardrails::setTablesThreshold,
               Guardrails::getTablesWarnThreshold,
               Guardrails::getTablesFailThreshold);

File: test/unit/org/apache/cassandra/db/guardrails/GuardrailWriteConsistencyLevelsTest.java
Patch:
@@ -42,6 +42,7 @@ public GuardrailWriteConsistencyLevelsTest()
     {
         super("write_consistency_levels_warned",
               "write_consistency_levels_disallowed",
+              Guardrails.writeConsistencyLevels,
               Guardrails::getWriteConsistencyLevelsWarned,
               Guardrails::getWriteConsistencyLevelsDisallowed,
               Guardrails::getWriteConsistencyLevelsWarnedCSV,

File: test/unit/org/apache/cassandra/db/guardrails/GuardrailsConfigProviderTest.java
Patch:
@@ -36,7 +36,8 @@ public void testBuildCustom() throws Throwable
     {
         String name = getClass().getCanonicalName() + '$' + CustomProvider.class.getSimpleName();
         GuardrailsConfigProvider provider = GuardrailsConfigProvider.build(name);
-        Threshold guard = new Threshold(state -> provider.getOrCreate(state).getTablesWarnThreshold(),
+        Threshold guard = new Threshold("test_guardrail",
+                                        state -> provider.getOrCreate(state).getTablesWarnThreshold(),
                                         state -> provider.getOrCreate(state).getTablesFailThreshold(),
                                         (isWarn, what, v, t) -> format("%s: for %s, %s > %s",
                                                                        isWarn ? "Warning" : "Aborting", what, v, t));

File: src/java/org/apache/cassandra/config/Schema.java
Patch:
@@ -759,7 +759,7 @@ public void dropView(String ksName, String viewName)
         CompactionManager.instance.interruptCompactionFor(Collections.singleton(cfs.metadata), true);
 
         if (DatabaseDescriptor.isAutoSnapshot())
-            cfs.snapshot(Keyspace.getTimestampedSnapshotName(cfs.name));
+            cfs.snapshot(Keyspace.getTimestampedSnapshotNameWithPrefix(cfs.name, ColumnFamilyStore.SNAPSHOT_DROP_PREFIX));
 
         // reinitialize the keyspace.
         ViewDefinition view = oldKsm.views.get(viewName).get();

File: src/java/org/apache/cassandra/cql3/ColumnIdentifier.java
Patch:
@@ -205,7 +205,7 @@ public long unsharedHeapSize()
     public long unsharedHeapSizeExcludingData()
     {
         return EMPTY_SIZE
-             + ObjectSizes.sizeOfEmptyHeapByteBuffer()
+             + ObjectSizes.sizeOnHeapExcludingData(bytes)
              + ObjectSizes.sizeOf(text);
     }
 

File: src/java/org/apache/cassandra/db/rows/ArrayCell.java
Patch:
@@ -112,6 +112,6 @@ public Cell<?> copy(AbstractAllocator allocator)
 
     public long unsharedHeapSizeExcludingData()
     {
-        return EMPTY_SIZE + ObjectSizes.sizeOfEmptyByteArray() + (path == null ? 0 : path.unsharedHeapSizeExcludingData());
+        return EMPTY_SIZE + ObjectSizes.sizeOfArray(value) - value.length + (path == null ? 0 : path.unsharedHeapSizeExcludingData());
     }
 }

File: src/java/org/apache/cassandra/db/rows/BufferCell.java
Patch:
@@ -144,6 +144,6 @@ public Cell<?> copy(AbstractAllocator allocator)
 
     public long unsharedHeapSizeExcludingData()
     {
-        return EMPTY_SIZE + ObjectSizes.sizeOfEmptyHeapByteBuffer() + (path == null ? 0 : path.unsharedHeapSizeExcludingData());
+        return EMPTY_SIZE + ObjectSizes.sizeOnHeapExcludingData(value) + (path == null ? 0 : path.unsharedHeapSizeExcludingData());
     }
 }

File: src/java/org/apache/cassandra/db/rows/CellPath.java
Patch:
@@ -127,7 +127,7 @@ public CellPath copy(AbstractAllocator allocator)
 
         public long unsharedHeapSizeExcludingData()
         {
-            return EMPTY_SIZE + ObjectSizes.sizeOfEmptyHeapByteBuffer();
+            return EMPTY_SIZE + ObjectSizes.sizeOnHeapExcludingData(value);
         }
     }
 

File: test/unit/org/apache/cassandra/db/CellSpecTest.java
Patch:
@@ -84,9 +84,9 @@ public void unsharedHeapSizeExcludingData()
     private static long valuePtrSize(Object value)
     {
         if (value instanceof ByteBuffer)
-            return ObjectSizes.sizeOfEmptyHeapByteBuffer();
+            return ObjectSizes.sizeOnHeapExcludingData((ByteBuffer) value);
         else if (value instanceof byte[])
-            return ObjectSizes.sizeOfEmptyByteArray();
+            return ObjectSizes.sizeOfArray((byte[]) value) - ((byte[]) value).length;
         throw new IllegalArgumentException("Unsupported type: " + value.getClass());
     }
 

File: src/java/org/apache/cassandra/tools/BulkLoadConnectionFactory.java
Patch:
@@ -43,7 +43,7 @@ public BulkLoadConnectionFactory(int secureStoragePort, EncryptionOptions.Server
         this.outboundBindAny = outboundBindAny;
     }
 
-    public NettyStreamingChannel connect(InetSocketAddress to, int messagingVersion, StreamingChannel.Kind kind) throws IOException
+    public NettyStreamingChannel create(InetSocketAddress to, int messagingVersion, StreamingChannel.Kind kind) throws IOException
     {
         // Connect to secure port for all peers if ServerEncryptionOptions is configured other than 'none'
         // When 'all', 'dc' and 'rack', server nodes always have SSL port open, and since thin client like sstableloader

File: src/java/org/apache/cassandra/tools/BulkLoadConnectionFactory.java
Patch:
@@ -50,7 +50,7 @@ public NettyStreamingChannel connect(InetSocketAddress to, int messagingVersion,
         // does not know which node is in which dc/rack, connecting to SSL port is always the option.
         OutboundConnectionSettings template = new OutboundConnectionSettings(getByAddress(to));
         if (encryptionOptions != null && encryptionOptions.internode_encryption != EncryptionOptions.ServerEncryptionOptions.InternodeEncryption.none)
-            template = template.withConnectTo(template.to.withPort(secureStoragePort));
+            template = template.withConnectTo(template.to.withPort(secureStoragePort)).withEncryption(encryptionOptions);
 
         return connect(template, messagingVersion, kind);
     }

File: src/java/org/apache/cassandra/tools/BulkLoadConnectionFactory.java
Patch:
@@ -47,7 +47,7 @@ public Channel createConnection(OutboundConnectionSettings template, int messagi
         // does not know which node is in which dc/rack, connecting to SSL port is always the option.
 
         if (encryptionOptions != null && encryptionOptions.internode_encryption != EncryptionOptions.ServerEncryptionOptions.InternodeEncryption.none)
-            template = template.withConnectTo(template.to.withPort(secureStoragePort));
+            template = template.withConnectTo(template.to.withPort(secureStoragePort)).withEncryption(encryptionOptions);
 
         return super.createConnection(template, messagingVersion);
     }

File: src/java/org/apache/cassandra/auth/AllowAllAuthorizer.java
Patch:
@@ -33,12 +33,12 @@ public Set<Permission> authorize(AuthenticatedUser user, IResource resource)
         return resource.applicablePermissions();
     }
 
-    public void grant(AuthenticatedUser performer, Set<Permission> permissions, IResource resource, RoleResource to)
+    public Set<Permission> grant(AuthenticatedUser performer, Set<Permission> permissions, IResource resource, RoleResource to)
     {
         throw new UnsupportedOperationException("GRANT operation is not supported by AllowAllAuthorizer");
     }
 
-    public void revoke(AuthenticatedUser performer, Set<Permission> permissions, IResource resource, RoleResource from)
+    public Set<Permission> revoke(AuthenticatedUser performer, Set<Permission> permissions, IResource resource, RoleResource from)
     {
         throw new UnsupportedOperationException("REVOKE operation is not supported by AllowAllAuthorizer");
     }

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -505,7 +505,7 @@ synchronized public void stopUnsafe(boolean deleteSegments)
         CommitLogSegment.resetReplayLimit();
         if (DatabaseDescriptor.isCDCEnabled() && deleteSegments)
             for (File f : new File(DatabaseDescriptor.getCDCLogLocation()).tryList())
-                FileUtils.deleteWithConfirm(f);
+                f.delete();
     }
 
     /**

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -386,6 +386,8 @@ public static void setOutboundBindAny(boolean value)
     public volatile boolean check_for_duplicate_rows_during_reads = true;
     public volatile boolean check_for_duplicate_rows_during_compaction = true;
 
+    public volatile boolean force_new_prepared_statement_behaviour = false;
+
     public static boolean isClientMode()
     {
         return isClientMode;

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -797,7 +797,7 @@ public ParsedStatement.Prepared prepare(ClientState clientState)
         {
             VariableSpecifications boundNames = getBoundVariables();
             ModificationStatement statement = prepare(boundNames, clientState);
-            return new ParsedStatement.Prepared(statement, boundNames, boundNames.getPartitionKeyBindIndexes(statement.cfm), statement.cfm.ksName);
+            return new ParsedStatement.Prepared(statement, boundNames, boundNames.getPartitionKeyBindIndexes(statement.cfm), statement.cfm.ksName, isFullyQualified());
         }
 
         public ModificationStatement prepare(VariableSpecifications boundNames, ClientState clientState)

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -941,7 +941,7 @@ public ParsedStatement.Prepared prepare(boolean forView, ClientState clientState
 
         protected ParsedStatement.Prepared prepare(SelectStatement stmt, VariableSpecifications boundNames, CFMetaData cfm)
         {
-            return new ParsedStatement.Prepared(stmt, boundNames, boundNames.getPartitionKeyBindIndexes(cfm), cfm.ksName);
+            return new ParsedStatement.Prepared(stmt, boundNames, boundNames.getPartitionKeyBindIndexes(cfm), cfm.ksName, isFullyQualified());
         }
 
         /**

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -1733,7 +1733,7 @@ public void stopShutdownAndWait(long timeout, TimeUnit unit) throws InterruptedE
     }
 
     @Nullable
-    public CassandraVersion getMinVersion(int delay, TimeUnit timeUnit)
+    public CassandraVersion getMinVersion(long delay, TimeUnit timeUnit)
     {
         try
         {

File: test/unit/org/apache/cassandra/cql3/validation/entities/SecondaryIndexTest.java
Patch:
@@ -1184,9 +1184,9 @@ public void testIndexOnPartitionKeyWithStaticColumnAndNoRows() throws Throwable
 
     private ResultMessage.Prepared prepareStatement(String cql, boolean forThrift)
     {
-        return QueryProcessor.prepare(String.format(cql, KEYSPACE, currentTable()),
-                                      ClientState.forInternalCalls(),
-                                      forThrift);
+        return QueryProcessor.instance.prepare(String.format(cql, KEYSPACE, currentTable()),
+                                               ClientState.forInternalCalls(),
+                                               forThrift);
     }
 
     private void validateCell(Cell cell, ColumnDefinition def, ByteBuffer val, long timestamp)

File: test/unit/org/apache/cassandra/cql3/validation/operations/AggregationTest.java
Patch:
@@ -1123,7 +1123,7 @@ public void testFunctionDropPreparedStatement() throws Throwable
                                        "SFUNC " + shortFunctionName(fState) + " " +
                                        "STYPE int");
 
-            ResultMessage.Prepared prepared = QueryProcessor.prepare("SELECT " + a + "(b) FROM " + otherKS + ".jsdp", ClientState.forInternalCalls(), false);
+            ResultMessage.Prepared prepared = QueryProcessor.instance.prepare("SELECT " + a + "(b) FROM " + otherKS + ".jsdp", ClientState.forInternalCalls(), false);
             assertNotNull(QueryProcessor.instance.getPrepared(prepared.statementId));
 
             execute("DROP AGGREGATE " + a + "(int)");
@@ -1135,7 +1135,7 @@ public void testFunctionDropPreparedStatement() throws Throwable
                     "SFUNC " + shortFunctionName(fState) + " " +
                     "STYPE int");
 
-            prepared = QueryProcessor.prepare("SELECT " + a + "(b) FROM " + otherKS + ".jsdp", ClientState.forInternalCalls(), false);
+            prepared = QueryProcessor.instance.prepare("SELECT " + a + "(b) FROM " + otherKS + ".jsdp", ClientState.forInternalCalls(), false);
             assertNotNull(QueryProcessor.instance.getPrepared(prepared.statementId));
 
             execute("DROP KEYSPACE " + otherKS + ";");

File: src/java/org/apache/cassandra/config/Converters.java
Patch:
@@ -65,14 +65,14 @@ public enum Converters
                       o -> ((DataStorageSpec)o).toBytes()),
     MEBIBYTES_PER_SECOND_DATA_RATE(Long.class,
                                    o -> DataRateSpec.inMebibytesPerSecond((Long) o),
-                                   o -> ((DataRateSpec)o).toMebibytesPerSecond()),
+                                   o -> ((DataRateSpec)o).toMebibytesPerSecondAsInt()),
     /**
      * This converter is a custom one to support backward compatibility for stream_throughput_outbound and
      * inter_dc_stream_throughput_outbound which were provided in megatibs per second prior CASSANDRA-15234.
      */
     MEGABITS_TO_MEBIBYTES_PER_SECOND_DATA_RATE(Long.class,
                                                o -> DataRateSpec.megabitsPerSecondInMebibytesPerSecond((Long)o),
-                                               o -> ((DataRateSpec)o).toMegabitsPerSecond());
+                                               o -> ((DataRateSpec)o).toMegabitsPerSecondAsInt());
 
     private final Class<?> inputType;
     private final Function<Object, Object> convert;

File: src/java/org/apache/cassandra/config/DataRateSpec.java
Patch:
@@ -300,6 +300,8 @@ public double toMebibytesPerSecond(double d)
 
             public double toMegabitsPerSecond(double d)
             {
+
+
                 if (d > MAX / (MEGABITS_PER_MEBIBYTE))
                     return MAX;
                 return Math.round(d * MEGABITS_PER_MEBIBYTE);

File: src/java/org/apache/cassandra/streaming/StreamingDataOutputPlus.java
Patch:
@@ -74,7 +74,7 @@ interface RateLimiter
     /**
      * Writes all data in file channel to stream: <br>
      * * For zero-copy-streaming, 1MiB at a time, with at most 2MiB in flight at once. <br>
-     * * For streaming with SSL, 64kb at a time, with at most 32+64kb (default low water mark + batch size) in flight. <br>
+     * * For streaming with SSL, 64KiB at a time, with at most 32+64KiB (default low water mark + batch size) in flight. <br>
      * <p>
      * This method takes ownership of the provided {@link FileChannel}.
      * <p>

File: src/java/org/apache/cassandra/tools/nodetool/GetCompactionThroughput.java
Patch:
@@ -22,12 +22,12 @@
 import org.apache.cassandra.tools.NodeProbe;
 import org.apache.cassandra.tools.NodeTool.NodeToolCmd;
 
-@Command(name = "getcompactionthroughput", description = "Print the MB/s throughput cap for compaction in the system")
+@Command(name = "getcompactionthroughput", description = "Print the MiB/s throughput cap for compaction in the system")
 public class GetCompactionThroughput extends NodeToolCmd
 {
     @Override
     public void execute(NodeProbe probe)
     {
-        probe.output().out.println("Current compaction throughput: " + probe.getCompactionThroughput() + " MB/s");
+        probe.output().out.println("Current compaction throughput: " + probe.getCompactionThroughput() + " MiB/s");
     }
 }

File: src/java/org/apache/cassandra/tools/nodetool/SetCompactionThroughput.java
Patch:
@@ -23,10 +23,10 @@
 import org.apache.cassandra.tools.NodeProbe;
 import org.apache.cassandra.tools.NodeTool.NodeToolCmd;
 
-@Command(name = "setcompactionthroughput", description = "Set the MB/s throughput cap for compaction in the system, or 0 to disable throttling")
+@Command(name = "setcompactionthroughput", description = "Set the MiB/s throughput cap for compaction in the system, or 0 to disable throttling")
 public class SetCompactionThroughput extends NodeToolCmd
 {
-    @Arguments(title = "compaction_throughput", usage = "<value_in_mb>", description = "Value in MB, 0 to disable throttling", required = true)
+    @Arguments(title = "compaction_throughput", usage = "<value_in_mb>", description = "Value in MiB, 0 to disable throttling", required = true)
     private Integer compactionThroughput = null;
 
     @Override

File: src/java/org/apache/cassandra/tools/nodetool/SetInterDCStreamThroughput.java
Patch:
@@ -23,11 +23,11 @@
 import org.apache.cassandra.tools.NodeProbe;
 import org.apache.cassandra.tools.NodeTool.NodeToolCmd;
 
-@Command(name = "setinterdcstreamthroughput", description = "Set the Mb/s throughput cap for inter-datacenter streaming and entire SSTable inter-datacenter streaming in the system, or 0 to disable throttling")
+@Command(name = "setinterdcstreamthroughput", description = "Set the throughput cap for inter-datacenter streaming and entire SSTable inter-datacenter streaming in the system, or 0 to disable throttling")
 public class SetInterDCStreamThroughput extends NodeToolCmd
 {
     @SuppressWarnings("UnusedDeclaration")
-    @Arguments(title = "inter_dc_stream_throughput", usage = "<value_in_mb>", description = "Value in Mb, 0 to disable throttling", required = true)
+    @Arguments(title = "inter_dc_stream_throughput", usage = "<value_in_mb>", description = "Value in megabits, 0 to disable throttling", required = true)
     private int interDCStreamThroughput;
 
     @SuppressWarnings("UnusedDeclaration")

File: src/java/org/apache/cassandra/tools/nodetool/SetStreamThroughput.java
Patch:
@@ -23,11 +23,11 @@
 import org.apache.cassandra.tools.NodeProbe;
 import org.apache.cassandra.tools.NodeTool.NodeToolCmd;
 
-@Command(name = "setstreamthroughput", description = "Set the Mb/s throughput cap for streaming and entire SSTable streaming in the system, or 0 to disable throttling")
+@Command(name = "setstreamthroughput", description = "Set throughput cap for streaming and entire SSTable streaming in the system, or 0 to disable throttling")
 public class SetStreamThroughput extends NodeToolCmd
 {
     @SuppressWarnings("UnusedDeclaration")
-    @Arguments(title = "stream_throughput", usage = "<value_in_mb>", description = "Value in Mb, 0 to disable throttling", required = true)
+    @Arguments(title = "stream_throughput", usage = "<value_in_mb>", description = "Value in megabits, 0 to disable throttling", required = true)
     private int streamThroughput;
 
     @SuppressWarnings("UnusedDeclaration")

File: test/distributed/org/apache/cassandra/distributed/test/NetstatsBootstrapWithEntireSSTablesCompressionStreamingTest.java
Patch:
@@ -37,6 +37,6 @@ public void testWithStreamingEntireSSTablesWithoutCompression() throws Exception
     @Test
     public void testWithStreamingEntireSSTablesWithoutCompressionWithoutThrottling() throws Exception
     {
-        executeTest(true, false, -1);
+        executeTest(true, false, 0);
     }
 }

File: test/distributed/org/apache/cassandra/distributed/test/NetstatsRepairStreamingTest.java
Patch:
@@ -54,8 +54,8 @@ private void executeTest(boolean compressionEnabled) throws Exception
         try (final Cluster cluster = Cluster.build()
                                             .withNodeIdTopology(NetworkTopology.singleDcNetworkTopology(2, "dc0", "rack0"))
                                             .withConfig(config -> config.with(NETWORK, GOSSIP, NATIVE_PROTOCOL)
-                                                                        .set("stream_throughput_outbound_megabits_per_sec", 1)
-                                                                        .set("compaction_throughput_mb_per_sec", 1)
+                                                                        .set("stream_throughput_outbound", "122KiB/s")
+                                                                        .set("compaction_throughput", "1MiB/s")
                                                                         .set("stream_entire_sstables", false)).start())
         {
             final IInvokableInstance node1 = cluster.get(1);

File: test/microbench/org/apache/cassandra/test/microbench/ZeroCopyStreamingBenchmark.java
Patch:
@@ -80,7 +80,7 @@
 import org.openjdk.jmh.annotations.Warmup;
 
 /**
- * Please ensure that this benchmark is run with entire_sstable_stream_throughput_outbound_megabits_per_sec
+ * Please ensure that this benchmark is run with entire_sstable_stream_throughput_outbound
  * set to a really high value otherwise, throttling will kick in and the results will not be meaningful.
  */
 @Warmup(iterations = 1, time = 1, timeUnit = TimeUnit.SECONDS)

File: test/unit/org/apache/cassandra/cql3/validation/miscellaneous/CrcCheckChanceTest.java
Patch:
@@ -185,7 +185,7 @@ public void testDropDuringCompaction() throws Throwable
             cfs.forceBlockingFlush();
         }
 
-        DatabaseDescriptor.setCompactionThroughputMbPerSec(1);
+        DatabaseDescriptor.setCompactionThroughputMebibytesPerSec(1);
         List<? extends Future<?>> futures = CompactionManager.instance.submitMaximal(cfs, CompactionManager.getDefaultGcBefore(cfs, FBUtilities.nowInSeconds()), false);
         execute("DROP TABLE %s");
 

File: test/distributed/org/apache/cassandra/distributed/test/GossipTest.java
Patch:
@@ -61,9 +61,6 @@ public class GossipTest extends TestBaseImpl
     public void nodeDownDuringMove() throws Throwable
     {
         int liveCount = 1;
-        System.setProperty("cassandra.ring_delay_ms", "5000"); // down from 30s default
-        System.setProperty("cassandra.consistent.rangemovement", "false");
-        System.setProperty("cassandra.consistent.simultaneousmoves.allow", "true");
         try (Cluster cluster = Cluster.build(2 + liveCount)
                                       .withConfig(config -> config.with(NETWORK).with(GOSSIP))
                                       .createWithoutStarting())

File: test/distributed/org/apache/cassandra/distributed/upgrade/CompactStorage2to3UpgradeTest.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
+import org.junit.Ignore;
 import org.junit.Test;
 
 import org.apache.cassandra.distributed.UpgradeableCluster;
@@ -37,7 +38,7 @@
 import static org.apache.cassandra.distributed.api.Feature.NATIVE_PROTOCOL;
 import static org.apache.cassandra.distributed.api.Feature.NETWORK;
 
-
+@Ignore // 2.2 branch is no longer maintained and using dtest-api 0.0.8 which is incompatible with current
 public class CompactStorage2to3UpgradeTest extends UpgradeTestBase
 {
     @Test

File: test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java
Patch:
@@ -299,7 +299,7 @@ private void doTransferTable(boolean transferSSTables) throws Exception
     {
         final Keyspace keyspace = Keyspace.open(KEYSPACE1);
         final ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(CF_INDEX);
-
+        cfs.disableAutoCompaction();
         List<String> keys = createAndTransfer(cfs, new Mutator()
         {
             public void mutate(String key, String col, long timestamp) throws Exception

File: src/java/org/apache/cassandra/streaming/StreamManager.java
Patch:
@@ -64,7 +64,7 @@ public static StreamRateLimiter getRateLimiter(InetAddress peer)
 
     public static class StreamRateLimiter
     {
-        public static final double BYTES_PER_MEGABIT = (1024 * 1024) / 8; // from bits
+        public static final double BYTES_PER_MEGABIT = (1000 * 1000) / 8.0;
         private static final RateLimiter limiter = RateLimiter.create(calculateRateInBytes());
         private static final RateLimiter interDCLimiter = RateLimiter.create(calculateInterDCRateInBytes());
         private final boolean isLocalDC;

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -254,6 +254,8 @@ public class Config
     public volatile int counter_cache_save_period = 7200;
     public volatile int counter_cache_keys_to_save = Integer.MAX_VALUE;
 
+    public int cache_load_timeout_seconds = 30;
+
     private static boolean isClientMode = false;
     private static Supplier<Config> overrideLoadConfig = null;
 

File: src/java/org/apache/cassandra/db/lifecycle/View.java
Patch:
@@ -137,7 +137,7 @@ public Iterable<SSTableReader> select(SSTableSet sstableSet)
             case NONCOMPACTING:
                 return filter(sstables, (s) -> !compacting.contains(s));
             case CANONICAL:
-                Set<SSTableReader> canonicalSSTables = new HashSet<>();
+                Set<SSTableReader> canonicalSSTables = new HashSet<>(sstables.size() + compacting.size());
                 for (SSTableReader sstable : compacting)
                     if (sstable.openReason != SSTableReader.OpenReason.EARLY)
                         canonicalSSTables.add(sstable);

File: src/java/org/apache/cassandra/auth/CassandraRoleManager.java
Patch:
@@ -80,7 +80,7 @@ public class CassandraRoleManager implements IRoleManager
 {
     private static final Logger logger = LoggerFactory.getLogger(CassandraRoleManager.class);
 
-    static final String DEFAULT_SUPERUSER_NAME = "cassandra";
+    public static final String DEFAULT_SUPERUSER_NAME = "cassandra";
     static final String DEFAULT_SUPERUSER_PASSWORD = "cassandra";
 
     /**

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -563,6 +563,9 @@ public class Config
      */
     public volatile double range_tombstone_list_growth_factor = 1.5;
 
+    /** The configuration for guardrails. */
+    public final GuardrailsOptions guardrails = new GuardrailsOptions();
+
     /**
      * @deprecated migrate to {@link DatabaseDescriptor#isClientInitialized()}
      */

File: src/java/org/apache/cassandra/cql3/statements/schema/AlterSchemaStatement.java
Patch:
@@ -44,7 +44,7 @@ protected AlterSchemaStatement(String keyspaceName)
         this.keyspaceName = keyspaceName;
     }
 
-    public final void validate(ClientState state)
+    public void validate(ClientState state)
     {
         // no-op; validation is performed while executing the statement, in apply()
     }

File: src/java/org/apache/cassandra/auth/CassandraRoleManager.java
Patch:
@@ -385,7 +385,7 @@ private static boolean hasExistingRoles() throws RequestExecutionException
     protected void scheduleSetupTask(final Callable<Void> setupTask)
     {
         // The delay is to give the node a chance to see its peers before attempting the operation
-        ScheduledExecutors.optionalTasks.schedule(() -> {
+        ScheduledExecutors.optionalTasks.scheduleSelfRecurring(() -> {
             isClusterReady = true;
             try
             {

File: src/java/org/apache/cassandra/config/CassandraRelevantProperties.java
Patch:
@@ -228,6 +228,7 @@ public enum CassandraRelevantProperties
     // properties for debugging simulator ASM output
     TEST_SIMULATOR_PRINT_ASM("cassandra.test.simulator.print_asm", "none"),
     TEST_SIMULATOR_PRINT_ASM_TYPES("cassandra.test.simulator.print_asm_types", ""),
+    TEST_SIMULATOR_LIVENESS_CHECK("cassandra.test.simulator.livenesscheck", "true"),
 
     // determinism properties for testing
     DETERMINISM_SSTABLE_COMPRESSION_DEFAULT("cassandra.sstable_compression_default", "true"),

File: src/java/org/apache/cassandra/cql3/statements/BatchUpdatesCollector.java
Patch:
@@ -30,7 +30,7 @@
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.partitions.PartitionUpdate;
 
-import static org.apache.cassandra.utils.MonotonicClock.approxTime;
+import static org.apache.cassandra.utils.MonotonicClock.Global.approxTime;
 
 /**
  * Utility class to collect updates.

File: src/java/org/apache/cassandra/db/Keyspace.java
Patch:
@@ -78,7 +78,7 @@
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static org.apache.cassandra.utils.Clock.Global.currentTimeMillis;
-import static org.apache.cassandra.utils.MonotonicClock.approxTime;
+import static org.apache.cassandra.utils.MonotonicClock.Global.approxTime;
 
 /**
  * It represents a Keyspace.

File: src/java/org/apache/cassandra/db/Mutation.java
Patch:
@@ -42,7 +42,7 @@
 import static org.apache.cassandra.net.MessagingService.VERSION_30;
 import static org.apache.cassandra.net.MessagingService.VERSION_3014;
 import static org.apache.cassandra.net.MessagingService.VERSION_40;
-import static org.apache.cassandra.utils.MonotonicClock.approxTime;
+import static org.apache.cassandra.utils.MonotonicClock.Global.approxTime;
 
 public class Mutation implements IMutation
 {

File: src/java/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -72,7 +72,7 @@
 import static com.google.common.collect.Iterables.any;
 import static com.google.common.collect.Iterables.filter;
 import static org.apache.cassandra.utils.Clock.Global.nanoTime;
-import static org.apache.cassandra.utils.MonotonicClock.approxTime;
+import static org.apache.cassandra.utils.MonotonicClock.Global.approxTime;
 import static org.apache.cassandra.db.partitions.UnfilteredPartitionIterators.MergeListener.NOOP;
 
 /**

File: src/java/org/apache/cassandra/db/ReadExecutionController.java
Patch:
@@ -28,7 +28,7 @@
 import org.apache.cassandra.utils.MonotonicClock;
 import org.apache.cassandra.utils.concurrent.OpOrder;
 
-import static org.apache.cassandra.utils.MonotonicClock.preciseTime;
+import static org.apache.cassandra.utils.MonotonicClock.Global.preciseTime;
 
 public class ReadExecutionController implements AutoCloseable
 {

File: src/java/org/apache/cassandra/db/commitlog/AbstractCommitLogService.java
Patch:
@@ -45,6 +45,7 @@
 import static org.apache.cassandra.concurrent.Interruptible.State.SHUTTING_DOWN;
 import static org.apache.cassandra.utils.Clock.Global.currentTimeMillis;
 import static org.apache.cassandra.utils.Clock.Global.nanoTime;
+import static org.apache.cassandra.utils.MonotonicClock.Global.preciseTime;
 import static org.apache.cassandra.utils.concurrent.Semaphore.newSemaphore;
 import static org.apache.cassandra.utils.concurrent.WaitQueue.newWaitQueue;
 
@@ -151,7 +152,7 @@ void start()
             throw new IllegalArgumentException(String.format("Commit log flush interval must be positive: %fms",
                                                              syncIntervalNanos * 1e-6));
 
-        SyncRunnable sync = new SyncRunnable(MonotonicClock.preciseTime);
+        SyncRunnable sync = new SyncRunnable(preciseTime);
         executor = executorFactory().infiniteLoop(name, sync, SAFE, NON_DAEMON, SYNCHRONIZED);
     }
 

File: src/java/org/apache/cassandra/db/monitoring/MonitorableImpl.java
Patch:
@@ -18,7 +18,7 @@
 
 package org.apache.cassandra.db.monitoring;
 
-import static org.apache.cassandra.utils.MonotonicClock.approxTime;
+import static org.apache.cassandra.utils.MonotonicClock.Global.approxTime;
 
 public abstract class MonitorableImpl implements Monitorable
 {

File: src/java/org/apache/cassandra/db/monitoring/MonitoringTask.java
Patch:
@@ -38,7 +38,7 @@
 
 import static java.lang.System.getProperty;
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
-import static org.apache.cassandra.utils.MonotonicClock.approxTime;
+import static org.apache.cassandra.utils.MonotonicClock.Global.approxTime;
 import static org.apache.cassandra.utils.concurrent.BlockingQueues.newBlockingQueue;
 
 /**

File: src/java/org/apache/cassandra/gms/FailureDetector.java
Patch:
@@ -28,7 +28,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.function.Predicate;
 import javax.management.openmbean.*;
-import org.apache.cassandra.io.util.File;
+
 import org.apache.cassandra.locator.Replica;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -41,7 +41,7 @@
 
 import static org.apache.cassandra.config.CassandraRelevantProperties.LINE_SEPARATOR;
 import static org.apache.cassandra.config.DatabaseDescriptor.newFailureDetector;
-import static org.apache.cassandra.utils.MonotonicClock.preciseTime;
+import static org.apache.cassandra.utils.MonotonicClock.Global.preciseTime;
 
 /**
  * This FailureDetector is an implementation of the paper titled

File: src/java/org/apache/cassandra/hints/HintsDispatcher.java
Patch:
@@ -39,7 +39,7 @@
 import static org.apache.cassandra.hints.HintsDispatcher.Callback.Outcome.*;
 import static org.apache.cassandra.metrics.HintsServiceMetrics.updateDelayMetrics;
 import static org.apache.cassandra.net.Verb.HINT_REQ;
-import static org.apache.cassandra.utils.MonotonicClock.approxTime;
+import static org.apache.cassandra.utils.MonotonicClock.Global.approxTime;
 import static org.apache.cassandra.utils.concurrent.Condition.newOneTimeCondition;
 
 /**

File: src/java/org/apache/cassandra/metrics/Sampler.java
Patch:
@@ -40,7 +40,7 @@ public enum SamplerType
     }
 
     @VisibleForTesting
-    MonotonicClock clock = MonotonicClock.approxTime;
+    MonotonicClock clock = MonotonicClock.Global.approxTime;
 
     @VisibleForTesting
     static final ExecutorPlus samplerExecutor = executorFactory()

File: src/java/org/apache/cassandra/net/AbstractMessageHandler.java
Patch:
@@ -44,7 +44,7 @@
 import static java.lang.Math.max;
 import static java.lang.Math.min;
 import static org.apache.cassandra.net.Crc.InvalidCrc;
-import static org.apache.cassandra.utils.MonotonicClock.approxTime;
+import static org.apache.cassandra.utils.MonotonicClock.Global.approxTime;
 
 /**
  * Core logic for handling inbound message deserialization and execution (in tandem with {@link FrameDecoder}).

File: src/java/org/apache/cassandra/net/InboundMessageHandler.java
Patch:
@@ -43,7 +43,7 @@
 import org.apache.cassandra.utils.NoSpamLogger;
 
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
-import static org.apache.cassandra.utils.MonotonicClock.approxTime;
+import static org.apache.cassandra.utils.MonotonicClock.Global.approxTime;
 
 /**
  * Implementation of {@link AbstractMessageHandler} for processing internode messages from peers.

File: src/java/org/apache/cassandra/net/InboundMessageHandlers.java
Patch:
@@ -32,7 +32,7 @@
 import org.apache.cassandra.net.Message.Header;
 
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
-import static org.apache.cassandra.utils.MonotonicClock.approxTime;
+import static org.apache.cassandra.utils.MonotonicClock.Global.approxTime;
 
 /**
  * An aggregation of {@link InboundMessageHandler}s for all connections from a peer.

File: src/java/org/apache/cassandra/net/Message.java
Patch:
@@ -57,7 +57,7 @@
 import static org.apache.cassandra.net.MessagingService.VERSION_30;
 import static org.apache.cassandra.net.MessagingService.VERSION_40;
 import static org.apache.cassandra.net.MessagingService.instance;
-import static org.apache.cassandra.utils.MonotonicClock.approxTime;
+import static org.apache.cassandra.utils.MonotonicClock.Global.approxTime;
 import static org.apache.cassandra.utils.vint.VIntCoding.computeUnsignedVIntSize;
 import static org.apache.cassandra.utils.vint.VIntCoding.getUnsignedVInt;
 import static org.apache.cassandra.utils.vint.VIntCoding.skipUnsignedVInt;

File: src/java/org/apache/cassandra/net/OutboundConnection.java
Patch:
@@ -68,7 +68,7 @@
 import static org.apache.cassandra.net.ResourceLimits.Outcome.*;
 import static org.apache.cassandra.net.SocketFactory.*;
 import static org.apache.cassandra.utils.FBUtilities.prettyPrintMemory;
-import static org.apache.cassandra.utils.MonotonicClock.approxTime;
+import static org.apache.cassandra.utils.MonotonicClock.Global.approxTime;
 import static org.apache.cassandra.utils.Throwables.isCausedBy;
 import static org.apache.cassandra.utils.concurrent.CountDownLatch.newCountDownLatch;
 

File: src/java/org/apache/cassandra/net/RequestCallbacks.java
Patch:
@@ -49,7 +49,7 @@
 import static org.apache.cassandra.concurrent.ExecutorFactory.Global.executorFactory;
 import static org.apache.cassandra.concurrent.Stage.INTERNAL_RESPONSE;
 import static org.apache.cassandra.utils.Clock.Global.nanoTime;
-import static org.apache.cassandra.utils.MonotonicClock.preciseTime;
+import static org.apache.cassandra.utils.MonotonicClock.Global.preciseTime;
 
 /**
  * An expiring map of request callbacks.

File: src/java/org/apache/cassandra/net/ResponseVerbHandler.java
Patch:
@@ -24,7 +24,7 @@
 import org.apache.cassandra.tracing.Tracing;
 
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
-import static org.apache.cassandra.utils.MonotonicClock.approxTime;
+import static org.apache.cassandra.utils.MonotonicClock.Global.approxTime;
 
 class ResponseVerbHandler implements IVerbHandler
 {

File: src/java/org/apache/cassandra/schema/SchemaKeyspace.java
Patch:
@@ -49,6 +49,7 @@
 import org.apache.cassandra.transport.ProtocolVersion;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
+import org.apache.cassandra.utils.Simulate;
 
 import static java.lang.String.format;
 
@@ -58,6 +59,7 @@
 import static org.apache.cassandra.cql3.QueryProcessor.executeInternal;
 import static org.apache.cassandra.cql3.QueryProcessor.executeOnceInternal;
 import static org.apache.cassandra.schema.SchemaKeyspaceTables.*;
+import static org.apache.cassandra.utils.Simulate.With.GLOBAL_CLOCK;
 
 /**
  * system_schema.* tables and methods for manipulating them.
@@ -294,6 +296,7 @@ static Collection<Mutation> convertSchemaDiffToMutations(KeyspacesDiff diff, lon
     /**
      * Add entries to system_schema.* for the hardcoded system keyspaces
      */
+    @Simulate(with = GLOBAL_CLOCK)
     static void saveSystemKeyspacesSchema()
     {
         KeyspaceMetadata system = Schema.instance.getKeyspaceMetadata(SchemaConstants.SYSTEM_KEYSPACE_NAME);

File: src/java/org/apache/cassandra/service/ActiveRepairService.java
Patch:
@@ -43,6 +43,7 @@
 import org.apache.cassandra.db.compaction.CompactionManager;
 import org.apache.cassandra.locator.EndpointsByRange;
 import org.apache.cassandra.locator.EndpointsForRange;
+import org.apache.cassandra.utils.Simulate;
 import org.apache.cassandra.utils.concurrent.CountDownLatch;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -106,6 +107,7 @@
 import static org.apache.cassandra.net.Message.out;
 import static org.apache.cassandra.net.Verb.PREPARE_MSG;
 import static org.apache.cassandra.utils.Clock.Global.currentTimeMillis;
+import static org.apache.cassandra.utils.Simulate.With.MONITORS;
 import static org.apache.cassandra.utils.concurrent.CountDownLatch.newCountDownLatch;
 
 /**
@@ -122,6 +124,7 @@
  * The creation of a repair session is done through the submitRepairSession that
  * returns a future on the completion of that session.
  */
+@Simulate(with = MONITORS)
 public class ActiveRepairService implements IEndpointStateChangeSubscriber, IFailureDetectionEventListener, ActiveRepairServiceMBean
 {
 

File: src/java/org/apache/cassandra/service/paxos/ProposeCallback.java
Patch:
@@ -28,6 +28,7 @@
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.net.Message;
+import org.apache.cassandra.utils.Nemesis;
 
 /**
  * ProposeCallback has two modes of operation, controlled by the failFast parameter.
@@ -46,7 +47,7 @@ public class ProposeCallback extends AbstractPaxosCallback<Boolean>
 {
     private static final Logger logger = LoggerFactory.getLogger(ProposeCallback.class);
 
-    private final AtomicInteger accepts = new AtomicInteger(0);
+    @Nemesis private final AtomicInteger accepts = new AtomicInteger(0);
     private final int requiredAccepts;
     private final boolean failFast;
 

File: src/java/org/apache/cassandra/transport/CQLMessageHandler.java
Patch:
@@ -46,7 +46,7 @@
 import org.apache.cassandra.transport.messages.ErrorMessage;
 import org.apache.cassandra.utils.NoSpamLogger;
 
-import static org.apache.cassandra.utils.MonotonicClock.approxTime;
+import static org.apache.cassandra.utils.MonotonicClock.Global.approxTime;
 
 /**
  * Implementation of {@link AbstractMessageHandler} for processing CQL messages which comprise a {@link Message} wrapped

File: src/java/org/apache/cassandra/utils/concurrent/AsyncFuture.java
Patch:
@@ -123,7 +123,7 @@ void appendListener(ListenerList<V> newListener)
     }
 
     /**
-     * Support {@link com.google.common.util.concurrent.Futures#transform(ListenableFuture, com.google.common.base.Function, Executor)} natively
+     * Support {@link com.google.common.util.concurrent.Futures#transform} natively
      *
      * See {@link #addListener(GenericFutureListener)} for ordering semantics.
      */

File: src/java/org/apache/cassandra/utils/concurrent/SyncFuture.java
Patch:
@@ -90,7 +90,7 @@ protected SyncFuture(FailureHolder initialState, GenericFutureListener<? extends
     }
 
     /**
-     * Support {@link com.google.common.util.concurrent.Futures#transform(ListenableFuture, com.google.common.base.Function, Executor)} natively
+     * Support {@link com.google.common.util.concurrent.Futures#transform} natively
      *
      * See {@link #addListener(GenericFutureListener)} for ordering semantics.
      */
@@ -165,7 +165,7 @@ synchronized void appendListener(ListenerList<V> newListener)
 
     private void notifyListeners()
     {
-        ListenerList.notify(listeners, this);
+        ListenerList.notifyExclusive(listeners, this);
         listenersUpdater.lazySet(this, null);
     }
 }

File: test/burn/org/apache/cassandra/utils/memory/LongBufferPoolTest.java
Patch:
@@ -265,7 +265,7 @@ public void testAllocate(BufferPool bufferPool, int threadCount, long duration)
         logger.info("{} - testing {} threads for {}m", DATE_FORMAT.format(new Date()), threadCount, TimeUnit.NANOSECONDS.toMinutes(duration));
         logger.info("Testing BufferPool with memoryUsageThreshold={} and enabling BufferPool.DEBUG", bufferPool.memoryUsageThreshold());
         Debug debug = new Debug();
-        bufferPool.debug(debug);
+        bufferPool.debug(debug, null);
 
         TestEnvironment testEnv = new TestEnvironment(threadCount, duration, bufferPool.memoryUsageThreshold());
 
@@ -305,7 +305,7 @@ public void testAllocate(BufferPool bufferPool, int threadCount, long duration)
         assertEquals(0, testEnv.executorService.shutdownNow().size());
 
         logger.info("Reverting BufferPool DEBUG config");
-        bufferPool.debug(BufferPool.Debug.NO_OP);
+        bufferPool.debug(BufferPool.Debug.NO_OP, null);
 
         testEnv.assertCheckedThreadsSucceeded();
 

File: src/java/org/apache/cassandra/cache/AutoSavingCache.java
Patch:
@@ -27,7 +27,6 @@
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 
-import org.apache.cassandra.io.util.File;
 import org.cliffc.high_scale_lib.NonBlockingHashSet;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: src/java/org/apache/cassandra/concurrent/NamedThreadFactory.java
Patch:
@@ -177,7 +177,7 @@ public static  <T extends Thread> T setupThread(T thread, int priority, ClassLoa
     @Override
     public String toString()
     {
-        return id;
+        return threadGroup != null ? id + " in " + threadGroup.getName() : id;
     }
 
     public void close()

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -297,7 +297,7 @@ protected void runMayThrow()
                     }
                 }
             };
-            ScheduledExecutors.scheduledTasks.schedule(runnable, period, TimeUnit.MILLISECONDS);
+            ScheduledExecutors.scheduledTasks.scheduleSelfRecurring(runnable, period, TimeUnit.MILLISECONDS);
         }
     }
 

File: src/java/org/apache/cassandra/db/Directories.java
Patch:
@@ -30,7 +30,6 @@
 import java.nio.file.FileStore;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.nio.file.Paths;
 import java.util.*;
 import java.util.concurrent.ThreadLocalRandom;
 import java.util.function.BiPredicate;

File: src/java/org/apache/cassandra/db/ReadResponse.java
Patch:
@@ -30,7 +30,6 @@
 import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.io.util.DataOutputPlus;
-import org.apache.cassandra.io.util.File;
 import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.schema.TableMetadata;
 import org.apache.cassandra.utils.ByteBufferUtil;

File: src/java/org/apache/cassandra/db/SystemKeyspace.java
Patch:
@@ -38,7 +38,6 @@
 import com.google.common.collect.Sets;
 import com.google.common.io.ByteStreams;
 
-import org.apache.cassandra.io.util.File;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: src/java/org/apache/cassandra/db/WindowsFailedSnapshotTracker.java
Patch:
@@ -23,8 +23,6 @@
 import java.io.IOException;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
-import java.nio.file.Files;
-import java.nio.file.Paths;
 
 import com.google.common.annotations.VisibleForTesting;
 import org.apache.cassandra.io.util.File;

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegmentManagerStandard.java
Patch:
@@ -19,7 +19,6 @@
 package org.apache.cassandra.db.commitlog;
 
 import org.apache.cassandra.db.Mutation;
-import org.apache.cassandra.io.util.File;
 import org.apache.cassandra.io.util.FileUtils;
 
 public class CommitLogSegmentManagerStandard extends AbstractCommitLogSegmentManager

File: src/java/org/apache/cassandra/db/compaction/Scrubber.java
Patch:
@@ -44,7 +44,6 @@
 import org.apache.cassandra.io.util.RandomAccessReader;
 import org.apache.cassandra.service.ActiveRepairService;
 import org.apache.cassandra.utils.*;
-import org.apache.cassandra.utils.Closeable;
 import org.apache.cassandra.utils.concurrent.Refs;
 import org.apache.cassandra.utils.memory.HeapAllocator;
 

File: src/java/org/apache/cassandra/db/compaction/writers/CompactionAwareWriter.java
Patch:
@@ -23,7 +23,6 @@
 import java.util.Set;
 import java.util.UUID;
 
-import org.apache.cassandra.io.util.File;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: src/java/org/apache/cassandra/db/lifecycle/LogRecord.java
Patch:
@@ -22,7 +22,6 @@
 
 
 import java.nio.file.Path;
-import java.nio.file.Paths;
 import java.util.*;
 import java.util.function.BiPredicate;
 import java.util.regex.Matcher;

File: src/java/org/apache/cassandra/gms/EndpointState.java
Patch:
@@ -26,7 +26,6 @@
 
 import com.google.common.annotations.VisibleForTesting;
 
-import org.apache.cassandra.io.util.File;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: src/java/org/apache/cassandra/gms/GossipDigest.java
Patch:
@@ -23,7 +23,6 @@
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputPlus;
-import org.apache.cassandra.io.util.File;
 import org.apache.cassandra.locator.InetAddressAndPort;
 
 import static org.apache.cassandra.locator.InetAddressAndPort.Serializer.inetAddressAndPortSerializer;

File: src/java/org/apache/cassandra/gms/GossipDigestAck2.java
Patch:
@@ -25,7 +25,6 @@
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputPlus;
-import org.apache.cassandra.io.util.File;
 import org.apache.cassandra.locator.InetAddressAndPort;
 
 import static org.apache.cassandra.locator.InetAddressAndPort.Serializer.inetAddressAndPortSerializer;

File: src/java/org/apache/cassandra/gms/GossipDigestSyn.java
Patch:
@@ -30,7 +30,6 @@
  * This is the first message that gets sent out as a start of the Gossip protocol in a
  * round.
  */
-import org.apache.cassandra.io.util.File;
 
 public class GossipDigestSyn
 {

File: src/java/org/apache/cassandra/gms/HeartBeatState.java
Patch:
@@ -29,7 +29,6 @@
 /**
  * HeartBeat State associated with any given endpoint.
  */
-import org.apache.cassandra.io.util.File;
 
 public class HeartBeatState
 {

File: src/java/org/apache/cassandra/gms/TokenSerializer.java
Patch:
@@ -30,9 +30,6 @@
 import java.util.ArrayList;
 import java.util.Collection;
 
-
-import org.apache.cassandra.io.util.File;
-
 public class TokenSerializer
 {
     private static final Logger logger = LoggerFactory.getLogger(TokenSerializer.class);

File: src/java/org/apache/cassandra/gms/VersionedValue.java
Patch:
@@ -24,7 +24,6 @@
 import java.util.UUID;
 import java.util.stream.Collectors;
 
-import org.apache.cassandra.io.util.File;
 import static java.nio.charset.StandardCharsets.ISO_8859_1;
 
 import com.google.common.annotations.VisibleForTesting;

File: src/java/org/apache/cassandra/hints/ChecksummedDataInput.java
Patch:
@@ -25,7 +25,6 @@
 
 import org.apache.cassandra.io.compress.BufferType;
 import org.apache.cassandra.io.util.*;
-import org.apache.cassandra.io.util.File;
 import org.apache.cassandra.utils.Throwables;
 import org.apache.cassandra.utils.NativeLibrary;
 

File: src/java/org/apache/cassandra/index/sasi/disk/OnDiskIndexBuilder.java
Patch:
@@ -31,7 +31,6 @@
 import org.apache.cassandra.db.marshal.*;
 import org.apache.cassandra.io.FSWriteError;
 import org.apache.cassandra.io.util.*;
-import org.apache.cassandra.io.util.File;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.Pair;

File: src/java/org/apache/cassandra/io/compress/CompressedSequentialWriter.java
Patch:
@@ -30,7 +30,6 @@
 import org.apache.cassandra.io.sstable.CorruptSSTableException;
 import org.apache.cassandra.io.sstable.metadata.MetadataCollector;
 import org.apache.cassandra.io.util.*;
-import org.apache.cassandra.io.util.File;
 import org.apache.cassandra.schema.CompressionParams;
 import org.apache.cassandra.utils.ByteBufferUtil;
 

File: src/java/org/apache/cassandra/io/compress/CompressionMetadata.java
Patch:
@@ -17,11 +17,8 @@
  */
 package org.apache.cassandra.io.compress;
 
-import java.nio.file.Files;
 import java.nio.file.NoSuchFileException;
-import java.nio.file.Paths;
 import java.io.DataInput;
-import java.io.DataInputStream;
 import java.io.DataOutput;
 import java.io.EOFException;
 

File: src/java/org/apache/cassandra/io/sstable/Descriptor.java
Patch:
@@ -17,8 +17,6 @@
  */
 package org.apache.cassandra.io.sstable;
 
-import java.io.IOError;
-import java.io.IOException;
 import java.util.*;
 import java.util.regex.Pattern;
 

File: src/java/org/apache/cassandra/io/sstable/SSTableIdentityIterator.java
Patch:
@@ -19,7 +19,6 @@
 
 import java.io.*;
 
-import org.apache.cassandra.io.util.File;
 import org.apache.cassandra.schema.TableMetadata;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.rows.*;

File: src/java/org/apache/cassandra/io/sstable/format/SSTableReaderBuilder.java
Patch:
@@ -39,12 +39,10 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.io.BufferedInputStream;
 import java.io.DataInputStream;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.file.Files;
-import java.nio.file.Paths;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 

File: src/java/org/apache/cassandra/io/sstable/format/big/BigTableWriter.java
Patch:
@@ -25,7 +25,7 @@
 
 import org.apache.cassandra.db.compaction.OperationType;
 import org.apache.cassandra.db.lifecycle.LifecycleNewTracker;
-import org.apache.cassandra.io.util.File;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: src/java/org/apache/cassandra/io/sstable/metadata/MetadataSerializer.java
Patch:
@@ -28,7 +28,6 @@
 import com.google.common.base.Throwables;
 import com.google.common.collect.Lists;
 
-import org.apache.cassandra.io.util.File;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: src/java/org/apache/cassandra/io/util/BufferedDataOutputStreamPlus.java
Patch:
@@ -243,6 +243,9 @@ public void flush() throws IOException
     @Override
     public void close() throws IOException
     {
+        if (buffer == null)
+            return;
+
         doFlush(0);
         channel.close();
         FileUtils.clean(buffer);

File: src/java/org/apache/cassandra/io/util/PathUtils.java
Patch:
@@ -41,8 +41,6 @@
 import org.apache.cassandra.utils.NoSpamLogger;
 
 import static java.nio.file.StandardOpenOption.*;
-import static java.nio.file.StandardOpenOption.CREATE;
-import static java.nio.file.StandardOpenOption.WRITE;
 import static java.util.Collections.unmodifiableSet;
 import static org.apache.cassandra.utils.Throwables.merge;
 

File: src/java/org/apache/cassandra/net/Verb.java
Patch:
@@ -225,7 +225,7 @@ public enum Kind
     private final Supplier<? extends IVersionedAsymmetricSerializer<?, ?>> serializer;
     private final Supplier<? extends IVerbHandler<?>> handler;
 
-    final Verb responseVerb;
+    public final Verb responseVerb;
 
     private final ToLongFunction<TimeUnit> expiration;
 

File: src/java/org/apache/cassandra/repair/consistent/SyncStatSummary.java
Patch:
@@ -28,7 +28,6 @@
 
 import com.google.common.collect.Lists;
 
-import org.apache.cassandra.locator.InetAddressAndPort;
 import org.apache.cassandra.repair.RepairResult;
 import org.apache.cassandra.repair.RepairSessionResult;
 import org.apache.cassandra.repair.SyncStat;

File: src/java/org/apache/cassandra/service/StartupChecks.java
Patch:
@@ -54,10 +54,8 @@
 import org.apache.cassandra.utils.NativeLibrary;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.JavaUtils;
-import org.apache.cassandra.utils.NoSpamLogger;
 import org.apache.cassandra.utils.SigarLibrary;
 
-import static java.lang.String.format;
 import static org.apache.cassandra.config.CassandraRelevantProperties.COM_SUN_MANAGEMENT_JMXREMOTE_PORT;
 import static org.apache.cassandra.config.CassandraRelevantProperties.JAVA_VERSION;
 import static org.apache.cassandra.config.CassandraRelevantProperties.JAVA_VM_NAME;

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -140,7 +140,6 @@
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static java.util.stream.Collectors.toList;
 import static java.util.stream.Collectors.toMap;
-import static org.apache.cassandra.concurrent.FutureTask.callable;
 import static org.apache.cassandra.config.CassandraRelevantProperties.BOOTSTRAP_SCHEMA_DELAY_MS;
 import static org.apache.cassandra.config.CassandraRelevantProperties.BOOTSTRAP_SKIP_SCHEMA_CHECK;
 import static org.apache.cassandra.config.CassandraRelevantProperties.REPLACEMENT_ALLOW_EMPTY;

File: src/java/org/apache/cassandra/service/paxos/PaxosState.java
Patch:
@@ -53,9 +53,9 @@ void put(DecoratedKey key)
         }
     }
 
-    private final Commit promised;
-    private final Commit accepted;
-    private final Commit mostRecentCommit;
+    public final Commit promised;
+    public final Commit accepted;
+    public final Commit mostRecentCommit;
 
     public PaxosState(DecoratedKey key, TableMetadata metadata)
     {

File: src/java/org/apache/cassandra/streaming/async/StreamingMultiplexedChannel.java
Patch:
@@ -59,6 +59,7 @@
 import static org.apache.cassandra.streaming.StreamSession.createLogTag;
 import static org.apache.cassandra.streaming.messages.StreamMessage.serialize;
 import static org.apache.cassandra.streaming.messages.StreamMessage.serializedSize;
+import static org.apache.cassandra.utils.Clock.Global.nanoTime;
 import static org.apache.cassandra.utils.FBUtilities.getAvailableProcessors;
 import static org.apache.cassandra.utils.JVMStabilityInspector.inspectThrowable;
 import static org.apache.cassandra.utils.concurrent.BlockingQueues.newBlockingQueue;

File: src/java/org/apache/cassandra/tools/BulkLoadConnectionFactory.java
Patch:
@@ -22,7 +22,6 @@
 import java.net.InetSocketAddress;
 
 import org.apache.cassandra.config.EncryptionOptions;
-import org.apache.cassandra.locator.InetAddressAndPort;
 import org.apache.cassandra.net.OutboundConnectionSettings;
 import org.apache.cassandra.streaming.StreamingChannel;
 import org.apache.cassandra.streaming.async.NettyStreamingConnectionFactory;

File: src/java/org/apache/cassandra/utils/BloomFilterSerializer.java
Patch:
@@ -18,12 +18,10 @@
 package org.apache.cassandra.utils;
 
 import java.io.DataInput;
-import java.io.DataInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 
 import org.apache.cassandra.db.TypeSizes;
-import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputPlus;
 import org.apache.cassandra.utils.obs.IBitSet;
 import org.apache.cassandra.utils.obs.OffHeapBitSet;

File: src/java/org/apache/cassandra/utils/FBUtilities.java
Patch:
@@ -44,7 +44,7 @@
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Joiner;
-import com.google.common.base.Strings;
+
 import org.apache.cassandra.io.util.File;
 import org.apache.cassandra.utils.concurrent.*;
 import org.apache.commons.lang3.StringUtils;

File: src/java/org/apache/cassandra/utils/binlog/ExternalArchiver.java
Patch:
@@ -36,7 +36,6 @@
 import org.slf4j.LoggerFactory;
 
 import net.openhft.chronicle.queue.impl.single.SingleChronicleQueue;
-import org.apache.cassandra.concurrent.NamedThreadFactory;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.concurrent.UncheckedInterruptedException;
 

File: src/java/org/apache/cassandra/utils/obs/OffHeapBitSet.java
Patch:
@@ -18,7 +18,6 @@
 package org.apache.cassandra.utils.obs;
 
 import java.io.*;
-import java.io.IOException;
 
 import com.google.common.annotations.VisibleForTesting;
 

File: test/distributed/org/apache/cassandra/distributed/impl/Coordinator.java
Patch:
@@ -111,7 +111,7 @@ private SimpleQueryResult executeInternal(String query, ConsistencyLevel consist
                                                        null,
                                                        ProtocolVersion.CURRENT,
                                                        null),
-                                   System.nanoTime());
+                                   nanoTime());
             // Collect warnings reported during the query.
             CoordinatorWarnings.done();
             if (res != null)

File: test/distributed/org/apache/cassandra/distributed/impl/Query.java
Patch:
@@ -35,6 +35,8 @@
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 
+import static org.apache.cassandra.utils.Clock.Global.nanoTime;
+
 public class Query implements IIsolatedExecutor.SerializableCallable<Object[][]>
 {
     private static final long serialVersionUID = 1L;
@@ -81,7 +83,7 @@ public Object[][] call()
                                                                  null,
                                                                  timestamp,
                                                                  FBUtilities.nowInSeconds()),
-                                             System.nanoTime());
+                                             nanoTime());
 
         // Collect warnings reported during the query.
         if (res != null)

File: test/unit/org/apache/cassandra/streaming/StreamTransferTaskTest.java
Patch:
@@ -95,6 +95,7 @@ public void testScheduleTimeout() throws Exception
     {
         InetAddressAndPort peer = FBUtilities.getBroadcastAddressAndPort();
         StreamSession session = new StreamSession(StreamOperation.BOOTSTRAP, peer, FACTORY, null, current_version, false, 0, UUID.randomUUID(), PreviewKind.ALL);
+        session.init(new StreamResultFuture(UUID.randomUUID(), StreamOperation.OTHER, UUID.randomUUID(), PreviewKind.NONE));
         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF_STANDARD);
 
         // create two sstables

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -1826,7 +1826,7 @@ protected void beforeExecute(Thread t, Runnable r)
         @Override
         public void afterExecute(Runnable r, Throwable t)
         {
-            DebuggableThreadPoolExecutor.maybeResetTraceSessionWrapper(r);
+            DebuggableThreadPoolExecutor.maybeResetLocalSessionWrapper(r);
 
             if (t == null)
                 t = DebuggableThreadPoolExecutor.extractThrowable(r);

File: src/java/org/apache/cassandra/config/CassandraRelevantProperties.java
Patch:
@@ -233,6 +233,7 @@ public enum CassandraRelevantProperties
     DETERMINISM_SSTABLE_COMPRESSION_DEFAULT("cassandra.sstable_compression_default", "true"),
     DETERMINISM_CONSISTENT_DIRECTORY_LISTINGS("cassandra.consistent_directory_listings", "false"),
     DETERMINISM_UNSAFE_UUID_NODE("cassandra.unsafe.deterministicuuidnode", "false"),
+    FAILURE_LOGGING_INTERVAL_SECONDS("cassandra.request_failure_log_interval_seconds", "60"),
 
     // properties to disable certain behaviours for testing
     DISABLE_GOSSIP_ENDPOINT_REMOVAL("cassandra.gossip.disable_endpoint_removal"),

File: src/java/org/apache/cassandra/cache/CaffeineCache.java
Patch:
@@ -27,6 +27,7 @@
 import com.github.benmanes.caffeine.cache.Caffeine;
 import com.github.benmanes.caffeine.cache.Policy.Eviction;
 import com.github.benmanes.caffeine.cache.Weigher;
+import org.apache.cassandra.concurrent.ImmediateExecutor;
 
 /**
  * An adapter from a Caffeine cache to the ICache interface. This provides an on-heap cache using
@@ -54,7 +55,7 @@ public static <K extends IMeasurableMemory, V extends IMeasurableMemory> Caffein
         Cache<K, V> cache = Caffeine.newBuilder()
                 .maximumWeight(weightedCapacity)
                 .weigher(weigher)
-                .executor(MoreExecutors.directExecutor())
+                .executor(ImmediateExecutor.INSTANCE)
                 .build();
         return new CaffeineCache<>(cache);
     }

File: src/java/org/apache/cassandra/cache/ChunkCache.java
Patch:
@@ -29,6 +29,7 @@
 import com.google.common.util.concurrent.MoreExecutors;
 
 import com.github.benmanes.caffeine.cache.*;
+import org.apache.cassandra.concurrent.ImmediateExecutor;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.io.sstable.CorruptSSTableException;
 import org.apache.cassandra.io.util.*;
@@ -143,7 +144,7 @@ private ChunkCache(BufferPool pool)
         metrics = new ChunkCacheMetrics(this);
         cache = Caffeine.newBuilder()
                         .maximumWeight(cacheSize)
-                        .executor(MoreExecutors.directExecutor())
+                        .executor(ImmediateExecutor.INSTANCE)
                         .weigher((key, buffer) -> ((Buffer) buffer).buffer.capacity())
                         .removalListener(this)
                         .recordStats(() -> metrics)

File: src/java/org/apache/cassandra/cache/SerializingCache.java
Patch:
@@ -21,6 +21,7 @@
 import com.github.benmanes.caffeine.cache.Caffeine;
 import com.github.benmanes.caffeine.cache.Weigher;
 
+import org.apache.cassandra.concurrent.ImmediateExecutor;
 import org.apache.cassandra.io.ISerializer;
 import org.apache.cassandra.io.util.MemoryInputStream;
 import org.apache.cassandra.io.util.MemoryOutputStream;
@@ -51,7 +52,7 @@ private SerializingCache(long capacity, Weigher<K, RefCountedMemory> weigher, IS
         this.cache = Caffeine.newBuilder()
                    .weigher(weigher)
                    .maximumWeight(capacity)
-                   .executor(MoreExecutors.directExecutor())
+                   .executor(ImmediateExecutor.INSTANCE)
                    .removalListener((key, mem, cause) -> {
                        if (cause.wasEvicted()) {
                            mem.unreference();

File: src/java/org/apache/cassandra/cql3/QueryProcessor.java
Patch:
@@ -35,6 +35,7 @@
 import org.slf4j.LoggerFactory;
 
 import org.antlr.runtime.*;
+import org.apache.cassandra.concurrent.ImmediateExecutor;
 import org.apache.cassandra.concurrent.ScheduledExecutors;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.metrics.ClientRequestMetrics;
@@ -97,7 +98,7 @@ public class QueryProcessor implements QueryHandler
     static
     {
         preparedStatements = Caffeine.newBuilder()
-                             .executor(MoreExecutors.directExecutor())
+                             .executor(ImmediateExecutor.INSTANCE)
                              .maximumWeight(capacityToBytes(DatabaseDescriptor.getPreparedStatementsCacheSizeMB()))
                              .weigher(QueryProcessor::measure)
                              .removalListener((key, prepared, cause) -> {

File: src/java/org/apache/cassandra/db/repair/PendingAntiCompaction.java
Patch:
@@ -372,7 +372,7 @@ public Future<List<Void>> run()
         }
 
         Future<List<AcquireResult>> acquisitionResults = FutureCombiner.successfulOf(tasks);
-        return acquisitionResults.andThenAsync(getAcquisitionCallback(prsId, tokenRanges));
+        return acquisitionResults.flatMap(getAcquisitionCallback(prsId, tokenRanges));
     }
 
     @VisibleForTesting

File: src/java/org/apache/cassandra/index/sasi/analyzer/filter/StemmerFactory.java
Patch:
@@ -24,6 +24,7 @@
 
 import com.google.common.util.concurrent.MoreExecutors;
 
+import org.apache.cassandra.concurrent.ImmediateExecutor;
 import org.tartarus.snowball.SnowballStemmer;
 import org.tartarus.snowball.ext.*;
 
@@ -42,7 +43,7 @@ public class StemmerFactory
 {
     private static final Logger logger = LoggerFactory.getLogger(StemmerFactory.class);
     private static final LoadingCache<Class, Constructor<?>> STEMMER_CONSTRUCTOR_CACHE = Caffeine.newBuilder()
-            .executor(MoreExecutors.directExecutor())
+            .executor(ImmediateExecutor.INSTANCE)
             .build(new CacheLoader<Class, Constructor<?>>()
             {
                 public Constructor<?> load(Class aClass) throws Exception

File: src/java/org/apache/cassandra/index/sasi/analyzer/filter/StopWordFactory.java
Patch:
@@ -32,6 +32,7 @@
 import com.github.benmanes.caffeine.cache.Caffeine;
 import com.github.benmanes.caffeine.cache.LoadingCache;
 
+import org.apache.cassandra.concurrent.ImmediateExecutor;
 import org.apache.cassandra.io.util.File;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -51,7 +52,7 @@ public class StopWordFactory
             "pl","pt","ro","ru","sv"));
 
     private static final LoadingCache<String, Set<String>> STOP_WORDS_CACHE = Caffeine.newBuilder()
-            .executor(MoreExecutors.directExecutor())
+            .executor(ImmediateExecutor.INSTANCE)
             .build(StopWordFactory::getStopWordsFromResource);
 
     public static Set<String> getStopWordsForLanguage(Locale locale)

File: src/java/org/apache/cassandra/metrics/HintedHandoffMetrics.java
Patch:
@@ -25,6 +25,7 @@
 import com.github.benmanes.caffeine.cache.Caffeine;
 import com.github.benmanes.caffeine.cache.LoadingCache;
 
+import org.apache.cassandra.concurrent.ImmediateExecutor;
 import org.apache.cassandra.db.SystemKeyspace;
 import org.apache.cassandra.locator.InetAddressAndPort;
 import org.apache.cassandra.utils.UUIDGen;
@@ -44,12 +45,12 @@ public class HintedHandoffMetrics
 
     /** Total number of hints which are not stored, This is not a cache. */
     private final LoadingCache<InetAddressAndPort, DifferencingCounter> notStored = Caffeine.newBuilder()
-                                                                                            .executor(MoreExecutors.directExecutor())
+                                                                                            .executor(ImmediateExecutor.INSTANCE)
                                                                                             .build(DifferencingCounter::new);
 
     /** Total number of hints that have been created, This is not a cache. */
     private final LoadingCache<InetAddressAndPort, Counter> createdHintCounts = Caffeine.newBuilder()
-                                                                                        .executor(MoreExecutors.directExecutor())
+                                                                                        .executor(ImmediateExecutor.INSTANCE)
                                                                                         .build(address -> Metrics.counter(factory.createMetricName("Hints_created-" + address.toString().replace(':', '.'))));
 
     public void incrCreatedHints(InetAddressAndPort address)

File: src/java/org/apache/cassandra/metrics/HintsServiceMetrics.java
Patch:
@@ -25,6 +25,7 @@
 import com.codahale.metrics.Meter;
 import com.github.benmanes.caffeine.cache.Caffeine;
 import com.github.benmanes.caffeine.cache.LoadingCache;
+import org.apache.cassandra.concurrent.ImmediateExecutor;
 import org.apache.cassandra.locator.InetAddressAndPort;
 
 import static org.apache.cassandra.metrics.CassandraMetricsRegistry.Metrics;
@@ -47,7 +48,7 @@ public final class HintsServiceMetrics
 
     /** Histograms per-endpoint of hint delivery delays, This is not a cache. */
     private static final LoadingCache<InetAddressAndPort, Histogram> delayByEndpoint = Caffeine.newBuilder()
-                                                                                               .executor(MoreExecutors.directExecutor())
+                                                                                               .executor(ImmediateExecutor.INSTANCE)
                                                                                                .build(address -> Metrics.histogram(factory.createMetricName("Hint_delays-"+address.toString().replace(':', '.')), false));
 
     public static void updateDelayMetrics(InetAddressAndPort endpoint, long delay)

File: src/java/org/apache/cassandra/repair/RepairJob.java
Patch:
@@ -135,7 +135,7 @@ public void run()
             }
 
             // When all snapshot complete, send validation requests
-            treeResponses = allSnapshotTasks.andThenAsync(endpoints -> {
+            treeResponses = allSnapshotTasks.flatMap(endpoints -> {
                 if (parallelismDegree == RepairParallelism.SEQUENTIAL)
                     return sendSequentialValidationRequest(endpoints);
                 else
@@ -149,7 +149,7 @@ public void run()
         }
 
         // When all validations complete, submit sync tasks
-        Future<List<SyncStat>> syncResults = treeResponses.andThenAsync(session.optimiseStreams && !session.pullRepair ? this::optimisedSyncing : this::standardSyncing, taskExecutor);
+        Future<List<SyncStat>> syncResults = treeResponses.flatMap(session.optimiseStreams && !session.pullRepair ? this::optimisedSyncing : this::standardSyncing, taskExecutor);
 
         // When all sync complete, set the final result
         syncResults.addCallback(new FutureCallback<List<SyncStat>>()

File: src/java/org/apache/cassandra/security/CipherFactory.java
Patch:
@@ -40,6 +40,7 @@
 import org.slf4j.LoggerFactory;
 
 import io.netty.util.concurrent.FastThreadLocal;
+import org.apache.cassandra.concurrent.ImmediateExecutor;
 import org.apache.cassandra.config.TransparentDataEncryptionOptions;
 
 /**
@@ -81,7 +82,7 @@ public CipherFactory(TransparentDataEncryptionOptions options)
 
         cache = Caffeine.newBuilder() // by default cache is unbounded
                 .maximumSize(64) // a value large enough that we should never even get close (so nothing gets evicted)
-                .executor(MoreExecutors.directExecutor())
+                .executor(ImmediateExecutor.INSTANCE)
                 .removalListener((key, value, cause) ->
                 {
                     // maybe reload the key? (to avoid the reload being on the user's dime)

File: test/distributed/org/apache/cassandra/distributed/test/AbstractNetstatsBootstrapStreaming.java
Patch:
@@ -77,8 +77,10 @@ protected void executeTest(final boolean streamEntireSSTables,
             final Future<?> startupRunnable = executorService.submit((Runnable) secondNode::startup);
             final Future<AbstractNetstatsStreaming.NetstatResults> netstatsFuture = executorService.submit(new NetstatsCallable(cluster.get(1)));
 
+            startupRunnable.get(3, MINUTES);
+            // 1m is a bit much, but should be fine on slower environments.  Node2 can't come up without streaming
+            // completing, so if node2 is up 1m is enough time for the nodetool watcher to yield
             final AbstractNetstatsStreaming.NetstatResults results = netstatsFuture.get(1, MINUTES);
-            startupRunnable.get(2, MINUTES);
 
             results.assertSuccessful();
 

File: src/java/org/apache/cassandra/hints/HintsService.java
Patch:
@@ -21,6 +21,7 @@
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 import java.util.Collections;
+import java.util.Objects;
 import java.util.UUID;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -187,7 +188,7 @@ void writeForAllReplicas(Hint hint)
      */
     public void flushAndFsyncBlockingly(Iterable<UUID> hostIds)
     {
-        Iterable<HintsStore> stores = transform(hostIds, catalog::get);
+        Iterable<HintsStore> stores = filter(transform(hostIds, catalog::getNullable), Objects::nonNull);
         writeExecutor.flushBufferPool(bufferPool, stores);
         writeExecutor.fsyncWritersBlockingly(stores);
     }

File: src/java/org/apache/cassandra/db/MutationVerbHandler.java
Patch:
@@ -87,7 +87,8 @@ private static void forwardToLocalNodes(Mutation mutation, MessagingService.Verb
             int size = in.readInt();
 
             // tell the recipients who to send their ack to
-            MessageOut<Mutation> message = new MessageOut<>(verb, mutation, Mutation.serializer).withParameter(Mutation.FORWARD_FROM, from.getAddress());
+            MessageOut<Mutation> message = new MessageOut<>(verb, mutation, Mutation.serializer).withParameter(Mutation.FORWARD_FROM, from.getAddress())
+                                                                                                .withParameter(MessagingService.FAILURE_CALLBACK_PARAM, MessagingService.ONE_BYTE);
             // Send a message to each of the addresses on our Forward List
             for (int i = 0; i < size; i++)
             {

File: src/java/org/apache/cassandra/service/AbstractWriteResponseHandler.java
Patch:
@@ -122,6 +122,9 @@ protected int totalBlockFor()
      */
     protected int totalEndpoints()
     {
+        if (consistencyLevel != null && consistencyLevel.isDatacenterLocal())
+            return consistencyLevel.countLocalEndpoints(Iterables.concat(naturalEndpoints, pendingEndpoints));
+
         return naturalEndpoints.size() + pendingEndpoints.size();
     }
 

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -1445,7 +1445,7 @@ public void runMayThrow()
                 catch (Exception ex)
                 {
                     if (!(ex instanceof WriteTimeoutException))
-                        logger.error("Failed to apply mutation locally : {}", ex);
+                        logger.error("Failed to apply mutation locally : ", ex);
                     handler.onFailure(FBUtilities.getBroadcastAddress());
                 }
             }

File: src/java/org/apache/cassandra/auth/AuthKeyspace.java
Patch:
@@ -21,6 +21,7 @@
 
 import org.apache.cassandra.config.CassandraRelevantProperties;
 import org.apache.cassandra.cql3.statements.schema.CreateTableStatement;
+import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.schema.TableId;
 import org.apache.cassandra.schema.TableMetadata;
 import org.apache.cassandra.schema.SchemaConstants;
@@ -112,7 +113,7 @@ private static TableMetadata parse(String name, String description, String cql)
     public static KeyspaceMetadata metadata()
     {
         return KeyspaceMetadata.create(SchemaConstants.AUTH_KEYSPACE_NAME,
-                                       KeyspaceParams.simple(DEFAULT_RF),
+                                       KeyspaceParams.simple(Math.max(DEFAULT_RF, DatabaseDescriptor.getDefaultKeyspaceRF())),
                                        Tables.of(Roles, RoleMembers, RolePermissions, ResourceRoleIndex, NetworkPermissions));
     }
 }

File: src/java/org/apache/cassandra/config/CassandraRelevantProperties.java
Patch:
@@ -211,6 +211,8 @@ public enum CassandraRelevantProperties
     BATCH_COMMIT_LOG_SYNC_INTERVAL("cassandra.batch_commitlog_sync_interval_millis", "1000"),
 
     SYSTEM_AUTH_DEFAULT_RF("cassandra.system_auth.default_rf", "1"),
+    SYSTEM_TRACES_DEFAULT_RF("cassandra.system_traces.default_rf", "2"),
+    SYSTEM_DISTRIBUTED_DEFAULT_RF("cassandra.system_distributed.default_rf", "3"),
 
     MEMTABLE_OVERHEAD_SIZE("cassandra.memtable.row_overhead_size", "-1"),
     MEMTABLE_OVERHEAD_COMPUTE_STEPS("cassandra.memtable_row_overhead_computation_step", "100000"),

File: src/java/org/apache/cassandra/repair/SystemDistributedKeyspace.java
Patch:
@@ -38,6 +38,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import org.apache.cassandra.config.CassandraRelevantProperties;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.cql3.QueryProcessor;
 import org.apache.cassandra.cql3.UntypedResultSet;
@@ -68,6 +69,7 @@ private SystemDistributedKeyspace()
     {
     }
 
+    private static final int DEFAULT_RF = CassandraRelevantProperties.SYSTEM_DISTRIBUTED_DEFAULT_RF.getInt();
     private static final Logger logger = LoggerFactory.getLogger(SystemDistributedKeyspace.class);
 
     /**
@@ -154,7 +156,7 @@ private static TableMetadata.Builder parse(String table, String description, Str
 
     public static KeyspaceMetadata metadata()
     {
-        return KeyspaceMetadata.create(SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, KeyspaceParams.simple(3), Tables.of(RepairHistory, ParentRepairHistory, ViewBuildStatus));
+        return KeyspaceMetadata.create(SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, KeyspaceParams.simple(Math.max(DEFAULT_RF, DatabaseDescriptor.getDefaultKeyspaceRF())), Tables.of(RepairHistory, ParentRepairHistory, ViewBuildStatus));
     }
 
     public static void startParentRepair(UUID parent_id, String keyspaceName, String[] cfnames, RepairOption options)

File: src/java/org/apache/cassandra/schema/ReplicationParams.java
Patch:
@@ -82,13 +82,13 @@ public static ReplicationParams fromMap(Map<String, String> map) {
         return fromMapWithDefaults(map, new HashMap<>());
     }
 
-    public static ReplicationParams fromMapWithDefaults(Map<String, String> map, Map<String, String> defaults)
+    public static ReplicationParams fromMapWithDefaults(Map<String, String> map, Map<String, String> previousOptions)
     {
         Map<String, String> options = new HashMap<>(map);
         String className = options.remove(CLASS);
 
         Class<? extends AbstractReplicationStrategy> klass = AbstractReplicationStrategy.getClass(className);
-        AbstractReplicationStrategy.prepareReplicationStrategyOptions(klass, options, defaults);
+        AbstractReplicationStrategy.prepareReplicationStrategyOptions(klass, options, previousOptions);
 
         return new ReplicationParams(klass, options);
     }

File: src/java/org/apache/cassandra/service/ReadCallback.java
Patch:
@@ -163,7 +163,7 @@ public void response(MessageIn<ReadResponse> message)
          * Ensure that data is present and the response accumulator has properly published the
          * responses it has received. This may result in not signaling immediately when we receive
          * the minimum number of required results, but it guarantees at least the minimum will
-         * be accessible when we do signal. (see rdar://77320313)
+         * be accessible when we do signal. (see CASSANDRA-16883)
          */
         if (n >= blockfor && resolver.responses.size() >= blockfor && resolver.isDataPresent())
         {

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -2728,7 +2728,9 @@ else if (endpoint.equals(currentOwner))
                 tokensToUpdateInMetadata.add(token);
                 tokensToUpdateInSystemKeyspace.add(token);
             }
-            else if (Gossiper.instance.compareEndpointStartup(endpoint, currentOwner) > 0)
+            // Note: in test scenarios, there may not be any delta between the heartbeat generations of the old
+            // and new nodes, so we first check whether the new endpoint is marked as a replacement for the old.
+            else if (endpoint.equals(tokenMetadata.getReplacementNode(currentOwner).orElse(null)) || Gossiper.instance.compareEndpointStartup(endpoint, currentOwner) > 0)
             {
                 tokensToUpdateInMetadata.add(token);
                 tokensToUpdateInSystemKeyspace.add(token);

File: test/unit/org/apache/cassandra/cql3/ViewTest.java
Patch:
@@ -1483,8 +1483,7 @@ public void testTruncateWhileBuilding() throws Throwable
         assertRows(execute("SELECT * FROM mv"));
 
         // check that the view builder finishes and that the view is still empty after that
-        Util.spinAssertEquals(0, ViewTest::runningCompactions, 60);
-        assertTrue(SystemKeyspace.isViewBuilt(KEYSPACE, "mv"));
+        Util.spinAssertEquals(true, () -> SystemKeyspace.isViewBuilt(KEYSPACE, "mv"), 60);
         waitForViewMutations();
         assertRows(execute("SELECT * FROM mv"));
     }

File: src/java/org/apache/cassandra/cql3/statements/AlterViewStatement.java
Patch:
@@ -79,9 +79,10 @@ public Event.SchemaChange announceMigration(QueryState queryState, boolean isLoc
 
         if (params.defaultTimeToLive > 0)
         {
-            throw new InvalidRequestException("Cannot set or alter default_time_to_live for a materialized view. " +
+            throw new InvalidRequestException("Forbidden default_time_to_live detected for a materialized view. " +
                                               "Data in a materialized view always expire at the same time than " +
-                                              "the corresponding data in the parent table.");
+                                              "the corresponding data in the parent table. default_time_to_live " +
+                                              "must be set to zero, see CASSANDRA-12868 for more information");
         }
 
         viewCopy.metadata.params(params);

File: src/java/org/apache/cassandra/db/Columns.java
Patch:
@@ -27,7 +27,6 @@
 import com.google.common.collect.Iterators;
 
 import net.nicoulaj.compilecommand.annotations.DontInline;
-import org.apache.cassandra.exceptions.UnknownColumnException;
 import org.apache.cassandra.schema.ColumnMetadata;
 import org.apache.cassandra.schema.TableMetadata;
 import org.apache.cassandra.cql3.ColumnIdentifier;

File: src/java/org/apache/cassandra/db/LegacyLayout.java
Patch:
@@ -1217,7 +1217,7 @@ public static LegacyAtom readLegacyAtom(CFMetaData metadata, DataInputPlus in, b
                 throw new IllegalStateException(String.format("Got cell for unknown column %s in sstable of %s.%s: " +
                                                               "This suggest a problem with the schema which doesn't list " +
                                                               "this column. Even if that column was dropped, it should have " +
-                                                              "been listed as such", metadata.ksName, metadata.cfName, UTF8Type.instance.compose(e.columnName)), e);
+                                                              "been listed as such", UTF8Type.instance.compose(e.columnName), metadata.ksName, metadata.cfName), e);
 
             throw e;
         }

File: src/java/org/apache/cassandra/cql3/functions/FunctionCall.java
Patch:
@@ -204,7 +204,7 @@ public AbstractType<?> getExactTypeIfKnown(String keyspace)
 
         public String getText()
         {
-            return name + terms.stream().map(Term.Raw::getText).collect(Collectors.joining(", ", "(", ")"));
+            return name.toCQLString() + terms.stream().map(Term.Raw::getText).collect(Collectors.joining(", ", "(", ")"));
         }
     }
 }

File: test/unit/org/apache/cassandra/tools/nodetool/RingTest.java
Patch:
@@ -85,7 +85,7 @@ private void validateRingOutput(String hostForm, String... args)
         assertThat(hostRing).contains(SimpleSnitch.RACK_NAME);
         assertThat(hostRing).contains("Up");
         assertThat(hostRing).contains("Normal");
-        assertThat(hostRing).containsPattern("\\d+\\.\\d+ KiB");
+        assertThat(hostRing).containsPattern("\\d+\\.?\\d+ KiB");
         assertThat(hostRing).containsPattern("\\d+\\.\\d+%");
         assertThat(hostRing).endsWith(token);
         assertThat(hostRing).doesNotContain("?");

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -877,7 +877,8 @@ public static void mutateMV(ByteBuffer dataKey, Collection<Mutation> mutations,
                         }
                         catch (Exception exc)
                         {
-                            logger.error("Error applying local view update to keyspace {}: {}", mutation.getKeyspaceName(), mutation);
+                            logger.error("Error applying local view update: Mutation (keyspace {}, tables {}, partition key {})",
+                                         mutation.getKeyspaceName(), mutation.getColumnFamilyIds(), mutation.key());
                             throw exc;
                         }
                     else

File: src/java/org/apache/cassandra/tools/nodetool/CompactionStats.java
Patch:
@@ -26,7 +26,6 @@
 import io.airlift.command.Option;
 import org.apache.cassandra.db.compaction.CompactionInfo.Unit;
 import org.apache.cassandra.db.compaction.CompactionManagerMBean;
-import org.apache.cassandra.db.compaction.OperationType;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.tools.NodeProbe;
 import org.apache.cassandra.tools.NodeTool.NodeToolCmd;
@@ -69,8 +68,7 @@ public void execute(NodeProbe probe)
                 String percentComplete = total == 0 ? "n/a" : new DecimalFormat("0.00").format((double) completed / total * 100) + "%";
                 String id = c.get("compactionId");
                 table.add(id, taskType, keyspace, columnFamily, completedStr, totalStr, unit, percentComplete);
-                if (taskType.equals(OperationType.COMPACTION.toString()))
-                    remainingBytes += total - completed;
+                remainingBytes += total - completed;
             }
 
             table.printTo(out);

File: src/java/org/apache/cassandra/db/MutationVerbHandler.java
Patch:
@@ -73,7 +73,7 @@ private static void forwardToLocalNodes(Message<Mutation> originalMessage, Forwa
                    .withParam(ParamType.RESPOND_TO, originalMessage.from())
                    .withoutParam(ParamType.FORWARD_TO);
 
-        boolean useSameMessageID = forwardTo.useSameMessageID();
+        boolean useSameMessageID = forwardTo.useSameMessageID(originalMessage.id());
         // reuse the same Message if all ids are identical (as they will be for 4.0+ node originated messages)
         Message<Mutation> message = useSameMessageID ? builder.build() : null;
 

File: src/java/org/apache/cassandra/net/ParamType.java
Patch:
@@ -24,12 +24,11 @@
 
 import org.apache.cassandra.exceptions.RequestFailureReason;
 import org.apache.cassandra.io.IVersionedSerializer;
-import org.apache.cassandra.locator.InetAddressAndPort;
 import org.apache.cassandra.tracing.Tracing;
 import org.apache.cassandra.utils.UUIDSerializer;
 
 import static java.lang.Math.max;
-import static org.apache.cassandra.locator.InetAddressAndPort.Serializer.inetAddressAndPortSerializer;
+import static org.apache.cassandra.locator.InetAddressAndPort.FwdFrmSerializer.fwdFrmSerializer;
 
 /**
  * Type names and serializers for various parameters that can be put in {@link Message} params map.
@@ -42,7 +41,7 @@
 public enum ParamType
 {
     FORWARD_TO          (0, "FWD_TO",        ForwardingInfo.serializer),
-    RESPOND_TO          (1, "FWD_FRM",       inetAddressAndPortSerializer),
+    RESPOND_TO          (1, "FWD_FRM",       fwdFrmSerializer),
 
     @Deprecated
     FAILURE_RESPONSE    (2, "FAIL",          LegacyFlag.serializer),

File: src/java/org/apache/cassandra/service/ReadCallback.java
Patch:
@@ -235,9 +235,7 @@ public void run()
 
                 if (traceState != null)
                     traceState.trace("Digest mismatch: {}", e.toString());
-                if (logger.isDebugEnabled())
-                    logger.debug("Digest mismatch:", e);
-                
+
                 ReadRepairMetrics.repairedBackground.mark();
                 
                 final DataResolver repairResolver = new DataResolver(keyspace, command, consistencyLevel, endpoints.size());

File: test/unit/org/apache/cassandra/utils/SlidingTimeRateTest.java
Patch:
@@ -126,7 +126,8 @@ public void testPruning() throws InterruptedException
     @Test
     public void testConcurrentUpdateAndGet() throws InterruptedException
     {
-        final ExecutorService executor = Executors.newFixedThreadPool(FBUtilities.getAvailableProcessors());
+        int nproc = Math.min(4, FBUtilities.getAvailableProcessors());
+        final ExecutorService executor = Executors.newFixedThreadPool(nproc);
         final TestTimeSource time = new TestTimeSource();
         final SlidingTimeRate rate = new SlidingTimeRate(time, 5, 1, TimeUnit.SECONDS);
         int updates = 100000;
@@ -141,6 +142,6 @@ public void testConcurrentUpdateAndGet() throws InterruptedException
         executor.shutdown();
 
         Assert.assertTrue(executor.awaitTermination(1, TimeUnit.MINUTES));
-        Assert.assertEquals(1000, rate.get(TimeUnit.SECONDS), 100.0);
+        Assert.assertEquals(1000, rate.get(TimeUnit.SECONDS), 150.0);
     }
 }

File: src/java/org/apache/cassandra/db/Clustering.java
Patch:
@@ -72,7 +72,7 @@ public default String toCQLString(TableMetadata metadata)
         for (int i = 0; i < size(); i++)
         {
             ColumnMetadata c = metadata.clusteringColumns().get(i);
-            sb.append(i == 0 ? "" : ", ").append(c.type.getString(get(i), accessor()));
+            sb.append(i == 0 ? "" : ", ").append(c.type.toCQLString(bufferAt(i)));
         }
         return sb.toString();
     }

File: src/java/org/apache/cassandra/db/filter/ClusteringIndexFilter.java
Patch:
@@ -23,6 +23,7 @@
 import org.apache.cassandra.db.partitions.CachedPartition;
 import org.apache.cassandra.db.partitions.Partition;
 import org.apache.cassandra.db.rows.*;
+import org.apache.cassandra.index.Index;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputPlus;
@@ -153,7 +154,7 @@ static interface InternalDeserializer
     public Kind kind();
 
     public String toString(TableMetadata metadata);
-    public String toCQLString(TableMetadata metadata);
+    public String toCQLString(TableMetadata metadata, RowFilter rowFilter);
 
     public interface Serializer
     {

File: src/java/org/apache/cassandra/db/filter/ColumnFilter.java
Patch:
@@ -940,7 +940,7 @@ private String toString(Iterator<ColumnMetadata> columns, boolean cql)
                 if (s.isEmpty())
                     joiner.add(columnName);
                 else
-                    s.forEach(subSel -> joiner.add(String.format("%s%s", columnName, subSel)));
+                    s.forEach(subSel -> joiner.add(String.format("%s%s", columnName, subSel.toString(cql))));
             }
             return joiner.toString();
         }

File: src/java/org/apache/cassandra/schema/ColumnMetadata.java
Patch:
@@ -33,7 +33,6 @@
 import org.apache.cassandra.db.marshal.*;
 import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.serializers.MarshalException;
-import org.apache.cassandra.utils.ByteBufferUtil;
 import org.github.jamm.Unmetered;
 
 @Unmetered
@@ -447,9 +446,9 @@ public static String toCQLString(Iterator<ColumnMetadata> defs)
             return "";
 
         StringBuilder sb = new StringBuilder();
-        sb.append(defs.next().name);
+        sb.append(defs.next().name.toCQLString());
         while (defs.hasNext())
-            sb.append(", ").append(defs.next().name);
+            sb.append(", ").append(defs.next().name.toCQLString());
         return sb.toString();
     }
 

File: src/java/org/apache/cassandra/utils/Mx4jTool.java
Patch:
@@ -26,7 +26,7 @@
  * If mx4j-tools is in the classpath call maybeLoad to load the HTTP interface of mx4j.
  *
  * The default port is 8081. To override that provide e.g. -Dmx4jport=8082
- * The default listen address is 0.0.0.0. To override that provide -Dmx4jaddress=127.0.0.1
+ * The default listen address is the broadcast_address. To override that provide -Dmx4jaddress=127.0.0.1
  */
 public class Mx4jTool
 {

File: test/distributed/org/apache/cassandra/distributed/upgrade/CompactStorage3to4UpgradeTest.java
Patch:
@@ -36,7 +36,7 @@ public void testNullClusteringValues() throws Throwable
     {
         new TestCase().nodes(1)
                       .upgrade(Versions.Major.v30, Versions.Major.v4)
-                      .withConfig(config -> config.with(GOSSIP, NETWORK, NATIVE_PROTOCOL))
+                      .withConfig(config -> config.with(GOSSIP, NETWORK, NATIVE_PROTOCOL).set("enable_drop_compact_storage", true))
                       .setup(cluster -> {
                           String create = "CREATE TABLE %s.%s(k int, c1 int, c2 int, v int, PRIMARY KEY (k, c1, c2)) " +
                                           "WITH compaction = { 'class':'LeveledCompactionStrategy', 'enabled':'false'} AND COMPACT STORAGE";

File: test/distributed/org/apache/cassandra/distributed/upgrade/CompactStorage3to4UpgradeTest.java
Patch:
@@ -36,7 +36,7 @@ public void testNullClusteringValues() throws Throwable
     {
         new TestCase().nodes(1)
                       .upgrade(Versions.Major.v30, Versions.Major.v4)
-                      .withConfig(config -> config.with(GOSSIP, NETWORK, NATIVE_PROTOCOL))
+                      .withConfig(config -> config.with(GOSSIP, NETWORK, NATIVE_PROTOCOL).set("enable_drop_compact_storage", true))
                       .setup(cluster -> {
                           String create = "CREATE TABLE %s.%s(k int, c1 int, c2 int, v int, PRIMARY KEY (k, c1, c2)) " +
                                           "WITH compaction = { 'class':'LeveledCompactionStrategy', 'enabled':'false'} AND COMPACT STORAGE";

File: test/distributed/org/apache/cassandra/distributed/test/SchemaTest.java
Patch:
@@ -40,7 +40,7 @@ public void readRepair() throws Throwable
 
             cluster.get(2).flush(KEYSPACE);
             cluster.get(2).schemaChangeInternal("ALTER TABLE " + KEYSPACE + ".tbl ADD " + name + " list<int>");
-            cluster.get(2).shutdown();
+            cluster.get(2).shutdown().get();
             cluster.get(2).startup();
             cluster.get(2).forceCompact(KEYSPACE, "tbl");
         }
@@ -61,7 +61,7 @@ public void readRepairWithCompaction() throws Throwable
             cluster.get(2).executeInternal("INSERT INTO " + KEYSPACE + ".tbl (pk, ck, v1, v2, " + name + ") values (?,1,1,1,[1])", 1);
             cluster.get(2).flush(KEYSPACE);
             cluster.get(2).forceCompact(KEYSPACE, "tbl");
-            cluster.get(2).shutdown();
+            cluster.get(2).shutdown().get();
             cluster.get(2).startup();
             cluster.get(2).forceCompact(KEYSPACE, "tbl");
         }

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -322,7 +322,7 @@ public class Config
 
     public boolean enable_materialized_views = true;
 
-    public volatile boolean enable_drop_compact_storage = true;
+    public volatile boolean enable_drop_compact_storage = false;
 
     /**
      * Optionally disable asynchronous UDF execution.

File: src/java/org/apache/cassandra/diag/DiagnosticEventService.java
Patch:
@@ -77,7 +77,7 @@ public void publish(DiagnosticEvent event)
         if (!DatabaseDescriptor.diagnosticEventsEnabled())
             return;
 
-        logger.trace("Publishing: {}", event);
+        logger.trace("Publishing: {}={}", event.getClass().getName(), event.toMap());
 
         // event class + type
         ImmutableMultimap<Enum<?>, Consumer<DiagnosticEvent>> consumersByType = subscribersByClassAndType.get(event.getClass());

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -593,7 +593,7 @@ private static ResultSet buildCasFailureResultSet(RowIterator partition,
         Selection selection;
         if (columnsWithConditions == null)
         {
-            selection = Selection.wildcard(metadata, false);
+            selection = Selection.wildcard(metadata, false, false);
         }
         else
         {
@@ -605,7 +605,7 @@ private static ResultSet buildCasFailureResultSet(RowIterator partition,
             if (isBatch)
                 Iterables.addAll(defs, metadata.primaryKeyColumns());
             Iterables.addAll(defs, columnsWithConditions);
-            selection = Selection.forColumns(metadata, new ArrayList<>(defs));
+            selection = Selection.forColumns(metadata, new ArrayList<>(defs), false);
 
         }
 

File: src/java/org/apache/cassandra/schema/SchemaKeyspace.java
Patch:
@@ -439,7 +439,7 @@ private static PartitionUpdate makeUpdateForSchema(UnfilteredRowIterator partiti
 
         // We want to skip the 'cdc' column. A simple solution for that is based on the fact that
         // 'PartitionUpdate.fromIterator()' will ignore any columns that are marked as 'fetched' but not 'queried'.
-        ColumnFilter.Builder builder = ColumnFilter.allRegularColumnsBuilder(partition.metadata());
+        ColumnFilter.Builder builder = ColumnFilter.allRegularColumnsBuilder(partition.metadata(), false);
         for (ColumnMetadata column : filter.fetchedColumns())
         {
             if (!column.name.toString().equals("cdc"))

File: src/java/org/apache/cassandra/utils/CassandraVersion.java
Patch:
@@ -49,6 +49,7 @@ public class CassandraVersion implements Comparable<CassandraVersion>
     private static final Pattern PATTERN = Pattern.compile(VERSION_REGEXP);
 
     public static final CassandraVersion CASSANDRA_4_0 = new CassandraVersion("4.0").familyLowerBound.get();
+    public static final CassandraVersion CASSANDRA_4_0_RC2 = new CassandraVersion(4, 0, 0, NO_HOTFIX, new String[] {"rc2"}, null);
     public static final CassandraVersion CASSANDRA_3_4 = new CassandraVersion("3.4").familyLowerBound.get();
 
     public final int major;

File: test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeReadTest.java
Patch:
@@ -51,7 +51,7 @@ public void mixedModeReadColumnSubsetDigestCheck() throws Throwable
             // we need to let gossip settle or the test will fail
             int attempts = 1;
             //noinspection Convert2MethodRef
-            while (!((IInvokableInstance) (cluster.get(1))).callOnInstance(() -> Gossiper.instance.isUpgradingFromVersionLowerThan(CassandraVersion.CASSANDRA_4_0.familyLowerBound.get()) &&
+            while (!((IInvokableInstance) cluster.get(1)).callOnInstance(() -> Gossiper.instance.isUpgradingFromVersionLowerThan(CassandraVersion.CASSANDRA_4_0) &&
                                                                                  !Gossiper.instance.isUpgradingFromVersionLowerThan(new CassandraVersion(("3.0")).familyLowerBound.get())))
             {
                 if (attempts++ > 90)

File: test/unit/org/apache/cassandra/db/ReadCommandTest.java
Patch:
@@ -328,7 +328,7 @@ public void testSinglePartitionGroupMerge() throws Exception
 
         List<ByteBuffer> buffers = new ArrayList<>(groups.length);
         int nowInSeconds = FBUtilities.nowInSeconds();
-        ColumnFilter columnFilter = ColumnFilter.allRegularColumnsBuilder(cfs.metadata()).build();
+        ColumnFilter columnFilter = ColumnFilter.allRegularColumnsBuilder(cfs.metadata(), false).build();
         RowFilter rowFilter = RowFilter.create();
         Slice slice = Slice.make(BufferClusteringBound.BOTTOM, BufferClusteringBound.TOP);
         ClusteringIndexSliceFilter sliceFilter = new ClusteringIndexSliceFilter(Slices.with(cfs.metadata().comparator, slice), false);
@@ -495,7 +495,7 @@ public void testCountDeletedRows() throws Exception
 
         List<ByteBuffer> buffers = new ArrayList<>(groups.length);
         int nowInSeconds = FBUtilities.nowInSeconds();
-        ColumnFilter columnFilter = ColumnFilter.allRegularColumnsBuilder(cfs.metadata()).build();
+        ColumnFilter columnFilter = ColumnFilter.allRegularColumnsBuilder(cfs.metadata(), false).build();
         RowFilter rowFilter = RowFilter.create();
         Slice slice = Slice.make(BufferClusteringBound.BOTTOM, BufferClusteringBound.TOP);
         ClusteringIndexSliceFilter sliceFilter = new ClusteringIndexSliceFilter(
@@ -571,7 +571,7 @@ public void testCountWithNoDeletedRow() throws Exception
 
         List<ByteBuffer> buffers = new ArrayList<>(groups.length);
         int nowInSeconds = FBUtilities.nowInSeconds();
-        ColumnFilter columnFilter = ColumnFilter.allRegularColumnsBuilder(cfs.metadata()).build();
+        ColumnFilter columnFilter = ColumnFilter.allRegularColumnsBuilder(cfs.metadata(), false).build();
         RowFilter rowFilter = RowFilter.create();
         Slice slice = Slice.make(BufferClusteringBound.BOTTOM, BufferClusteringBound.TOP);
         ClusteringIndexSliceFilter sliceFilter = new ClusteringIndexSliceFilter(

File: test/unit/org/apache/cassandra/gms/GossiperTest.java
Patch:
@@ -37,6 +37,7 @@
 
 import org.apache.cassandra.Util;
 import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.db.SystemKeyspace;
 import org.apache.cassandra.db.commitlog.CommitLog;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.RandomPartitioner;
@@ -115,7 +116,7 @@ public void testHasVersion3Nodes() throws Exception
 
         VersionedValue.VersionedValueFactory factory = new VersionedValue.VersionedValueFactory(null);
         EndpointState es = new EndpointState((HeartBeatState) null);
-        es.addApplicationState(ApplicationState.RELEASE_VERSION, factory.releaseVersion("4.0-SNAPSHOT"));
+        es.addApplicationState(ApplicationState.RELEASE_VERSION, factory.releaseVersion(SystemKeyspace.CURRENT_VERSION.toString()));
         Gossiper.instance.endpointStateMap.put(InetAddressAndPort.getByName("127.0.0.1"), es);
         Gossiper.instance.liveEndpoints.add(InetAddressAndPort.getByName("127.0.0.1"));
 

File: test/unit/org/apache/cassandra/utils/memory/NativeAllocatorTest.java
Patch:
@@ -122,7 +122,7 @@ public void testBookKeeping() throws ExecutionException, InterruptedException
             canClean.countDown();
             try
             {
-                isClean.await(10L, TimeUnit.MILLISECONDS);
+                Assert.assertTrue(isClean.await(10L, TimeUnit.SECONDS));
             }
             catch (InterruptedException e)
             {

File: test/distributed/org/apache/cassandra/distributed/impl/RowUtil.java
Patch:
@@ -25,10 +25,10 @@
 import java.util.List;
 
 import com.google.common.collect.Iterators;
+import com.google.common.collect.Lists;
 
 import com.datastax.driver.core.ResultSet;
 import com.datastax.driver.core.Row;
-import com.google.monitoring.runtime.instrumentation.common.collect.Lists;
 import org.apache.cassandra.cql3.ColumnSpecification;
 import org.apache.cassandra.cql3.UntypedResultSet;
 import org.apache.cassandra.distributed.api.QueryResults;

File: src/java/org/apache/cassandra/cql3/statements/schema/AlterTypeStatement.java
Patch:
@@ -193,7 +193,7 @@ private AlterField(String keyspaceName, String typeName)
 
         UserType apply(KeyspaceMetadata keyspace, UserType userType)
         {
-            throw ire("Alterting field types is no longer supported");
+            throw ire("Altering field types is no longer supported");
         }
     }
 

File: test/unit/org/apache/cassandra/io/sstable/LegacySSTableTest.java
Patch:
@@ -612,7 +612,7 @@ private static void loadLegacyTable(String tablePattern, String legacyVersion) t
      * during development. I.e. remove the {@code @Ignore} annotation temporarily.
      * </p>
      */
-//    @Ignore
+    @Ignore
     @Test
     public void testGenerateSstables() throws Throwable
     {

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1746,7 +1746,7 @@ public boolean bootstrap(final Collection<Token> tokens, long bootstrapTimeoutMi
             SystemKeyspace.removeEndpoint(DatabaseDescriptor.getReplaceAddress());
         }
         if (!Gossiper.instance.seenAnySeed())
-            throw new IllegalStateException("Unable to contact any seeds!");
+            throw new IllegalStateException("Unable to contact any seeds: " + Gossiper.instance.getSeeds());
 
         if (Boolean.getBoolean("cassandra.reset_bootstrap_progress"))
         {

File: test/unit/org/apache/cassandra/gms/ShadowRoundTest.java
Patch:
@@ -43,14 +43,14 @@
 import org.apache.cassandra.locator.InetAddressAndPort;
 import org.apache.cassandra.locator.PropertyFileSnitch;
 import org.apache.cassandra.net.Message;
-import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.net.MockMessagingService;
 import org.apache.cassandra.net.MockMessagingSpy;
 import org.apache.cassandra.net.Verb;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.FBUtilities;
 
 import static org.apache.cassandra.net.MockMessagingService.verb;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
@@ -117,7 +117,7 @@ public void testDelayedResponse()
         }
         catch (Exception e)
         {
-            assertEquals("Unable to contact any seeds!", e.getMessage());
+            assertThat(e.getMessage()).startsWith("Unable to contact any seeds");
         }
 
         // we expect one SYN for each seed during shadow round + additional SYNs after gossiper has been enabled

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -2207,7 +2207,7 @@ else if (Gossiper.instance.compareEndpointStartup(endpoint, currentOwner) > 0)
             }
             else
             {
-                logger.info("Nodes () and {} have the same token {}.  Ignoring {}", endpoint, currentOwner, token, endpoint);
+                logger.info("Nodes {} and {} have the same token {}.  Ignoring {}", endpoint, currentOwner, token, endpoint);
             }
         }
 

File: test/unit/org/apache/cassandra/gms/ShadowRoundTest.java
Patch:
@@ -107,10 +107,10 @@ public void testDelayedResponse()
         }
 
         // we expect one SYN for each seed during shadow round + additional SYNs after gossiper has been enabled
-        assertTrue(spySyn.messagesIntercepted > noOfSeeds);
+        assertTrue(spySyn.messagesIntercepted() > noOfSeeds);
 
         // we don't expect to emit any GOSSIP_DIGEST_ACK2 or MIGRATION_REQUEST messages
-        assertEquals(0, spyAck2.messagesIntercepted);
-        assertEquals(0, spyMigrationReq.messagesIntercepted);
+        assertEquals(0, spyAck2.messagesIntercepted());
+        assertEquals(0, spyMigrationReq.messagesIntercepted());
     }
 }

File: test/unit/org/apache/cassandra/net/MockMessagingServiceTest.java
Patch:
@@ -25,6 +25,7 @@
 import org.junit.Test;
 
 import org.apache.cassandra.SchemaLoader;
+import org.apache.cassandra.Util;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.gms.EchoMessage;
 import org.apache.cassandra.service.StorageService;
@@ -86,10 +87,10 @@ public boolean isLatencyForSnitch()
 
         // we must have intercepted the outgoing message at this point
         MessageOut<?> msg = spy.captureMessageOut().get();
-        assertEquals(1, spy.messagesIntercepted);
+        assertEquals(1, spy.messagesIntercepted());
         assertTrue(msg == echoMessageOut);
 
         // and return a mocked response
-        assertEquals(1, spy.mockedMessageResponses);
+        Util.spinAssertEquals(1, spy::mockedMessageResponses, 60);
     }
 }

File: src/java/org/apache/cassandra/batchlog/BatchlogManager.java
Patch:
@@ -489,8 +489,8 @@ private static ReplayWriteResponseHandler<Mutation> sendSingleReplayMutation(fin
                         Hint.create(mutation, writtenAt));
             }
 
-            ReplicaPlan.ForTokenWrite replicaPlan = new ReplicaPlan.ForTokenWrite(keyspace, ConsistencyLevel.ONE,
-                    liveRemoteOnly.pending(), liveRemoteOnly.all(), liveRemoteOnly.all(), liveRemoteOnly.all());
+            ReplicaPlan.ForTokenWrite replicaPlan = new ReplicaPlan.ForTokenWrite(keyspace, liveAndDown.replicationStrategy(),
+                    ConsistencyLevel.ONE, liveRemoteOnly.pending(), liveRemoteOnly.all(), liveRemoteOnly.all(), liveRemoteOnly.all());
             ReplayWriteResponseHandler<Mutation> handler = new ReplayWriteResponseHandler<>(replicaPlan, System.nanoTime());
             Message<Mutation> message = Message.outWithFlag(MUTATION_REQ, mutation, MessageFlag.CALL_BACK_ON_FAILURE);
             for (Replica replica : liveRemoteOnly.all())

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -383,7 +383,7 @@ private Map<DecoratedKey, Partition> readRequiredLists(Collection<ByteBuffer> pa
 
         try
         {
-            cl.validateForRead(keyspace());
+            cl.validateForRead();
         }
         catch (InvalidRequestException e)
         {
@@ -463,7 +463,7 @@ private ResultMessage executeWithoutCondition(QueryState queryState, QueryOption
         if (isCounter())
             cl.validateCounterForWrite(metadata());
         else
-            cl.validateForWrite(metadata.keyspace);
+            cl.validateForWrite();
 
         List<? extends IMutation> mutations =
             getMutations(options,

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -232,7 +232,7 @@ public ResultMessage.Rows execute(QueryState state, QueryOptions options, long q
         ConsistencyLevel cl = options.getConsistency();
         checkNotNull(cl, "Invalid empty consistency level");
 
-        cl.validateForRead(keyspace());
+        cl.validateForRead();
 
         int nowInSec = options.getNowInSeconds(state);
         int userLimit = getLimit(options);

File: src/java/org/apache/cassandra/db/view/ViewUtils.java
Patch:
@@ -59,10 +59,8 @@ private ViewUtils()
      *
      * @return Optional.empty() if this method is called using a base token which does not belong to this replica
      */
-    public static Optional<Replica> getViewNaturalEndpoint(String keyspaceName, Token baseToken, Token viewToken)
+    public static Optional<Replica> getViewNaturalEndpoint(AbstractReplicationStrategy replicationStrategy, Token baseToken, Token viewToken)
     {
-        AbstractReplicationStrategy replicationStrategy = Keyspace.open(keyspaceName).getReplicationStrategy();
-
         String localDataCenter = DatabaseDescriptor.getEndpointSnitch().getLocalDatacenter();
         EndpointsForToken naturalBaseReplicas = replicationStrategy.getNaturalReplicasForToken(baseToken);
         EndpointsForToken naturalViewReplicas = replicationStrategy.getNaturalReplicasForToken(viewToken);

File: src/java/org/apache/cassandra/locator/TokenMetadata.java
Patch:
@@ -36,6 +36,7 @@
 
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.DecoratedKey;
+import org.apache.cassandra.db.Keyspace;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.Token;
@@ -1294,7 +1295,7 @@ public EndpointsForToken pendingEndpointsForToken(Token token, String keyspaceNa
     public EndpointsForToken getWriteEndpoints(Token token, String keyspaceName, EndpointsForToken natural)
     {
         EndpointsForToken pending = pendingEndpointsForToken(token, keyspaceName);
-        return ReplicaLayout.forTokenWrite(natural, pending).all();
+        return ReplicaLayout.forTokenWrite(Keyspace.open(keyspaceName).getReplicationStrategy(), natural, pending).all();
     }
 
     /** @return an endpoint to token multimap representation of tokenToEndpointMap (a copy) */

File: src/java/org/apache/cassandra/service/DatacenterSyncWriteResponseHandler.java
Patch:
@@ -49,9 +49,9 @@ public DatacenterSyncWriteResponseHandler(ReplicaPlan.ForTokenWrite replicaPlan,
         super(replicaPlan, callback, writeType, queryStartNanoTime);
         assert replicaPlan.consistencyLevel() == ConsistencyLevel.EACH_QUORUM;
 
-        if (replicaPlan.keyspace().getReplicationStrategy() instanceof NetworkTopologyStrategy)
+        if (replicaPlan.replicationStrategy() instanceof NetworkTopologyStrategy)
         {
-            NetworkTopologyStrategy strategy = (NetworkTopologyStrategy) replicaPlan.keyspace().getReplicationStrategy();
+            NetworkTopologyStrategy strategy = (NetworkTopologyStrategy) replicaPlan.replicationStrategy();
             for (String dc : strategy.getDatacenters())
             {
                 int rf = strategy.getReplicationFactor(dc).allReplicas;
@@ -60,7 +60,7 @@ public DatacenterSyncWriteResponseHandler(ReplicaPlan.ForTokenWrite replicaPlan,
         }
         else
         {
-            responses.put(DatabaseDescriptor.getLocalDataCenter(), new AtomicInteger(ConsistencyLevel.quorumFor(replicaPlan.keyspace())));
+            responses.put(DatabaseDescriptor.getLocalDataCenter(), new AtomicInteger(ConsistencyLevel.quorumFor(replicaPlan.replicationStrategy())));
         }
 
         // During bootstrap, we have to include the pending endpoints or we may fail the consistency level

File: src/java/org/apache/cassandra/service/reads/ReplicaFilteringProtection.java
Patch:
@@ -537,14 +537,14 @@ private UnfilteredPartitionIterator fetchFromSource()
             }
             catch (ReadTimeoutException e)
             {
-                int blockFor = consistency.blockFor(keyspace);
+                int blockFor = consistency.blockFor(replicaPlan.replicationStrategy());
                 throw new ReadTimeoutException(consistency, blockFor - 1, blockFor, true);
             }
             catch (UnavailableException e)
             {
-                int blockFor = consistency.blockFor(keyspace);
+                int blockFor = consistency.blockFor(replicaPlan.replicationStrategy());
                 throw UnavailableException.create(consistency, blockFor, blockFor - 1);
             }
         }
     }
-}
\ No newline at end of file
+}

File: src/java/org/apache/cassandra/service/reads/repair/AbstractReadRepair.java
Patch:
@@ -155,7 +155,7 @@ private boolean shouldSpeculate()
         ConsistencyLevel consistency = replicaPlan().consistencyLevel();
         ConsistencyLevel speculativeCL = consistency.isDatacenterLocal() ? ConsistencyLevel.LOCAL_QUORUM : ConsistencyLevel.QUORUM;
         return  consistency != ConsistencyLevel.EACH_QUORUM
-                && consistency.satisfies(speculativeCL, cfs.keyspace)
+                && consistency.satisfies(speculativeCL, replicaPlan.get().replicationStrategy())
                 && cfs.sampleReadLatencyNanos <= command.getTimeout(NANOSECONDS);
     }
 

File: src/java/org/apache/cassandra/service/reads/repair/BlockingReadRepairs.java
Patch:
@@ -85,7 +85,7 @@ public static Mutation createRepairMutation(PartitionUpdate update, ConsistencyL
 
                 if (!suppressException)
                 {
-                    int blockFor = consistency.blockFor(keyspace);
+                    int blockFor = consistency.blockFor(keyspace.getReplicationStrategy());
                     Tracing.trace("Timed out while read-repairing after receiving all {} data and digest responses", blockFor);
                     throw new ReadTimeoutException(consistency, blockFor - 1, blockFor, true);
                 }

File: test/unit/org/apache/cassandra/db/view/ViewUtilsTest.java
Patch:
@@ -77,7 +77,7 @@ public void testGetIndexNaturalEndpoint() throws Exception
         KeyspaceMetadata meta = KeyspaceMetadata.create("Keyspace1", KeyspaceParams.create(false, replicationMap));
         Schema.instance.load(meta);
 
-        Optional<Replica> naturalEndpoint = ViewUtils.getViewNaturalEndpoint("Keyspace1",
+        Optional<Replica> naturalEndpoint = ViewUtils.getViewNaturalEndpoint(Keyspace.open("Keyspace1").getReplicationStrategy(),
                                                                              new StringToken("CA"),
                                                                              new StringToken("BB"));
 
@@ -110,7 +110,7 @@ public void testLocalHostPreference() throws Exception
         KeyspaceMetadata meta = KeyspaceMetadata.create("Keyspace1", KeyspaceParams.create(false, replicationMap));
         Schema.instance.load(meta);
 
-        Optional<Replica> naturalEndpoint = ViewUtils.getViewNaturalEndpoint("Keyspace1",
+        Optional<Replica> naturalEndpoint = ViewUtils.getViewNaturalEndpoint(Keyspace.open("Keyspace1").getReplicationStrategy(),
                                                                              new StringToken("CA"),
                                                                              new StringToken("BB"));
 
@@ -142,7 +142,7 @@ public void testBaseTokenDoesNotBelongToLocalReplicaShouldReturnEmpty() throws E
         KeyspaceMetadata meta = KeyspaceMetadata.create("Keyspace1", KeyspaceParams.create(false, replicationMap));
         Schema.instance.load(meta);
 
-        Optional<Replica> naturalEndpoint = ViewUtils.getViewNaturalEndpoint("Keyspace1",
+        Optional<Replica> naturalEndpoint = ViewUtils.getViewNaturalEndpoint(Keyspace.open("Keyspace1").getReplicationStrategy(),
                                                                              new StringToken("AB"),
                                                                              new StringToken("BB"));
 

File: test/unit/org/apache/cassandra/service/reads/DataResolverTest.java
Patch:
@@ -1321,7 +1321,7 @@ private void assertRepairMetadata(Mutation mutation)
 
     private ReplicaPlan.SharedForRangeRead plan(EndpointsForRange replicas, ConsistencyLevel consistencyLevel)
     {
-        return ReplicaPlan.shared(new ReplicaPlan.ForRangeRead(ks, consistencyLevel, ReplicaUtils.FULL_BOUNDS, replicas, replicas, 1));
+        return ReplicaPlan.shared(new ReplicaPlan.ForRangeRead(ks, ks.getReplicationStrategy(), consistencyLevel, ReplicaUtils.FULL_BOUNDS, replicas, replicas, 1));
     }
 
     private static void resolveAndConsume(DataResolver resolver)
@@ -1338,4 +1338,4 @@ private static void resolveAndConsume(DataResolver resolver)
             }
         }
     }
-}
\ No newline at end of file
+}

File: test/unit/org/apache/cassandra/service/reads/DigestResolverTest.java
Patch:
@@ -161,6 +161,6 @@ public void transientResponseData()
 
     private ReplicaPlan.SharedForTokenRead plan(ConsistencyLevel consistencyLevel, EndpointsForToken replicas)
     {
-        return ReplicaPlan.shared(new ReplicaPlan.ForTokenRead(ks, consistencyLevel, replicas, replicas));
+        return ReplicaPlan.shared(new ReplicaPlan.ForTokenRead(ks, ks.getReplicationStrategy(), consistencyLevel, replicas, replicas));
     }
 }

File: test/unit/org/apache/cassandra/service/reads/ReadExecutorTest.java
Patch:
@@ -270,6 +270,6 @@ private ReplicaPlan.ForTokenRead plan(EndpointsForToken targets, ConsistencyLeve
 
     private ReplicaPlan.ForTokenRead plan(ConsistencyLevel consistencyLevel, EndpointsForToken natural, EndpointsForToken selected)
     {
-        return new ReplicaPlan.ForTokenRead(ks, consistencyLevel, natural, selected);
+        return new ReplicaPlan.ForTokenRead(ks, ks.getReplicationStrategy(), consistencyLevel, natural, selected);
     }
 }

File: test/distributed/org/apache/cassandra/distributed/upgrade/UpgradeTestBase.java
Patch:
@@ -26,16 +26,15 @@
 import java.util.Set;
 import java.util.function.Consumer;
 
+import com.google.common.base.Preconditions;
 import org.junit.After;
 import org.junit.BeforeClass;
 
 import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.dht.Murmur3Partitioner;
 import org.apache.cassandra.distributed.UpgradeableCluster;
 import org.apache.cassandra.distributed.api.ICluster;
-import org.apache.cassandra.distributed.api.IInstance;
 import org.apache.cassandra.distributed.api.IInstanceConfig;
-import org.apache.cassandra.distributed.impl.AbstractCluster.AbstractBuilder;
 import org.apache.cassandra.distributed.impl.Instance;
 import org.apache.cassandra.distributed.shared.DistributedTestBase;
 import org.apache.cassandra.distributed.shared.Versions;
@@ -44,6 +43,7 @@
 import static org.apache.cassandra.distributed.shared.Versions.Major;
 import static org.apache.cassandra.distributed.shared.Versions.Version;
 import static org.apache.cassandra.distributed.shared.Versions.find;
+import static org.apache.commons.lang3.ArrayUtils.isNotEmpty;
 
 public class UpgradeTestBase extends DistributedTestBase
 {
@@ -83,6 +83,7 @@ public static class TestVersions
 
         public TestVersions(Version initial, Version ... upgrade)
         {
+            Preconditions.checkArgument(isNotEmpty(upgrade), "TestVersions must be constructed with one or more target upgrade versions.");
             this.initial = initial;
             this.upgrade = upgrade;
         }
@@ -189,7 +190,6 @@ public void run() throws Throwable
                         runAfterClusterUpgrade.run(cluster);
                     }
                 }
-
             }
         }
         public TestCase nodesToUpgrade(int ... nodes)

File: src/java/org/apache/cassandra/io/util/RandomAccessReader.java
Patch:
@@ -21,11 +21,14 @@
 import java.io.IOException;
 import java.nio.ByteOrder;
 
+import javax.annotation.concurrent.NotThreadSafe;
+
 import com.google.common.primitives.Ints;
 
 import org.apache.cassandra.io.compress.BufferType;
 import org.apache.cassandra.io.util.Rebufferer.BufferHolder;
 
+@NotThreadSafe
 public class RandomAccessReader extends RebufferingInputStream implements FileDataInput
 {
     // The default buffer size when the client doesn't specify it

File: src/java/org/apache/cassandra/repair/messages/PrepareMessage.java
Patch:
@@ -130,8 +130,6 @@ public PrepareMessage deserialize(DataInputPlus in, int version) throws IOExcept
 
         public long serializedSize(PrepareMessage message, int version)
         {
-            Preconditions.checkArgument(version == MessagingService.current_version, MIXED_MODE_ERROR);
-
             long size;
             size = TypeSizes.sizeof(message.tableIds.size());
             for (TableId tableId : message.tableIds)

File: test/unit/org/apache/cassandra/db/ScrubTest.java
Patch:
@@ -56,6 +56,7 @@
 import org.apache.cassandra.db.compaction.Scrubber;
 import org.apache.cassandra.db.lifecycle.LifecycleNewTracker;
 import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
+import org.apache.cassandra.db.marshal.Int32Type;
 import org.apache.cassandra.db.marshal.LongType;
 import org.apache.cassandra.db.marshal.UUIDType;
 import org.apache.cassandra.db.partitions.Partition;
@@ -548,7 +549,7 @@ public void testScrubColumnValidation() throws InterruptedException, RequestExec
         QueryProcessor.process("CREATE TABLE \"Keyspace1\".test_scrub_validation (a text primary key, b int)", ConsistencyLevel.ONE);
         ColumnFamilyStore cfs2 = keyspace.getColumnFamilyStore("test_scrub_validation");
 
-        new Mutation(UpdateBuilder.create(cfs2.metadata(), "key").newRow().add("b", LongType.instance.decompose(1L)).build()).apply();
+        new Mutation(UpdateBuilder.create(cfs2.metadata(), "key").newRow().add("b", Int32Type.instance.decompose(1)).build()).apply();
         cfs2.forceBlockingFlush();
 
         CompactionManager.instance.performScrub(cfs2, false, false, 2);

File: test/distributed/org/apache/cassandra/distributed/upgrade/MixedModeReadTest.java
Patch:
@@ -20,6 +20,7 @@
 
 import org.junit.Test;
 
+import org.apache.cassandra.distributed.api.Feature;
 import org.apache.cassandra.distributed.api.IInvokableInstance;
 import org.apache.cassandra.distributed.shared.Versions;
 import org.apache.cassandra.gms.Gossiper;
@@ -35,6 +36,7 @@ public class MixedModeReadTest extends UpgradeTestBase
     public void mixedModeReadColumnSubsetDigestCheck() throws Throwable
     {
         new TestCase()
+        .withConfig(c -> c.with(Feature.GOSSIP, Feature.NETWORK))
         .nodes(2)
         .nodesToUpgrade(1)
         .upgrade(Versions.Major.v30, Versions.Major.v4)
@@ -52,7 +54,7 @@ public void mixedModeReadColumnSubsetDigestCheck() throws Throwable
             while (!((IInvokableInstance) (cluster.get(1))).callOnInstance(() -> Gossiper.instance.isUpgradingFromVersionLowerThan(CassandraVersion.CASSANDRA_4_0.familyLowerBound.get()) &&
                                                                                  !Gossiper.instance.isUpgradingFromVersionLowerThan(new CassandraVersion(("3.0")).familyLowerBound.get())))
             {
-                if (attempts++ > 30)
+                if (attempts++ > 90)
                     throw new RuntimeException("Gossiper.instance.haveMajorVersion3Nodes() continually returns false despite expecting to be true");
                 Thread.sleep(1000);
             }

File: test/unit/org/apache/cassandra/OffsetAwareConfigurationLoader.java
Patch:
@@ -56,7 +56,10 @@ public Config loadConfig() throws ConfigurationException
 
         String sep = File.pathSeparator;
 
+        assert offset < 2000;
         config.native_transport_port += offset;
+        if (config.native_transport_port_ssl != null)
+            config.native_transport_port_ssl += offset;
         config.storage_port += offset;
         config.ssl_storage_port += offset;
 

File: test/distributed/org/apache/cassandra/distributed/upgrade/CompactStorageUpgradeTest.java
Patch:
@@ -24,7 +24,8 @@
 import org.junit.Test;
 
 import org.apache.cassandra.distributed.api.ConsistencyLevel;
-import org.apache.cassandra.distributed.api.Feature;
+import static org.apache.cassandra.distributed.api.Feature.GOSSIP;
+import static org.apache.cassandra.distributed.api.Feature.NETWORK;
 import org.apache.cassandra.distributed.shared.Versions;
 import static org.apache.cassandra.distributed.shared.AssertUtils.*;
 
@@ -145,6 +146,7 @@ public void compactStorageUpgradeTest() throws Throwable
         .nodes(2)
         .nodesToUpgrade(1, 2)
         .upgrade(Versions.Major.v30, Versions.Major.v4)
+        .withConfig(config -> config.with(GOSSIP, NETWORK))
         .setup((cluster) -> {
             cluster.schemaChange("CREATE TABLE " + KEYSPACE + ".tbl (pk int, ck int, PRIMARY KEY (pk, ck)) WITH COMPACT STORAGE");
             cluster.coordinator(1).execute("INSERT INTO " + KEYSPACE + ".tbl (pk, ck) VALUES (1,1)", ConsistencyLevel.ALL);

File: src/java/org/apache/cassandra/cql3/MultiColumnRelation.java
Patch:
@@ -227,9 +227,9 @@ public Relation renameIdentifier(ColumnIdentifier from, ColumnIdentifier to)
     }
 
     @Override
-    public String toString()
+    public String toCQLString()
     {
-        StringBuilder builder = new StringBuilder(Tuples.tupleToString(entities));
+        StringBuilder builder = new StringBuilder(Tuples.tupleToString(entities, ColumnIdentifier::toCQLString));
         if (isIN())
         {
             return builder.append(" IN ")

File: src/java/org/apache/cassandra/cql3/SingleColumnRelation.java
Patch:
@@ -143,9 +143,9 @@ public Relation renameIdentifier(ColumnIdentifier from, ColumnIdentifier to)
     }
 
     @Override
-    public String toString()
+    public String toCQLString()
     {
-        String entityAsString = entity.toString();
+        String entityAsString = entity.toCQLString();
         if (mapKey != null)
             entityAsString = String.format("%s[%s]", entityAsString, mapKey);
 

File: src/java/org/apache/cassandra/cql3/TokenRelation.java
Patch:
@@ -140,9 +140,9 @@ public Relation renameIdentifier(ColumnIdentifier from, ColumnIdentifier to)
     }
 
     @Override
-    public String toString()
+    public String toCQLString()
     {
-        return String.format("token%s %s %s", Tuples.tupleToString(entities), relationType, value);
+        return String.format("token%s %s %s", Tuples.tupleToString(entities, ColumnIdentifier::toCQLString), relationType, value);
     }
 
     @Override

File: src/java/org/apache/cassandra/schema/SchemaKeyspace.java
Patch:
@@ -740,7 +740,7 @@ private static void addViewToSchemaMutation(ViewMetadata view, boolean includeCo
                                               .add("include_all_columns", view.includeAllColumns)
                                               .add("base_table_id", view.baseTableId.asUUID())
                                               .add("base_table_name", view.baseTableName)
-                                              .add("where_clause", view.whereClause.toString())
+                                              .add("where_clause", view.whereClause.toCQLString())
                                               .add("id", table.id.asUUID());
 
         addTableParamsToRowBuilder(table.params, rowBuilder);

File: src/java/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -595,8 +595,8 @@ protected Predicate<Long> getPurgeEvaluator()
     public String toCQLString()
     {
         StringBuilder sb = new StringBuilder();
-        sb.append("SELECT ").append(columnFilter());
-        sb.append(" FROM ").append(metadata().ksName).append('.').append(metadata.cfName);
+        sb.append("SELECT ").append(columnFilter().toCQLString());
+        sb.append(" FROM ").append(metadata().ksName).append('.').append(metadata().cfName);
         appendCQLWhereClause(sb);
 
         if (limits() != DataLimits.NONE)

File: src/java/org/apache/cassandra/schema/IndexMetadata.java
Patch:
@@ -261,7 +261,7 @@ public void appendCqlTo(CqlBuilder builder, TableMetadata table, boolean ifNotEx
 
             if (!copyOptions.isEmpty())
                 builder.append(" WITH OPTIONS = ")
-                       .append(options);
+                       .append(copyOptions);
         }
         else
         {

File: test/distributed/org/apache/cassandra/distributed/impl/Instance.java
Patch:
@@ -82,6 +82,7 @@
 import org.apache.cassandra.gms.ApplicationState;
 import org.apache.cassandra.gms.Gossiper;
 import org.apache.cassandra.gms.VersionedValue;
+import org.apache.cassandra.hints.DTestSerializer;
 import org.apache.cassandra.hints.HintsService;
 import org.apache.cassandra.index.SecondaryIndexManager;
 import org.apache.cassandra.io.IVersionedSerializer;
@@ -559,6 +560,8 @@ public void startup(ICluster cluster)
                 SystemKeyspace.persistLocalMetadata();
                 LegacySchemaMigrator.migrate();
 
+                MessagingService.instance().verbSerializers.put(MessagingService.Verb.HINT,
+                                                                new DTestSerializer());
                 try
                 {
                     // load schema from disk

File: src/java/org/apache/cassandra/dht/BootStrapper.java
Patch:
@@ -33,7 +33,6 @@
 import org.apache.cassandra.gms.Gossiper;
 import org.apache.cassandra.locator.AbstractReplicationStrategy;
 import org.apache.cassandra.locator.InetAddressAndPort;
-import org.apache.cassandra.locator.NetworkTopologyStrategy;
 import org.apache.cassandra.locator.TokenMetadata;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.streaming.*;

File: test/unit/org/apache/cassandra/service/MigrationCoordinatorTest.java
Patch:
@@ -56,7 +56,6 @@ public class MigrationCoordinatorTest
     private static final UUID LOCAL_VERSION = UUID.randomUUID();
     private static final UUID V1 = UUID.randomUUID();
     private static final UUID V2 = UUID.randomUUID();
-    private static final UUID V3 = UUID.randomUUID();
 
     static
     {
@@ -256,7 +255,7 @@ protected boolean shouldPullImmediately(InetAddress endpoint, UUID version)
     }
 
     @Test
-    public void testWeKeepSendingRequests()
+    public void testWeKeepSendingRequests() throws Exception
     {
         InstrumentedCoordinator coordinator = new InstrumentedCoordinator();
 
@@ -283,7 +282,7 @@ public void testWeKeepSendingRequests()
                 Assert.fail(String.format("Not expecting prev %s to be equal to next %s", prev.endpoint, next.endpoint));
 
             // should send a new request
-            next.fail();
+            next.fail().get();
             prev = next;
             Assert.assertFalse(coordinator.awaitSchemaRequests(1));
 

File: src/java/org/apache/cassandra/service/DataResolver.java
Patch:
@@ -746,7 +746,7 @@ public UnfilteredPartitionIterator moreContents()
              * Can only take the short cut if there is no per partition limit set. Otherwise it's possible to hit false
              * positives due to some rows being uncounted for in certain scenarios (see CASSANDRA-13911).
              */
-            if (!singleResultCounter.isDone() && command.limits().perPartitionCount() == DataLimits.NO_LIMIT)
+            if (command.limits().isExhausted(singleResultCounter) && command.limits().perPartitionCount() == DataLimits.NO_LIMIT)
                 return null;
 
             /*
@@ -844,7 +844,7 @@ public UnfilteredRowIterator moreContents()
                  * Can only take the short cut if there is no per partition limit set. Otherwise it's possible to hit false
                  * positives due to some rows being uncounted for in certain scenarios (see CASSANDRA-13911).
                  */
-                if (!singleResultCounter.isDoneForPartition() && command.limits().perPartitionCount() == DataLimits.NO_LIMIT)
+                if (command.limits().isExhausted(singleResultCounter) && command.limits().perPartitionCount() == DataLimits.NO_LIMIT)
                     return null;
 
                 /*

File: src/java/org/apache/cassandra/locator/SimpleSnitch.java
Patch:
@@ -25,10 +25,11 @@
 public class SimpleSnitch extends AbstractEndpointSnitch
 {
     public static final String DATA_CENTER_NAME = "datacenter1";
+    public static final String RACK_NAME = "rack1";
 
     public String getRack(InetAddressAndPort endpoint)
     {
-        return "rack1";
+        return RACK_NAME;
     }
 
     public String getDatacenter(InetAddressAndPort endpoint)

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -5170,7 +5170,7 @@ public LinkedHashMap<String, Float> effectiveOwnershipWithPort(String keyspace)
     {
         LinkedHashMap<InetAddressAndPort, Float> result = getEffectiveOwnership(keyspace);
         LinkedHashMap<String, Float> asStrings = new LinkedHashMap<>();
-        result.entrySet().stream().forEachOrdered(entry -> asStrings.put(entry.getKey().toString(), entry.getValue()));
+        result.entrySet().stream().forEachOrdered(entry -> asStrings.put(entry.getKey().getHostAddressAndPort(), entry.getValue()));
         return asStrings;
     }
 

File: src/java/org/apache/cassandra/tools/nodetool/HostStatWithPort.java
Patch:
@@ -42,6 +42,6 @@ public String ipOrDns(boolean withPort)
 
         return resolveIp ?
                endpointWithPort.address.getHostName() + ':' + endpointWithPort.port :
-               endpointWithPort.toString();
+               endpointWithPort.getHostAddressAndPort();
     }
 }

File: src/java/org/apache/cassandra/tools/nodetool/SetHostStatWithPort.java
Patch:
@@ -50,7 +50,7 @@ public Iterator<HostStatWithPort> iterator()
     public void add(String token, String host, Map<String, Float> ownerships) throws UnknownHostException
     {
         InetAddressAndPort endpoint = InetAddressAndPort.getByName(host);
-        Float owns = ownerships.get(endpoint.toString());
+        Float owns = ownerships.get(endpoint.getHostAddressAndPort());
         hostStats.add(new HostStatWithPort(token, endpoint, resolveIp, owns));
     }
 }

File: test/distributed/org/apache/cassandra/distributed/test/NodeToolTest.java
Patch:
@@ -52,19 +52,19 @@ public static void after()
     }
 
     @Test
-    public void testCommands() throws Throwable
+    public void testCommands()
     {
         assertEquals(0, NODE.nodetool("help"));
         assertEquals(0, NODE.nodetool("flush"));
         assertEquals(1, NODE.nodetool("not_a_legal_command"));
     }
 
     @Test
-    public void testCaptureConsoleOutput() throws Throwable
+    public void testCaptureConsoleOutput()
     {
         NodeToolResult ringResult = NODE.nodetoolResult("ring");
         ringResult.asserts().stdoutContains("Datacenter: datacenter0");
-        ringResult.asserts().stdoutContains("127.0.0.1  rack0       Up     Normal");
+        ringResult.asserts().stdoutContains("127.0.0.1       rack0       Up     Normal");
         assertEquals("Non-empty error output", "", ringResult.getStderr());
     }
 

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -466,6 +466,7 @@ public enum DiskOptimizationStrategy
     private static final List<String> SENSITIVE_KEYS = new ArrayList<String>() {{
         add("client_encryption_options");
         add("server_encryption_options");
+        add("encryption_options");
     }};
 
     public static void log(Config config)

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -728,13 +728,15 @@ else if (conf.native_transport_max_frame_size_in_mb >= 2048)
             throw new ConfigurationException("index_summary_capacity_in_mb option was set incorrectly to '"
                     + conf.index_summary_capacity_in_mb + "', it should be a non-negative integer.", false);
 
-        if(conf.encryption_options != null)
+        if (conf.encryption_options != null)
         {
             logger.warn("Please rename encryption_options as server_encryption_options in the yaml");
             //operate under the assumption that server_encryption_options is not set in yaml rather than both
             conf.server_encryption_options = conf.encryption_options;
         }
 
+        conf.server_encryption_options.validate();
+
         // load the seeds for node contact points
         if (conf.seed_provider == null)
         {

File: tools/fqltool/test/unit/org/apache/cassandra/fqltool/FQLCompareTest.java
Patch:
@@ -33,7 +33,7 @@
 
 import net.openhft.chronicle.core.io.Closeable;
 import net.openhft.chronicle.queue.ChronicleQueue;
-import net.openhft.chronicle.queue.ChronicleQueueBuilder;
+import net.openhft.chronicle.queue.impl.single.SingleChronicleQueueBuilder;
 import org.apache.cassandra.cql3.QueryOptions;
 import org.apache.cassandra.fqltool.commands.Compare;
 import org.apache.cassandra.tools.Util;
@@ -80,7 +80,7 @@ public void compareEqual() throws IOException
         List<ChronicleQueue> readQueues = null;
         try
         {
-            readQueues = resultPaths.stream().map(s -> ChronicleQueueBuilder.single(s).readOnly(true).build()).collect(Collectors.toList());
+            readQueues = resultPaths.stream().map(s -> SingleChronicleQueueBuilder.single(s).readOnly(true).build()).collect(Collectors.toList());
             List<Iterator<ResultHandler.ComparableResultSet>> its = readQueues.stream().map(q -> new Compare.StoredResultSetIterator(q.createTailer())).collect(Collectors.toList());
             List<ResultHandler.ComparableResultSet> resultSets = Compare.resultSets(its);
             while(resultSets.stream().allMatch(Objects::nonNull))

File: test/unit/org/apache/cassandra/cql3/validation/operations/UpdateTest.java
Patch:
@@ -20,7 +20,6 @@
 
 import java.util.Arrays;
 
-import org.junit.Assert;
 import org.junit.Test;
 
 import static org.apache.commons.lang3.StringUtils.isEmpty;

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -3324,24 +3324,23 @@ public List<String> getMovingNodesWithPort()
         return endpoints;
     }
 
-
+    @Deprecated
     public List<String> getJoiningNodes()
     {
         return stringify(tokenMetadata.getBootstrapTokens().valueSet(), false);
     }
 
-    @Deprecated
     public List<String> getJoiningNodesWithPort()
     {
         return stringify(tokenMetadata.getBootstrapTokens().valueSet(), true);
     }
 
+    @Deprecated
     public List<String> getLiveNodes()
     {
         return stringify(Gossiper.instance.getLiveMembers(), false);
     }
 
-    @Deprecated
     public List<String> getLiveNodesWithPort()
     {
         return stringify(Gossiper.instance.getLiveMembers(), true);

File: src/java/org/apache/cassandra/db/marshal/ByteBufferAccessor.java
Patch:
@@ -193,7 +193,7 @@ public short getShort(ByteBuffer value, int offset)
     @Override
     public int getUnsignedShort(ByteBuffer value, int offset)
     {
-        return ByteBufferUtil.getUnsignedShort(value, offset);
+        return ByteBufferUtil.getUnsignedShort(value, value.position() + offset);
     }
 
     @Override

File: src/java/org/apache/cassandra/service/reads/AbstractReadExecutor.java
Patch:
@@ -371,6 +371,7 @@ public void awaitResponses() throws ReadTimeoutException
         try
         {
             handler.awaitResults();
+            assert digestResolver.isDataPresent() : "awaitResults returned with no data present.";
         }
         catch (ReadTimeoutException e)
         {

File: src/java/org/apache/cassandra/service/reads/DigestResolver.java
Patch:
@@ -74,8 +74,6 @@ private boolean hasTransientResponse(Collection<Message<ReadResponse>> responses
 
     public PartitionIterator getData()
     {
-        assert isDataPresent();
-
         Collection<Message<ReadResponse>> responses = this.responses.snapshot();
 
         if (!hasTransientResponse(responses))
@@ -109,7 +107,8 @@ public boolean responsesMatch()
         // validate digests against each other; return false immediately on mismatch.
         ByteBuffer digest = null;
         Collection<Message<ReadResponse>> snapshot = responses.snapshot();
-        if (snapshot.size() <= 1)
+        assert snapshot.size() > 0 : "Attempted response match comparison while no responses have been received.";
+        if (snapshot.size() == 1)
             return true;
 
         // TODO: should also not calculate if only one full node

File: src/java/org/apache/cassandra/service/reads/AbstractReadExecutor.java
Patch:
@@ -371,7 +371,6 @@ public void awaitResponses() throws ReadTimeoutException
         try
         {
             handler.awaitResults();
-            assert digestResolver.isDataPresent() : "awaitResults returned with no data present.";
         }
         catch (ReadTimeoutException e)
         {

File: src/java/org/apache/cassandra/service/reads/DigestResolver.java
Patch:
@@ -74,6 +74,8 @@ private boolean hasTransientResponse(Collection<Message<ReadResponse>> responses
 
     public PartitionIterator getData()
     {
+        assert isDataPresent();
+
         Collection<Message<ReadResponse>> responses = this.responses.snapshot();
 
         if (!hasTransientResponse(responses))
@@ -107,8 +109,7 @@ public boolean responsesMatch()
         // validate digests against each other; return false immediately on mismatch.
         ByteBuffer digest = null;
         Collection<Message<ReadResponse>> snapshot = responses.snapshot();
-        assert snapshot.size() > 0 : "Attempted response match comparison while no responses have been received.";
-        if (snapshot.size() == 1)
+        if (snapshot.size() <= 1)
             return true;
 
         // TODO: should also not calculate if only one full node

File: src/java/org/apache/cassandra/service/reads/AbstractReadExecutor.java
Patch:
@@ -371,6 +371,7 @@ public void awaitResponses() throws ReadTimeoutException
         try
         {
             handler.awaitResults();
+            assert digestResolver.isDataPresent() : "awaitResults returned with no data present.";
         }
         catch (ReadTimeoutException e)
         {

File: src/java/org/apache/cassandra/service/reads/DigestResolver.java
Patch:
@@ -74,8 +74,6 @@ private boolean hasTransientResponse(Collection<Message<ReadResponse>> responses
 
     public PartitionIterator getData()
     {
-        assert isDataPresent();
-
         Collection<Message<ReadResponse>> responses = this.responses.snapshot();
 
         if (!hasTransientResponse(responses))
@@ -109,7 +107,8 @@ public boolean responsesMatch()
         // validate digests against each other; return false immediately on mismatch.
         ByteBuffer digest = null;
         Collection<Message<ReadResponse>> snapshot = responses.snapshot();
-        if (snapshot.size() <= 1)
+        assert snapshot.size() > 0 : "Attempted response match comparison while no responses have been received.";
+        if (snapshot.size() == 1)
             return true;
 
         // TODO: should also not calculate if only one full node

File: src/java/org/apache/cassandra/db/commitlog/AbstractCommitLogSegmentManager.java
Patch:
@@ -494,7 +494,8 @@ public void awaitTermination() throws InterruptedException
         for (CommitLogSegment segment : activeSegments)
             segment.close();
 
-        bufferPool.emptyBufferPool();
+        if (bufferPool != null)
+            bufferPool.emptyBufferPool();
     }
 
     /**

File: src/java/org/apache/cassandra/db/commitlog/AbstractCommitLogSegmentManager.java
Patch:
@@ -494,7 +494,8 @@ public void awaitTermination() throws InterruptedException
         for (CommitLogSegment segment : activeSegments)
             segment.close();
 
-        bufferPool.emptyBufferPool();
+        if (bufferPool != null)
+            bufferPool.emptyBufferPool();
     }
 
     /**

File: src/java/org/apache/cassandra/service/paxos/PaxosState.java
Patch:
@@ -20,12 +20,9 @@
  */
 package org.apache.cassandra.service.paxos;
 
-import java.util.concurrent.ExecutionException;
 import java.util.concurrent.locks.Lock;
 
-import com.google.common.base.Throwables;
 import com.google.common.util.concurrent.Striped;
-import com.google.common.util.concurrent.Uninterruptibles;
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.DatabaseDescriptor;

File: test/distributed/org/apache/cassandra/distributed/test/NodeToolRingTest.java
Patch:
@@ -147,7 +147,8 @@ public void testRingResolve()
             Assertions.assertThat(tool.getStdout())
                       .contains("Datacenter: datacenter0")
                       .contains("Address    Rack        Status State   Load            Owns                Token")
-                      .contains("localhost  rack0       Up     Normal")
+                      .contains("localhost")
+                      .contains("rack0       Up     Normal")
                       .contains("100.00%             9223372036854775807");
             assertEquals(0, tool.getExitCode());
             assertTrue(tool.getCleanedStderr().isEmpty());

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -266,7 +266,7 @@ public class Config
     public boolean dynamic_snitch = true;
     public int dynamic_snitch_update_interval_in_ms = 100;
     public int dynamic_snitch_reset_interval_in_ms = 600000;
-    public double dynamic_snitch_badness_threshold = 0.1;
+    public double dynamic_snitch_badness_threshold = 1.0;
 
     public EncryptionOptions.ServerEncryptionOptions server_encryption_options = new EncryptionOptions.ServerEncryptionOptions();
     public EncryptionOptions client_encryption_options = new EncryptionOptions();

File: test/unit/org/apache/cassandra/locator/DynamicEndpointSnitchTest.java
Patch:
@@ -66,6 +66,7 @@ private static EndpointsForRange full(InetAddressAndPort... endpoints)
     public void testSnitch() throws InterruptedException, IOException, ConfigurationException
     {
         // do this because SS needs to be initialized before DES can work properly.
+        DatabaseDescriptor.setDynamicBadnessThreshold(0.1);
         StorageService.instance.unsafeInitialize();
         SimpleSnitch ss = new SimpleSnitch();
         DynamicEndpointSnitch dsnitch = new DynamicEndpointSnitch(ss, String.valueOf(ss.hashCode()));

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -113,7 +113,7 @@ public class StorageService extends NotificationBroadcasterSupport implements IE
     private static final Logger logger = LoggerFactory.getLogger(StorageService.class);
 
     public static final int RING_DELAY = getRingDelay(); // delay after which we assume ring has stablized
-    public static final int SCHEMA_DELAY = getRingDelay(); // delay after which we assume ring has stablized
+    public static final int SCHEMA_DELAY_MILLIS = getSchemaDelay();
 
     private static final boolean REQUIRE_SCHEMAS = !Boolean.getBoolean("cassandra.skip_schema_check");
 
@@ -873,7 +873,7 @@ public void waitForSchema(int delay)
             Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);
         }
 
-        boolean schemasReceived = MigrationCoordinator.instance.awaitSchemaRequests(TimeUnit.SECONDS.toMillis(SCHEMA_DELAY));
+        boolean schemasReceived = MigrationCoordinator.instance.awaitSchemaRequests(SCHEMA_DELAY_MILLIS);
 
         if (schemasReceived)
             return;

File: src/java/org/apache/cassandra/concurrent/SharedExecutorPool.java
Patch:
@@ -108,9 +108,9 @@ void maybeStartSpinningWorker()
             schedule(Work.SPINNING);
     }
 
-    public synchronized LocalAwareExecutorService newExecutor(int maxConcurrency, int maxQueuedTasks, String jmxPath, String name)
+    public synchronized LocalAwareExecutorService newExecutor(int maxConcurrency, String jmxPath, String name)
     {
-        SEPExecutor executor = new SEPExecutor(this, maxConcurrency, maxQueuedTasks, jmxPath, name);
+        SEPExecutor executor = new SEPExecutor(this, maxConcurrency, jmxPath, name);
         executors.add(executor);
         return executor;
     }

File: src/java/org/apache/cassandra/concurrent/StageManager.java
Patch:
@@ -91,7 +91,7 @@ private static JMXEnabledThreadPoolExecutor multiThreadedStage(Stage stage, int
 
     private static LocalAwareExecutorService multiThreadedLowSignalStage(Stage stage, int numThreads)
     {
-        return SharedExecutorPool.SHARED.newExecutor(numThreads, Integer.MAX_VALUE, stage.getJmxType(), stage.getJmxName());
+        return SharedExecutorPool.SHARED.newExecutor(numThreads, stage.getJmxType(), stage.getJmxName());
     }
 
     /**

File: src/java/org/apache/cassandra/transport/Message.java
Patch:
@@ -421,7 +421,6 @@ public void encode(ChannelHandlerContext ctx, Message message, List results)
     public static class Dispatcher extends SimpleChannelInboundHandler<Request>
     {
         private static final LocalAwareExecutorService requestExecutor = SHARED.newExecutor(DatabaseDescriptor.getNativeTransportMaxThreads(),
-                                                                                            Integer.MAX_VALUE,
                                                                                             "transport",
                                                                                             "Native-Transport-Requests");
 

File: test/unit/org/apache/cassandra/concurrent/SEPExecutorTest.java
Patch:
@@ -51,7 +51,7 @@ public void write(int b) { }
 
         for (int idx = 0; idx < 20; idx++)
         {
-            ExecutorService es = sharedPool.newExecutor(FBUtilities.getAvailableProcessors(), Integer.MAX_VALUE, "STAGE", run + MAGIC + idx);
+            ExecutorService es = sharedPool.newExecutor(FBUtilities.getAvailableProcessors(), "STAGE", run + MAGIC + idx);
             // Write to black hole
             es.execute(() -> nullPrintSteam.println("TEST" + es));
         }

File: test/distributed/org/apache/cassandra/distributed/impl/Instance.java
Patch:
@@ -690,6 +690,8 @@ private void initializeRing(ICluster cluster)
             // check that all nodes are in token metadata
             for (int i = 0; i < tokens.size(); ++i)
                 assert storageService.getTokenMetadata().isMember(hosts.get(i).getAddress());
+
+            storageService.setNormalModeUnsafe();
         }
         catch (Throwable e) // UnknownHostException
         {

File: src/java/org/apache/cassandra/cql3/UpdateParameters.java
Patch:
@@ -24,7 +24,6 @@
 import org.apache.cassandra.schema.TableMetadata;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.context.CounterContext;
-import org.apache.cassandra.db.filter.ColumnFilter;
 import org.apache.cassandra.db.partitions.Partition;
 import org.apache.cassandra.db.rows.*;
 import org.apache.cassandra.exceptions.InvalidRequestException;
@@ -203,7 +202,7 @@ public Row getPrefetchedRow(DecoratedKey key, Clustering<?> clustering)
             return null;
 
         Partition partition = prefetchedRows.get(key);
-        Row prefetchedRow = partition == null ? null : partition.searchIterator(ColumnFilter.selection(partition.columns()), false).next(clustering);
+        Row prefetchedRow = partition == null ? null : partition.getRow(clustering);
 
         // We need to apply the pending mutations to return the row in its current state
         Row pendingMutations = builder.copy().build();

File: src/java/org/apache/cassandra/db/rows/BTreeRow.java
Patch:
@@ -327,7 +327,8 @@ public Row filter(ColumnFilter filter, DeletionTime activeDeletion, boolean setA
         Map<ByteBuffer, DroppedColumn> droppedColumns = metadata.droppedColumns;
 
         boolean mayFilterColumns = !filter.fetchesAllColumns(isStatic());
-        boolean mayHaveShadowed = activeDeletion.supersedes(deletion.time());
+        // When merging sstable data in Row.Merger#merge(), rowDeletion is removed if it doesn't supersede activeDeletion.
+        boolean mayHaveShadowed = !activeDeletion.isLive() && !deletion.time().supersedes(activeDeletion);
 
         if (!mayFilterColumns && !mayHaveShadowed && droppedColumns.isEmpty())
             return this;

File: src/java/org/apache/cassandra/db/rows/RangeTombstoneMarker.java
Patch:
@@ -158,8 +158,8 @@ private DeletionTime currentOpenDeletionTimeInMerged()
                 return DeletionTime.LIVE;
 
             DeletionTime biggestDeletionTime = openMarkers[biggestOpenMarker];
-            // it's only open in the merged iterator if it's not shadowed by the partition level deletion
-            return partitionDeletion.supersedes(biggestDeletionTime) ? DeletionTime.LIVE : biggestDeletionTime;
+            // it's only open in the merged iterator if it doesn't supersedes the partition level deletion
+            return !biggestDeletionTime.supersedes(partitionDeletion) ? DeletionTime.LIVE : biggestDeletionTime;
         }
 
         private void updateOpenMarkers()

File: src/java/org/apache/cassandra/db/rows/RowAndDeletionMergeIterator.java
Patch:
@@ -161,7 +161,9 @@ private void updateNextRange()
         while (nextRange == null && ranges.hasNext())
         {
             nextRange = ranges.next();
-            if ((removeShadowedData && partitionLevelDeletion().supersedes(nextRange.deletionTime()))
+            // partition deletion will shadow range tombstone if partition deletion time is greater to equal to range
+            // tombstone time.
+            if ((removeShadowedData && !nextRange.deletionTime().supersedes(partitionLevelDeletion()))
                 || nextRange.deletedSlice().isEmpty(metadata.comparator))
                 nextRange = null;
         }

File: test/unit/org/apache/cassandra/cql3/validation/ThriftIntegrationTest.java
Patch:
@@ -936,7 +936,7 @@ public void beforeAndAfterFlush(CheckedFunction runnable) throws Throwable
 
     private void flushAll()
     {
-        for (String cfName : new String[]{ currentTable(), currentSparseTable(), currentCounterTable() })
-            Keyspace.open(KEYSPACE).getColumnFamilyStore(cfName);
+        for (String cfName : new String[]{ currentTable(), currentSparseTable(), currentCounterTable(), currentDenseTable() })
+            Keyspace.open(KEYSPACE).getColumnFamilyStore(cfName).forceBlockingFlush();
     }
 }

File: src/java/org/apache/cassandra/metrics/ClientRequestSizeMetrics.java
Patch:
@@ -31,6 +31,6 @@ public class ClientRequestSizeMetrics
     private static final String TYPE = "ClientRequestSize";
     public static final Counter totalBytesRead = Metrics.counter(DefaultNameFactory.createMetricName(TYPE, "IncomingBytes", null));
     public static final Counter totalBytesWritten = Metrics.counter(DefaultNameFactory.createMetricName(TYPE, "OutgoingBytes", null));
-    public static final Histogram bytesRecievedPerFrame = Metrics.histogram(DefaultNameFactory.createMetricName(TYPE, "BytesRecievedPerFrame", null), true);
+    public static final Histogram bytesReceivedPerFrame = Metrics.histogram(DefaultNameFactory.createMetricName(TYPE, "BytesRecievedPerFrame", null), true);
     public static final Histogram bytesTransmittedPerFrame = Metrics.histogram(DefaultNameFactory.createMetricName(TYPE, "BytesTransmittedPerFrame", null), true);
 }

File: src/java/org/apache/cassandra/transport/Frame.java
Patch:
@@ -224,7 +224,7 @@ Frame decodeFrame(ByteBuf buffer)
                 return null;
 
             ClientRequestSizeMetrics.totalBytesRead.inc(frameLength);
-            ClientRequestSizeMetrics.bytesRecievedPerFrame.update(frameLength);
+            ClientRequestSizeMetrics.bytesReceivedPerFrame.update(frameLength);
 
             // extract body
             ByteBuf body = buffer.slice(idx, (int) bodyLength);

File: src/java/org/apache/cassandra/net/OutboundConnection.java
Patch:
@@ -110,7 +110,8 @@ public class OutboundConnection
 
     private final OutboundMessageCallbacks callbacks;
     private final OutboundDebugCallbacks debug;
-    private final OutboundMessageQueue queue;
+    @VisibleForTesting
+    final OutboundMessageQueue queue;
     /** the number of bytes we permit to queue to the network without acquiring any shared resource permits */
     private final long pendingCapacityInBytes;
     /** the number of messages and bytes queued for flush to the network,

File: src/java/org/apache/cassandra/net/OutboundMessageQueue.java
Patch:
@@ -87,6 +87,7 @@ void add(Message<?> m)
     {
         maybePruneExpired();
         externalQueue.offer(m);
+        // Known race here. See CASSANDRAi-15958
         nextExpirationDeadlineUpdater.accumulateAndGet(this,
                                                        maybeUpdateEarliestExpiresAt(clock.now(), m.expiresAtNanos()),
                                                        Math::min);

File: src/java/org/apache/cassandra/db/commitlog/CompressedSegment.java
Patch:
@@ -45,12 +45,11 @@ public class CompressedSegment extends FileDirectSegment
     {
         super(commitLog, manager);
         this.compressor = commitLog.configuration.getCompressor();
-        manager.getBufferPool().setPreferredReusableBufferType(compressor.preferredBufferType());
     }
 
     ByteBuffer createBuffer(CommitLog commitLog)
     {
-        return manager.getBufferPool().createBuffer(commitLog.configuration.getCompressor().preferredBufferType());
+        return manager.getBufferPool().createBuffer();
     }
 
     @Override

File: src/java/org/apache/cassandra/db/commitlog/EncryptedSegment.java
Patch:
@@ -78,8 +78,6 @@ public EncryptedSegment(CommitLog commitLog, AbstractCommitLogSegmentManager man
             throw new FSWriteError(e, logFile);
         }
         logger.debug("created a new encrypted commit log segment: {}", logFile);
-        // Keep reusable buffers on-heap regardless of compression preference so we avoid copy off/on repeatedly during decryption
-        manager.getBufferPool().setPreferredReusableBufferType(BufferType.ON_HEAP);
     }
 
     protected Map<String, String> additionalHeaderParameters()
@@ -93,7 +91,7 @@ ByteBuffer createBuffer(CommitLog commitLog)
     {
         // Note: we want to keep the compression buffers on-heap as we need those bytes for encryption,
         // and we want to avoid copying from off-heap (compression buffer) to on-heap encryption APIs
-        return manager.getBufferPool().createBuffer(BufferType.ON_HEAP);
+        return manager.getBufferPool().createBuffer();
     }
 
     void write(int startMarker, int nextMarker)

File: src/java/org/apache/cassandra/cache/ChunkCache.java
Patch:
@@ -42,7 +42,7 @@ public class ChunkCache
     public static final long cacheSize = 1024L * 1024L * Math.max(0, DatabaseDescriptor.getFileCacheSizeInMB() - RESERVED_POOL_SPACE_IN_MB);
     public static final boolean roundUp = DatabaseDescriptor.getFileCacheRoundUp();
 
-    private static boolean enabled = cacheSize > 0;
+    private static boolean enabled = DatabaseDescriptor.getFileCacheEnabled() && cacheSize > 0;
     public static final ChunkCache instance = enabled ? new ChunkCache() : null;
 
     private final LoadingCache<Key, Buffer> cache;

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -304,6 +304,8 @@ public class Config
 
     public Integer file_cache_size_in_mb;
 
+    public boolean file_cache_enabled = Boolean.getBoolean("cassandra.file_cache_enabled");
+
     /**
      * Because of the current {@link org.apache.cassandra.utils.memory.BufferPool} slab sizes of 64 kb, we
      * store in the file cache buffers that divide 64 kb, so we need to round the buffer sizes to powers of two.

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -561,7 +561,7 @@ public int compare(InetAddress endpoint1, InetAddress endpoint2)
                 throw new ConfigurationException("saved_caches_directory is missing and -Dcassandra.storagedir is not set", false);
             conf.saved_caches_directory += File.separator + "saved_caches";
         }
-        if (conf.data_file_directories == null)
+        if (conf.data_file_directories == null || conf.data_file_directories.length == 0)
         {
             String defaultDataDir = System.getProperty("cassandra.storagedir", null);
             if (defaultDataDir == null)

File: test/unit/org/apache/cassandra/schema/MockSchema.java
Patch:
@@ -141,6 +141,7 @@ public static SSTableReader sstable(int generation, int size, boolean keepRef, l
             }
             SerializationHeader header = SerializationHeader.make(cfs.metadata(), Collections.emptyList());
             StatsMetadata metadata = (StatsMetadata) new MetadataCollector(cfs.metadata().comparator)
+                                                     .sstableLevel(level)
                                                      .finalizeMetadata(cfs.metadata().partitioner.getClass().getCanonicalName(), 0.01f, UNREPAIRED_SSTABLE, null, false, header)
                                                      .get(MetadataType.STATS);
             SSTableReader reader = SSTableReader.internalOpen(descriptor, components, cfs.metadata,

File: src/java/org/apache/cassandra/tools/nodetool/TableHistograms.java
Patch:
@@ -145,9 +145,9 @@ else if (args.size() == 1)
                 }
 
                 String[] percentiles = new String[]{"50%", "75%", "95%", "98%", "99%", "Min", "Max"};
-                double[] readLatency = probe.metricPercentilesAsArray((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspace, table, "ReadLatency"));
-                double[] writeLatency = probe.metricPercentilesAsArray((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspace, table, "WriteLatency"));
-                double[] sstablesPerRead = probe.metricPercentilesAsArray((CassandraMetricsRegistry.JmxHistogramMBean) probe.getColumnFamilyMetric(keyspace, table, "SSTablesPerReadHistogram"));
+                Double[] readLatency = probe.metricPercentilesAsArray((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspace, table, "ReadLatency"));
+                Double[] writeLatency = probe.metricPercentilesAsArray((CassandraMetricsRegistry.JmxTimerMBean) probe.getColumnFamilyMetric(keyspace, table, "WriteLatency"));
+                Double[] sstablesPerRead = probe.metricPercentilesAsArray((CassandraMetricsRegistry.JmxHistogramMBean) probe.getColumnFamilyMetric(keyspace, table, "SSTablesPerReadHistogram"));
 
                 System.out.println(format("%s/%s histograms", keyspace, table));
                 System.out.println(format("%-10s%18s%18s%18s%18s%18s",

File: src/java/org/apache/cassandra/tools/nodetool/TpStats.java
Patch:
@@ -17,8 +17,6 @@
  */
 package org.apache.cassandra.tools.nodetool;
 
-import javax.management.MBeanServerConnection;
-
 import io.airlift.airline.Command;
 
 import io.airlift.airline.Option;

File: src/java/org/apache/cassandra/tools/nodetool/stats/TpStatsHolder.java
Patch:
@@ -22,7 +22,6 @@
 import java.util.Map;
 
 import org.apache.cassandra.tools.NodeProbe;
-import org.apache.cassandra.tools.nodetool.stats.StatsHolder;
 
 public class TpStatsHolder implements StatsHolder
 {
@@ -39,7 +38,7 @@ public Map<String, Object> convert2Map()
         HashMap<String, Object> result = new HashMap<>();
         HashMap<String, Map<String, Object>> threadPools = new HashMap<>();
         HashMap<String, Object> droppedMessage = new HashMap<>();
-        HashMap<String, double[]> waitLatencies = new HashMap<>();
+        HashMap<String, Double[]> waitLatencies = new HashMap<>();
 
         for (Map.Entry<String, String> tp : probe.getThreadPools().entries())
         {

File: test/unit/org/apache/cassandra/utils/AbstractTypeGenerators.java
Patch:
@@ -72,11 +72,11 @@ public final class AbstractTypeGenerators
               TypeSupport.of(LongType.instance, SourceDSL.longs().all()),
               TypeSupport.of(FloatType.instance, SourceDSL.floats().any()),
               TypeSupport.of(DoubleType.instance, SourceDSL.doubles().any()),
-              TypeSupport.of(BytesType.instance, Generators.bytes(0, 1024)),
+              TypeSupport.of(BytesType.instance, Generators.bytes(1, 1024)),
               TypeSupport.of(UUIDType.instance, Generators.UUID_RANDOM_GEN),
               TypeSupport.of(InetAddressType.instance, Generators.INET_ADDRESS_UNRESOLVED_GEN), // serialization strips the hostname, only keeps the address
-              TypeSupport.of(AsciiType.instance, SourceDSL.strings().ascii().ofLengthBetween(0, 1024)),
-              TypeSupport.of(UTF8Type.instance, Generators.utf8(0, 1024)),
+              TypeSupport.of(AsciiType.instance, SourceDSL.strings().ascii().ofLengthBetween(1, 1024)),
+              TypeSupport.of(UTF8Type.instance, Generators.utf8(1, 1024)),
               TypeSupport.of(TimestampType.instance, Generators.DATE_GEN),
               // null is desired here as #decompose will call org.apache.cassandra.serializers.EmptySerializer.serialize which ignores the input and returns empty bytes
               TypeSupport.of(EmptyType.instance, rnd -> null)

File: src/java/org/apache/cassandra/repair/consistent/admin/PendingStats.java
Patch:
@@ -45,6 +45,7 @@ public class PendingStats
                                                SimpleType.STRING,
                                                PendingStat.COMPOSITE_TYPE,
                                                PendingStat.COMPOSITE_TYPE,
+                                               PendingStat.COMPOSITE_TYPE,
                                                PendingStat.COMPOSITE_TYPE};
             COMPOSITE_TYPE = new CompositeType(RepairStats.Section.class.getName(), "PendingStats", COMPOSITE_NAMES, COMPOSITE_NAMES, COMPOSITE_TYPES);
         }

File: src/java/org/apache/cassandra/cache/ChunkCache.java
Patch:
@@ -166,7 +166,7 @@ public void close()
         cache.invalidateAll();
     }
 
-    public RebuffererFactory wrap(ChunkReader file)
+    private RebuffererFactory wrap(ChunkReader file)
     {
         return new CachingRebufferer(file);
     }

File: src/java/org/apache/cassandra/cache/InstrumentingCache.java
Patch:
@@ -96,6 +96,9 @@ public long weightedSize()
     public void clear()
     {
         map.clear();
+
+        // this does not clear metered metrics which are defined statically. for testing purposes, these can be
+        // cleared by CacheMetrics.reset()
         metrics = new CacheMetrics(type, map);
     }
 

File: src/java/org/apache/cassandra/io/util/FileHandle.java
Patch:
@@ -419,7 +419,7 @@ public void close()
         private RebuffererFactory maybeCached(ChunkReader reader)
         {
             if (chunkCache != null && chunkCache.capacity() > 0)
-                return chunkCache.wrap(reader);
+                return chunkCache.maybeWrap(reader);
             return reader;
         }
 

File: src/java/org/apache/cassandra/net/Verb.java
Patch:
@@ -329,7 +329,7 @@ Supplier<? extends IVerbHandler<?>> unsafeSetHandler(Supplier<? extends IVerbHan
     }
 
     @VisibleForTesting
-    Supplier<? extends IVersionedAsymmetricSerializer<?, ?>> unsafeSetSerializer(Supplier<? extends IVersionedAsymmetricSerializer<?, ?>> serializer) throws NoSuchFieldException, IllegalAccessException
+    public Supplier<? extends IVersionedAsymmetricSerializer<?, ?>> unsafeSetSerializer(Supplier<? extends IVersionedAsymmetricSerializer<?, ?>> serializer) throws NoSuchFieldException, IllegalAccessException
     {
         Supplier<? extends IVersionedAsymmetricSerializer<?, ?>> original = this.serializer;
         Field field = Verb.class.getDeclaredField("serializer");

File: test/unit/org/apache/cassandra/CassandraXMLJUnitResultFormatter.java
Patch:
@@ -143,8 +143,8 @@ public void startTestSuite(final JUnitTest suite) {
         doc = getDocumentBuilder().newDocument();
         rootElement = doc.createElement(TESTSUITE);
         String n = suite.getName();
-//        if (n != null && !tag.isEmpty())
-//            n = n + "-" + tag;
+        if (n != null && !tag.isEmpty())
+            n = n + "-" + tag;
         rootElement.setAttribute(ATTR_NAME, n == null ? UNKNOWN : n);
 
         //add the timestamp

File: test/unit/org/apache/cassandra/config/DatabaseDescriptorRefTest.java
Patch:
@@ -77,6 +77,7 @@ public class DatabaseDescriptorRefTest
     "org.apache.cassandra.config.EncryptionOptions$ClientEncryptionOptions",
     "org.apache.cassandra.config.EncryptionOptions$ServerEncryptionOptions",
     "org.apache.cassandra.config.EncryptionOptions$ServerEncryptionOptions$InternodeEncryption",
+    "org.apache.cassandra.config.ReplicaFilteringProtectionOptions",
     "org.apache.cassandra.config.YamlConfigurationLoader",
     "org.apache.cassandra.config.YamlConfigurationLoader$PropertiesChecker",
     "org.apache.cassandra.config.YamlConfigurationLoader$PropertiesChecker$1",

File: test/unit/org/apache/cassandra/cql3/EmptyValuesTest.java
Patch:
@@ -46,7 +46,7 @@
 import org.apache.cassandra.db.marshal.UTF8Type;
 import org.apache.cassandra.db.marshal.UUIDType;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
-import org.apache.cassandra.transport.Server;
+import org.apache.cassandra.transport.ProtocolVersion;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
 import static org.junit.Assume.assumeTrue;
@@ -60,12 +60,12 @@ private void verify(String emptyValue) throws Throwable
         Assert.assertTrue(row.getColumns().stream().anyMatch(c -> c.name.toString().equals("v")));
         Assert.assertEquals(0, row.getBytes("v").remaining());
 
-        ResultSet resultNet = executeNet(Server.CURRENT_VERSION, "SELECT * FROM %s");
+        ResultSet resultNet = executeNet(ProtocolVersion.CURRENT, "SELECT * FROM %s");
         Row rowNet = resultNet.one();
         Assert.assertTrue(rowNet.getColumnDefinitions().contains("v"));
         Assert.assertEquals(0, rowNet.getBytesUnsafe("v").remaining());
 
-        ResultSet jsonNet = executeNet(Server.CURRENT_VERSION, "SELECT JSON * FROM %s");
+        ResultSet jsonNet = executeNet(ProtocolVersion.CURRENT, "SELECT JSON * FROM %s");
         Row jsonRowNet = jsonNet.one();
         Assert.assertTrue(jsonRowNet.getString("[json]"), jsonRowNet.getString("[json]").matches(".*\"v\"\\s*:\\s*\"" + Pattern.quote(emptyValue) + "\".*"));
 

File: test/unit/org/apache/cassandra/db/marshal/UUIDTypeTest.java
Patch:
@@ -31,7 +31,7 @@
 import org.junit.Test;
 
 import junit.framework.Assert;
-import org.apache.cassandra.transport.Server;
+import org.apache.cassandra.transport.ProtocolVersion;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.UUIDGen;
 import org.slf4j.Logger;
@@ -47,7 +47,7 @@ public class UUIDTypeTest
     @Test //CASSANDRA-15896
     public void testToJsonEmptyValue()
     {
-        String res = uuidType.toJSONString(uuidType.fromJSONObject("").bindAndGet(null), Server.CURRENT_VERSION);
+        String res = uuidType.toJSONString(uuidType.fromJSONObject("").bindAndGet(null), ProtocolVersion.CURRENT);
         assertEquals("\"\"", res);
     }
 

File: src/java/org/apache/cassandra/db/marshal/AbstractType.java
Patch:
@@ -26,6 +26,7 @@
 import java.util.Comparator;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -150,7 +151,7 @@ public String getString(ByteBuffer bytes)
      */
     public String toJSONString(ByteBuffer buffer, int protocolVersion)
     {
-        return '"' + getSerializer().deserialize(buffer).toString() + '"';
+        return '"' + Objects.toString(getSerializer().deserialize(buffer), "") + '"';
     }
 
     /* validate that the byte array is a valid sequence for the type we are supposed to be comparing */

File: src/java/org/apache/cassandra/db/marshal/DoubleType.java
Patch:
@@ -86,6 +86,8 @@ public Term fromJSONObject(Object parsed) throws MarshalException
     public String toJSONString(ByteBuffer buffer, int protocolVersion)
     {
         Double value = getSerializer().deserialize(buffer);
+        if (value == null)
+            return "\"\"";
         // JSON does not support NaN, Infinity and -Infinity values. Most of the parser convert them into null.
         if (value.isNaN() || value.isInfinite())
             return "null";

File: src/java/org/apache/cassandra/db/marshal/FloatType.java
Patch:
@@ -85,6 +85,8 @@ public Term fromJSONObject(Object parsed) throws MarshalException
     public String toJSONString(ByteBuffer buffer, int protocolVersion)
     {
         Float value = getSerializer().deserialize(buffer);
+        if (value == null)
+            return "\"\"";
         // JSON does not support NaN, Infinity and -Infinity values. Most of the parser convert them into null.
         if (value.isNaN() || value.isInfinite())
             return "null";

File: src/java/org/apache/cassandra/db/marshal/Int32Type.java
Patch:
@@ -18,6 +18,7 @@
 package org.apache.cassandra.db.marshal;
 
 import java.nio.ByteBuffer;
+import java.util.Objects;
 
 import org.apache.cassandra.cql3.CQL3Type;
 import org.apache.cassandra.cql3.Constants;
@@ -97,7 +98,7 @@ public Term fromJSONObject(Object parsed) throws MarshalException
     @Override
     public String toJSONString(ByteBuffer buffer, int protocolVersion)
     {
-        return getSerializer().deserialize(buffer).toString();
+        return Objects.toString(getSerializer().deserialize(buffer), "\"\"");
     }
 
     public CQL3Type asCQL3Type()

File: src/java/org/apache/cassandra/db/marshal/IntegerType.java
Patch:
@@ -19,6 +19,7 @@
 
 import java.math.BigInteger;
 import java.nio.ByteBuffer;
+import java.util.Objects;
 
 import org.apache.cassandra.cql3.CQL3Type;
 import org.apache.cassandra.cql3.Constants;
@@ -165,7 +166,7 @@ public Term fromJSONObject(Object parsed) throws MarshalException
     @Override
     public String toJSONString(ByteBuffer buffer, int protocolVersion)
     {
-        return getSerializer().deserialize(buffer).toString();
+        return Objects.toString(getSerializer().deserialize(buffer), "\"\"");
     }
 
     @Override

File: src/java/org/apache/cassandra/db/marshal/LongType.java
Patch:
@@ -18,6 +18,7 @@
 package org.apache.cassandra.db.marshal;
 
 import java.nio.ByteBuffer;
+import java.util.Objects;
 
 import org.apache.cassandra.cql3.CQL3Type;
 import org.apache.cassandra.cql3.Constants;
@@ -99,7 +100,7 @@ public Term fromJSONObject(Object parsed) throws MarshalException
     @Override
     public String toJSONString(ByteBuffer buffer, int protocolVersion)
     {
-        return getSerializer().deserialize(buffer).toString();
+        return Objects.toString(getSerializer().deserialize(buffer), "\"\"");
     }
 
     @Override

File: src/java/org/apache/cassandra/db/marshal/ShortType.java
Patch:
@@ -18,6 +18,7 @@
 package org.apache.cassandra.db.marshal;
 
 import java.nio.ByteBuffer;
+import java.util.Objects;
 
 import org.apache.cassandra.cql3.CQL3Type;
 import org.apache.cassandra.cql3.Constants;
@@ -77,7 +78,7 @@ public Term fromJSONObject(Object parsed) throws MarshalException
     @Override
     public String toJSONString(ByteBuffer buffer, int protocolVersion)
     {
-        return getSerializer().deserialize(buffer).toString();
+        return Objects.toString(getSerializer().deserialize(buffer), "\"\"");
     }
 
     @Override

File: test/unit/org/apache/cassandra/cql3/validation/entities/FrozenCollectionsTest.java
Patch:
@@ -557,7 +557,7 @@ public void testSecondaryIndex() throws Throwable
         assertInvalidIndexCreationWithMessage("CREATE INDEX ON %s (full(a))", "Cannot create secondary index on the only partition key column");
         assertInvalidIndexCreationWithMessage("CREATE INDEX ON %s (keys(a))", "Cannot create secondary index on the only partition key column");
         assertInvalidIndexCreationWithMessage("CREATE INDEX ON %s (keys(b))", "Cannot create keys() index on frozen column b. " +
-                                                                              "Frozen collections only support indexes on the entire data structure");
+                                                                              "Frozen collections are immutable and must be fully indexed");
 
         createTable("CREATE TABLE %s (a int, b frozen<list<int>>, c frozen<set<int>>, d frozen<map<int, text>>, PRIMARY KEY (a, b))");
 

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -2335,9 +2335,9 @@ public void snapshotWithoutFlush(String snapshotName)
      */
     public void snapshotWithoutFlush(String snapshotName, Predicate<SSTableReader> predicate, boolean ephemeral)
     {
+        final JSONArray filesJSONArr = new JSONArray();
         for (ColumnFamilyStore cfs : concatWithIndexes())
         {
-            final JSONArray filesJSONArr = new JSONArray();
             try (RefViewFragment currentView = cfs.selectAndReference(CANONICAL_SSTABLES))
             {
                 for (SSTableReader ssTable : currentView.sstables)
@@ -2352,10 +2352,9 @@ public void snapshotWithoutFlush(String snapshotName, Predicate<SSTableReader> p
                     if (logger.isDebugEnabled())
                         logger.debug("Snapshot for {} keyspace data file {} created in {}", keyspace, ssTable.getFilename(), snapshotDirectory);
                 }
-
-                writeSnapshotManifest(filesJSONArr, snapshotName);
             }
         }
+        writeSnapshotManifest(filesJSONArr, snapshotName);
         if (ephemeral)
             createEphemeralSnapshotMarkerFile(snapshotName);
     }

File: src/java/org/apache/cassandra/service/StartupChecks.java
Patch:
@@ -148,7 +148,7 @@ else if ("-".equals(jemalloc))
         {
             LZ4Factory.nativeInstance(); // make sure native loads
         }
-        catch (AssertionError e)
+        catch (AssertionError | LinkageError e)
         {
             logger.warn("lz4-java was unable to load native libraries; this will lower the performance of lz4 (network/sstables/etc.): {}", Throwables.getRootCause(e).getMessage());
         }

File: src/java/org/apache/cassandra/service/StartupChecks.java
Patch:
@@ -150,7 +150,7 @@ else if ("-".equals(jemalloc))
         }
         catch (AssertionError e)
         {
-            logger.warn("lz4-java was unable to load native librarires; this will lower the performance of lz4 (network/sstables/etc.): {}", Throwables.getRootCause(e).getMessage());
+            logger.warn("lz4-java was unable to load native libraries; this will lower the performance of lz4 (network/sstables/etc.): {}", Throwables.getRootCause(e).getMessage());
         }
     };
 

File: src/java/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -537,7 +537,9 @@ public void onClose()
                 boolean warnTombstones = tombstones > warningThreshold && respectTombstoneThresholds;
                 if (warnTombstones)
                 {
-                    String msg = String.format("Read %d live rows and %d tombstone cells for query %1.512s (see tombstone_warn_threshold)", liveRows, tombstones, ReadCommand.this.toCQLString());
+                    String msg = String.format(
+                            "Read %d live rows and %d tombstone cells for query %1.512s; token %s (see tombstone_warn_threshold)",
+                            liveRows, tombstones, ReadCommand.this.toCQLString(), currentKey.getToken());
                     ClientWarn.instance.warn(msg);
                     logger.warn(msg);
                 }

File: src/java/org/apache/cassandra/db/filter/TombstoneOverwhelmingException.java
Patch:
@@ -28,8 +28,8 @@ public class TombstoneOverwhelmingException extends RuntimeException
 {
     public TombstoneOverwhelmingException(int numTombstones, String query, CFMetaData metadata, DecoratedKey lastPartitionKey, ClusteringPrefix lastClustering)
     {
-        super(String.format("Scanned over %d tombstones during query '%s' (last scanned row partion key was (%s)); query aborted",
-                            numTombstones, query, makePKString(metadata, lastPartitionKey.getKey(), lastClustering)));
+        super(String.format("Scanned over %d tombstones during query '%s' (last scanned row token was %s and partion key was (%s)); query aborted",
+                            numTombstones, query, lastPartitionKey.getToken(), makePKString(metadata, lastPartitionKey.getKey(), lastClustering)));
     }
 
     private static String makePKString(CFMetaData metadata, ByteBuffer partitionKey, ClusteringPrefix clustering)

File: test/unit/org/apache/cassandra/auth/PasswordAuthenticatorTest.java
Patch:
@@ -26,6 +26,7 @@
 import org.junit.Test;
 
 import com.datastax.driver.core.Authenticator;
+import com.datastax.driver.core.EndPoint;
 import com.datastax.driver.core.PlainTextAuthProvider;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.cql3.CQLTester;
@@ -121,7 +122,7 @@ private void testDecodeIllegalUserAndPwd(String username, String password)
     {
         SaslNegotiator negotiator = authenticator.newSaslNegotiator(null);
         Authenticator clientAuthenticator = (new PlainTextAuthProvider(username, password))
-                                            .newAuthenticator(null, null);
+                                            .newAuthenticator((EndPoint) null, null);
 
         negotiator.evaluateResponse(clientAuthenticator.initialResponse());
         negotiator.getAuthenticatedUser();

File: src/java/org/apache/cassandra/db/virtual/SettingsTable.java
Patch:
@@ -160,7 +160,7 @@ private void addEncryptionOptions(SimpleDataSet result, Field f)
         Preconditions.checkArgument(EncryptionOptions.class.isAssignableFrom(f.getType()));
 
         EncryptionOptions value = (EncryptionOptions) getValue(f);
-        result.row(f.getName() + "_enabled").column(VALUE, Boolean.toString(value.enabled));
+        result.row(f.getName() + "_enabled").column(VALUE, Boolean.toString(value.isEnabled()));
         result.row(f.getName() + "_algorithm").column(VALUE, value.algorithm);
         result.row(f.getName() + "_protocol").column(VALUE, value.protocol);
         result.row(f.getName() + "_cipher_suites").column(VALUE, value.cipher_suites.toString());

File: src/java/org/apache/cassandra/net/InboundSockets.java
Patch:
@@ -190,7 +190,7 @@ private static void addBindings(InboundConnectionSettings template, ImmutableLis
         InboundConnectionSettings       settings = template.withDefaults();
         InboundConnectionSettings legacySettings = template.withLegacyDefaults();
 
-        if (settings.encryption.enable_legacy_ssl_storage_port && settings.encryption.enabled)
+        if (settings.encryption.enable_legacy_ssl_storage_port)
         {
             out.add(new InboundSocket(legacySettings));
 

File: src/java/org/apache/cassandra/service/NativeTransportService.java
Patch:
@@ -79,7 +79,7 @@ synchronized void initialize()
                                                                 .withEventLoopGroup(workerGroup)
                                                                 .withHost(nativeAddr);
 
-        if (!DatabaseDescriptor.getNativeProtocolEncryptionOptions().enabled)
+        if (!DatabaseDescriptor.getNativeProtocolEncryptionOptions().isEnabled())
         {
             servers = Collections.singleton(builder.withSSL(false).withPort(nativePort).build());
         }

File: src/java/org/apache/cassandra/tools/BulkLoader.java
Patch:
@@ -246,7 +246,7 @@ private void printSummary(int connectionsPerHost)
     private static SSLOptions buildSSLOptions(EncryptionOptions clientEncryptionOptions)
     {
 
-        if (!clientEncryptionOptions.enabled)
+        if (!clientEncryptionOptions.isEnabled())
         {
             return null;
         }

File: src/java/org/apache/cassandra/tools/LoaderOptions.java
Patch:
@@ -464,7 +464,7 @@ public Builder parseArgs(String cmdArgs[])
                 }
                 else
                 {
-                    if (config.native_transport_port_ssl != null && (config.client_encryption_options.enabled || clientEncOptions.enabled))
+                    if (config.native_transport_port_ssl != null && (config.client_encryption_options.isEnabled() || clientEncOptions.isEnabled()))
                         nativePort = config.native_transport_port_ssl;
                     else
                         nativePort = config.native_transport_port;

File: src/java/org/apache/cassandra/transport/SimpleClient.java
Patch:
@@ -168,7 +168,7 @@ protected void establishConnection() throws IOException
                     .option(ChannelOption.TCP_NODELAY, true);
 
         // Configure the pipeline factory.
-        if(encryptionOptions.enabled)
+        if(encryptionOptions.isEnabled())
         {
             bootstrap.handler(new SecureInitializer());
         }

File: test/unit/org/apache/cassandra/net/ConnectionTest.java
Patch:
@@ -179,7 +179,6 @@ Settings override(Settings settings)
 
     static final EncryptionOptions.ServerEncryptionOptions encryptionOptions =
             new EncryptionOptions.ServerEncryptionOptions()
-            .withEnabled(true)
             .withLegacySslStoragePort(true)
             .withOptional(true)
             .withInternodeEncryption(EncryptionOptions.ServerEncryptionOptions.InternodeEncryption.all)

File: tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java
Patch:
@@ -138,7 +138,7 @@ public void connect(ProtocolOptions.Compression compression) throws Exception
         if (loadBalancingPolicy != null)
             clusterBuilder.withLoadBalancingPolicy(loadBalancingPolicy);
         clusterBuilder.withCompression(compression);
-        if (encryptionOptions.enabled)
+        if (encryptionOptions.isEnabled())
         {
             SSLContext sslContext;
             sslContext = SSLFactory.createSSLContext(encryptionOptions, true);

File: src/java/org/apache/cassandra/db/DisallowedDirectoriesMBean.java
Patch:
@@ -20,7 +20,8 @@
 import java.io.File;
 import java.util.Set;
 
-public interface BlacklistedDirectoriesMBean {
+public interface DisallowedDirectoriesMBean
+{
 
     public Set<File> getUnreadableDirectories();
     

File: src/java/org/apache/cassandra/db/compaction/AbstractCompactionStrategy.java
Patch:
@@ -243,10 +243,10 @@ public List<SSTableReader> filterSSTablesForReads(List<SSTableReader> sstables)
     }
 
     /**
-     * Filters SSTables that are to be blacklisted from the given collection
+     * Filters SSTables that are to be excluded from the given collection
      *
-     * @param originalCandidates The collection to check for blacklisted SSTables
-     * @return list of the SSTables with blacklisted ones filtered out
+     * @param originalCandidates The collection to check for excluded SSTables
+     * @return list of the SSTables with excluded ones filtered out
      */
     public static Iterable<SSTableReader> filterSuspectSSTables(Iterable<SSTableReader> originalCandidates)
     {

File: src/java/org/apache/cassandra/db/compaction/LeveledManifest.java
Patch:
@@ -546,7 +546,7 @@ public boolean apply(SSTableReader candidate)
 
     /**
      * @return highest-priority sstables to compact for the given level.
-     * If no compactions are possible (because of concurrent compactions or because some sstables are blacklisted
+     * If no compactions are possible (because of concurrent compactions or because some sstables are excluded
      * for prior failure), will return an empty list.  Never returns null.
      */
     private Collection<SSTableReader> getCandidatesFor(int level)

File: src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java
Patch:
@@ -1687,7 +1687,7 @@ public boolean isMarkedCompacted()
     public void markSuspect()
     {
         if (logger.isTraceEnabled())
-            logger.trace("Marking {} as a suspect for blacklisting.", getFilename());
+            logger.trace("Marking {} as a suspect to be excluded from reads.", getFilename());
 
         isSuspect.getAndSet(true);
     }

File: src/java/org/apache/cassandra/service/DefaultFSErrorHandler.java
Patch:
@@ -24,7 +24,7 @@
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.config.DatabaseDescriptor;
-import org.apache.cassandra.db.BlacklistedDirectories;
+import org.apache.cassandra.db.DisallowedDirectories;
 import org.apache.cassandra.db.Keyspace;
 import org.apache.cassandra.io.FSError;
 import org.apache.cassandra.io.FSErrorHandler;
@@ -66,10 +66,10 @@ public void handleFSError(FSError e)
                 break;
             case best_effort:
                 // for both read and write errors mark the path as unwritable.
-                BlacklistedDirectories.maybeMarkUnwritable(e.path);
+                DisallowedDirectories.maybeMarkUnwritable(e.path);
                 if (e instanceof FSReadError)
                 {
-                    File directory = BlacklistedDirectories.maybeMarkUnreadable(e.path);
+                    File directory = DisallowedDirectories.maybeMarkUnreadable(e.path);
                     if (directory != null)
                         Keyspace.removeUnreadableSSTables(directory);
                 }

File: test/unit/org/apache/cassandra/cql3/OutOfSpaceBase.java
Patch:
@@ -26,7 +26,7 @@
 import org.junit.After;
 import org.junit.Assert;
 
-import org.apache.cassandra.db.BlacklistedDirectories;
+import org.apache.cassandra.db.DisallowedDirectories;
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.Directories.DataDirectory;
 import org.apache.cassandra.db.commitlog.CommitLog;
@@ -56,7 +56,7 @@ public void markDirectoriesUnwriteable()
             for ( ; ; )
             {
                 DataDirectory dir = cfs.directories.getWriteableLocation(1);
-                BlacklistedDirectories.maybeMarkUnwritable(cfs.directories.getLocationForDisk(dir));
+                DisallowedDirectories.maybeMarkUnwritable(cfs.directories.getLocationForDisk(dir));
             }
         }
         catch (IOError e)

File: test/unit/org/apache/cassandra/db/DirectoriesTest.java
Patch:
@@ -282,7 +282,7 @@ public void testDiskFailurePolicy_best_effort()
             for (DataDirectory dd : Directories.dataDirectories)
             {
                 File file = new File(dd.location, new File(KS, "bad").getPath());
-                assertTrue(BlacklistedDirectories.isUnwritable(file));
+                assertTrue(DisallowedDirectories.isUnwritable(file));
             }
         } 
         finally 

File: src/java/org/apache/cassandra/transport/Event.java
Patch:
@@ -90,9 +90,9 @@ public static abstract class NodeEvent extends Event
     {
         public final InetSocketAddress node;
 
-        public InetAddress nodeAddress()
+        public InetAddressAndPort nodeAddressAndPort()
         {
-            return node.getAddress();
+            return InetAddressAndPort.getByAddressOverrideDefaults(node.getAddress(), node.getPort());
         }
 
         private NodeEvent(Type type, InetSocketAddress node)

File: src/java/org/apache/cassandra/transport/Server.java
Patch:
@@ -613,15 +613,15 @@ private InetAddressAndPort getNativeAddress(InetAddressAndPort endpoint)
         private void send(InetAddressAndPort endpoint, Event.NodeEvent event)
         {
             if (logger.isTraceEnabled())
-                logger.trace("Sending event for endpoint {}, rpc address {}", endpoint, event.nodeAddress());
+                logger.trace("Sending event for endpoint {}, rpc address {}", endpoint, event.nodeAddressAndPort());
 
             // If the endpoint is not the local node, extract the node address
             // and if it is the same as our own RPC broadcast address (which defaults to the rcp address)
             // then don't send the notification. This covers the case of rpc_address set to "localhost",
             // which is not useful to any driver and in fact may cauase serious problems to some drivers,
             // see CASSANDRA-10052
             if (!endpoint.equals(FBUtilities.getBroadcastAddressAndPort()) &&
-                event.nodeAddress().equals(FBUtilities.getJustBroadcastNativeAddress()))
+                event.nodeAddressAndPort().equals(FBUtilities.getBroadcastNativeAddressAndPort()))
                 return;
 
             send(event);

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -216,7 +216,6 @@ public class Config
     public volatile int compaction_large_partition_warning_threshold_mb = 100;
     public int min_free_space_per_drive_in_mb = 50;
 
-    public volatile int concurrent_validations = Integer.MAX_VALUE;
     public volatile int concurrent_materialized_view_builders = 1;
 
     /**
@@ -416,6 +415,7 @@ public class Config
     public volatile boolean back_pressure_enabled = false;
     public volatile ParameterizedClass back_pressure_strategy;
 
+    public volatile int concurrent_validations;
     public RepairCommandPoolFullStrategy repair_command_pool_full_strategy = RepairCommandPoolFullStrategy.queue;
     public int repair_command_pool_size = concurrent_validations;
 

File: test/distributed/org/apache/cassandra/distributed/impl/Instance.java
Patch:
@@ -553,7 +553,7 @@ public Future<Void> shutdown(boolean graceful)
                                 () -> DiagnosticSnapshotService.instance.shutdownAndWait(1L, MINUTES),
                                 () -> ScheduledExecutors.shutdownAndWait(1L, MINUTES),
                                 () -> SSTableReader.shutdownBlocking(1L, MINUTES),
-                                () -> shutdownAndWait(Collections.singletonList(ActiveRepairService.repairCommandExecutor)),
+                                () -> shutdownAndWait(Collections.singletonList(ActiveRepairService.repairCommandExecutor())),
                                 () -> ScheduledExecutors.shutdownAndWait(1L, MINUTES)
             );
 

File: test/distributed/org/apache/cassandra/distributed/test/RepairCoordinatorTimeout.java
Patch:
@@ -42,19 +42,19 @@ public void prepareRPCTimeout()
             NodeToolResult result = repair(1, KEYSPACE, table);
             result.asserts()
                   .failure()
-                  .errorContains("Got negative replies from endpoints [127.0.0.2:7012]");
+                  .errorContains("Did not get replies from all endpoints.");
             if (withNotifications)
             {
                 result.asserts()
                       .notificationContains(NodeToolResult.ProgressEventType.START, "Starting repair command")
                       .notificationContains(NodeToolResult.ProgressEventType.START, "repairing keyspace " + KEYSPACE + " with repair options")
-                      .notificationContains(NodeToolResult.ProgressEventType.ERROR, "Got negative replies from endpoints [127.0.0.2:7012]")
+                      .notificationContains(NodeToolResult.ProgressEventType.ERROR, "Did not get replies from all endpoints.")
                       .notificationContains(NodeToolResult.ProgressEventType.COMPLETE, "finished with error");
             }
 
             if (repairType != RepairType.PREVIEW)
             {
-                assertParentRepairFailedWithMessageContains(CLUSTER, KEYSPACE, table, "Got negative replies from endpoints [127.0.0.2:7012]");
+                assertParentRepairFailedWithMessageContains(CLUSTER, KEYSPACE, table, "Did not get replies from all endpoints.");
             }
             else
             {

File: test/unit/org/apache/cassandra/io/sstable/CQLSSTableWriterTest.java
Patch:
@@ -37,6 +37,7 @@
 import org.apache.cassandra.cql3.functions.UDHelper;
 import org.apache.cassandra.cql3.functions.types.*;
 import org.apache.cassandra.db.Keyspace;
+import org.apache.cassandra.db.commitlog.CommitLog;
 import org.apache.cassandra.dht.*;
 import org.apache.cassandra.exceptions.*;
 import org.apache.cassandra.schema.Schema;
@@ -59,6 +60,7 @@ public class CQLSSTableWriterTest
     @BeforeClass
     public static void setup() throws Exception
     {
+        CommitLog.instance.start();
         SchemaLoader.cleanupAndLeaveDirs();
         Keyspace.setInitialized();
         StorageService.instance.initServer();

File: test/unit/org/apache/cassandra/schema/SchemaTest.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.Keyspace;
+import org.apache.cassandra.db.commitlog.CommitLog;
 import org.apache.cassandra.gms.Gossiper;
 
 import static org.junit.Assert.assertNotNull;
@@ -43,6 +44,7 @@ public static void setupDatabaseDescriptor()
     @Test
     public void testTransKsMigration() throws IOException
     {
+        CommitLog.instance.start();
         SchemaLoader.cleanupAndLeaveDirs();
         Schema.instance.loadFromDisk();
         assertEquals(0, Schema.instance.getNonSystemKeyspaces().size());

File: src/java/org/apache/cassandra/db/compaction/CompactionIterator.java
Patch:
@@ -199,11 +199,12 @@ public void onMergedPartitionLevelDeletion(DeletionTime mergedDeletion, Deletion
                     {
                     }
 
-                    public void onMergedRows(Row merged, Row[] versions)
+                    public Row onMergedRows(Row merged, Row[] versions)
                     {
                         indexTransaction.start();
                         indexTransaction.onRowMerge(merged, versions);
                         indexTransaction.commit();
+                        return merged;
                     }
 
                     public void onMergedRangeTombstoneMarkers(RangeTombstoneMarker mergedMarker, RangeTombstoneMarker[] versions)

File: test/unit/org/apache/cassandra/db/ScrubTest.java
Patch:
@@ -42,6 +42,7 @@
 import org.apache.cassandra.db.compaction.OperationType;
 import org.apache.cassandra.db.compaction.Scrubber;
 import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
+import org.apache.cassandra.db.marshal.Int32Type;
 import org.apache.cassandra.db.marshal.LongType;
 import org.apache.cassandra.db.marshal.UUIDType;
 import org.apache.cassandra.db.partitions.Partition;
@@ -509,7 +510,7 @@ public void testScrubColumnValidation() throws InterruptedException, RequestExec
         QueryProcessor.process("CREATE TABLE \"Keyspace1\".test_scrub_validation (a text primary key, b int)", ConsistencyLevel.ONE);
         ColumnFamilyStore cfs2 = keyspace.getColumnFamilyStore("test_scrub_validation");
 
-        new Mutation(UpdateBuilder.create(cfs2.metadata, "key").newRow().add("b", LongType.instance.decompose(1L)).build()).apply();
+        new Mutation(UpdateBuilder.create(cfs2.metadata, "key").newRow().add("b", Int32Type.instance.decompose(1)).build()).apply();
         cfs2.forceBlockingFlush();
 
         CompactionManager.instance.performScrub(cfs2, false, false, 2);

File: test/unit/org/apache/cassandra/db/marshal/EmptyTypeTest.java
Patch:
@@ -88,7 +88,7 @@ public void composeNonEmptyInput()
             Assert.fail("compose is expected to reject non-empty values, but did not");
         }
         catch (MarshalException e) {
-            Assert.assertEquals("EmptyType only accept empty values", e.getMessage());
+            Assert.assertTrue(e.getMessage().startsWith("EmptyType only accept empty values"));
         }
     }
 }

File: test/unit/org/apache/cassandra/db/streaming/CassandraStreamManagerTest.java
Patch:
@@ -161,6 +161,9 @@ private Set<SSTableReader> selectReaders(UUID pendingRepair)
     @Test
     public void incrementalSSTableSelection() throws Exception
     {
+        // CASSANDRA-15825 Make sure a compaction won't be triggered under our feet removing the sstables mid-flight
+        cfs.disableAutoCompaction();
+
         // make 3 tables, 1 unrepaired, 2 pending repair with different repair ids, and 1 repaired
         SSTableReader sstable1 = createSSTable(() -> QueryProcessor.executeInternal(String.format("INSERT INTO %s.%s (k, v) VALUES (1, 1)", keyspace, table)));
         SSTableReader sstable2 = createSSTable(() -> QueryProcessor.executeInternal(String.format("INSERT INTO %s.%s (k, v) VALUES (2, 2)", keyspace, table)));

File: src/java/org/apache/cassandra/serializers/EmptySerializer.java
Patch:
@@ -28,6 +28,7 @@ public class EmptySerializer implements TypeSerializer<Void>
 
     public Void deserialize(ByteBuffer bytes)
     {
+        validate(bytes);
         return null;
     }
 

File: src/java/org/apache/cassandra/net/InboundConnectionInitiator.java
Patch:
@@ -239,8 +239,8 @@ private void logSsl(ChannelHandlerContext ctx)
             if (sslHandler != null)
             {
                 SSLSession session = sslHandler.engine().getSession();
-                logger.info("connection from peer {}, protocol = {}, cipher suite = {}",
-                            ctx.channel().remoteAddress(), session.getProtocol(), session.getCipherSuite());
+                logger.info("connection from peer {} to {}, protocol = {}, cipher suite = {}",
+                            ctx.channel().remoteAddress(), ctx.channel().localAddress(), session.getProtocol(), session.getCipherSuite());
             }
         }
 

File: src/java/org/apache/cassandra/db/filter/ClusteringIndexNamesFilter.java
Patch:
@@ -191,15 +191,15 @@ public String toString(CFMetaData metadata)
 
     public String toCQLString(CFMetaData metadata)
     {
-        if (metadata.clusteringColumns().isEmpty() || clusterings.size() <= 1)
+        if (metadata.clusteringColumns().isEmpty() || clusterings.isEmpty())
             return "";
 
         StringBuilder sb = new StringBuilder();
         sb.append('(').append(ColumnDefinition.toCQLString(metadata.clusteringColumns())).append(')');
         sb.append(clusterings.size() == 1 ? " = " : " IN (");
         int i = 0;
         for (Clustering clustering : clusterings)
-            sb.append(i++ == 0 ? "" : ", ").append("(").append(clustering.toCQLString(metadata)).append(")");
+            sb.append(i++ == 0 ? "" : ", ").append('(').append(clustering.toCQLString(metadata)).append(')');
         sb.append(clusterings.size() == 1 ? "" : ")");
 
         appendOrderByToCQLString(metadata, sb);

File: test/unit/org/apache/cassandra/cql3/validation/entities/JsonTest.java
Patch:
@@ -1364,7 +1364,7 @@ public void run()
             future.get(30, TimeUnit.SECONDS);
 
         executor.shutdown();
-        Assert.assertTrue(executor.awaitTermination(30, TimeUnit.SECONDS));
+        Assert.assertTrue(executor.awaitTermination(1, TimeUnit.MINUTES));
     }
 
     @Test

File: test/unit/org/apache/cassandra/db/commitlog/CommitLogUpgradeTestMaker.java
Patch:
@@ -33,6 +33,7 @@
 import java.util.concurrent.atomic.AtomicLong;
 
 import com.google.common.util.concurrent.RateLimiter;
+import org.junit.Assert;
 
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
@@ -110,7 +111,7 @@ public void makeLog() throws IOException, InterruptedException
         Thread.sleep(runTimeMs);
         stop = true;
         scheduled.shutdown();
-        scheduled.awaitTermination(2, TimeUnit.SECONDS);
+        Assert.assertTrue(scheduled.awaitTermination(1, TimeUnit.MINUTES));
 
         int hash = 0;
         int cells = 0;

File: test/unit/org/apache/cassandra/db/compaction/CompactionExecutorTest.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.concurrent.TimeUnit;
 
 import org.junit.After;
+import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 import org.apache.cassandra.concurrent.DebuggableThreadPoolExecutor;
@@ -62,7 +63,7 @@ public void setup()
     public void destroy() throws Exception
     {
         executor.shutdown();
-        executor.awaitTermination(1, TimeUnit.MINUTES);
+        Assert.assertTrue(executor.awaitTermination(1, TimeUnit.MINUTES));
     }
 
     @Test

File: test/unit/org/apache/cassandra/db/monitoring/MonitoringTaskTest.java
Patch:
@@ -276,7 +276,7 @@ public void testMultipleThreads() throws InterruptedException
         }
 
         executorService.shutdown();
-        assertTrue(executorService.awaitTermination(30, TimeUnit.SECONDS));
+        assertTrue(executorService.awaitTermination(1, TimeUnit.MINUTES));
         assertEquals(opCount, operations.size());
 
         waitForOperationsToComplete(operations);

File: test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java
Patch:
@@ -1121,7 +1121,7 @@ public void testConcurrentMemtableReadsAndWrites() throws Exception
             Assert.assertEquals(writeCount, rows.size());
         } finally {
             scheduler.shutdownNow();
-            scheduler.awaitTermination(30, TimeUnit.SECONDS);
+            Assert.assertTrue(scheduler.awaitTermination(1, TimeUnit.MINUTES));
         }
     }
 

File: test/unit/org/apache/cassandra/io/util/RandomAccessReaderTest.java
Patch:
@@ -36,6 +36,7 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 
+import org.junit.Assert;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -494,7 +495,7 @@ private static void testSeek(int numThreads) throws IOException, InterruptedExce
                     executor.submit(worker);
 
                 executor.shutdown();
-                executor.awaitTermination(1, TimeUnit.MINUTES);
+                Assert.assertTrue(executor.awaitTermination(1, TimeUnit.MINUTES));
             }
         }
     }

File: test/unit/org/apache/cassandra/metrics/DecayingEstimatedHistogramReservoirTest.java
Patch:
@@ -26,6 +26,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.LockSupport;
 
+import org.assertj.core.api.Assertions;
 import org.junit.Assert;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -157,7 +158,7 @@ public void testStriping() throws InterruptedException
         }
 
         executors.shutdown();
-        executors.awaitTermination(10, TimeUnit.SECONDS);
+        Assert.assertTrue(executors.awaitTermination(1, TimeUnit.MINUTES));
 
         Snapshot modelSnapshot = model.getSnapshot();
         Snapshot testSnapshot = test.getSnapshot();

File: test/unit/org/apache/cassandra/net/ConnectionTest.java
Patch:
@@ -817,7 +817,7 @@ public void testAcquireReleaseOutbound() throws Throwable
                 submitOrder.forEach(executor::submit);
 
                 executor.shutdown();
-                executor.awaitTermination(10, TimeUnit.SECONDS);
+                Assert.assertTrue(executor.awaitTermination(1, TimeUnit.MINUTES));
 
                 Assert.assertEquals(acquireCount * acquireStep - (acquisitionFailures.get() * acquireStep), outbound.pendingBytes());
                 Assert.assertEquals(acquireCount - acquisitionFailures.get(), outbound.pendingCount());

File: test/unit/org/apache/cassandra/utils/StatusLoggerTest.java
Patch:
@@ -27,6 +27,7 @@
 import java.util.stream.Collectors;
 
 import com.google.common.collect.Range;
+import org.junit.Assert;
 import org.junit.Test;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -70,7 +71,7 @@ private void submitTwoLogRequestsConcurrently() throws InterruptedException
         executorService.submit(StatusLogger::log);
         executorService.submit(StatusLogger::log);
         executorService.shutdown();
-        executorService.awaitTermination(1, TimeUnit.SECONDS);
+        Assert.assertTrue(executorService.awaitTermination(1, TimeUnit.MINUTES));
     }
 
     private void verifyOnlySingleStatusWasAppendedConcurrently(List<ILoggingEvent> events)

File: test/unit/org/apache/cassandra/utils/UUIDTests.java
Patch:
@@ -29,6 +29,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import org.junit.Assert;
 import org.junit.Test;
 
 import com.google.common.collect.Sets;
@@ -135,7 +136,7 @@ public void verifyConcurrentUUIDGeneration() throws Throwable
                 es.execute(task);
             }
             es.shutdown();
-            es.awaitTermination(10, TimeUnit.MINUTES);
+            Assert.assertTrue(es.awaitTermination(1, TimeUnit.MINUTES));
 
             assert !failedOrdering.get();
             assert !failedDuplicate.get();

File: test/unit/org/apache/cassandra/config/DatabaseDescriptorRefTest.java
Patch:
@@ -69,10 +69,11 @@ public class DatabaseDescriptorRefTest
     "org.apache.cassandra.config.Config",
     "org.apache.cassandra.config.Config$1",
     "org.apache.cassandra.config.Config$CommitLogSync",
+    "org.apache.cassandra.config.Config$CommitFailurePolicy",
     "org.apache.cassandra.config.Config$DiskAccessMode",
     "org.apache.cassandra.config.Config$DiskFailurePolicy",
-    "org.apache.cassandra.config.Config$CommitFailurePolicy",
     "org.apache.cassandra.config.Config$DiskOptimizationStrategy",
+    "org.apache.cassandra.config.Config$FlushCompression",
     "org.apache.cassandra.config.Config$InternodeCompression",
     "org.apache.cassandra.config.Config$MemtableAllocationType",
     "org.apache.cassandra.config.Config$RepairCommandPoolFullStrategy",
@@ -126,6 +127,7 @@ public class DatabaseDescriptorRefTest
     "org.apache.cassandra.io.FSWriteError",
     "org.apache.cassandra.io.FSError",
     "org.apache.cassandra.io.compress.ICompressor",
+    "org.apache.cassandra.io.compress.ICompressor$Uses",
     "org.apache.cassandra.io.compress.LZ4Compressor",
     "org.apache.cassandra.io.sstable.metadata.MetadataType",
     "org.apache.cassandra.io.util.BufferedDataOutputStreamPlus",

File: src/java/org/apache/cassandra/hadoop/cql3/CqlInputFormat.java
Patch:
@@ -204,6 +204,7 @@ public List<org.apache.hadoop.mapreduce.InputSplit> getSplits(JobContext context
                         maxSplits = tokenRangeSplits.size();
                         expectedPartionsForFailedRanges = tokenRangeSplits.get(0).getLength();
                     }
+                    splits.addAll(tokenRangeSplits);
                 }
                 catch (Exception e)
                 {

File: test/unit/org/apache/cassandra/cql3/CustomNowInSecondsTest.java
Patch:
@@ -54,7 +54,6 @@ public void testSelectQuery()
 
     private void testSelectQuery(boolean prepared)
     {
-        int now = (int) (System.currentTimeMillis() / 1000);
         int day = 86400;
 
         String ks = createKeyspace("CREATE KEYSPACE %s WITH replication={ 'class' : 'SimpleStrategy', 'replication_factor' : 1 }");
@@ -63,6 +62,8 @@ private void testSelectQuery(boolean prepared)
         // insert a row with TTL = 1 day.
         executeModify(format("INSERT INTO %s.%s (id, val) VALUES (0, 0) USING TTL %d", ks, tbl, day), Integer.MIN_VALUE, prepared);
 
+        int now = (int) (System.currentTimeMillis() / 1000);
+
         // execute a SELECT query without overriding nowInSeconds - make sure we observe one row.
         assertEquals(1, executeSelect(format("SELECT * FROM %s.%s", ks, tbl), Integer.MIN_VALUE, prepared).size());
 

File: src/java/org/apache/cassandra/streaming/IncomingStream.java
Patch:
@@ -41,5 +41,6 @@ public interface IncomingStream
 
     String getName();
     long getSize();
+    int getNumFiles();
     TableId getTableId();
 }

File: src/java/org/apache/cassandra/streaming/OutgoingStream.java
Patch:
@@ -49,4 +49,5 @@ public interface OutgoingStream
     String getName();
     long getSize();
     TableId getTableId();
+    int getNumFiles();
 }

File: src/java/org/apache/cassandra/streaming/StreamReceiveTask.java
Patch:
@@ -82,7 +82,7 @@ public synchronized void received(IncomingStream stream)
             return;
         }
 
-        remoteStreamsReceived++;
+        remoteStreamsReceived += stream.getNumFiles();
         bytesReceived += stream.getSize();
         Preconditions.checkArgument(tableId.equals(stream.getTableId()));
         logger.debug("received {} of {} total files {} of total bytes {}", remoteStreamsReceived, totalStreams,

File: test/unit/org/apache/cassandra/streaming/StreamTransferTaskTest.java
Patch:
@@ -95,7 +95,7 @@ public void testScheduleTimeout() throws Exception
             ranges.add(new Range<>(sstable.first.getToken(), sstable.last.getToken()));
             task.addTransferStream(new CassandraOutgoingFile(StreamOperation.BOOTSTRAP, sstable.selfRef(), sstable.getPositionsForRanges(ranges), ranges, 1));
         }
-        assertEquals(2, task.getTotalNumberOfFiles());
+        assertEquals(14, task.getTotalNumberOfFiles());
 
         // if file sending completes before timeout then the task should be canceled.
         Future f = task.scheduleTimeout(0, 0, TimeUnit.NANOSECONDS);
@@ -147,7 +147,7 @@ public void testFailSessionDuringTransferShouldNotReleaseReferences() throws Exc
             refs.add(ref);
             task.addTransferStream(new CassandraOutgoingFile(StreamOperation.BOOTSTRAP, ref, sstable.getPositionsForRanges(ranges), ranges, 1));
         }
-        assertEquals(2, task.getTotalNumberOfFiles());
+        assertEquals(14, task.getTotalNumberOfFiles());
 
         //add task to stream session, so it is aborted when stream session fails
         session.transfers.put(TableId.generate(), task);

File: src/java/org/apache/cassandra/cql3/statements/BatchStatement.java
Patch:
@@ -141,7 +141,7 @@ public List<ColumnSpecification> getBindVariables()
     public short[] getPartitionKeyBindVariableIndexes()
     {
         boolean affectsMultipleTables =
-            !statements.isEmpty() && statements.stream().map(s -> s.metadata().id).allMatch(isEqual(statements.get(0).metadata().id));
+            !statements.isEmpty() && !statements.stream().map(s -> s.metadata().id).allMatch(isEqual(statements.get(0).metadata().id));
 
         // Use the TableMetadata of the first statement for partition key bind indexes.  If the statements affect
         // multiple tables, we won't send partition key bind indexes.

File: src/java/org/apache/cassandra/net/OutboundConnection.java
Patch:
@@ -795,7 +795,7 @@ boolean doRun(Established established)
                             out = new DataOutputBufferFixed(sending.buffer);
                         }
 
-                        Tracing.instance.traceOutgoingMessage(next, settings.connectTo);
+                        Tracing.instance.traceOutgoingMessage(next, messageSize, settings.connectTo);
                         Message.serializer.serialize(next, out, messagingVersion);
 
                         if (sending.length() != sendingBytes + messageSize)
@@ -963,7 +963,7 @@ boolean doRun(Established established)
                 if (messageSize > DatabaseDescriptor.getInternodeMaxMessageSizeInBytes())
                     throw new Message.OversizedMessageException(messageSize);
 
-                Tracing.instance.traceOutgoingMessage(send, established.settings.connectTo);
+                Tracing.instance.traceOutgoingMessage(send, messageSize, established.settings.connectTo);
                 Message.serializer.serialize(send, out, established.messagingVersion);
 
                 if (out.position() != messageSize)

File: src/java/org/apache/cassandra/tracing/Tracing.java
Patch:
@@ -273,15 +273,16 @@ public TraceState initializeFromMessage(final Message.Header header)
     /**
      * Record any tracing data, if enabled on this message.
      */
-    public void traceOutgoingMessage(Message<?> message, InetAddressAndPort sendTo)
+    public void traceOutgoingMessage(Message<?> message, int serializedSize, InetAddressAndPort sendTo)
     {
         try
         {
             final UUID sessionId = message.traceSession();
             if (sessionId == null)
                 return;
 
-            String logMessage = String.format("Sending %s message to %s", message.verb(), sendTo);
+            String logMessage = String.format("Sending %s message to %s message size %d bytes", message.verb(), sendTo,
+                                              serializedSize);
 
             TraceState state = get(sessionId);
             if (state == null) // session may have already finished; see CASSANDRA-5668

File: src/java/org/apache/cassandra/audit/DiagnosticEventAuditLogger.java
Patch:
@@ -27,7 +27,7 @@ public void log(AuditLogEntry logMessage)
         AuditEvent.create(logMessage);
     }
 
-    public boolean enabled()
+    public boolean isEnabled()
     {
         return DiagnosticEventService.instance().isDiagnosticsEnabled();
     }

File: src/java/org/apache/cassandra/audit/FileAuditLogger.java
Patch:
@@ -36,7 +36,7 @@ public FileAuditLogger()
     }
 
     @Override
-    public boolean enabled()
+    public boolean isEnabled()
     {
         return enabled;
     }

File: src/java/org/apache/cassandra/audit/NoOpAuditLogger.java
Patch:
@@ -23,7 +23,7 @@
 public class NoOpAuditLogger implements IAuditLogger
 {
     @Override
-    public boolean enabled()
+    public boolean isEnabled()
     {
         return false;
     }

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -34,7 +34,7 @@
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.audit.AuditLogOptions;
-import org.apache.cassandra.audit.FullQueryLoggerOptions;
+import org.apache.cassandra.fql.FullQueryLoggerOptions;
 import org.apache.cassandra.db.ConsistencyLevel;
 
 /**

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -40,7 +40,7 @@
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.audit.AuditLogOptions;
-import org.apache.cassandra.audit.FullQueryLoggerOptions;
+import org.apache.cassandra.fql.FullQueryLoggerOptions;
 import org.apache.cassandra.auth.AllowAllInternodeAuthenticator;
 import org.apache.cassandra.auth.AuthConfig;
 import org.apache.cassandra.auth.IAuthenticator;

File: src/java/org/apache/cassandra/cql3/QueryHandler.java
Patch:
@@ -30,7 +30,9 @@
 
 public interface QueryHandler
 {
-    ResultMessage process(String query,
+    CQLStatement parse(String queryString, QueryState queryState, QueryOptions options);
+
+    ResultMessage process(CQLStatement statement,
                           QueryState state,
                           QueryOptions options,
                           Map<String, ByteBuffer> customPayload,

File: src/java/org/apache/cassandra/fql/FullQueryLoggerOptions.java
Patch:
@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-package org.apache.cassandra.audit;
+package org.apache.cassandra.fql;
 
 import org.apache.commons.lang3.StringUtils;
 

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -44,6 +44,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import org.apache.cassandra.audit.AuditLogManager;
 import org.apache.cassandra.concurrent.ScheduledExecutors;
 import org.apache.cassandra.db.virtual.SystemViewsKeyspace;
 import org.apache.cassandra.db.virtual.VirtualKeyspaceRegistry;
@@ -409,6 +410,8 @@ protected void setup()
             }
         }
 
+        AuditLogManager.instance.initialize();
+
         // schedule periodic background compaction task submission. this is simply a backstop against compactions stalling
         // due to scheduling errors or race conditions
         ScheduledExecutors.optionalTasks.scheduleWithFixedDelay(ColumnFamilyStore.getBackgroundCompactionTaskSubmitter(), 5, 1, TimeUnit.MINUTES);

File: src/java/org/apache/cassandra/tools/nodetool/DisableFullQueryLog.java
Patch:
@@ -28,6 +28,6 @@ public class DisableFullQueryLog extends NodeToolCmd
     @Override
     public void execute(NodeProbe probe)
     {
-        probe.getSpProxy().stopFullQueryLogger();
+        probe.stopFullQueryLogger();
     }
 }
\ No newline at end of file

File: src/java/org/apache/cassandra/tools/nodetool/EnableFullQueryLog.java
Patch:
@@ -51,6 +51,6 @@ public class EnableFullQueryLog extends NodeToolCmd
     @Override
     public void execute(NodeProbe probe)
     {
-        probe.getSpProxy().configureFullQueryLogger(path, rollCycle, blocking, maxQueueWeight, maxLogSize, archiveCommand, archiveRetries);
+        probe.enableFullQueryLogger(path, rollCycle, blocking, maxQueueWeight, maxLogSize, archiveCommand, archiveRetries);
     }
 }
\ No newline at end of file

File: src/java/org/apache/cassandra/tools/nodetool/ResetFullQueryLog.java
Patch:
@@ -28,6 +28,6 @@ public class ResetFullQueryLog extends NodeToolCmd
     @Override
     public void execute(NodeProbe probe)
     {
-        probe.getSpProxy().resetFullQueryLogger();
+        probe.resetFullQueryLogger();
     }
 }
\ No newline at end of file

File: test/unit/org/apache/cassandra/audit/AuditLoggerAuthTest.java
Patch:
@@ -251,7 +251,7 @@ private static void executeWithCredentials(List<String> queries, String username
 
     private static Queue<AuditLogEntry> getInMemAuditLogger()
     {
-        return ((InMemoryAuditLogger) AuditLogManager.getInstance().getLogger()).inMemQueue;
+        return ((InMemoryAuditLogger) AuditLogManager.instance.getLogger()).inMemQueue;
     }
 
     private static void assertLogEntry(AuditLogEntry logEntry, AuditLogEntryType type, String cql, String username)

File: test/unit/org/apache/cassandra/audit/BinAuditLoggerTest.java
Patch:
@@ -33,7 +33,7 @@
 import org.apache.cassandra.cql3.CQLTester;
 import org.apache.cassandra.utils.binlog.BinLogTest;
 
-import static org.hamcrest.CoreMatchers.containsString;
+import static org.hamcrest.core.StringContains.containsString;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertThat;
@@ -54,6 +54,7 @@ public static void setUp() throws Exception
         options.roll_cycle = "TEST_SECONDLY";
         options.audit_logs_dir = tempDir.toString();
         DatabaseDescriptor.setAuditLoggingOptions(options);
+        AuditLogManager.instance.enable(DatabaseDescriptor.getAuditLoggingOptions());
         requireNetwork();
     }
 

File: test/unit/org/apache/cassandra/audit/InMemoryAuditLogger.java
Patch:
@@ -27,7 +27,7 @@ public class InMemoryAuditLogger implements IAuditLogger
     private boolean enabled = true;
 
     @Override
-    public boolean enabled()
+    public boolean isEnabled()
     {
         return enabled;
     }

File: test/unit/org/apache/cassandra/cql3/CQLTester.java
Patch:
@@ -46,6 +46,7 @@
 import com.datastax.driver.core.ResultSet;
 
 import org.apache.cassandra.SchemaLoader;
+import org.apache.cassandra.audit.AuditLogManager;
 import org.apache.cassandra.concurrent.ScheduledExecutors;
 import org.apache.cassandra.db.virtual.VirtualKeyspaceRegistry;
 import org.apache.cassandra.db.virtual.VirtualSchemaKeyspace;
@@ -236,6 +237,7 @@ public void uncaughtException(Thread t, Throwable e)
 
         Keyspace.setInitialized();
         SystemKeyspace.persistLocalMetadata();
+        AuditLogManager.instance.initialize();
         isServerPrepared = true;
     }
 

File: test/unit/org/apache/cassandra/cql3/CustomNowInSecondsTest.java
Patch:
@@ -186,7 +186,8 @@ private static ResultMessage execute(String query, int nowInSeconds, boolean pre
         }
         else
         {
-            return QueryProcessor.instance.process(query, qs, queryOptions(nowInSeconds), Collections.emptyMap(), System.nanoTime());
+            CQLStatement statement = QueryProcessor.instance.parse(query, qs, queryOptions(nowInSeconds));
+            return QueryProcessor.instance.process(statement, qs, queryOptions(nowInSeconds), Collections.emptyMap(), System.nanoTime());
         }
     }
 

File: test/unit/org/apache/cassandra/transport/CQLUserAuditTest.java
Patch:
@@ -43,6 +43,7 @@
 import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.audit.AuditEvent;
 import org.apache.cassandra.audit.AuditLogEntryType;
+import org.apache.cassandra.audit.AuditLogManager;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.OverrideConfigurationLoader;
 import org.apache.cassandra.cql3.CQLTester;
@@ -84,6 +85,7 @@ public static void setup() throws Exception
                   "cassandra", "cassandra", null);
 
         DiagnosticEventService.instance().subscribe(AuditEvent.class, auditEvents::add);
+        AuditLogManager.instance.initialize();
     }
 
     @AfterClass

File: tools/fqltool/src/org/apache/cassandra/fqltool/FQLQuery.java
Patch:
@@ -28,7 +28,7 @@
 import com.datastax.driver.core.ConsistencyLevel;
 import com.datastax.driver.core.SimpleStatement;
 import com.datastax.driver.core.Statement;
-import org.apache.cassandra.audit.FullQueryLogger;
+import org.apache.cassandra.fql.FullQueryLogger;
 import org.apache.cassandra.cql3.QueryOptions;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.QueryState;

File: tools/fqltool/src/org/apache/cassandra/fqltool/commands/Dump.java
Patch:
@@ -40,7 +40,7 @@
 import net.openhft.chronicle.wire.ReadMarshallable;
 import net.openhft.chronicle.wire.ValueIn;
 import net.openhft.chronicle.wire.WireIn;
-import org.apache.cassandra.audit.FullQueryLogger;
+import org.apache.cassandra.fql.FullQueryLogger;
 import org.apache.cassandra.cql3.QueryOptions;
 import org.apache.cassandra.transport.ProtocolVersion;
 import org.apache.cassandra.utils.binlog.BinLog;

File: tools/fqltool/test/unit/org/apache/cassandra/fqltool/FQLReplayTest.java
Patch:
@@ -42,7 +42,7 @@
 import net.openhft.chronicle.queue.ExcerptAppender;
 import net.openhft.chronicle.queue.ExcerptTailer;
 import net.openhft.chronicle.wire.WireOut;
-import org.apache.cassandra.audit.FullQueryLogger;
+import org.apache.cassandra.fql.FullQueryLogger;
 import org.apache.cassandra.cql3.QueryOptions;
 import org.apache.cassandra.cql3.statements.BatchStatement;
 import org.apache.cassandra.fqltool.commands.Compare;

File: test/distributed/org/apache/cassandra/distributed/impl/InstanceConfig.java
Patch:
@@ -220,7 +220,7 @@ private void propagate(Object writeToConfig, String fieldName, Object value, Map
         }
         catch (NoSuchFieldException e)
         {
-            throw new IllegalStateException(e);
+            return;
         }
 
         if (valueField.getType().isEnum() && value instanceof String)

File: src/java/org/apache/cassandra/net/InboundMessageHandler.java
Patch:
@@ -578,7 +578,7 @@ private ResourceLimits.Outcome acquireCapacity(Limit endpointReserve, Limit glob
         {
             globalReserve.release(allocatedExcess);
             globalWaitQueue.signal();
-            return ResourceLimits.Outcome.INSUFFICIENT_GLOBAL;
+            return ResourceLimits.Outcome.INSUFFICIENT_ENDPOINT;
         }
 
         long newQueueSize = queueSizeUpdater.addAndGet(this, bytes);

File: src/java/org/apache/cassandra/net/OutboundSink.java
Patch:
@@ -25,7 +25,7 @@
 /**
  * A message sink that all outbound messages go through.
  *
- * Default sink {@link Sink} used by {@link MessagingService} is MessagingService#doSend(), which proceeds to
+ * Default sink {@link Sink} used by {@link MessagingService} is {@link MessagingService#doSend(Message, InetAddressAndPort, ConnectionType)}, which proceeds to
  * send messages over the network, but it can be overridden to filter out certain messages, record the fact
  * of attempted delivery, or delay they delivery.
  *

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -843,7 +843,7 @@ private void logFlush()
             offHeapTotal += allocator.offHeap().owns();
         }
 
-        logger.debug("Enqueuing flush of {}: {}",
+        logger.info("Enqueuing flush of {}: {}",
                      name,
                      String.format("%s (%.0f%%) on-heap, %s (%.0f%%) off-heap",
                                    FBUtilities.prettyPrintMemory(onHeapTotal),
@@ -1233,7 +1233,7 @@ public void run()
                 float flushingOffHeap = Memtable.MEMORY_POOL.offHeap.reclaimingRatio();
                 float thisOnHeap = largest.getAllocator().onHeap().ownershipRatio();
                 float thisOffHeap = largest.getAllocator().offHeap().ownershipRatio();
-                logger.debug("Flushing largest {} to free up room. Used total: {}, live: {}, flushing: {}, this: {}",
+                logger.info("Flushing largest {} to free up room. Used total: {}, live: {}, flushing: {}, this: {}",
                             largest.cfs, ratio(usedOnHeap, usedOffHeap), ratio(liveOnHeap, liveOffHeap),
                             ratio(flushingOnHeap, flushingOffHeap), ratio(thisOnHeap, thisOffHeap));
                 largest.cfs.switchMemtableIfCurrent(largest);

File: src/java/org/apache/cassandra/db/commitlog/CommitLogReader.java
Patch:
@@ -253,7 +253,7 @@ public void readCommitLogSegment(CommitLogReadHandler handler,
                     throw (IOException) re.getCause();
                 throw re;
             }
-            logger.debug("Finished reading {}", file);
+            logger.info("Finished reading {}", file);
         }
     }
 

File: src/java/org/apache/cassandra/db/repair/CassandraValidationIterator.java
Patch:
@@ -204,6 +204,8 @@ public CassandraValidationIterator(ColumnFamilyStore cfs, Collection<Range<Token
         }
 
         Preconditions.checkArgument(sstables != null);
+        logger.info("Performing validation compaction on {} sstables", sstables.size());
+        logger.debug("Performing validation compaction on {}", sstables);
         controller = new ValidationCompactionController(cfs, getDefaultGcBefore(cfs, nowInSec));
         scanners = cfs.getCompactionStrategyManager().getScanners(sstables, ranges);
         ci = new ValidationCompactionIterator(scanners.scanners, controller, nowInSec, CompactionManager.instance.active);

File: src/java/org/apache/cassandra/io/sstable/SSTable.java
Patch:
@@ -108,7 +108,7 @@ protected SSTable(Descriptor descriptor, Set<Component> components, TableMetadat
      */
     public static boolean delete(Descriptor desc, Set<Component> components)
     {
-        logger.debug("Deleting sstable: {}", desc);
+        logger.info("Deleting sstable: {}", desc);
         // remove the DATA component first if it exists
         if (components.contains(Component.DATA))
             FileUtils.deleteWithConfirm(desc.filenameFor(Component.DATA));

File: src/java/org/apache/cassandra/repair/ValidationManager.java
Patch:
@@ -165,6 +165,7 @@ public Object call() throws IOException
                 {
                     // we need to inform the remote end of our failure, otherwise it will hang on repair forever
                     validator.fail();
+                    logger.error("Validation failed.", e);
                     throw e;
                 }
                 return this;

File: src/java/org/apache/cassandra/transport/ConnectionLimitHandler.java
Patch:
@@ -61,7 +61,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception
         if (count > limit)
         {
             // The decrement will be done in channelClosed(...)
-            noSpamLogger.warn("Exceeded maximum native connection limit of {} by using {} connections", limit, count);
+            noSpamLogger.error("Exceeded maximum native connection limit of {} by using {} connections (see native_transport_max_concurrent_connections in cassandra.yaml)", limit, count);
             ctx.close();
         }
         else
@@ -85,7 +85,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception
                 if (perIpCount.incrementAndGet() > perIpLimit)
                 {
                     // The decrement will be done in channelClosed(...)
-                    noSpamLogger.warn("Exceeded maximum native connection limit per ip of {} by using {} connections", perIpLimit, perIpCount);
+                    noSpamLogger.error("Exceeded maximum native connection limit per ip of {} by using {} connections (see native_transport_max_concurrent_connections_per_ip)", perIpLimit, perIpCount);
                     ctx.close();
                     return;
                 }

File: src/java/org/apache/cassandra/tools/NodeProbe.java
Patch:
@@ -415,7 +415,7 @@ public void repairAsync(final PrintStream out, final String keyspace, Map<String
         }
         catch (Exception e)
         {
-            throw new IOException(e) ;
+            throw new IOException(e);
         }
         finally
         {

File: test/distributed/org/apache/cassandra/distributed/test/FullRepairCoordinatorNeighbourDownTest.java
Patch:
@@ -25,9 +25,9 @@
 import org.apache.cassandra.distributed.test.DistributedRepairUtils.RepairType;
 
 @RunWith(Parameterized.class)
-public class FullRepairCoordinatorSlowTest extends RepairCoordinatorSlow
+public class FullRepairCoordinatorNeighbourDownTest extends RepairCoordinatorNeighbourDown
 {
-    public FullRepairCoordinatorSlowTest(RepairParallelism parallelism, boolean withNotifications)
+    public FullRepairCoordinatorNeighbourDownTest(RepairParallelism parallelism, boolean withNotifications)
     {
         super(RepairType.FULL, parallelism, withNotifications);
     }

File: test/distributed/org/apache/cassandra/distributed/test/IncrementalRepairCoordinatorNeighbourDownTest.java
Patch:
@@ -25,9 +25,9 @@
 import org.apache.cassandra.distributed.test.DistributedRepairUtils.RepairType;
 
 @RunWith(Parameterized.class)
-public class IncrementalRepairCoordinatorSlowTest extends RepairCoordinatorSlow
+public class IncrementalRepairCoordinatorNeighbourDownTest extends RepairCoordinatorNeighbourDown
 {
-    public IncrementalRepairCoordinatorSlowTest(RepairParallelism parallelism, boolean withNotifications)
+    public IncrementalRepairCoordinatorNeighbourDownTest(RepairParallelism parallelism, boolean withNotifications)
     {
         super(RepairType.INCREMENTAL, parallelism, withNotifications);
     }

File: test/distributed/org/apache/cassandra/distributed/test/PreviewRepairCoordinatorNeighbourDownTest.java
Patch:
@@ -25,9 +25,9 @@
 import org.apache.cassandra.distributed.test.DistributedRepairUtils.RepairType;
 
 @RunWith(Parameterized.class)
-public class PreviewRepairCoordinatorSlowTest extends RepairCoordinatorSlow
+public class PreviewRepairCoordinatorNeighbourDownTest extends RepairCoordinatorNeighbourDown
 {
-    public PreviewRepairCoordinatorSlowTest(RepairParallelism parallelism, boolean withNotifications)
+    public PreviewRepairCoordinatorNeighbourDownTest(RepairParallelism parallelism, boolean withNotifications)
     {
         super(RepairType.PREVIEW, parallelism, withNotifications);
     }

File: src/java/org/apache/cassandra/exceptions/ReadFailureException.java
Patch:
@@ -19,6 +19,8 @@
 
 import java.util.Map;
 
+import com.google.common.collect.ImmutableMap;
+
 import org.apache.cassandra.db.ConsistencyLevel;
 import org.apache.cassandra.locator.InetAddressAndPort;
 
@@ -28,7 +30,7 @@ public class ReadFailureException extends RequestFailureException
 
     public ReadFailureException(ConsistencyLevel consistency, int received, int blockFor, boolean dataPresent, Map<InetAddressAndPort, RequestFailureReason> failureReasonByEndpoint)
     {
-        super(ExceptionCode.READ_FAILURE, consistency, received, blockFor, failureReasonByEndpoint);
+        super(ExceptionCode.READ_FAILURE, consistency, received, blockFor, ImmutableMap.copyOf(failureReasonByEndpoint));
         this.dataPresent = dataPresent;
     }
 }

File: src/java/org/apache/cassandra/exceptions/WriteFailureException.java
Patch:
@@ -19,6 +19,8 @@
 
 import java.util.Map;
 
+import com.google.common.collect.ImmutableMap;
+
 import org.apache.cassandra.db.ConsistencyLevel;
 import org.apache.cassandra.db.WriteType;
 import org.apache.cassandra.locator.InetAddressAndPort;
@@ -29,7 +31,7 @@ public class WriteFailureException extends RequestFailureException
 
     public WriteFailureException(ConsistencyLevel consistency, int received, int blockFor, WriteType writeType, Map<InetAddressAndPort, RequestFailureReason> failureReasonByEndpoint)
     {
-        super(ExceptionCode.WRITE_FAILURE, consistency, received, blockFor, failureReasonByEndpoint);
+        super(ExceptionCode.WRITE_FAILURE, consistency, received, blockFor, ImmutableMap.copyOf(failureReasonByEndpoint));
         this.writeType = writeType;
     }
 }

File: test/unit/org/apache/cassandra/cql3/validation/operations/AlterTest.java
Patch:
@@ -316,6 +316,7 @@ public void testCreateAlterNetworkTopologyWithDefaults() throws Throwable
                    row("tbl1", map("class", "org.apache.cassandra.db.compaction.SizeTieredCompactionStrategy",
                                   "min_threshold", "7",
                                   "max_threshold", "32")));
+        metadata.clearUnsafe();
     }
 
     @Test

File: src/java/org/apache/cassandra/index/sasi/memory/SkipListMemIndex.java
Patch:
@@ -63,6 +63,7 @@ public long add(DecoratedKey key, ByteBuffer value)
         return overhead;
     }
 
+    @SuppressWarnings("resource")
     public RangeIterator<Long, Token> search(Expression expression)
     {
         ByteBuffer min = expression.lower == null ? null : expression.lower.value;

File: src/java/org/apache/cassandra/index/sasi/memory/TrieMemIndex.java
Patch:
@@ -137,6 +137,7 @@ public long add(String value, DecoratedKey key)
             return overhead;
         }
 
+        @SuppressWarnings("resource")
         public RangeIterator<Long, Token> search(Expression expression)
         {
             ByteBuffer prefix = expression.lower == null ? null : expression.lower.value;

File: src/java/org/apache/cassandra/index/sasi/memory/KeyRangeIterator.java
Patch:
@@ -37,9 +37,9 @@ public class KeyRangeIterator extends RangeIterator<Long, Token>
 {
     private final DKIterator iterator;
 
-    public KeyRangeIterator(ConcurrentSkipListSet<DecoratedKey> keys)
+    public KeyRangeIterator(ConcurrentSkipListSet<DecoratedKey> keys, int size)
     {
-        super((Long) keys.first().getToken().getTokenValue(), (Long) keys.last().getToken().getTokenValue(), keys.size());
+        super((Long) keys.first().getToken().getTokenValue(), (Long) keys.last().getToken().getTokenValue(), size);
         this.iterator = new DKIterator(keys.iterator());
     }
 

File: src/java/org/apache/cassandra/index/sasi/memory/TrieMemIndex.java
Patch:
@@ -146,8 +146,9 @@ public RangeIterator<Long, Token> search(Expression expression)
             RangeUnionIterator.Builder<Long, Token> builder = RangeUnionIterator.builder();
             for (ConcurrentSkipListSet<DecoratedKey> keys : search)
             {
-                if (!keys.isEmpty())
-                    builder.add(new KeyRangeIterator(keys));
+                int size;
+                if ((size = keys.size()) > 0)
+                    builder.add(new KeyRangeIterator(keys, size));
             }
 
             return builder.build();

File: src/java/org/apache/cassandra/repair/consistent/CoordinatorSession.java
Patch:
@@ -44,6 +44,7 @@
 import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.net.Verb;
 import org.apache.cassandra.repair.RepairSessionResult;
+import org.apache.cassandra.repair.SomeRepairFailedException;
 import org.apache.cassandra.repair.messages.FailSession;
 import org.apache.cassandra.repair.messages.FinalizeCommit;
 import org.apache.cassandra.repair.messages.FinalizePropose;
@@ -322,7 +323,7 @@ public ListenableFuture<Boolean> apply(List<RepairSessionResult> results) throws
                         logger.debug("Incremental repair {} validation/stream phase completed in {}", sessionID, formatDuration(repairStart, finalizeStart));
 
                     }
-                    return Futures.immediateFailedFuture(new RuntimeException());
+                    return Futures.immediateFailedFuture(SomeRepairFailedException.INSTANCE);
                 }
                 else
                 {

File: src/java/org/apache/cassandra/tools/NodeTool.java
Patch:
@@ -276,13 +276,13 @@ private static void printHistory(String... args)
         }
     }
 
-    private static void badUse(Exception e)
+    protected void badUse(Exception e)
     {
         System.out.println("nodetool: " + e.getMessage());
         System.out.println("See 'nodetool help' or 'nodetool help <command>'.");
     }
 
-    private static void err(Throwable e)
+    protected void err(Throwable e)
     {
         System.err.println("error: " + e.getMessage());
         System.err.println("-- StackTrace --");

File: test/distributed/org/apache/cassandra/distributed/test/PreviewRepairTest.java
Patch:
@@ -131,7 +131,7 @@ public void testFinishingIncRepairDuringPreview() throws IOException, Interrupte
             SimpleCondition continuePreviewRepair = new SimpleCondition();
             DelayMessageFilter filter = new DelayMessageFilter(continuePreviewRepair);
             // this pauses the validation request sent from node1 to node2 until we have run a full inc repair below
-            cluster.filters().verbs(Verb.VALIDATION_REQ.id).from(1).to(2).messagesMatching(filter).drop();
+            cluster.filters().outbound().verbs(Verb.VALIDATION_REQ.id).from(1).to(2).messagesMatching(filter).drop();
 
             Future<Pair<Boolean, Boolean>> rsFuture = es.submit(() -> cluster.get(1).callOnInstance(repair(options(true))));
             Thread.sleep(1000);
@@ -170,7 +170,7 @@ public void testFinishingNonIntersectingIncRepairDuringPreview() throws IOExcept
             // pause preview repair validation messages on node2 until node1 has finished
             SimpleCondition continuePreviewRepair = new SimpleCondition();
             DelayMessageFilter filter = new DelayMessageFilter(continuePreviewRepair);
-            cluster.filters().verbs(Verb.VALIDATION_REQ.id).from(1).to(2).messagesMatching(filter).drop();
+            cluster.filters().outbound().verbs(Verb.VALIDATION_REQ.id).from(1).to(2).messagesMatching(filter).drop();
 
             // get local ranges to repair two separate ranges:
             List<String> localRanges = cluster.get(1).callOnInstance(() -> {

File: test/unit/org/apache/cassandra/security/SSLFactoryTest.java
Patch:
@@ -21,7 +21,6 @@
 import static org.junit.Assert.assertArrayEquals;
 
 import java.io.IOException;
-import java.net.InetAddress;
 
 import javax.net.ssl.SSLServerSocket;
 
@@ -31,6 +30,7 @@
 
 import org.apache.cassandra.config.EncryptionOptions;
 import org.apache.cassandra.config.EncryptionOptions.ServerEncryptionOptions;
+import org.apache.cassandra.utils.FBUtilities;
 import org.junit.Test;
 
 public class SSLFactoryTest
@@ -62,7 +62,7 @@ public void testServerSocketCiphers() throws IOException
         };
 
         // enabled ciphers must be a subset of configured ciphers with identical order
-        try (SSLServerSocket socket = SSLFactory.getServerSocket(options, InetAddress.getLocalHost(), 55123))
+        try (SSLServerSocket socket = SSLFactory.getServerSocket(options, FBUtilities.getLocalAddress(), 55123))
         {
             String[] enabled = socket.getEnabledCipherSuites();
             String[] wanted = Iterables.toArray(Iterables.filter(Lists.newArrayList(options.cipher_suites),

File: src/java/org/apache/cassandra/metrics/DecayingEstimatedHistogramReservoir.java
Patch:
@@ -65,7 +65,7 @@
  *
  * Each bucket represents values from (previous bucket offset, current offset].
  *
- * To reduce contention each logical bucket is striped accross a configurable number of stripes (default: 4). Threads are
+ * To reduce contention each logical bucket is striped accross a configurable number of stripes (default: 2). Threads are
  * assigned to specific stripes. In addition, logical buckets are distributed across the physical storage to reduce conention
  * when logically adjacent buckets are updated. See CASSANDRA-15213.
  *

File: src/java/org/apache/cassandra/tools/nodetool/DescribeCluster.java
Patch:
@@ -109,7 +109,7 @@ public void execute(NodeProbe probe)
 
             ArrayListMultimap<InetAddressAndPort, HostStatWithPort> hostToTokens = ArrayListMultimap.create();
             for (HostStatWithPort stat : dc.getValue())
-                hostToTokens.put(stat.endpoint, stat);
+                hostToTokens.put(stat.endpointWithPort, stat);
 
             int totalNodes = 0; // total number of nodes in a datacenter
             int downNodes = 0; // number of down nodes in a datacenter

File: src/java/org/apache/cassandra/tools/nodetool/DescribeCluster.java
Patch:
@@ -109,7 +109,7 @@ public void execute(NodeProbe probe)
 
             ArrayListMultimap<InetAddressAndPort, HostStatWithPort> hostToTokens = ArrayListMultimap.create();
             for (HostStatWithPort stat : dc.getValue())
-                hostToTokens.put(stat.endpoint, stat);
+                hostToTokens.put(stat.endpointWithPort, stat);
 
             int totalNodes = 0; // total number of nodes in a datacenter
             int downNodes = 0; // number of down nodes in a datacenter

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -207,7 +207,7 @@ public class Config
 
     /* if the size of columns or super-columns are more than this, indexing will kick in */
     public int column_index_size_in_kb = 64;
-    public int column_index_cache_size_in_kb = 2;
+    public volatile int column_index_cache_size_in_kb = 2;
     public volatile int batch_size_warn_threshold_in_kb = 5;
     public volatile int batch_size_fail_threshold_in_kb = 50;
     public Integer unlogged_batch_across_partitions_warn_threshold = 10;

File: src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java
Patch:
@@ -1855,7 +1855,7 @@ public DecoratedKey keyAt(long indexPosition) throws IOException
             // this saves index summary lookup and index file iteration which whould be pretty costly
             // especially in presence of promoted column indexes
             if (isKeyCacheEnabled())
-                cacheKey(key, rowIndexEntrySerializer.deserialize(in, in.getFilePointer()));
+                cacheKey(key, rowIndexEntrySerializer.deserialize(in));
         }
 
         return key;

File: src/java/org/apache/cassandra/io/sstable/format/big/BigTableReader.java
Patch:
@@ -244,7 +244,7 @@ protected RowIndexEntry getPosition(PartitionPosition key,
                 if (opSatisfied)
                 {
                     // read data position from index entry
-                    RowIndexEntry indexEntry = rowIndexEntrySerializer.deserialize(in, in.getFilePointer());
+                    RowIndexEntry indexEntry = rowIndexEntrySerializer.deserialize(in);
                     if (exactMatch && updateCacheAndStats)
                     {
                         assert key instanceof DecoratedKey; // key can be == to the index key only if it's a true row key

File: src/java/org/apache/cassandra/io/sstable/format/big/BigTableScanner.java
Patch:
@@ -309,7 +309,7 @@ protected UnfilteredRowIterator computeNext()
                             return endOfData();
 
                         currentKey = sstable.decorateKey(ByteBufferUtil.readWithShortLength(ifile));
-                        currentEntry = rowIndexEntrySerializer.deserialize(ifile, ifile.getFilePointer());
+                        currentEntry = rowIndexEntrySerializer.deserialize(ifile);
                     } while (!currentRange.contains(currentKey));
                 }
                 else
@@ -328,7 +328,7 @@ protected UnfilteredRowIterator computeNext()
                 {
                     // we need the position of the start of the next key, regardless of whether it falls in the current range
                     nextKey = sstable.decorateKey(ByteBufferUtil.readWithShortLength(ifile));
-                    nextEntry = rowIndexEntrySerializer.deserialize(ifile, ifile.getFilePointer());
+                    nextEntry = rowIndexEntrySerializer.deserialize(ifile);
 
                     if (!currentRange.contains(nextKey))
                     {

File: src/java/org/apache/cassandra/db/lifecycle/LogReplica.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.cassandra.io.FSError;
 import org.apache.cassandra.io.FSReadError;
 import org.apache.cassandra.io.util.FileUtils;
+import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.NativeLibrary;
 
 /**
@@ -50,7 +51,7 @@ final class LogReplica implements AutoCloseable
     static LogReplica create(File folder, String fileName)
     {
         int folderFD = NativeLibrary.tryOpenDirectory(folder.getPath());
-        if (folderFD == -1)
+        if (folderFD == -1 && !FBUtilities.isWindows())
             throw new FSReadError(new IOException(String.format("Invalid folder descriptor trying to create log replica %s", folder.getPath())), folder.getPath());
 
         return new LogReplica(new File(fileName), folderFD);
@@ -59,7 +60,7 @@ static LogReplica create(File folder, String fileName)
     static LogReplica open(File file)
     {
         int folderFD = NativeLibrary.tryOpenDirectory(file.getParentFile().getPath());
-        if (folderFD == -1)
+        if (folderFD == -1 && !FBUtilities.isWindows())
             throw new FSReadError(new IOException(String.format("Invalid folder descriptor trying to create log replica %s", file.getParentFile().getPath())), file.getParentFile().getPath());
 
         return new LogReplica(file, folderFD);

File: src/java/org/apache/cassandra/hints/HintsCatalog.java
Patch:
@@ -34,6 +34,7 @@
 import org.apache.cassandra.io.FSReadError;
 import org.apache.cassandra.io.FSWriteError;
 import org.apache.cassandra.io.util.FileUtils;
+import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.NativeLibrary;
 import org.apache.cassandra.utils.SyncUtil;
 
@@ -161,7 +162,7 @@ void fsyncDirectory()
                 FileUtils.handleFSErrorAndPropagate(e);
             }
         }
-        else
+        else if (!FBUtilities.isWindows())
         {
             logger.error("Unable to open directory {}", hintsDirectory.getAbsolutePath());
             FileUtils.handleFSErrorAndPropagate(new FSWriteError(new IOException(String.format("Unable to open hint directory %s", hintsDirectory.getAbsolutePath())), hintsDirectory.getAbsolutePath()));

File: test/distributed/org/apache/cassandra/distributed/test/MessageForwardingTest.java
Patch:
@@ -25,6 +25,7 @@
 import java.util.Map;
 import java.util.UUID;
 import java.util.concurrent.Future;
+import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 import java.util.stream.Stream;
 
@@ -35,7 +36,6 @@
 import org.apache.cassandra.distributed.Cluster;
 import org.apache.cassandra.distributed.impl.IsolatedExecutor;
 import org.apache.cassandra.distributed.impl.TracingUtil;
-import org.apache.cassandra.locator.InetAddressAndPort;
 import org.apache.cassandra.utils.UUIDGen;
 
 public class MessageForwardingTest extends DistributedTestBase
@@ -66,7 +66,7 @@ public void mutationsForwardedToAllReplicasTest()
             // Wait for each of the futures to complete before checking the traces, don't care
             // about the result so
             //noinspection ResultOfMethodCallIgnored
-            inserts.map(IsolatedExecutor::waitOn).count();
+            inserts.map(IsolatedExecutor::waitOn).collect(Collectors.toList());
 
             cluster.stream("dc1").forEach(instance -> forwardFromCounts.put(instance.broadcastAddressAndPort().address, 0));
             cluster.forEach(instance -> commitCounts.put(instance.broadcastAddressAndPort().address, 0));

File: test/unit/org/apache/cassandra/db/ImportTest.java
Patch:
@@ -308,7 +308,7 @@ private void testCorruptHelper(boolean verify) throws Throwable
         getCurrentColumnFamilyStore().clearUnsafe();
         File backupdirCorrect = moveToBackupDir(correctSSTables);
 
-        File [] beforeImport = backupdir.listFiles();
+        Set<File> beforeImport = Sets.newHashSet(backupdir.listFiles());
         // first we moved out 2 sstables, one correct and one corrupt in to a single directory (backupdir)
         // then we moved out 1 sstable, a correct one (in backupdirCorrect).
         // now import should fail import on backupdir, but import the one in backupdirCorrect.
@@ -323,7 +323,7 @@ private void testCorruptHelper(boolean verify) throws Throwable
             assertTrue("pk = "+pk, pk >= 100 && pk < 130);
         }
         assertEquals("Data dir should contain one file", 1, countFiles(getCurrentColumnFamilyStore().getDirectories().getDirectoryForNewSSTables()));
-        assertArrayEquals("backupdir contained 2 files before import, should still contain 2 after failing to import it", beforeImport, backupdir.listFiles());
+        assertEquals("backupdir contained 2 files before import, should still contain 2 after failing to import it", beforeImport, Sets.newHashSet(backupdir.listFiles()));
         assertEquals("backupdirCorrect contained 1 file before import, should be empty after import", 0, countFiles(backupdirCorrect));
     }
 

File: test/distributed/org/apache/cassandra/distributed/impl/Versions.java
Patch:
@@ -146,7 +146,7 @@ public Version getLatest(Major major)
     public static Versions find()
     {
         logger.info("Looking for dtest jars in " + new File("build").getAbsolutePath());
-        final Pattern pattern = Pattern.compile("dtest-([0-9.]+)\\.jar");
+        final Pattern pattern = Pattern.compile("dtest-(?<fullversion>(\\d+)\\.(\\d+)(\\.\\d+)?(\\.\\d+)?)([~\\-]\\w[.\\w]*(?:\\-\\w[.\\w]*)*)?(\\+[.\\w]+)?\\.jar");
         final Map<Major, List<Version>> versions = new HashMap<>();
         for (Major major : Major.values())
             versions.put(major, new ArrayList<>());
@@ -156,7 +156,7 @@ public static Versions find()
             Matcher m = pattern.matcher(file.getName());
             if (!m.matches())
                 continue;
-            String version = m.group(1);
+            String version = m.group("fullversion");
             Major major = Major.fromFull(version);
             versions.get(major).add(new Version(major, version, new URL[] { toURL(file) }));
         }

File: test/distributed/org/apache/cassandra/distributed/impl/Instance.java
Patch:
@@ -231,10 +231,11 @@ public boolean test(Message<?> messageOut, InetAddressAndPort to)
         {
             try (DataOutputBuffer out = new DataOutputBuffer(1024))
             {
+                int version = MessagingService.instance().versions.get(to);
                 InetAddressAndPort from = broadcastAddressAndPort();
                 Tracing.instance.traceOutgoingMessage(messageOut, to);
-                Message.serializer.serialize(messageOut, out, MessagingService.current_version);
-                deliver.accept(to, new MessageImpl(messageOut.verb().id, out.toByteArray(), messageOut.id(), MessagingService.current_version, from));
+                Message.serializer.serialize(messageOut, out, version);
+                deliver.accept(to, new MessageImpl(messageOut.verb().id, out.toByteArray(), messageOut.id(), version, from));
             }
             catch (IOException e)
             {

File: test/distributed/org/apache/cassandra/distributed/test/DistributedTestBase.java
Patch:
@@ -94,7 +94,7 @@ public static void assertRows(Object[][] actual, Object[]... expected)
         {
             Object[] expectedRow = expected[i];
             Object[] actualRow = actual[i];
-            Assert.assertTrue(rowsNotEqualErrorMessage(expected, actual),
+            Assert.assertTrue(rowsNotEqualErrorMessage(actual, expected),
                               Arrays.equals(expectedRow, actualRow));
         }
     }

File: src/java/org/apache/cassandra/db/streaming/CassandraCompressedStreamReader.java
Patch:
@@ -85,7 +85,7 @@ public SSTableMultiWriter read(DataInputPlus inputPlus) throws IOException
             int sectionIdx = 0;
             for (SSTableReader.PartitionPositionBounds section : sections)
             {
-                assert cis.getTotalCompressedBytesRead() <= totalSize;
+                assert cis.chunkBytesRead() <= totalSize;
                 long sectionLength = section.upperPosition - section.lowerPosition;
 
                 logger.trace("[Stream #{}] Reading section {} with length {} from stream.", session.planId(), sectionIdx++, sectionLength);
@@ -97,12 +97,12 @@ public SSTableMultiWriter read(DataInputPlus inputPlus) throws IOException
                 {
                     writePartition(deserializer, writer);
                     // when compressed, report total bytes of compressed chunks read since remoteFile.size is the sum of chunks transferred
-                    session.progress(filename, ProgressInfo.Direction.IN, cis.getTotalCompressedBytesRead(), totalSize);
+                    session.progress(filename, ProgressInfo.Direction.IN, cis.chunkBytesRead(), totalSize);
                 }
                 assert in.getBytesRead() == sectionLength;
             }
             logger.trace("[Stream #{}] Finished receiving file #{} from {} readBytes = {}, totalSize = {}", session.planId(), fileSeqNum,
-                         session.peer, FBUtilities.prettyPrintMemory(cis.getTotalCompressedBytesRead()), FBUtilities.prettyPrintMemory(totalSize));
+                         session.peer, FBUtilities.prettyPrintMemory(cis.chunkBytesRead()), FBUtilities.prettyPrintMemory(totalSize));
             return writer;
         }
         catch (Throwable e)

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -108,7 +108,7 @@ public class Config
     public Integer streaming_connections_per_host = 1;
     public Integer streaming_keep_alive_period_in_secs = 300; //5 minutes
 
-    public boolean cross_node_timeout = false;
+    public boolean cross_node_timeout = true;
 
     public volatile long slow_query_log_timeout_in_ms = 500L;
 

File: src/java/org/apache/cassandra/db/compaction/OperationType.java
Patch:
@@ -19,6 +19,7 @@
 
 public enum OperationType
 {
+    /** Each modification here should be also applied to {@link org.apache.cassandra.tools.nodetool.Stop#compactionType} */
     COMPACTION("Compaction"),
     VALIDATION("Validation"),
     KEY_CACHE_SAVE("Key cache save"),

File: src/java/org/apache/cassandra/tools/nodetool/Stop.java
Patch:
@@ -30,7 +30,7 @@ public class Stop extends NodeToolCmd
 {
     @Arguments(title = "compaction_type",
               usage = "<compaction type>",
-              description = "Supported types are COMPACTION, VALIDATION, CLEANUP, SCRUB, VERIFY, INDEX_BUILD",
+              description = "Supported types are COMPACTION, VALIDATION, CLEANUP, SCRUB, UPGRADE_SSTABLES, INDEX_BUILD, TOMBSTONE_COMPACTION, ANTICOMPACTION, VERIFY, VIEW_BUILD, INDEX_SUMMARY, RELOCATE, GARBAGE_COLLECT",
               required = false)
     private OperationType compactionType = OperationType.UNKNOWN;
 

File: src/java/org/apache/cassandra/tools/nodetool/Stop.java
Patch:
@@ -48,4 +48,4 @@ public void execute(NodeProbe probe)
         else
             probe.stop(compactionType.name());
     }
-}
\ No newline at end of file
+}

File: src/java/org/apache/cassandra/cql3/selection/Selection.java
Patch:
@@ -428,7 +428,7 @@ private List<ByteBuffer> rowToJson(List<ByteBuffer> row, int protocolVersion)
                 sb.append('"');
                 sb.append(Json.quoteAsJsonString(columnName));
                 sb.append("\": ");
-                if (buffer == null || !buffer.hasRemaining())
+                if (buffer == null)
                     sb.append("null");
                 else
                     sb.append(spec.type.toJSONString(buffer, protocolVersion));

File: src/java/org/apache/cassandra/schema/SchemaKeyspace.java
Patch:
@@ -488,7 +488,7 @@ public static Mutation makeCreateTableMutation(KeyspaceMetadata keyspace, CFMeta
         return mutation;
     }
 
-    static void addTableToSchemaMutation(CFMetaData table, long timestamp, boolean withColumnsAndTriggers, Mutation mutation)
+    public static void addTableToSchemaMutation(CFMetaData table, long timestamp, boolean withColumnsAndTriggers, Mutation mutation)
     {
         RowUpdateBuilder adder = new RowUpdateBuilder(Tables, timestamp, mutation).clustering(table.cfName);
 

File: src/java/org/apache/cassandra/io/util/FileUtils.java
Patch:
@@ -318,8 +318,8 @@ public static String getCanonicalPath(File file)
     /** Return true if file is contained in folder */
     public static boolean isContained(File folder, File file)
     {
-        String folderPath = getCanonicalPath(folder);
-        String filePath = getCanonicalPath(file);
+        Path folderPath = Paths.get(getCanonicalPath(folder));
+        Path filePath = Paths.get(getCanonicalPath(file));
 
         return filePath.startsWith(folderPath);
     }

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -844,6 +844,7 @@ public static boolean needsCleanup(SSTableReader sstable, Collection<Range<Token
      *
      * @throws IOException
      */
+    @SuppressWarnings("resource")
     private void doCleanupOne(final ColumnFamilyStore cfs, LifecycleTransaction txn, CleanupStrategy cleanupStrategy, Collection<Range<Token>> ranges, boolean hasIndexes) throws IOException
     {
         assert !cfs.isIndex();

File: src/java/org/apache/cassandra/db/compaction/LeveledCompactionStrategy.java
Patch:
@@ -215,6 +215,7 @@ public long getMaxSSTableBytes()
         return maxSSTableSizeInMB * 1024L * 1024L;
     }
 
+    @SuppressWarnings("resource")
     public ScannerList getScanners(Collection<SSTableReader> sstables, Range<Token> range)
     {
         Set<SSTableReader>[] sstablesPerLevel = manifest.getSStablesPerLevelSnapshot();

File: src/java/org/apache/cassandra/repair/SystemDistributedKeyspace.java
Patch:
@@ -69,7 +69,9 @@ private SystemDistributedKeyspace()
                      + "range_begin text,"
                      + "range_end text,"
                      + "coordinator inet,"
+                     + "coordinator_port int,"
                      + "participants set<inet>,"
+                     + "participants_v2 set<text>,"
                      + "exception_message text,"
                      + "exception_stacktrace text,"
                      + "status text,"
@@ -90,6 +92,7 @@ private SystemDistributedKeyspace()
                      + "exception_stacktrace text,"
                      + "requested_ranges set<text>,"
                      + "successful_ranges set<text>,"
+                     + "options map<text, text>,"
                      + "PRIMARY KEY (parent_id))");
 
     private static CFMetaData compile(String name, String description, String schema)

File: src/java/org/apache/cassandra/tracing/TraceKeyspace.java
Patch:
@@ -49,6 +49,7 @@ private TraceKeyspace()
                 + "command text,"
                 + "client inet,"
                 + "coordinator inet,"
+                + "coordinator_port int,"
                 + "duration int,"
                 + "parameters map<text, text>,"
                 + "request text,"
@@ -63,6 +64,7 @@ private TraceKeyspace()
                 + "event_id timeuuid,"
                 + "activity text,"
                 + "source inet,"
+                + "source_port int,"
                 + "source_elapsed int,"
                 + "thread text,"
                 + "PRIMARY KEY ((session_id), event_id))");

File: src/java/org/apache/cassandra/index/sasi/plan/Expression.java
Patch:
@@ -335,7 +335,7 @@ public boolean isLowerSatisfiedBy(OnDiskIndex.DataTerm term)
         if (!hasLower())
             return true;
 
-        int cmp = term.compareTo(validator, lower.value, false);
+        int cmp = term.compareTo(validator, lower.value, operation == Op.RANGE && !isLiteral);
         return cmp > 0 || cmp == 0 && lower.inclusive;
     }
 
@@ -344,7 +344,7 @@ public boolean isUpperSatisfiedBy(OnDiskIndex.DataTerm term)
         if (!hasUpper())
             return true;
 
-        int cmp = term.compareTo(validator, upper.value, false);
+        int cmp = term.compareTo(validator, upper.value, operation == Op.RANGE && !isLiteral);
         return cmp < 0 || cmp == 0 && upper.inclusive;
     }
 

File: test/distributed/org/apache/cassandra/distributed/api/ICluster.java
Patch:
@@ -29,6 +29,8 @@ public interface ICluster
     IInstance get(InetAddressAndPort endpoint);
     int size();
     Stream<? extends IInstance> stream();
+    Stream<? extends IInstance> stream(String dcName);
+    Stream<? extends IInstance> stream(String dcName, String rackName);
     IMessageFilters filters();
 
 }

File: test/distributed/org/apache/cassandra/distributed/impl/InstanceClassLoader.java
Patch:
@@ -39,7 +39,8 @@ public class InstanceClassLoader extends URLClassLoader
                     InetAddressAndPort.class,
                     ParameterizedClass.class,
                     SigarLibrary.class,
-                    IInvokableInstance.class
+                    IInvokableInstance.class,
+                    NetworkTopology.class
             })
             .map(Class::getName)
             .collect(Collectors.toSet());

File: test/distributed/org/apache/cassandra/distributed/impl/IsolatedExecutor.java
Patch:
@@ -77,7 +77,7 @@ public Future<Void> shutdown()
             return t;
         };
         ExecutorService shutdownExecutor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 0, TimeUnit.SECONDS,
-                                                                  new LinkedBlockingQueue<Runnable>(), threadFactory);
+                                                                  new LinkedBlockingQueue<>(), threadFactory);
         return shutdownExecutor.submit(() -> {
             try
             {
@@ -165,7 +165,7 @@ private static Method lookupDeserializeOneObject(ClassLoader classLoader)
     public static Object deserializeOneObject(byte[] bytes)
     {
         try (ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
-             ObjectInputStream ois = new ObjectInputStream(bais);)
+             ObjectInputStream ois = new ObjectInputStream(bais))
         {
             return ois.readObject();
         }
@@ -190,7 +190,7 @@ private static byte[] serializeOneObject(Object object)
         }
     }
 
-    private static <T> T waitOn(Future<T> f)
+    public static <T> T waitOn(Future<T> f)
     {
         try
         {

File: test/distributed/org/apache/cassandra/distributed/test/DistributedReadWritePathTest.java
Patch:
@@ -80,7 +80,7 @@ public void readRepairTest() throws Throwable
             assertRows(cluster.get(3).executeInternal("SELECT * FROM " + KEYSPACE + ".tbl WHERE pk = 1"));
 
             assertRows(cluster.coordinator(1).execute("SELECT * FROM " + KEYSPACE + ".tbl WHERE pk = 1",
-                                                     ConsistencyLevel.QUORUM),
+                                                     ConsistencyLevel.ALL), // ensure node3 in preflist
                        row(1, 1, 1));
 
             // Verify that data got repaired to the third node

File: src/java/org/apache/cassandra/io/compress/CompressedSequentialWriter.java
Patch:
@@ -185,7 +185,10 @@ public synchronized void resetAndTruncate(DataPosition mark)
         // compressed chunk size (- 4 bytes reserved for checksum)
         int chunkSize = (int) (metadataWriter.chunkOffsetBy(realMark.nextChunkIndex) - chunkOffset - 4);
         if (compressed.capacity() < chunkSize)
+        {
+            FileUtils.clean(compressed);
             compressed = compressor.preferredBufferType().allocate(chunkSize);
+        }
 
         try
         {

File: src/java/org/apache/cassandra/tools/nodetool/Snapshot.java
Patch:
@@ -71,7 +71,7 @@ public void execute(NodeProbe probe)
                 else
                 {
                     throw new IOException(
-                            "When specifying the Keyspace columfamily list for a snapshot, you should not specify columnfamily");
+                            "When specifying the Keyspace table list (using -kt,--kt-list,-kc,--kc.list), you must not also specify keyspaces to snapshot");
                 }
                 if (!snapshotName.isEmpty())
                     sb.append(" with snapshot name [").append(snapshotName).append("]");

File: test/unit/org/apache/cassandra/db/LegacyLayoutTest.java
Patch:
@@ -374,8 +374,8 @@ public void testAsymmetricRTBoundSerializedSize()
         ByteBuffer one = Int32Type.instance.decompose(1);
         ByteBuffer two = Int32Type.instance.decompose(2);
         PartitionUpdate p = new PartitionUpdate(table, table.decorateKey(one), table.partitionColumns(), 0);
-        p.add(new RangeTombstone(Slice.make(new Slice.Bound(ClusteringPrefix.Kind.EXCL_START_BOUND, new ByteBuffer[] { one, one }),
-                                            new Slice.Bound(ClusteringPrefix.Kind.INCL_END_BOUND, new ByteBuffer[] { two })),
+        p.add(new RangeTombstone(Slice.make(new ClusteringBound(ClusteringPrefix.Kind.EXCL_START_BOUND, new ByteBuffer[] { one, one }),
+                                            new ClusteringBound(ClusteringPrefix.Kind.INCL_END_BOUND, new ByteBuffer[] { two })),
                                  new DeletionTime(1, 1)
         ));
 

File: src/java/org/apache/cassandra/db/LegacyLayout.java
Patch:
@@ -2598,11 +2598,10 @@ private long serializedSizeCompound(boolean isDense)
 
                 CompositeType.Builder startBuilder = type.builder();
                 CompositeType.Builder endBuilder = type.builder();
-                for (int j = 0; j < start.bound.clustering().size(); j++)
-                {
+                for (int j = 0; j < start.bound.size(); j++)
                     startBuilder.add(start.bound.get(j));
+                for (int j = 0; j < end.bound.size(); j++)
                     endBuilder.add(end.bound.get(j));
-                }
 
                 if (start.collectionName != null)
                     startBuilder.add(start.collectionName.name.bytes);

File: test/unit/org/apache/cassandra/cql3/validation/entities/CollectionsTest.java
Patch:
@@ -593,13 +593,13 @@ public void testDropAndReaddCollection() throws Throwable
     }
 
     @Test
-    public void testDropAndReaddDroppedCollection() throws Throwable
+    public void testDropAndReaddFrozenCollection() throws Throwable
     {
         createTable("create table %s (k int primary key, v frozen<set<text>>, x int)");
         execute("insert into %s (k, v) VALUES (0, {'fffffffff'})");
         flush();
         execute("alter table %s drop v");
-        execute("alter table %s add v set<int>");
+        assertInvalid("alter table %s add v frozen<set<int>>");
     }
 
     @Test

File: src/java/org/apache/cassandra/cql3/statements/schema/AlterTableStatement.java
Patch:
@@ -166,7 +166,7 @@ private void addColumn(KeyspaceMetadata keyspace,
             {
                 // After #8099, not safe to re-add columns of incompatible types - until *maybe* deser logic with dropped
                 // columns is pushed deeper down the line. The latter would still be problematic in cases of schema races.
-                if (!droppedColumn.type.isValueCompatibleWith(type))
+                if (!type.isValueCompatibleWith(droppedColumn.type))
                 {
                     throw ire("Cannot re-add previously dropped column '%s' of type %s, incompatible with previous type %s",
                               name,

File: src/java/org/apache/cassandra/db/virtual/SystemViewsKeyspace.java
Patch:
@@ -34,7 +34,7 @@ private SystemViewsKeyspace()
                     .add(new SSTableTasksTable(NAME))
                     .add(new ThreadPoolsTable(NAME))
                     .add(new InternodeOutboundTable(NAME))
-                    .add(new InternodeOutboundTable(NAME))
+                    .add(new InternodeInboundTable(NAME))
                     .addAll(TableMetricTables.getAll(NAME))
                     .build());
     }

File: src/java/org/apache/cassandra/utils/MerkleTree.java
Patch:
@@ -313,7 +313,7 @@ static int differenceHelper(MerkleTree ltree, MerkleTree rtree, List<TreeRange>
         }
         else if (!lreso)
         {
-            logger.debug("({}) Left sub-range fully inconsistent {}", active.depth, right);
+            logger.debug("({}) Left sub-range fully inconsistent {}", active.depth, left);
             ldiff = FULLY_INCONSISTENT;
         }
 

File: src/java/org/apache/cassandra/net/ShareableBytes.java
Patch:
@@ -40,14 +40,14 @@ class ShareableBytes
     private static final AtomicIntegerFieldUpdater<ShareableBytes> countUpdater =
         AtomicIntegerFieldUpdater.newUpdater(ShareableBytes.class, "count");
 
-    ShareableBytes(ByteBuffer bytes)
+    private ShareableBytes(ByteBuffer bytes)
     {
         this.count = UNSHARED;
         this.owner = this;
         this.bytes = bytes;
     }
 
-    ShareableBytes(ShareableBytes owner, ByteBuffer bytes)
+    private ShareableBytes(ShareableBytes owner, ByteBuffer bytes)
     {
         this.owner = owner;
         this.bytes = bytes;

File: test/unit/org/apache/cassandra/db/filter/RowFilterTest.java
Patch:
@@ -25,6 +25,7 @@
 import org.junit.Assert;
 import org.junit.Test;
 
+import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.ColumnDefinition;
 import org.apache.cassandra.cql3.ColumnIdentifier;
@@ -54,6 +55,7 @@ public class RowFilterTest
     public void testCQLFilterClose()
     {
         // CASSANDRA-15126
+        SchemaLoader.prepareServer();
         CFMetaData metadata = CFMetaData.Builder.create("testks", "testcf")
                                                 .addPartitionKey("pk", Int32Type.instance)
                                                 .addStaticColumn("s", Int32Type.instance)

File: test/distributed/org/apache/cassandra/distributed/impl/AbstractCluster.java
Patch:
@@ -141,7 +141,7 @@ public synchronized void startup()
         {
             if (!isShutdown)
                 throw new IllegalStateException();
-            delegate.startup(AbstractCluster.this);
+            delegate().startup(AbstractCluster.this);
             isShutdown = false;
             updateMessagingVersions();
         }

File: test/unit/org/apache/cassandra/gms/GossiperTest.java
Patch:
@@ -47,6 +47,7 @@ public class GossiperTest
 {
     static
     {
+        System.setProperty(Gossiper.Props.DISABLE_THREAD_VALIDATION, "true");
         DatabaseDescriptor.setDaemonInitialized();
     }
     static final IPartitioner partitioner = new RandomPartitioner();

File: test/unit/org/apache/cassandra/gms/PendingRangeCalculatorServiceTest.java
Patch:
@@ -55,6 +55,7 @@ public class PendingRangeCalculatorServiceTest
     @BeforeClass
     public static void setUp() throws ConfigurationException
     {
+        System.setProperty(Gossiper.Props.DISABLE_THREAD_VALIDATION, "true");
         SchemaLoader.prepareServer();
         StorageService.instance.initServer();
     }

File: test/unit/org/apache/cassandra/locator/CloudstackSnitchTest.java
Patch:
@@ -45,6 +45,7 @@ public class CloudstackSnitchTest
     @BeforeClass
     public static void setup() throws Exception
     {
+        System.setProperty(Gossiper.Props.DISABLE_THREAD_VALIDATION, "true");
         DatabaseDescriptor.setDaemonInitialized();
         SchemaLoader.mkdirs();
         SchemaLoader.cleanup();

File: test/unit/org/apache/cassandra/locator/EC2SnitchTest.java
Patch:
@@ -50,6 +50,7 @@ public class EC2SnitchTest
     @BeforeClass
     public static void setup() throws Exception
     {
+        System.setProperty(Gossiper.Props.DISABLE_THREAD_VALIDATION, "true");
         DatabaseDescriptor.setDaemonInitialized();
         SchemaLoader.mkdirs();
         SchemaLoader.cleanup();

File: test/unit/org/apache/cassandra/locator/GoogleCloudSnitchTest.java
Patch:
@@ -46,6 +46,7 @@ public class GoogleCloudSnitchTest
     @BeforeClass
     public static void setup() throws Exception
     {
+        System.setProperty(Gossiper.Props.DISABLE_THREAD_VALIDATION, "true");
         DatabaseDescriptor.setDaemonInitialized();
         SchemaLoader.mkdirs();
         SchemaLoader.cleanup();

File: test/unit/org/apache/cassandra/locator/PropertyFileSnitchTest.java
Patch:
@@ -64,6 +64,7 @@ public class PropertyFileSnitchTest
     @Before
     public void setup() throws ConfigurationException, IOException
     {
+        System.setProperty(Gossiper.Props.DISABLE_THREAD_VALIDATION, "true");
         String confFile = FBUtilities.resourceToFile(PropertyFileSnitch.SNITCH_PROPERTIES_FILENAME);
         effectiveFile = Paths.get(confFile);
         backupFile = Paths.get(confFile + ".bak");

File: src/java/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -856,6 +856,8 @@ public ReadCommand deserialize(DataInputPlus in, int version) throws IOException
                 limits = DataLimits.distinctLimits(maxResults);
             else if (compositesToGroup == -1)
                 limits = DataLimits.thriftLimits(maxResults, perPartitionLimit);
+            else if (metadata.isStaticCompactTable())
+                limits = DataLimits.legacyCompactStaticCqlLimits(maxResults);
             else
                 limits = DataLimits.cqlLimits(maxResults);
 

File: src/java/org/apache/cassandra/tools/nodetool/stats/TableStatsPrinter.java
Patch:
@@ -59,7 +59,7 @@ public void print(TableStatsHolder data, PrintStream out)
                 List<StatsTable> tables = keyspace.tables;
                 for (StatsTable table : tables)
                 {
-                    out.println("\t\tTable" + (table.isIndex ? " (index): " + table.name : ": ") + table.name);
+                    out.println("\t\tTable" + (table.isIndex ? " (index): " : ": ") + table.name);
                     out.println("\t\tSSTable count: " + table.sstableCount);
                     if (table.isLeveledSstable)
                         out.println("\t\tSSTables in each level: [" + String.join(", ",

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -1751,7 +1751,8 @@ public void interruptCompactionFor(Iterable<CFMetaData> columnFamilies, boolean
             if ((info.getTaskType() == OperationType.VALIDATION) && !interruptValidation)
                 continue;
 
-            if (Iterables.contains(columnFamilies, info.getCFMetaData()))
+            // cfmetadata is null for index summary redistributions which are 'global' - they involve all keyspaces/tables
+            if (info.getCFMetaData() == null || Iterables.contains(columnFamilies, info.getCFMetaData()))
                 compactionHolder.stop(); // signal compaction to stop
         }
     }

File: test/distributed/org/apache/cassandra/distributed/api/IInstance.java
Patch:
@@ -21,6 +21,7 @@
 import org.apache.cassandra.locator.InetAddressAndPort;
 
 import java.util.UUID;
+import java.util.concurrent.Future;
 
 // The cross-version API requires that an Instance has a constructor signature of (IInstanceConfig, ClassLoader)
 public interface IInstance extends IIsolatedExecutor
@@ -36,7 +37,7 @@ public interface IInstance extends IIsolatedExecutor
     UUID schemaVersion();
 
     void startup();
-    void shutdown();
+    Future<Void> shutdown();
 
     // these methods are not for external use, but for simplicity we leave them public and on the normal IInstance interface
     void startup(ICluster cluster);

File: test/distributed/org/apache/cassandra/distributed/api/IIsolatedExecutor.java
Patch:
@@ -20,7 +20,6 @@
 
 import java.io.Serializable;
 import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Future;
 import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
@@ -52,7 +51,7 @@ public interface TriFunction<I1, I2, I3, O>
     }
     public interface SerializableTriFunction<I1, I2, I3, O> extends Serializable, TriFunction<I1, I2, I3, O> { }
 
-    void shutdown();
+    Future<Void> shutdown();
 
     /**
      * Convert the execution to one performed asynchronously on the IsolatedExecutor, returning a Future of the execution result

File: test/distributed/org/apache/cassandra/distributed/impl/DelegatingInvokableInstance.java
Patch:
@@ -92,9 +92,9 @@ public IListen listen()
     }
 
     @Override
-    public void shutdown()
+    public Future<Void> shutdown()
     {
-        delegate().shutdown();
+        return delegate().shutdown();
     }
 
     @Override

File: src/java/org/apache/cassandra/db/LegacyLayout.java
Patch:
@@ -1127,7 +1127,7 @@ public static LegacyAtom readLegacyAtom(CFMetaData metadata, DataInputPlus in, b
                 throw new IllegalStateException(String.format("Got cell for unknown column %s in sstable of %s.%s: " +
                                                               "This suggest a problem with the schema which doesn't list " +
                                                               "this column. Even if that column was dropped, it should have " +
-                                                              "been listed as such", metadata.ksName, metadata.cfName, UTF8Type.instance.compose(e.columnName)), e);
+                                                              "been listed as such", UTF8Type.instance.compose(e.columnName), metadata.ksName, metadata.cfName), e);
 
             throw e;
         }

File: src/java/org/apache/cassandra/repair/KeyspaceRepairManager.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.Collection;
 import java.util.UUID;
 import java.util.concurrent.ExecutorService;
+import java.util.function.BooleanSupplier;
 
 import com.google.common.util.concurrent.ListenableFuture;
 
@@ -40,5 +41,6 @@ public interface KeyspaceRepairManager
     ListenableFuture prepareIncrementalRepair(UUID sessionID,
                                               Collection<ColumnFamilyStore> tables,
                                               RangesAtEndpoint tokenRanges,
-                                              ExecutorService executor);
+                                              ExecutorService executor,
+                                              BooleanSupplier isCancelled);
 }

File: test/unit/org/apache/cassandra/db/compaction/AntiCompactionBytemanTest.java
Patch:
@@ -125,7 +125,7 @@ public void testRedundantTransitions() throws Throwable
 
         try (LifecycleTransaction txn = getCurrentColumnFamilyStore().getTracker().tryModify(getCurrentColumnFamilyStore().getLiveSSTables(), OperationType.ANTICOMPACTION))
         {
-            CompactionManager.instance.antiCompactGroup(getCurrentColumnFamilyStore(), ranges, txn, UUID.randomUUID());
+            CompactionManager.instance.antiCompactGroup(getCurrentColumnFamilyStore(), ranges, txn, UUID.randomUUID(), () -> false);
         }
         finished.set(true);
         t.join();

File: test/unit/org/apache/cassandra/db/compaction/CancelCompactionsTest.java
Patch:
@@ -259,7 +259,7 @@ public void testAnticompaction() throws InterruptedException, ExecutionException
             InetAddressAndPort local = FBUtilities.getBroadcastAddressAndPort();
             RangesAtEndpoint rae = RangesAtEndpoint.builder(local).add(new Replica(local, range, true)).build();
 
-            PendingAntiCompaction pac = new PendingAntiCompaction(prsid, Collections.singleton(cfs), rae, Executors.newSingleThreadExecutor());
+            PendingAntiCompaction pac = new PendingAntiCompaction(prsid, Collections.singleton(cfs), rae, Executors.newSingleThreadExecutor(), () -> false);
             Future<?> fut = pac.run();
             Thread.sleep(600);
             List<TestCompactionTask> toAbort = new ArrayList<>();

File: test/unit/org/apache/cassandra/db/repair/PendingAntiCompactionBytemanTest.java
Patch:
@@ -67,7 +67,7 @@ public void testExceptionAnticompaction() throws InterruptedException
         UUID prsid = prepareSession();
         try
         {
-            PendingAntiCompaction pac = new PendingAntiCompaction(prsid, Lists.newArrayList(cfs, cfs2), atEndpoint(ranges, NO_RANGES), es);
+            PendingAntiCompaction pac = new PendingAntiCompaction(prsid, Lists.newArrayList(cfs, cfs2), atEndpoint(ranges, NO_RANGES), es, () -> false);
             pac.run().get();
             fail("PAC should throw exception when anticompaction throws exception!");
         }

File: src/java/org/apache/cassandra/repair/CommonRange.java
Patch:
@@ -41,10 +41,10 @@ public class CommonRange
 
     public CommonRange(Set<InetAddressAndPort> endpoints, Set<InetAddressAndPort> transEndpoints, Collection<Range<Token>> ranges)
     {
-        Preconditions.checkArgument(endpoints != null && !endpoints.isEmpty());
-        Preconditions.checkArgument(transEndpoints != null);
+        Preconditions.checkArgument(endpoints != null && !endpoints.isEmpty(), "Endpoints can not be empty");
+        Preconditions.checkArgument(transEndpoints != null, "Transient endpoints can not be null");
         Preconditions.checkArgument(endpoints.containsAll(transEndpoints), "transEndpoints must be a subset of endpoints");
-        Preconditions.checkArgument(ranges != null && !ranges.isEmpty());
+        Preconditions.checkArgument(ranges != null && !ranges.isEmpty(), "Ranges can not be empty");
 
         this.endpoints = ImmutableSet.copyOf(endpoints);
         this.transEndpoints = ImmutableSet.copyOf(transEndpoints);

File: src/java/org/apache/cassandra/audit/AuditEvent.java
Patch:
@@ -26,7 +26,7 @@
 import org.apache.cassandra.diag.DiagnosticEventService;
 
 /**
- * {@Link AuditLogEntry} wrapper to expose audit events as {@link DiagnosticEvent}s.
+ * {@link AuditLogEntry} wrapper to expose audit events as {@link DiagnosticEvent}s.
  */
 public final class AuditEvent extends DiagnosticEvent
 {

File: src/java/org/apache/cassandra/audit/AuditLogFilter.java
Patch:
@@ -50,6 +50,9 @@ private AuditLogFilter(ImmutableSet<String> excludedKeyspaces, ImmutableSet<Stri
 
     /**
      * (Re-)Loads filters from config. Called during startup as well as JMX invocations.
+     *
+     * @param auditLogOptions
+     * @return
      */
     public static AuditLogFilter create(AuditLogOptions auditLogOptions)
     {

File: src/java/org/apache/cassandra/auth/Role.java
Patch:
@@ -30,8 +30,8 @@ public class Role
     /**
      * Represents a user or group in the auth subsystem.
      * Roles may be members of other roles, but circular graphs of roles are not permitted.
-     * The reason that memberOf is a Set<String> and not Set<Role> is to simplify loading
-     * for IRoleManager implementations (in particular, CassandraRoleManager)
+     * The reason that memberOf is a {@code Set<String>} and not {@code Set<Role>} is to simplify loading
+     * for {@link IRoleManager} implementations (in particular, {@link CassandraRoleManager})
      */
 
     public final RoleResource resource ;

File: src/java/org/apache/cassandra/auth/Roles.java
Patch:
@@ -70,7 +70,7 @@ public static Set<RoleResource> getRoles(RoleResource primaryRole)
      * Get detailed info on all the roles granted to the role identified by the supplied RoleResource.
      * This includes superuser status and login privileges for the primary role and all roles granted directly
      * to it or inherited.
-     * The returnred roles may be cached if roles_validity_in_ms > 0
+     * The returnred roles may be cached if {@code roles_validity_in_ms > 0}
      * This method is used where we need to know specific attributes of the collection of granted roles, i.e.
      * when checking for superuser status which may be inherited from *any* granted role.
      *
@@ -117,7 +117,7 @@ public static boolean canLogin(final RoleResource role)
      * Returns the map of custom options for the named role. These options are not inherited from granted roles, but
      * are set directly.
      * @param role the role identifier
-     * @return map of option_name -> value. If no options are set for the named role, the map will be empty
+     * @return map of {@code option_name -> value}. If no options are set for the named role, the map will be empty
      * but never null.
      */
     public static Map<String, String> getOptions(RoleResource role)

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -423,8 +423,8 @@ public class Config
 
     /**
      * flags for enabling tracking repaired state of data during reads
-     * separate flags for range & single partition reads as single partition reads are only tracked
-     * when CL > 1 and a digest mismatch occurs. Currently, range queries don't use digests so if
+     * separate flags for range &amp; single partition reads as single partition reads are only tracked
+     * when {@code CL > 1} and a digest mismatch occurs. Currently, range queries don't use digests so if
      * enabled for range reads, all such reads will include repaired data tracking. As this adds
      * some overhead, operators may wish to disable it whilst still enabling it for partition reads
      */

File: src/java/org/apache/cassandra/cql3/Terms.java
Patch:
@@ -197,7 +197,7 @@ public List<Terminal> bind(QueryOptions options)
     /**
      * Creates a {@code Terms} containing a set of {@code Term}.
      *
-     * @param term the {@code Term}
+     * @param terms {@code List<Term>}
      * @return a {@code Terms} containing a set of {@code Term}.
      */
     public static Terms of(final List<Term> terms)

File: src/java/org/apache/cassandra/cql3/functions/TimeFcts.java
Patch:
@@ -92,7 +92,7 @@ public ByteBuffer execute(ProtocolVersion protocolVersion, List<ByteBuffer> para
 
     /**
      * Function that convert a value of <code>TIMEUUID</code> into a value of type <code>TIMESTAMP</code>.
-     * @deprecated Replaced by the {@link #timeUuidToTimestamp} function
+     * @deprecated Replaced by the {@link #toUnixTimestamp} function
      */
     public static final NativeScalarFunction dateOfFct = new NativeScalarFunction("dateof", TimestampType.instance, TimeUUIDType.instance)
     {
@@ -118,7 +118,7 @@ public ByteBuffer execute(ProtocolVersion protocolVersion, List<ByteBuffer> para
 
     /**
      * Function that convert a value of type <code>TIMEUUID</code> into an UNIX timestamp.
-     * @deprecated Replaced by the {@link #timeUuidToUnixTimestamp} function
+     * @deprecated Replaced by the {@link #toUnixTimestamp} function
      */
     public static final NativeScalarFunction unixTimestampOfFct = new NativeScalarFunction("unixtimestampof", LongType.instance, TimeUUIDType.instance)
     {

File: src/java/org/apache/cassandra/cql3/selection/Selector.java
Patch:
@@ -108,7 +108,6 @@ public boolean isTTLSelectorFactory()
         /**
          * Checks if this factory creates <code>Selector</code>s that simply return a column value.
          *
-         * @param index the column index
          * @return <code>true</code> if this factory creates <code>Selector</code>s that simply return a column value,
          * <code>false</code> otherwise.
          */

File: src/java/org/apache/cassandra/cql3/statements/schema/AlterTableStatement.java
Patch:
@@ -90,7 +90,7 @@ public String toString()
     abstract KeyspaceMetadata apply(KeyspaceMetadata keyspace, TableMetadata table);
 
     /**
-     * ALTER TABLE <table> ALTER <column> TYPE <newtype>;
+     * {@code ALTER TABLE <table> ALTER <column> TYPE <newtype>;}
      *
      * No longer supported.
      */

File: src/java/org/apache/cassandra/db/ColumnFamilyStoreMBean.java
Patch:
@@ -152,7 +152,6 @@ public interface ColumnFamilyStoreMBean
      * @param verifySSTables if the new sstables should be verified that they are not corrupt
      * @param verifyTokens if the tokens in the new sstables should be verified that they are owned by the current node
      * @param invalidateCaches if row cache should be invalidated for the keys in the new sstables
-     * @param jbodCheck if the new sstables should be placed 'optimally' - count tokens and move the sstable to the directory where it has the most keys
      * @param extendedVerify if we should run an extended verify checking all values in the new sstables
      *
      * @return list of failed import directories

File: src/java/org/apache/cassandra/db/LivenessInfo.java
Patch:
@@ -183,11 +183,11 @@ public int dataSize()
      * Whether this liveness information supersedes another one (that is
      * whether is has a greater timestamp than the other or not).
      *
-     * </br>
+     * <br>
      *
      * If timestamps are the same and none of them are expired livenessInfo,
      * livenessInfo with greater TTL supersedes another. It also means, if timestamps are the same,
-     * ttl superseders no-ttl. This is the same rule as {@link Conflicts#resolveRegular}
+     * ttl superseders no-ttl. This is the same rule as {@link org.apache.cassandra.db.rows.Cells#resolveRegular}
      *
      * If timestamps are the same and one of them is expired livenessInfo. Expired livenessInfo
      * supersedes, ie. tombstone supersedes.

File: src/java/org/apache/cassandra/db/compaction/ActiveCompactions.java
Patch:
@@ -51,7 +51,7 @@ public void finishCompaction(CompactionInfo.Holder ci)
     /**
      * Iterates over the active compactions and tries to find the CompactionInfo for the given sstable
      *
-     * Number of entries in compactions should be small (< 10) but avoid calling in any time-sensitive context
+     * Number of entries in compactions should be small ({@code < 10}) but avoid calling in any time-sensitive context
      */
     public CompactionInfo getCompactionForSSTable(SSTableReader sstable)
     {

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -717,7 +717,6 @@ private static void mutateFullyContainedSSTables(ColumnFamilyStore cfs,
      * @param replicas token ranges to be repaired
      * @param validatedForRepair SSTables containing the repaired ranges. Should be referenced before passing them.
      * @param sessionID the repair session we're anti-compacting for
-     * @throws InterruptedException
      * @throws IOException
      */
     public void performAnticompaction(ColumnFamilyStore cfs,

File: src/java/org/apache/cassandra/db/filter/DataLimits.java
Patch:
@@ -155,7 +155,7 @@ public abstract boolean hasEnoughLiveData(CachedPartition cached,
      * @param countPartitionsWithOnlyStaticData if {@code true} the partitions with only static data should be counted
      * as 1 valid row.
      * @param enforceStrictLiveness whether the row should be purged if there is no PK liveness info,
-     *                              normally retrieved from {@link CFMetaData#enforceStrictLiveness()}
+     *                              normally retrieved from {@link org.apache.cassandra.schema.TableMetadata#enforceStrictLiveness()}
      * @return a new {@code Counter} for this limits.
      */
     public abstract Counter newCounter(int nowInSec,

File: src/java/org/apache/cassandra/db/rows/BTreeRow.java
Patch:
@@ -379,7 +379,7 @@ public boolean hasDeletion(int nowInSec)
      * Returns a copy of the row where all timestamps for live data have replaced by {@code newTimestamp} and
      * all deletion timestamp by {@code newTimestamp - 1}.
      *
-     * This exists for the Paxos path, see {@link PartitionUpdate#updateAllTimestamp} for additional details.
+     * This exists for the Paxos path, see {@link PartitionUpdate.Builder#updateAllTimestamp(long)} for additional details.
      */
     public Row updateAllTimestamp(long newTimestamp)
     {

File: src/java/org/apache/cassandra/db/rows/ColumnData.java
Patch:
@@ -83,7 +83,7 @@ protected ColumnData(ColumnMetadata column)
      * Returns a copy of the data where all timestamps for live data have replaced by {@code newTimestamp} and
      * all deletion timestamp by {@code newTimestamp - 1}.
      *
-     * This exists for the Paxos path, see {@link PartitionUpdate#updateAllTimestamp} for additional details.
+     * This exists for the Paxos path, see {@link PartitionUpdate.Builder#updateAllTimestamp} for additional details.
      */
     public abstract ColumnData updateAllTimestamp(long newTimestamp);
 

File: src/java/org/apache/cassandra/db/rows/Row.java
Patch:
@@ -115,7 +115,7 @@ public interface Row extends Unfiltered, Iterable<ColumnData>
      * 
      * @param nowInSec the current time to decide what is deleted and what isn't
      * @param enforceStrictLiveness whether the row should be purged if there is no PK liveness info,
-     *                              normally retrieved from {@link CFMetaData#enforceStrictLiveness()}
+     *                              normally retrieved from {@link TableMetadata#enforceStrictLiveness()}
      * @return true if there is some live information
      */
     public boolean hasLiveData(int nowInSec, boolean enforceStrictLiveness);

File: src/java/org/apache/cassandra/db/rows/ThrottledUnfilteredIterator.java
Patch:
@@ -30,7 +30,7 @@
 import com.google.common.annotations.VisibleForTesting;
 
 /**
- * A utility class to split the given {@link#UnfilteredRowIterator} into smaller chunks each
+ * A utility class to split the given {@link UnfilteredRowIterator} into smaller chunks each
  * having at most {@link #throttle} + 1 unfiltereds.
  *
  * Only the first output contains partition level info: {@link UnfilteredRowIterator#partitionLevelDeletion}
@@ -41,7 +41,7 @@
  *
  * The lifecycle of outputed {{@link UnfilteredRowIterator} only last till next call to {@link #next()}.
  *
- * A subsequent {@link #next} call will exhaust the previously returned iterator before computing the next,
+ * A subsequent {@link ThrottledUnfilteredIterator#next} call will exhaust the previously returned iterator before computing the next,
  * effectively skipping unfiltereds up to the throttle size.
  *
  * Closing this iterator will close the underlying iterator.

File: src/java/org/apache/cassandra/db/rows/Unfiltered.java
Patch:
@@ -41,7 +41,7 @@ public enum Kind { ROW, RANGE_TOMBSTONE_MARKER };
     /**
      * Digest the atom using the provided {@link Hasher}.
      *
-     * @param hasher the {@see Hasher} to use.
+     * @param hasher the {@link Hasher} to use.
      */
     public void digest(Hasher hasher);
 

File: src/java/org/apache/cassandra/dht/RangeFetchMapCalculator.java
Patch:
@@ -62,9 +62,9 @@
  *   - if we have more machines than ranges to stream the capacity will be 1 (each machine will stream at most 1 range)
  * * Since the sum of the capacity on the edges from the super source to the range-vertices is less or equal to the sum
  *   of the capacities between the node-vertices and super sink we know that to get maximum flow we will use all the
- *   range-vertices. (Say we have x ranges, y machines to provide them, total supersource -> range-vertice capacity will be x,
- *   total node-vertice -> supersink capacity will be (y * ceil(x / y)) which worst case is x if x==y). The capacity between
- *   the range-vertices and node-vertices is infinite.
+ *   range-vertices. (Say we have x ranges, y machines to provide them, total {@code supersource -> range-vertice capacity} will be x,
+ *   total {@code node-vertice -> supersink} capacity will be {@code(y * ceil(x / y))} which worst case is x {@code if
+ *   x==y)}. The capacity between the range-vertices and node-vertices is infinite.
  * * Then we try to solve the max-flow problem using psjava
  * * If we can't find a solution where the total flow is = number of range-vertices, we bump the capacity between the node-vertices
  *   and the super source and try again.

File: src/java/org/apache/cassandra/diag/DiagnosticEvent.java
Patch:
@@ -45,6 +45,8 @@ public abstract class DiagnosticEvent
      * maps, but must be Serializable, as returned values may be consumed by external clients. It's strongly recommended
      * to stick to standard Java classes to avoid distributing custom classes to clients and also prevent potential
      * class versioning conflicts.
+     *
+     * @return Returns map of key-value pairs containing relevant event details.
      */
     public abstract Map<String, Serializable> toMap();
 }

File: src/java/org/apache/cassandra/diag/LastEventIdBroadcasterMBean.java
Patch:
@@ -6,9 +6,8 @@
  * Provides a list of event types and the corresponding highest event IDs. Consumers may these IDs to determine
  * if new data is available.
  *
- * <p>Example result</p>
- *
  * <table>
+ *     <caption>Example result</caption>
  *     <tr>
  *         <th>Event</th>
  *         <th>Last ID</th>

File: src/java/org/apache/cassandra/hadoop/cql3/CqlOutputFormat.java
Patch:
@@ -34,8 +34,7 @@
  * table.
  *
  * <p>
- * As is the case with the {@link org.apache.cassandra.hadoop.ColumnFamilyInputFormat}, 
- * you need to set the prepared statement in your
+ * You need to set the prepared statement in your
  * Hadoop job Configuration. The {@link CqlConfigHelper} class, through its
  * {@link CqlConfigHelper#setOutputCql} method, is provided to make this
  * simple.

File: src/java/org/apache/cassandra/index/SecondaryIndexManager.java
Patch:
@@ -110,7 +110,7 @@
  * a target replica.
  * <br><br>
  * Finally, this class provides a clear and safe lifecycle to manage index builds, either full rebuilds via
- * {@link this#rebuildIndexesBlocking(Set)} or builds of new sstables
+ * {@link SecondaryIndexManager#rebuildIndexesBlocking} or builds of new sstables
  * added via {@link org.apache.cassandra.notifications.SSTableAddedNotification}s, guaranteeing
  * the following:
  * <ul>

File: src/java/org/apache/cassandra/index/sasi/analyzer/StandardTokenizerInterface.java
Patch:
@@ -57,7 +57,7 @@ public interface StandardTokenizerInterface
      *
      * All internal variables are reset, the old input stream
      * <b>cannot</b> be reused (internal buffer is discarded and lost).
-     * Lexical state is set to <tt>ZZ_INITIAL</tt>.
+     * Lexical state is set to <code>{@literal ZZ_INITIAL}</code>.
      *
      * @param reader   the new input stream
      */

File: src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java
Patch:
@@ -394,7 +394,7 @@ public static SSTableReader openNoValidation(Descriptor descriptor, TableMetadat
      * @param components
      * @param metadata
      * @return opened SSTableReader
-     * @throws IOException
+     * @throws CorruptSSTableException
      */
     public static SSTableReader openForBatch(Descriptor descriptor, Set<Component> components, TableMetadataRef metadata)
     {
@@ -477,7 +477,7 @@ public static SSTableReader openForBatch(Descriptor descriptor, Set<Component> c
      * @param isOffline Whether we are opening this SSTable "offline", for example from an external tool or not for inclusion in queries (validations)
      *                  This stops regenerating BF + Summaries and also disables tracking of hotness for the SSTable.
      * @return {@link SSTableReader}
-     * @throws IOException
+     * @throws CorruptSSTableException
      */
     public static SSTableReader open(Descriptor descriptor,
                                      Set<Component> components,

File: src/java/org/apache/cassandra/locator/AbstractEndpointSnitch.java
Patch:
@@ -25,10 +25,10 @@ public abstract class AbstractEndpointSnitch implements IEndpointSnitch
     public abstract int compareEndpoints(InetAddressAndPort target, Replica r1, Replica r2);
 
     /**
-     * Sorts the <tt>Collection</tt> of node addresses by proximity to the given address
+     * Sorts the <code>{@literal Collection}</code> of node addresses by proximity to the given address
      * @param address the address to sort by proximity to
      * @param unsortedAddress the nodes to sort
-     * @return a new sorted <tt>List</tt>
+     * @return a new sorted <code>{@literal List}</code>
      */
     public <C extends ReplicaCollection<? extends C>> C sortedByProximity(final InetAddressAndPort address, C unsortedAddress)
     {

File: src/java/org/apache/cassandra/locator/IEndpointSnitch.java
Patch:
@@ -61,7 +61,7 @@ default public String getDatacenter(Replica replica)
     }
 
     /**
-     * returns a new <tt>List</tt> sorted by proximity to the given endpoint
+     * returns a new <code>{@literal List}</code> sorted by proximity to the given endpoint
      */
     public <C extends ReplicaCollection<? extends C>> C sortedByProximity(final InetAddressAndPort address, C addresses);
 

File: src/java/org/apache/cassandra/locator/TokenMetadata.java
Patch:
@@ -57,7 +57,7 @@ public class TokenMetadata
     /** Maintains endpoint to host ID map of every node in the cluster */
     private final BiMap<InetAddressAndPort, UUID> endpointToHostIdMap;
 
-    // Prior to CASSANDRA-603, we just had <tt>Map<Range, InetAddressAndPort> pendingRanges<tt>,
+    // Prior to CASSANDRA-603, we just had <code>{@literal Map<Range, InetAddressAndPort> pendingRanges}</code>,
     // which was added to when a node began bootstrap and removed from when it finished.
     //
     // This is inadequate when multiple changes are allowed simultaneously.  For example,
@@ -70,8 +70,8 @@ public class TokenMetadata
     //
     // So, we made two changes:
     //
-    // First, we changed pendingRanges to a <tt>Multimap<Range, InetAddressAndPort></tt> (now
-    // <tt>Map<String, Multimap<Range, InetAddressAndPort>></tt>, because replication strategy
+    // First, we changed pendingRanges to a <code>{@literal Multimap<Range, InetAddressAndPort>}</code> (now
+    // <code>{@literal Map<String, Multimap<Range, InetAddressAndPort>>}</code>, because replication strategy
     // and options are per-KeySpace).
     //
     // Second, we added the bootstrapTokens and leavingEndpoints collections, so we can

File: src/java/org/apache/cassandra/metrics/KeyspaceMetrics.java
Patch:
@@ -135,7 +135,7 @@ public class KeyspaceMetrics
      */
     public final Meter confirmedRepairedInconsistencies;
     /**
-     * Incremented where an inconsistency is detected, but there are pending & uncommitted repair sessions
+     * Incremented where an inconsistency is detected, but there are pending &amp; uncommitted repair sessions
      * in play on at least one replica. This may indicate a false positive as the inconsistency could be due to
      * replicas marking the repair session as committed at slightly different times and so some consider it to
      * be part of the repaired set whilst others do not.

File: src/java/org/apache/cassandra/net/MessageOut.java
Patch:
@@ -74,7 +74,7 @@
  * encoded as two bytes, followed by the UTF-8 byte encoding of the string (see {@link java.io.DataOutput#writeUTF(java.lang.String)}).
  * The body is serialized with it's length, encoded as four bytes, followed by the bytes of the value.
  *
- * * @param <T> The type of the message payload.
+ * @param <T> The type of the message payload.
  */
 public class MessageOut<T>
 {

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -1624,7 +1624,7 @@ public static void validatePartitioner(AbstractBounds<?> bounds)
     }
 
     /**
-     * This method is used to determine the preferred IP & Port of a peer using the
+     * This method is used to determine the preferred IP &amp; Port of a peer using the
      * {@link OutboundMessagingPool} and SystemKeyspace.
      */
     public InetAddressAndPort getPreferredRemoteAddr(InetAddressAndPort to)

File: src/java/org/apache/cassandra/net/async/NettyFactory.java
Patch:
@@ -359,8 +359,8 @@ public static class OutboundInitializer extends ChannelInitializer<SocketChannel
         /**
          * {@inheritDoc}
          *
-         * To determine if we should enable TLS, we only need to check if {@link #params#encryptionOptions} is set.
-         * The logic for figuring that out is is located in {@link MessagingService#getMessagingConnection(InetAddress)};
+         * To determine if we should enable TLS, we only need to check if {@link #params}'s {@code encryptionOptions} is set.
+         * The logic for figuring that out is is located in {@link MessagingService#getMessagingConnection(InetAddressAndPort)};
          */
         public void initChannel(SocketChannel channel) throws Exception
         {

File: src/java/org/apache/cassandra/repair/consistent/LocalSessions.java
Patch:
@@ -91,7 +91,7 @@
 
 /**
  * Manages all consistent repair sessions a node is participating in.
- * <p/>
+ * <br>
  * Since sessions need to be loaded, and since we need to handle cases where sessions might not exist, most of the logic
  * around local sessions is implemented in this class, with the LocalSession class being treated more like a simple struct,
  * in contrast with {@link CoordinatorSession}

File: src/java/org/apache/cassandra/schema/Schema.java
Patch:
@@ -886,7 +886,7 @@ private void notifyDropAggregate(UDAggregate udf)
 
     /**
      * Converts the given schema version to a string. Returns {@code unknown}, if {@code version} is {@code null}
-     * or {@code "(empty)"}, if {@code version} refers to an {@link SchemaConstants#emptyVersion empty) schema.
+     * or {@code "(empty)"}, if {@code version} refers to an {@link SchemaConstants#emptyVersion} empty) schema.
      */
     public static String schemaVersionToString(UUID version)
     {

File: src/java/org/apache/cassandra/service/EmbeddedCassandraService.java
Patch:
@@ -24,7 +24,6 @@
  * This kind of service is useful when running unit tests of
  * services using cassandra for example.
  *
- * See {@link org.apache.cassandra.service.EmbeddedCassandraServiceTest} for usage.
  * <p>
  * This is the implementation of https://issues.apache.org/jira/browse/CASSANDRA-740
  * <p>

File: src/java/org/apache/cassandra/service/StorageServiceMBean.java
Patch:
@@ -362,7 +362,7 @@ public interface StorageServiceMBean extends NotificationEmitter
     /**
      * Get the status of a given parent repair session.
      * @param cmd the int reference returned when issuing the repair
-     * @return status of parent repair from enum {@link org.apache.cassandra.repair.RepairRunnable.Status}
+     * @return status of parent repair from enum {@link org.apache.cassandra.service.ActiveRepairService.ParentRepairStatus}
      * followed by final message or messages of the session
      */
     @Nullable

File: src/java/org/apache/cassandra/tools/NodeProbe.java
Patch:
@@ -1590,7 +1590,8 @@ public Object getCompactionMetric(String metricName)
 
     /**
      * Retrieve Proxy metrics
-     * @param connections, connectedNativeClients, connectedNativeClientsByUser, clientsByProtocolVersion
+     * @param metricName valid values include (connections, connectedNativeClients, connectedNativeClientsByUser,
+     *                   clientsByProtocolVersion)
      */
     public Object getClientMetric(String metricName)
     {

File: src/java/org/apache/cassandra/transport/frame/FrameBodyTransformer.java
Patch:
@@ -48,7 +48,7 @@ public interface FrameBodyTransformer
 
     /**
      * Returns an EnumSet of the flags that should be added to the header for any message whose frame body has been
-     * modified by the transformer. E.g. it may add perform chunking & checksumming to the frame body,
+     * modified by the transformer. E.g. it may add perform chunking &amp; checksumming to the frame body,
      * compress it, or both.
      * @return EnumSet containing the header flags to set on messages transformed
      */

File: src/java/org/apache/cassandra/utils/CoalescingStrategies.java
Patch:
@@ -100,7 +100,7 @@ static long determineCoalescingTime(long averageGap, long maxCoalesceWindow)
      * {@link #currentCoalescingTimeNanos()}.
      * <p>
      * Note that it is expected that a call {@link #currentCoalescingTimeNanos()} will come just after a call to
-     * {@link #newArrival(Coalescable))}, as the intent of the value returned by the former method is "Given a new message, how much
+     * {@link #newArrival(Coalescable)}, as the intent of the value returned by the former method is "Given a new message, how much
      * time should I wait for more messages to arrive and be coalesced with that message". But both calls are separated
      * as one may not want to call {@link #currentCoalescingTimeNanos()} after every call to {@link #newArrival(Coalescable)}
      * and we thus save processing. How arrivals influence the coalescing time is however entirely up to the strategy and some

File: src/java/org/apache/cassandra/utils/btree/BTree.java
Patch:
@@ -435,7 +435,7 @@ public static <V> void replaceInSitu(Object[] node, Comparator<? super V> compar
 
     /**
      * Honours result semantics of {@link Arrays#binarySearch}, as though it were performed on the tree flattened into an array
-     * @return index of item in tree, or <tt>(-(<i>insertion point</i>) - 1)</tt> if not present
+     * @return index of item in tree, or <code>{@literal (-(insertion point) - 1)}</code> if not present
      */
     public static <V> int findIndex(Object[] node, Comparator<? super V> comparator, V find)
     {
@@ -801,7 +801,7 @@ public static int hashCode(Object[] btree)
     }
 
     /**
-     * tree index => index of key wrt all items in the tree laid out serially
+     * tree {@code index => index} of key wrt all items in the tree laid out serially
      *
      * This version of the method permits requesting out-of-bounds indexes, -1 and size
      * @param root to calculate tree index within

File: test/unit/org/apache/cassandra/db/compaction/CompactionStrategyManagerTest.java
Patch:
@@ -89,7 +89,8 @@ public static void beforeClass()
         DatabaseDescriptor.setIncrementalBackupsEnabled(false);
         /**
          * We use byte ordered partitioner in this test to be able to easily infer an SSTable
-         * disk assignment based on its generation - See {@link this#getSSTableIndex(Integer[], SSTableReader)}
+         * disk assignment based on its generation - See
+         * {@link CompactionStrategyManagerTest#getSSTableIndex(Integer[], SSTableReader)}
          */
         originalPartitioner = StorageService.instance.setPartitionerUnsafe(ByteOrderedPartitioner.instance);
         SchemaLoader.createKeyspace(KS_PREFIX,

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -2138,7 +2138,6 @@ public LifecycleTransaction call() throws Exception
                 assert data.getCompacting().isEmpty() : data.getCompacting();
                 Iterable<SSTableReader> sstables = getLiveSSTables();
                 sstables = AbstractCompactionStrategy.filterSuspectSSTables(sstables);
-                sstables = ImmutableList.copyOf(sstables);
                 LifecycleTransaction modifier = data.tryModify(sstables, operationType);
                 assert modifier != null: "something marked things compacting while compactions are disabled";
                 return modifier;

File: src/java/org/apache/cassandra/db/compaction/TimeWindowCompactionStrategy.java
Patch:
@@ -169,13 +169,13 @@ private List<SSTableReader> getCompactionCandidates(Iterable<SSTableReader> cand
     }
 
     @Override
-    public void addSSTable(SSTableReader sstable)
+    public synchronized void addSSTable(SSTableReader sstable)
     {
         sstables.add(sstable);
     }
 
     @Override
-    public void removeSSTable(SSTableReader sstable)
+    public synchronized void removeSSTable(SSTableReader sstable)
     {
         sstables.remove(sstable);
     }

File: src/java/org/apache/cassandra/locator/NetworkTopologyStrategy.java
Patch:
@@ -29,6 +29,7 @@
 import org.apache.cassandra.locator.TokenMetadata.Topology;
 import org.apache.cassandra.utils.FBUtilities;
 
+import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.Multimap;
 
 /**
@@ -91,7 +92,7 @@ public List<InetAddress> calculateNaturalEndpoints(Token searchToken, TokenMetad
         // all endpoints in each DC, so we can check when we have exhausted all the members of a DC
         Multimap<String, InetAddress> allEndpoints = topology.getDatacenterEndpoints();
         // all racks in a DC so we can check when we have exhausted all racks in a DC
-        Map<String, Multimap<String, InetAddress>> racks = topology.getDatacenterRacks();
+        Map<String, ImmutableMultimap<String, InetAddress>> racks = topology.getDatacenterRacks();
         assert !allEndpoints.isEmpty() && !racks.isEmpty() : "not aware of any cluster members";
 
         // tracks the racks we have already placed replicas in

File: src/java/org/apache/cassandra/hints/HintsBufferPool.java
Patch:
@@ -18,14 +18,12 @@
 package org.apache.cassandra.hints;
 
 import java.io.Closeable;
-import java.io.IOException;
 import java.util.UUID;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 
 import org.apache.cassandra.config.Config;
 import org.apache.cassandra.net.MessagingService;
-import sun.nio.ch.DirectBuffer;
 
 /**
  * A primitive pool of {@link HintsBuffer} buffers. Under normal conditions should only hold two buffers - the currently

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -149,7 +149,7 @@ public class Config
     public Integer native_transport_max_frame_size_in_mb = 256;
     public volatile Long native_transport_max_concurrent_connections = -1L;
     public volatile Long native_transport_max_concurrent_connections_per_ip = -1L;
-    public boolean native_transport_flush_in_batches_legacy = false;
+    public boolean native_transport_flush_in_batches_legacy = true;
 
     @Deprecated
     public Integer thrift_max_message_length_in_mb = 16;

File: src/java/org/apache/cassandra/concurrent/AbstractLocalAwareExecutorService.java
Patch:
@@ -166,7 +166,7 @@ public void run()
             catch (Throwable t)
             {
                 JVMStabilityInspector.inspectThrowable(t);
-                logger.warn("Uncaught exception on thread {}: {}", Thread.currentThread(), t);
+                logger.warn("Uncaught exception on thread {}", Thread.currentThread(), t);
                 result = t;
                 failure = true;
             }

File: test/unit/org/apache/cassandra/db/SinglePartitionSliceCommandTest.java
Patch:
@@ -395,7 +395,7 @@ public static List<Unfiltered> getUnfilteredsFromSinglePartition(String q)
         SelectStatement stmt = (SelectStatement) QueryProcessor.parseStatement(q).prepare(ClientState.forInternalCalls()).statement;
 
         List<Unfiltered> unfiltereds = new ArrayList<>();
-        SinglePartitionReadCommand.Group query = (SinglePartitionReadCommand.Group) stmt.getQuery(QueryOptions.DEFAULT, FBUtilities.nowInSeconds());
+        SinglePartitionReadCommand.Group query = (SinglePartitionReadCommand.Group) stmt.getQuery(QueryOptions.DEFAULT, 0);
         Assert.assertEquals(1, query.commands.size());
         SinglePartitionReadCommand command = Iterables.getOnlyElement(query.commands);
         try (ReadOrderGroup group = ReadOrderGroup.forCommand(command);

File: src/java/org/apache/cassandra/schema/CompressionParams.java
Patch:
@@ -55,7 +55,7 @@ public final class CompressionParams
     private static volatile boolean hasLoggedChunkLengthWarning;
     private static volatile boolean hasLoggedCrcCheckChanceWarning;
 
-    public static final int DEFAULT_CHUNK_LENGTH = 65536;
+    public static final int DEFAULT_CHUNK_LENGTH = 1024 * 16;
     public static final double DEFAULT_MIN_COMPRESS_RATIO = 0.0;        // Since pre-4.0 versions do not understand the
                                                                         // new compression parameter we can't use a
                                                                         // different default value.

File: src/java/org/apache/cassandra/db/Serializers.java
Patch:
@@ -79,6 +79,9 @@ public ClusteringPrefix deserialize(DataInputPlus in) throws IOException
                 if (clusteringSize == 0)
                     return Clustering.EMPTY;
 
+                if (metadata.isCompound() && CompositeType.isStaticName(bb))
+                    return Clustering.STATIC_CLUSTERING;
+
                 if (!metadata.isCompound())
                     return new Clustering(bb);
 

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -2630,9 +2630,9 @@ public static FullQueryLoggerOptions getFullQueryLogOptions()
         return  conf.full_query_logging_options;
     }
 
-    public static int getBlockForPeersPercentage()
+    public static boolean getBlockForPeersInRemoteDatacenters()
     {
-        return conf.block_for_peers_percentage;
+        return conf.block_for_peers_in_remote_dcs;
     }
 
     public static int getBlockForPeersTimeoutInSeconds()

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -505,9 +505,9 @@ public void init(String[] arguments) throws IOException
      */
     public void start()
     {
-        StartupClusterConnectivityChecker connectivityChecker = StartupClusterConnectivityChecker.create(DatabaseDescriptor.getBlockForPeersPercentage(),
-                                                                                                         DatabaseDescriptor.getBlockForPeersTimeoutInSeconds());
-        connectivityChecker.execute(Gossiper.instance.getEndpoints());
+        StartupClusterConnectivityChecker connectivityChecker = StartupClusterConnectivityChecker.create(DatabaseDescriptor.getBlockForPeersTimeoutInSeconds(),
+                                                                                                         DatabaseDescriptor.getBlockForPeersInRemoteDatacenters());
+        connectivityChecker.execute(Gossiper.instance.getEndpoints(), DatabaseDescriptor.getEndpointSnitch()::getDatacenter);
 
         String nativeFlag = System.getProperty("cassandra.start_native_transport");
         if ((nativeFlag != null && Boolean.parseBoolean(nativeFlag)) || (nativeFlag == null && DatabaseDescriptor.startNativeTransport()))

File: src/java/org/apache/cassandra/io/sstable/format/big/BigFormat.java
Patch:
@@ -111,7 +111,7 @@ public SSTableReader open(Descriptor descriptor, Set<Component> components, CFMe
     // we always incremented the major version.
     static class BigVersion extends Version
     {
-        public static final String current_version = "mc";
+        public static final String current_version = "md";
         public static final String earliest_supported_version = "jb";
 
         // jb (2.0.1): switch from crc32 to adler32 for compression checksums

File: src/java/org/apache/cassandra/net/StartupClusterConnectivityChecker.java
Patch:
@@ -114,7 +114,7 @@ public boolean execute(Set<InetAddressAndPort> peers)
                     TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos),
                     connected,
                     peers.size(),
-                    connected / (peers.size()) * 100.0);
+                    String.format("%.2f", (connected / (float)peers.size()) * 100));
         return succeeded;
     }
 

File: src/java/org/apache/cassandra/locator/ReplicaLayout.java
Patch:
@@ -278,7 +278,7 @@ static <E extends Endpoints<E>> boolean haveWriteConflicts(E natural, E pending)
     @VisibleForTesting
     static EndpointsForToken resolveWriteConflictsInNatural(EndpointsForToken natural, EndpointsForToken pending)
     {
-        EndpointsForToken.Mutable resolved = natural.newMutable(natural.size());
+        EndpointsForToken.Builder resolved = natural.newBuilder(natural.size());
         for (Replica replica : natural)
         {
             // always prefer the full natural replica, if there is a conflict
@@ -297,7 +297,7 @@ static EndpointsForToken resolveWriteConflictsInNatural(EndpointsForToken natura
             }
             resolved.add(replica);
         }
-        return resolved.asSnapshot();
+        return resolved.build();
     }
 
     /**

File: src/java/org/apache/cassandra/db/rows/RangeTombstoneBoundaryMarker.java
Patch:
@@ -136,12 +136,12 @@ public static RangeTombstoneBoundaryMarker makeBoundary(boolean reversed, Slice.
 
     public RangeTombstoneBoundMarker createCorrespondingCloseMarker(boolean reversed)
     {
-        return new RangeTombstoneBoundMarker(closeBound(reversed), endDeletion);
+        return new RangeTombstoneBoundMarker(closeBound(reversed), closeDeletionTime(reversed));
     }
 
     public RangeTombstoneBoundMarker createCorrespondingOpenMarker(boolean reversed)
     {
-        return new RangeTombstoneBoundMarker(openBound(reversed), startDeletion);
+        return new RangeTombstoneBoundMarker(openBound(reversed), openDeletionTime(reversed));
     }
 
     public void digest(MessageDigest digest)

File: src/java/org/apache/cassandra/db/ReadCommandVerbHandler.java
Patch:
@@ -102,8 +102,8 @@ private void validateTransientStatus(MessageIn<ReadCommand> message)
         {
             MessagingService.instance().incrementDroppedMessages(message, message.getLifetimeInMS());
             throw new InvalidRequestException(String.format("Attempted to serve %s data request from %s node in %s",
-                                                            replica.isTransient() ? "transient" : "full",
                                                             command.acceptsTransient() ? "transient" : "full",
+                                                            replica.isTransient() ? "transient" : "full",
                                                             this));
         }
     }

File: test/unit/org/apache/cassandra/db/LegacyLayoutTest.java
Patch:
@@ -276,8 +276,8 @@ public void testStaticRangeTombstoneRoundTripDroppedColumn() throws Throwable
 
         Row.Builder builder;
         builder = BTreeRow.unsortedBuilder(0);
-        builder.newRow(new Clustering(UTF8Serializer.instance.serialize("a")));
-        builder.addCell(BufferCell.live(table, v, 0L, Int32Serializer.instance.serialize(1), null));
+        builder.newRow(new BufferClustering(UTF8Serializer.instance.serialize("a")));
+        builder.addCell(BufferCell.live(v, 0L, Int32Serializer.instance.serialize(1), null));
         builder.addComplexDeletion(bug, new DeletionTime(1L, 1));
         Row row = builder.build();
 

File: test/unit/org/apache/cassandra/service/WriteResponseHandlerTest.java
Patch:
@@ -214,6 +214,7 @@ public void idealCLDatacenterWriteResponeHandlerWorks() throws Throwable
     @Test
     public void failedIdealCLIncrementsStat() throws Throwable
     {
+        ks.metric.idealCLWriteLatency.totalLatency.dec(ks.metric.idealCLWriteLatency.totalLatency.getCount());
         AbstractWriteResponseHandler awr = createWriteResponseHandler(ConsistencyLevel.LOCAL_QUORUM, ConsistencyLevel.EACH_QUORUM);
 
         //Succeed in local DC

File: test/unit/org/apache/cassandra/db/LegacyLayoutTest.java
Patch:
@@ -187,7 +187,6 @@ private static UnfilteredRowIterator roundTripVia21(UnfilteredRowIterator partit
         }
     }
 
-
     @Test
     public void testStaticRangeTombstoneRoundTripUnexpectedDeletion() throws Throwable
     {

File: src/java/org/apache/cassandra/hints/HintsService.java
Patch:
@@ -34,6 +34,8 @@
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableMap;
+import org.apache.cassandra.db.Keyspace;
+import org.apache.cassandra.locator.ReplicaLayout;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -185,7 +187,7 @@ void writeForAllReplicas(Hint hint)
         String keyspaceName = hint.mutation.getKeyspaceName();
         Token token = hint.mutation.key().getToken();
 
-        EndpointsForToken replicas = StorageService.instance.getNaturalAndPendingReplicasForToken(keyspaceName, token);
+        EndpointsForToken replicas = ReplicaLayout.forTokenWriteLiveAndDown(Keyspace.open(keyspaceName), token).all();
 
         // judicious use of streams: eagerly materializing probably cheaper
         // than performing filters / translations 2x extra via Iterables.filter/transform

File: src/java/org/apache/cassandra/locator/EndpointsForRange.java
Patch:
@@ -86,7 +86,7 @@ public static class Mutable extends EndpointsForRange implements ReplicaCollecti
     {
         boolean hasSnapshot;
         public Mutable(Range<Token> range) { this(range, 0); }
-        public Mutable(Range<Token> range, int capacity) { super(range, new ArrayList<>(capacity), false, new LinkedHashMap<>()); }
+        public Mutable(Range<Token> range, int capacity) { super(range, new ArrayList<>(capacity), false, new LinkedHashMap<>(capacity)); }
 
         public void add(Replica replica, Conflict ignoreConflict)
         {

File: src/java/org/apache/cassandra/locator/EndpointsForToken.java
Patch:
@@ -77,7 +77,7 @@ public static class Mutable extends EndpointsForToken implements ReplicaCollecti
     {
         boolean hasSnapshot;
         public Mutable(Token token) { this(token, 0); }
-        public Mutable(Token token, int capacity) { super(token, new ArrayList<>(capacity), false, new LinkedHashMap<>()); }
+        public Mutable(Token token, int capacity) { super(token, new ArrayList<>(capacity), false, new LinkedHashMap<>(capacity)); }
 
         public void add(Replica replica, Conflict ignoreConflict)
         {

File: src/java/org/apache/cassandra/locator/RangesAtEndpoint.java
Patch:
@@ -173,7 +173,7 @@ public static class Mutable extends RangesAtEndpoint implements ReplicaCollectio
     {
         boolean hasSnapshot;
         public Mutable(InetAddressAndPort endpoint) { this(endpoint, 0); }
-        public Mutable(InetAddressAndPort endpoint, int capacity) { super(endpoint, new ArrayList<>(capacity), false, new LinkedHashMap<>()); }
+        public Mutable(InetAddressAndPort endpoint, int capacity) { super(endpoint, new ArrayList<>(capacity), false, new LinkedHashMap<>(capacity)); }
 
         public void add(Replica replica, Conflict ignoreConflict)
         {

File: src/java/org/apache/cassandra/service/ActiveRepairService.java
Patch:
@@ -331,7 +331,7 @@ else if (range.intersects(toRepair))
             TokenMetadata.Topology topology = ss.getTokenMetadata().cloneOnlyTokenMap().getTopology();
             Multimap<String, InetAddressAndPort> dcEndpointsMap = topology.getDatacenterEndpoints();
             Iterable<InetAddressAndPort> dcEndpoints = concat(transform(dataCenters, dcEndpointsMap::get));
-            return neighbors.keep(dcEndpoints);
+            return neighbors.select(dcEndpoints, true);
         }
         else if (hosts != null && !hosts.isEmpty())
         {

File: src/java/org/apache/cassandra/service/reads/repair/ReadRepairEvent.java
Patch:
@@ -67,7 +67,7 @@ enum ReadRepairEventType
         this.keyspace = readRepair.cfs.keyspace;
         this.tableName = readRepair.cfs.getTableName();
         this.cqlCommand = readRepair.command.toCQLString();
-        this.consistency = readRepair.replicaLayout.consistencyLevel();
+        this.consistency = readRepair.replicaPlan().consistencyLevel();
         this.speculativeRetry = readRepair.cfs.metadata().params.speculativeRetry.kind();
         this.destinations = destinations;
         this.allEndpoints = allEndpoints;

File: test/unit/org/apache/cassandra/service/WriteResponseHandlerTest.java
Patch:
@@ -27,7 +27,7 @@
 import com.google.common.base.Predicates;
 import org.apache.cassandra.dht.Murmur3Partitioner;
 import org.apache.cassandra.locator.EndpointsForToken;
-import org.apache.cassandra.locator.ReplicaLayout;
+import org.apache.cassandra.locator.ReplicaPlans;
 import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -236,7 +236,7 @@ private static AbstractWriteResponseHandler createWriteResponseHandler(Consisten
 
     private static AbstractWriteResponseHandler createWriteResponseHandler(ConsistencyLevel cl, ConsistencyLevel ideal, long queryStartTime)
     {
-        return ks.getReplicationStrategy().getWriteResponseHandler(ReplicaLayout.forWriteWithDownNodes(ks, cl, targets.token(), targets, pending),
+        return ks.getReplicationStrategy().getWriteResponseHandler(ReplicaPlans.forWrite(ks, cl, targets, pending, Predicates.alwaysTrue(), ReplicaPlans.writeAll),
                                                                    null, WriteType.SIMPLE, queryStartTime, ideal);
     }
 

File: test/unit/org/apache/cassandra/service/reads/DigestResolverTest.java
Patch:
@@ -18,6 +18,7 @@
 
 package org.apache.cassandra.service.reads;
 
+import org.apache.cassandra.locator.ReplicaPlan;
 import org.junit.Assert;
 import org.junit.Test;
 
@@ -158,8 +159,8 @@ public void transientResponseData()
                               resolver.getData());
     }
 
-    private ReplicaLayout.ForToken plan(ConsistencyLevel consistencyLevel, EndpointsForToken replicas)
+    private ReplicaPlan.SharedForTokenRead plan(ConsistencyLevel consistencyLevel, EndpointsForToken replicas)
     {
-        return new ReplicaLayout.ForToken(ks, consistencyLevel, replicas.token(), replicas, null, replicas);
+        return ReplicaPlan.shared(new ReplicaPlan.ForTokenRead(ks, consistencyLevel, replicas, replicas));
     }
 }

File: test/unit/org/apache/cassandra/service/reads/repair/InstrumentedReadRepair.java
Patch:
@@ -23,9 +23,11 @@
 import org.apache.cassandra.locator.Endpoints;
 import org.apache.cassandra.locator.InetAddressAndPort;
 import org.apache.cassandra.locator.ReplicaLayout;
+import org.apache.cassandra.locator.ReplicaPlan;
 import org.apache.cassandra.service.reads.ReadCallback;
 
-public interface InstrumentedReadRepair<E extends Endpoints<E>, L extends ReplicaLayout<E, L>> extends ReadRepair<E, L>
+public interface InstrumentedReadRepair<E extends Endpoints<E>, P extends ReplicaPlan.ForRead<E>>
+        extends ReadRepair<E, P>
 {
     Set<InetAddressAndPort> getReadRecipients();
 

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -41,6 +41,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import com.codahale.metrics.Snapshot;
 import org.apache.cassandra.cache.*;
 import org.apache.cassandra.concurrent.*;
 import org.apache.cassandra.config.*;
@@ -453,8 +454,8 @@ public void updateSpeculationThreshold()
     {
         try
         {
-            sampleReadLatencyNanos = metadata().params.speculativeRetry.calculateThreshold(metric.coordinatorReadLatency);
-            transientWriteLatencyNanos = metadata().params.speculativeWriteThreshold.calculateThreshold(metric.coordinatorWriteLatency);
+            sampleReadLatencyNanos = metadata().params.speculativeRetry.calculateThreshold(metric.coordinatorReadLatency.getSnapshot(), sampleReadLatencyNanos);
+            transientWriteLatencyNanos = metadata().params.speculativeWriteThreshold.calculateThreshold(metric.coordinatorWriteLatency.getSnapshot(), transientWriteLatencyNanos);
         }
         catch (Throwable e)
         {

File: src/java/org/apache/cassandra/service/reads/AlwaysSpeculativeRetryPolicy.java
Patch:
@@ -19,7 +19,7 @@
 
 import com.google.common.base.Objects;
 
-import com.codahale.metrics.Timer;
+import com.codahale.metrics.Snapshot;
 
 public class AlwaysSpeculativeRetryPolicy implements SpeculativeRetryPolicy
 {
@@ -30,7 +30,7 @@ private AlwaysSpeculativeRetryPolicy()
     }
 
     @Override
-    public long calculateThreshold(Timer readLatency)
+    public long calculateThreshold(Snapshot latency, long existingValue)
     {
         return 0;
     }

File: src/java/org/apache/cassandra/service/reads/FixedSpeculativeRetryPolicy.java
Patch:
@@ -23,7 +23,7 @@
 
 import com.google.common.base.Objects;
 
-import com.codahale.metrics.Timer;
+import com.codahale.metrics.Snapshot;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.schema.TableParams;
 
@@ -39,7 +39,7 @@ public class FixedSpeculativeRetryPolicy implements SpeculativeRetryPolicy
     }
 
     @Override
-    public long calculateThreshold(Timer readLatency)
+    public long calculateThreshold(Snapshot latency, long existingValue)
     {
         return TimeUnit.MILLISECONDS.toNanos(speculateAtMilliseconds);
     }

File: src/java/org/apache/cassandra/service/reads/NeverSpeculativeRetryPolicy.java
Patch:
@@ -19,7 +19,7 @@
 
 import com.google.common.base.Objects;
 
-import com.codahale.metrics.Timer;
+import com.codahale.metrics.Snapshot;
 
 public class NeverSpeculativeRetryPolicy implements SpeculativeRetryPolicy
 {
@@ -30,7 +30,7 @@ private NeverSpeculativeRetryPolicy()
     }
 
     @Override
-    public long calculateThreshold(Timer readLatency)
+    public long calculateThreshold(Snapshot latency, long existingValue)
     {
         return Long.MAX_VALUE;
     }

File: src/java/org/apache/cassandra/service/reads/SpeculativeRetryPolicy.java
Patch:
@@ -17,7 +17,7 @@
  */
 package org.apache.cassandra.service.reads;
 
-import com.codahale.metrics.Timer;
+import com.codahale.metrics.Snapshot;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.schema.TableParams;
 
@@ -28,7 +28,7 @@ public enum Kind
         NEVER, FIXED, PERCENTILE, HYBRID, ALWAYS
     }
 
-    long calculateThreshold(Timer readLatency);
+    long calculateThreshold(Snapshot latency, long existingValue);
 
     Kind kind();
 

File: src/java/org/apache/cassandra/auth/AuthCache.java
Patch:
@@ -37,7 +37,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
-public class AuthCache<K, V> implements AuthCacheMBean<K>
+public class AuthCache<K, V> implements AuthCacheMBean
 {
     private static final Logger logger = LoggerFactory.getLogger(AuthCache.class);
 

File: src/java/org/apache/cassandra/auth/AuthCacheMBean.java
Patch:
@@ -18,12 +18,10 @@
 
 package org.apache.cassandra.auth;
 
-public interface AuthCacheMBean<T>
+public interface AuthCacheMBean
 {
     public void invalidate();
 
-    public void invalidate(T t);
-
     public void setValidity(int validityPeriod);
 
     public int getValidity();

File: src/java/org/apache/cassandra/auth/NetworkAuthCache.java
Patch:
@@ -34,5 +34,4 @@ public NetworkAuthCache(INetworkAuthorizer authorizer)
               authorizer::authorize,
               () -> DatabaseDescriptor.getAuthenticator().requireAuthentication());
     }
-
 }

File: src/java/org/apache/cassandra/auth/PasswordAuthenticator.java
Patch:
@@ -228,7 +228,7 @@ else if (user == null)
         }
     }
 
-    private static class CredentialsCache extends AuthCache<String, String>
+    private static class CredentialsCache extends AuthCache<String, String> implements CredentialsCacheMBean
     {
         private CredentialsCache(PasswordAuthenticator authenticator)
         {

File: src/java/org/apache/cassandra/utils/SortedBiMultiValMap.java
Patch:
@@ -65,7 +65,7 @@ public static <K, V> SortedBiMultiValMap<K, V> create(BiMultiValMap<K, V> map, C
 
     private static <K, V> void copy(BiMultiValMap<K, V> map, BiMultiValMap<K, V> newMap)
     {
-        newMap.forwardMap.putAll(map);
+        newMap.forwardMap.putAll(map.forwardMap);
         // Put each individual TreeSet instead of Multimap#putAll(Multimap) to get linear complexity
         // See CASSANDRA-14660
         for (Entry<V, Collection<K>> entry : map.inverse().asMap().entrySet())

File: test/unit/org/apache/cassandra/service/reads/repair/ReadRepairTest.java
Patch:
@@ -157,7 +157,7 @@ private static Cell cell(String name, String value, long timestamp)
 
     private static Mutation mutation(Cell... cells)
     {
-        Row.Builder builder = BTreeRow.unsortedBuilder(0);
+        Row.Builder builder = BTreeRow.unsortedBuilder();
         builder.newRow(Clustering.EMPTY);
         for (Cell cell: cells)
         {

File: src/java/org/apache/cassandra/cache/InstrumentingCache.java
Patch:
@@ -56,9 +56,10 @@ public boolean replace(K key, V old, V value)
     public V get(K key)
     {
         V v = map.get(key);
-        metrics.requests.mark();
         if (v != null)
             metrics.hits.mark();
+        else
+            metrics.misses.mark();
         return v;
     }
 

File: src/java/org/apache/cassandra/io/sstable/IndexSummaryBuilder.java
Patch:
@@ -207,8 +207,8 @@ public void prepareToCommit()
     {
         // this method should only be called when we've finished appending records, so we truncate the
         // memory we're using to the exact amount required to represent it before building our summary
-        entries.setCapacity(entries.length());
-        offsets.setCapacity(offsets.length());
+        entries.trim();
+        offsets.trim();
     }
 
     public IndexSummary build(IPartitioner partitioner)

File: src/java/org/apache/cassandra/io/util/DataOutputBufferFixed.java
Patch:
@@ -58,7 +58,7 @@ protected void doFlush(int count) throws IOException
      * @see org.apache.cassandra.io.util.DataOutputBuffer#reallocate(long)
      */
     @Override
-    protected void reallocate(long newSize)
+    protected void expandToFit(long newSize)
     {
         throw new BufferOverflowException();
     }

File: test/unit/org/apache/cassandra/io/util/DataOutputTest.java
Patch:
@@ -134,11 +134,11 @@ void publicFlush() throws IOException
 
         void superReallocate(int count) throws IOException
         {
-            super.reallocate(count);
+            super.expandToFit(count);
         }
 
         @Override
-        protected void reallocate(long count)
+        protected void expandToFit(long count)
         {
             if (count <= 0)
                 return;

File: src/java/org/apache/cassandra/config/ColumnDefinition.java
Patch:
@@ -153,7 +153,6 @@ public ColumnDefinition(String ksName,
     {
         super(ksName, cfName, name, type);
         assert name != null && type != null && kind != null;
-        assert name.isInterned();
         assert (position == NO_POSITION) == !kind.isPrimaryKeyKind(); // The position really only make sense for partition and clustering columns (and those must have one),
                                                                       // so make sure we don't sneak it for something else since it'd breaks equals()
         this.kind = kind;

File: src/java/org/apache/cassandra/schema/SchemaKeyspace.java
Patch:
@@ -1075,9 +1075,7 @@ public static ColumnDefinition createColumnFromRow(UntypedResultSet.Row row, Typ
         if (order == ClusteringOrder.DESC)
             type = ReversedType.getInstance(type);
 
-        ColumnIdentifier name = ColumnIdentifier.getInterned(type,
-                                                             row.getBytes("column_name_bytes"),
-                                                             row.getString("column_name"));
+        ColumnIdentifier name = new ColumnIdentifier(row.getBytes("column_name_bytes"), row.getString("column_name"));
 
         return new ColumnDefinition(keyspace, table, name, type, position, kind);
     }

File: src/java/org/apache/cassandra/utils/NativeSSTableLoaderClient.java
Patch:
@@ -218,9 +218,7 @@ private static ColumnDefinition createDefinitionFromRow(Row row, String keyspace
         if (order == ClusteringOrder.DESC)
             type = ReversedType.getInstance(type);
 
-        ColumnIdentifier name = ColumnIdentifier.getInterned(type,
-                                                             row.getBytes("column_name_bytes"),
-                                                             row.getString("column_name"));
+        ColumnIdentifier name = new ColumnIdentifier(row.getBytes("column_name_bytes"), row.getString("column_name"));
 
         int position = row.getInt("position");
         ColumnDefinition.Kind kind = ColumnDefinition.Kind.valueOf(row.getString("kind").toUpperCase());

File: src/java/org/apache/cassandra/cql3/functions/TimeFcts.java
Patch:
@@ -49,7 +49,7 @@ public static Collection<Function> all()
                                 toTimestamp(TimeUUIDType.instance),
                                 toUnixTimestamp(TimeUUIDType.instance),
                                 toUnixTimestamp(TimestampType.instance),
-                                toDate(SimpleDateType.instance),
+                                toDate(TimestampType.instance),
                                 toUnixTimestamp(SimpleDateType.instance),
                                 toTimestamp(SimpleDateType.instance));
     }

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -27,6 +27,7 @@
 import javax.management.openmbean.OpenDataException;
 import javax.management.openmbean.TabularData;
 
+import org.apache.commons.lang3.StringUtils;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
@@ -581,7 +582,7 @@ else if (r.intersects(sstableBounds) && !nonAnticompacting.contains(sstable))
                 }
 
                 if (!anticompactRanges.isEmpty())
-                    logger.info("SSTable {} ({}) will be anticompacted on ranges: {}", sstable, sstableBounds, String.join(", ", anticompactRanges));
+                    logger.info("SSTable {} ({}) will be anticompacted on ranges: {}", sstable, sstableBounds, StringUtils.join(anticompactRanges, ", "));
 
                 if (!shouldAnticompact)
                 {

File: src/java/org/apache/cassandra/locator/DynamicEndpointSnitch.java
Patch:
@@ -186,7 +186,7 @@ private void sortByProximityWithBadness(final InetAddress address, List<InetAddr
         {
             Double score = scores.get(inet);
             if (score == null)
-                score = 0.0;
+                continue;
             subsnitchOrderedScores.add(score);
         }
 

File: test/unit/org/apache/cassandra/locator/DynamicEndpointSnitchTest.java
Patch:
@@ -92,7 +92,7 @@ public void testSnitch() throws InterruptedException, IOException, Configuration
         assertEquals(order, dsnitch.getSortedListByProximity(self, Arrays.asList(host1, host2, host3, host4)));
 
         setScores(dsnitch, 20, hosts, 10, 10, 10);
-        order = Arrays.asList(host4, host1, host2, host3);
+        order = Arrays.asList(host1, host2, host3, host4);
         assertEquals(order, dsnitch.getSortedListByProximity(self, Arrays.asList(host1, host2, host3, host4)));
     }
 }

File: test/unit/org/apache/cassandra/db/CounterCellTest.java
Patch:
@@ -32,7 +32,6 @@
 import org.apache.cassandra.db.rows.BTreeRow;
 import org.apache.cassandra.db.rows.BufferCell;
 import org.apache.cassandra.db.rows.Cell;
-import org.apache.cassandra.db.rows.CellPath;
 import org.apache.cassandra.db.rows.Cells;
 import org.apache.cassandra.db.context.CounterContext;
 import org.apache.cassandra.db.rows.Row;
@@ -292,10 +291,10 @@ public void testDigestWithEmptyCells() throws Exception
         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE1).getColumnFamilyStore(COUNTER1);
 
         ColumnDefinition emptyColDef = cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("val2"));
-        BufferCell emptyCell = BufferCell.live(emptyColDef, 0, ByteBuffer.allocate(0));
+        BufferCell emptyCell = BufferCell.live(cfs.metadata, emptyColDef, 0, ByteBuffer.allocate(0));
 
         Row.Builder builder = BTreeRow.unsortedBuilder(0);
-        builder.newRow(Clustering.make(AsciiSerializer.instance.serialize("test")));
+        builder.newRow(new Clustering(AsciiSerializer.instance.serialize("test")));
         builder.addCell(emptyCell);
         Row row = builder.build();
 

File: test/unit/org/apache/cassandra/OffsetAwareConfigurationLoader.java
Patch:
@@ -58,6 +58,7 @@ public Config loadConfig() throws ConfigurationException
 
         config.native_transport_port += offset;
         config.storage_port += offset;
+        config.ssl_storage_port += offset;
 
         //Rewrite the seed ports string
         String[] hosts = config.seed_provider.parameters.get("seeds").split(",", -1);

File: src/java/org/apache/cassandra/db/compaction/LeveledCompactionStrategy.java
Patch:
@@ -596,9 +596,6 @@ public static Map<String, String> validateOptions(Map<String, String> options) t
         uncheckedOptions.remove(CompactionParams.Option.MIN_THRESHOLD.toString());
         uncheckedOptions.remove(CompactionParams.Option.MAX_THRESHOLD.toString());
 
-        uncheckedOptions.remove(CompactionParams.Option.MIN_THRESHOLD.toString());
-        uncheckedOptions.remove(CompactionParams.Option.MAX_THRESHOLD.toString());
-
         uncheckedOptions = SizeTieredCompactionStrategyOptions.validateOptions(options, uncheckedOptions);
 
         return uncheckedOptions;

File: src/java/org/apache/cassandra/tools/fqltool/Dump.java
Patch:
@@ -81,7 +81,7 @@ public static void dump(List<String> arguments, String rollCycle, boolean follow
             {
                 int protocolVersion = wireIn.read("protocol-version").int32();
                 sb.append("Protocol version: ").append(protocolVersion).append(System.lineSeparator());
-                QueryOptions options = QueryOptions.codec.decode(Unpooled.wrappedBuffer(wireIn.read("query-options").bytesStore().toTemporaryDirectByteBuffer()), ProtocolVersion.decode(protocolVersion));
+                QueryOptions options = QueryOptions.codec.decode(Unpooled.wrappedBuffer(wireIn.read("query-options").bytes()), ProtocolVersion.decode(protocolVersion));
                 sb.append("Query time: ").append(wireIn.read("query-time").int64()).append(System.lineSeparator());
 
                 if (type.equals("single"))
@@ -126,7 +126,7 @@ public static void dump(List<String> arguments, String rollCycle, boolean follow
 
         //Backoff strategy for spinning on the queue, not aggressive at all as this doesn't need to be low latency
         Pauser pauser = Pauser.millis(100);
-        List<ChronicleQueue> queues = arguments.stream().distinct().map(path -> ChronicleQueueBuilder.single(new File(path)).rollCycle(RollCycles.valueOf(rollCycle)).build()).collect(Collectors.toList());
+        List<ChronicleQueue> queues = arguments.stream().distinct().map(path -> ChronicleQueueBuilder.single(new File(path)).readOnly(true).rollCycle(RollCycles.valueOf(rollCycle)).build()).collect(Collectors.toList());
         List<ExcerptTailer> tailers = queues.stream().map(ChronicleQueue::createTailer).collect(Collectors.toList());
         boolean hadWork = true;
         while (hadWork)

File: src/java/org/apache/cassandra/service/paxos/PaxosState.java
Patch:
@@ -46,7 +46,7 @@ public PaxosState(DecoratedKey key, TableMetadata metadata)
     public PaxosState(Commit promised, Commit accepted, Commit mostRecentCommit)
     {
         assert promised.update.partitionKey().equals(accepted.update.partitionKey()) && accepted.update.partitionKey().equals(mostRecentCommit.update.partitionKey());
-        assert promised.update.metadata() == accepted.update.metadata() && accepted.update.metadata() == mostRecentCommit.update.metadata();
+        assert promised.update.metadata().id.equals(accepted.update.metadata().id) && accepted.update.metadata().id.equals(mostRecentCommit.update.metadata().id);
 
         this.promised = promised;
         this.accepted = accepted;

File: src/java/org/apache/cassandra/service/paxos/PrepareResponse.java
Patch:
@@ -45,7 +45,7 @@ public class PrepareResponse
     public PrepareResponse(boolean promised, Commit inProgressCommit, Commit mostRecentCommit)
     {
         assert inProgressCommit.update.partitionKey().equals(mostRecentCommit.update.partitionKey());
-        assert inProgressCommit.update.metadata() == mostRecentCommit.update.metadata();
+        assert inProgressCommit.update.metadata().id.equals(mostRecentCommit.update.metadata().id);
 
         this.promised = promised;
         this.mostRecentCommit = mostRecentCommit;

File: src/java/org/apache/cassandra/db/columniterator/AbstractSSTableIterator.java
Patch:
@@ -420,12 +420,12 @@ public void setToBlock(int blockIdx) throws IOException
             if (blockIdx >= 0 && blockIdx < indexes.size())
             {
                 reader.seekToPosition(columnOffset(blockIdx));
+                mark = reader.file.mark();
                 reader.deserializer.clearState();
             }
 
             currentIndexIdx = blockIdx;
             reader.openMarker = blockIdx > 0 ? indexes.get(blockIdx - 1).endOpenMarker : null;
-            mark = reader.file.mark();
 
             // If we're reading an old format file and we move to the first block in the index (i.e. the
             // head of the partition), we skip the static row as it's already been read when we first opened

File: src/java/org/apache/cassandra/db/columniterator/SSTableReversedIterator.java
Patch:
@@ -281,6 +281,7 @@ public void setForSlice(Slice slice) throws IOException
             if (startIdx < 0)
             {
                 iterator = Collections.emptyIterator();
+                indexState.setToBlock(startIdx);
                 return;
             }
 

File: src/java/org/apache/cassandra/hadoop/cql3/CqlRecordReader.java
Patch:
@@ -133,7 +133,7 @@ public void initialize(InputSplit split, TaskAttemptContext context) throws IOEx
         }
 
         if (cluster != null)
-            session = cluster.connect(keyspace);
+            session = cluster.connect(quote(keyspace));
 
         if (session == null)
           throw new RuntimeException("Can't create connection session");

File: test/unit/org/apache/cassandra/db/compaction/BlacklistingCompactionsTest.java
Patch:
@@ -48,6 +48,8 @@ public class BlacklistingCompactionsTest
 {
     private static final String KEYSPACE1 = "BlacklistingCompactionsTest";
     private static final String CF_STANDARD1 = "Standard1";
+    // seed hardcoded to one we know works:
+    private static final Random random = new Random(1);
 
     @After
     public void leakDetect() throws InterruptedException
@@ -142,7 +144,7 @@ public void testBlacklisting(String compactionStrategy) throws Exception
                 raf = new RandomAccessFile(sstable.getFilename(), "rw");
                 assertNotNull(raf);
                 assertTrue(raf.length() > 20);
-                raf.seek(new Random().nextInt((int)(raf.length() - 20)));
+                raf.seek(random.nextInt((int)(raf.length() - 20)));
                 // We want to write something large enough that the corruption cannot get undetected
                 // (even without compression)
                 byte[] corruption = new byte[20];

File: src/java/org/apache/cassandra/repair/RepairRunnable.java
Patch:
@@ -103,7 +103,7 @@ protected void fireProgressEvent(String tag, ProgressEvent event)
 
     protected void fireErrorAndComplete(String tag, int progressCount, int totalProgress, String message)
     {
-        fireProgressEvent(tag, new ProgressEvent(ProgressEventType.ERROR, progressCount, totalProgress, message));
+        fireProgressEvent(tag, new ProgressEvent(ProgressEventType.ERROR, progressCount, totalProgress, String.format("Repair command #%d failed with error %s", cmd, message)));
         fireProgressEvent(tag, new ProgressEvent(ProgressEventType.COMPLETE, progressCount, totalProgress, String.format("Repair command #%d finished with error", cmd)));
     }
 

File: src/java/org/apache/cassandra/utils/progress/jmx/LegacyJMXProgressSupport.java
Patch:
@@ -35,7 +35,7 @@
  */
 public class LegacyJMXProgressSupport implements ProgressListener
 {
-    protected static final Pattern SESSION_FAILED_MATCHER = Pattern.compile("Repair session .* for range .* failed with error .*");
+    protected static final Pattern SESSION_FAILED_MATCHER = Pattern.compile("Repair session .* for range .* failed with error .*|Repair command .* failed with error .*");
     protected static final Pattern SESSION_SUCCESS_MATCHER = Pattern.compile("Repair session .* for range .* finished");
 
     private final AtomicLong notificationSerialNumber = new AtomicLong();
@@ -86,6 +86,7 @@ protected static Optional<Status> getStatus(ProgressEvent event)
                 return Optional.of(Status.STARTED);
             case COMPLETE:
                 return Optional.of(Status.FINISHED);
+            case ERROR:
             case PROGRESS:
                 if (SESSION_FAILED_MATCHER.matcher(event.getMessage()).matches())
                 {

File: src/java/org/apache/cassandra/db/compaction/CompactionStrategyManager.java
Patch:
@@ -210,6 +210,7 @@ public AbstractCompactionTask getNextBackgroundTask(int gcBefore)
      * @return
      */
     @VisibleForTesting
+    @SuppressWarnings("resource") // transaction is closed by AbstractCompactionTask::execute
     AbstractCompactionTask findUpgradeSSTableTask()
     {
         if (!isEnabled() || !DatabaseDescriptor.automaticSSTableUpgrade())

File: src/java/org/apache/cassandra/net/OutboundTcpConnection.java
Patch:
@@ -232,6 +232,7 @@ else if (socket != null || connect())
                         // clear out the queue, else gossip messages back up.
                         drainedMessages.clear();
                         backlog.clear();
+                        currentMsgBufferCount = 0;
                         break inner;
                     }
                 }

File: src/java/org/apache/cassandra/cache/AutoSavingCache.java
Patch:
@@ -42,6 +42,7 @@
 import org.apache.cassandra.db.compaction.CompactionInfo;
 import org.apache.cassandra.db.compaction.CompactionManager;
 import org.apache.cassandra.db.compaction.OperationType;
+import org.apache.cassandra.db.compaction.CompactionInfo.Unit;
 import org.apache.cassandra.io.FSWriteError;
 import org.apache.cassandra.io.util.*;
 import org.apache.cassandra.io.util.ChecksummedRandomAccessReader.CorruptFileException;
@@ -304,7 +305,7 @@ else if (cacheType == CacheService.CacheType.COUNTER_CACHE)
                                       type,
                                       0,
                                       keysEstimate,
-                                      "keys",
+                                      Unit.KEYS,
                                       UUIDGen.getTimeUUID());
         }
 

File: src/java/org/apache/cassandra/io/sstable/IndexSummaryRedistribution.java
Patch:
@@ -30,14 +30,15 @@
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.Keyspace;
 import org.apache.cassandra.db.compaction.CompactionInfo;
 import org.apache.cassandra.db.compaction.CompactionInterruptedException;
 import org.apache.cassandra.db.compaction.OperationType;
+import org.apache.cassandra.db.compaction.CompactionInfo.Unit;
 import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.utils.Pair;
@@ -308,7 +309,7 @@ public int compare(ResampleEntry o1, ResampleEntry o2)
 
     public CompactionInfo getCompactionInfo()
     {
-        return new CompactionInfo(OperationType.INDEX_SUMMARY, (memoryPoolBytes - remainingSpace), memoryPoolBytes, "bytes", compactionId);
+        return new CompactionInfo(OperationType.INDEX_SUMMARY, (memoryPoolBytes - remainingSpace), memoryPoolBytes, Unit.BYTES, compactionId);
     }
 
     /** Utility class for sorting sstables by their read rates. */

File: src/java/org/apache/cassandra/io/util/SequentialWriter.java
Patch:
@@ -430,6 +430,7 @@ public void resetAndTruncate(FileMark mark)
             throw new FSReadError(e, getPath());
         }
 
+        bufferOffset = truncateTarget;
         resetBuffer();
     }
 
@@ -443,6 +444,7 @@ public void truncate(long toSize)
         try
         {
             channel.truncate(toSize);
+            lastFlushOffset = toSize;
         }
         catch (IOException e)
         {

File: test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java
Patch:
@@ -385,7 +385,7 @@ public void testOpeningSSTable() throws Exception
         long bloomModified = Files.getLastModifiedTime(bloomPath).toMillis();
         long summaryModified = Files.getLastModifiedTime(summaryPath).toMillis();
 
-        Thread.sleep(TimeUnit.MILLISECONDS.toMillis(10)); // sleep to ensure modified time will be different
+        TimeUnit.MILLISECONDS.sleep(1000); // sleep to ensure modified time will be different
 
         // Offline tests
         // check that bloomfilter/summary ARE NOT regenerated
@@ -432,7 +432,7 @@ public void testOpeningSSTable() throws Exception
         summaryModified = Files.getLastModifiedTime(summaryPath).toMillis();
         summaryFile.delete();
 
-        Thread.sleep(TimeUnit.MILLISECONDS.toMillis(10)); // sleep to ensure modified time will be different
+        TimeUnit.MILLISECONDS.sleep(1000); // sleep to ensure modified time will be different
         bloomModified = Files.getLastModifiedTime(bloomPath).toMillis();
 
         target = SSTableReader.open(desc, components, store.metadata);
@@ -449,7 +449,7 @@ public void testOpeningSSTable() throws Exception
         summaryModified = Files.getLastModifiedTime(summaryPath).toMillis();
         target = SSTableReader.open(desc, components, store.metadata, false, false);
 
-        Thread.sleep(TimeUnit.MILLISECONDS.toMillis(10)); // sleep to ensure modified time will be different
+        TimeUnit.MILLISECONDS.sleep(1000); // sleep to ensure modified time will be different
         assertEquals(bloomModified, Files.getLastModifiedTime(bloomPath).toMillis());
         assertEquals(summaryModified, Files.getLastModifiedTime(summaryPath).toMillis());
 

File: src/java/org/apache/cassandra/repair/RepairJob.java
Patch:
@@ -155,6 +155,9 @@ public void onFailure(Throwable t)
                 setException(t);
             }
         }, taskExecutor);
+
+        // Wait for validation to complete
+        Futures.getUnchecked(validations);
     }
 
     /**

File: test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java
Patch:
@@ -381,7 +381,7 @@ public void testOpeningSSTable() throws Exception
         long bloomModified = Files.getLastModifiedTime(bloomPath).toMillis();
         long summaryModified = Files.getLastModifiedTime(summaryPath).toMillis();
 
-        Thread.sleep(TimeUnit.MILLISECONDS.toMillis(10)); // sleep to ensure modified time will be different
+        Thread.sleep(TimeUnit.MILLISECONDS.toMillis(1000)); // sleep to ensure modified time will be different
 
         // Offline tests
         // check that bloomfilter/summary ARE NOT regenerated
@@ -428,7 +428,7 @@ public void testOpeningSSTable() throws Exception
         summaryModified = Files.getLastModifiedTime(summaryPath).toMillis();
         summaryFile.delete();
 
-        Thread.sleep(TimeUnit.MILLISECONDS.toMillis(10)); // sleep to ensure modified time will be different
+        Thread.sleep(TimeUnit.MILLISECONDS.toMillis(1000)); // sleep to ensure modified time will be different
         bloomModified = Files.getLastModifiedTime(bloomPath).toMillis();
 
         target = SSTableReader.open(desc, components, store.metadata);

File: src/java/org/apache/cassandra/service/reads/PercentileSpeculativeRetryPolicy.java
Patch:
@@ -29,6 +29,8 @@
 
 public class PercentileSpeculativeRetryPolicy implements SpeculativeRetryPolicy
 {
+    public static final PercentileSpeculativeRetryPolicy NINETY_NINE_P = new PercentileSpeculativeRetryPolicy(99.0);
+
     private static final Pattern PATTERN = Pattern.compile("^(?<val>[0-9.]+)p(ercentile)?$", Pattern.CASE_INSENSITIVE);
     private static final DecimalFormat FORMATTER = new DecimalFormat("#.####");
 

File: test/unit/org/apache/cassandra/hints/HintTest.java
Patch:
@@ -87,7 +87,7 @@ public void resetGcGraceSeconds()
         tokenMeta.updateNormalTokens(BootStrapper.getRandomTokens(tokenMeta, 1), local);
 
         for (TableMetadata table : Schema.instance.getTablesAndViews(KEYSPACE))
-            MigrationManager.announceTableUpdate(table.unbuild().gcGraceSeconds(TableParams.DEFAULT_GC_GRACE_SECONDS).build(), true);
+            MigrationManager.announceTableUpdate(table.unbuild().gcGraceSeconds(864000).build(), true);
     }
 
     @Test

File: src/java/org/apache/cassandra/service/reads/repair/NoopReadRepair.java
Patch:
@@ -18,7 +18,6 @@
 
 package org.apache.cassandra.service.reads.repair;
 
-import java.net.InetAddress;
 import java.util.List;
 import java.util.function.Consumer;
 

File: src/java/org/apache/cassandra/service/reads/repair/ReadRepair.java
Patch:
@@ -33,6 +33,7 @@
 
 public interface ReadRepair
 {
+
     /**
      * Used by DataResolver to generate corrections as the partition iterator is consumed
      */

File: test/unit/org/apache/cassandra/service/reads/repair/TestableReadRepair.java
Patch:
@@ -18,7 +18,6 @@
 
 package org.apache.cassandra.service.reads.repair;
 
-import java.net.InetAddress;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;

File: src/java/org/apache/cassandra/service/pager/SliceQueryPager.java
Patch:
@@ -89,7 +89,7 @@ protected List<Row> queryNextPage(int pageSize, ConsistencyLevel consistencyLeve
         if (lastReturned != null)
             filter = filter.withUpdatedStart(lastReturned, cfm);
 
-        logger.debug("Querying next page of slice query; new filter: {}", filter);
+        logger.trace("Querying next page of slice query; new filter: {}", filter);
         ReadCommand pageCmd = command.withUpdatedFilter(filter);
         return localQuery
              ? Collections.singletonList(pageCmd.getRow(Keyspace.open(command.ksName)))

File: src/java/org/apache/cassandra/service/reads/SpeculativeRetryPolicy.java
Patch:
@@ -42,8 +42,6 @@ public enum Kind
                                                          Pattern.CASE_INSENSITIVE);
     public static final SpeculativeRetryPolicy DEFAULT = new PercentileSpeculativeRetryPolicy(99.0);
 
-    boolean isDynamic();
-
     long calculateThreshold(Timer readLatency);
 
     Kind kind();

File: src/java/org/apache/cassandra/locator/DynamicEndpointSnitch.java
Patch:
@@ -234,7 +234,7 @@ private void sortByProximityWithBadness(final InetAddress address, List<InetAddr
         {
             Double score = scores.get(inet);
             if (score == null)
-                continue;
+                score = 0.0;
             subsnitchOrderedScores.add(score);
         }
 

File: test/unit/org/apache/cassandra/locator/DynamicEndpointSnitchTest.java
Patch:
@@ -101,7 +101,7 @@ public void testSnitch() throws InterruptedException, IOException, Configuration
         assertEquals(order, dsnitch.getSortedListByProximity(self, Arrays.asList(host1, host2, host3, host4)));
 
         setScores(dsnitch, 20, hosts, 10, 10, 10);
-        order = Arrays.asList(host1, host2, host3, host4);
+        order = Arrays.asList(host4, host1, host2, host3);
         assertEquals(order, dsnitch.getSortedListByProximity(self, Arrays.asList(host1, host2, host3, host4)));
     }
 }

File: src/java/org/apache/cassandra/locator/DynamicEndpointSnitch.java
Patch:
@@ -186,7 +186,7 @@ private void sortByProximityWithBadness(final InetAddress address, List<InetAddr
         {
             Double score = scores.get(inet);
             if (score == null)
-                continue;
+                score = 0.0;
             subsnitchOrderedScores.add(score);
         }
 

File: test/unit/org/apache/cassandra/locator/DynamicEndpointSnitchTest.java
Patch:
@@ -92,7 +92,7 @@ public void testSnitch() throws InterruptedException, IOException, Configuration
         assertEquals(order, dsnitch.getSortedListByProximity(self, Arrays.asList(host1, host2, host3, host4)));
 
         setScores(dsnitch, 20, hosts, 10, 10, 10);
-        order = Arrays.asList(host1, host2, host3, host4);
+        order = Arrays.asList(host4, host1, host2, host3);
         assertEquals(order, dsnitch.getSortedListByProximity(self, Arrays.asList(host1, host2, host3, host4)));
     }
 }

File: src/java/org/apache/cassandra/locator/DynamicEndpointSnitch.java
Patch:
@@ -235,7 +235,7 @@ private void sortByProximityWithBadness(final InetAddressAndPort address, List<I
         {
             Double score = scores.get(inet);
             if (score == null)
-                continue;
+                score = 0.0;
             subsnitchOrderedScores.add(score);
         }
 

File: test/unit/org/apache/cassandra/locator/DynamicEndpointSnitchTest.java
Patch:
@@ -100,7 +100,7 @@ public void testSnitch() throws InterruptedException, IOException, Configuration
         assertEquals(order, dsnitch.getSortedListByProximity(self, Arrays.asList(host1, host2, host3, host4)));
 
         setScores(dsnitch, 20, hosts, 10, 10, 10);
-        order = Arrays.asList(host1, host2, host3, host4);
+        order = Arrays.asList(host4, host1, host2, host3);
         assertEquals(order, dsnitch.getSortedListByProximity(self, Arrays.asList(host1, host2, host3, host4)));
     }
 }

File: src/java/org/apache/cassandra/tools/NodeTool.java
Patch:
@@ -1283,7 +1283,7 @@ public static class Scrub extends NodeToolCmd
         private int jobs = 2;
 
         @Option(title = "reinsert_overflowed_ttl",
-        name = {"r", "--reinsert-overflowed-ttl"},
+        name = {"-r", "--reinsert-overflowed-ttl"},
         description = StandaloneScrubber.REINSERT_OVERFLOWED_TTL_OPTION_DESCRIPTION)
         private boolean reinsertOverflowedTTL = false;
 

File: src/java/org/apache/cassandra/io/sstable/SSTable.java
Patch:
@@ -104,7 +104,7 @@ protected SSTable(Descriptor descriptor, Set<Component> components, CFMetaData m
      */
     public static boolean delete(Descriptor desc, Set<Component> components)
     {
-        logger.info("Deleting sstable: {}", desc);
+        logger.debug("Deleting sstable: {}", desc);
         // remove the DATA component first if it exists
         if (components.contains(Component.DATA))
             FileUtils.deleteWithConfirm(desc.filenameFor(Component.DATA));

File: src/java/org/apache/cassandra/db/commitlog/BatchCommitLogService.java
Patch:
@@ -30,7 +30,7 @@ protected void maybeWaitForSync(CommitLogSegment.Allocation alloc)
     {
         // wait until record has been safely persisted to disk
         pending.incrementAndGet();
-        haveWork.release();
+        requestSync();
         alloc.awaitDiskSync(commitLog.metrics.waitingOnCommit);
         pending.decrementAndGet();
     }

File: src/java/org/apache/cassandra/repair/StreamingRepairTask.java
Patch:
@@ -40,7 +40,7 @@
 import org.apache.cassandra.streaming.StreamOperation;
 
 /**
- * StreamingRepairTask performs data streaming between two remote replica which neither is not repair coordinator.
+ * StreamingRepairTask performs data streaming between two remote replicas, neither of which is repair coordinator.
  * Task will send {@link SyncComplete} message back to coordinator upon streaming completion.
  */
 public class StreamingRepairTask implements Runnable, StreamEventHandler

File: src/java/org/apache/cassandra/db/ExpirationDateOverflowHandling.java
Patch:
@@ -25,7 +25,6 @@
 import org.slf4j.LoggerFactory;
 import org.slf4j.helpers.MessageFormatter;
 
-import org.apache.cassandra.cql3.Attributes;
 import org.apache.cassandra.db.rows.BufferCell;
 import org.apache.cassandra.db.rows.Cell;
 import org.apache.cassandra.exceptions.InvalidRequestException;
@@ -35,7 +34,7 @@
 
 public class ExpirationDateOverflowHandling
 {
-    private static final Logger logger = LoggerFactory.getLogger(Attributes.class);
+    private static final Logger logger = LoggerFactory.getLogger(ExpirationDateOverflowHandling.class);
 
     private static final int EXPIRATION_OVERFLOW_WARNING_INTERVAL_MINUTES = Integer.getInteger("cassandra.expiration_overflow_warning_interval_minutes", 5);
 

File: src/java/org/apache/cassandra/service/NativeTransportService.java
Patch:
@@ -187,14 +187,14 @@ public void destroy()
     }
 
     /**
-     * @return intend to use epoll bassed event looping
+     * @return intend to use epoll based event looping
      */
     public static boolean useEpoll()
     {
         final boolean enableEpoll = Boolean.parseBoolean(System.getProperty("cassandra.native.epoll.enabled", "true"));
 
         if (enableEpoll && !Epoll.isAvailable() && NativeLibrary.osType == NativeLibrary.OSType.LINUX)
-            logger.warn("epoll not availble {}", Epoll.unavailabilityCause());
+            logger.warn("epoll not available {}", Epoll.unavailabilityCause());
 
         return enableEpoll && Epoll.isAvailable();
     }

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -2011,7 +2011,7 @@ public void beforeChange(InetAddressAndPort endpoint, EndpointState currentState
      */
     public void onChange(InetAddressAndPort endpoint, ApplicationState state, VersionedValue value)
     {
-        if (state == ApplicationState.STATUS | state == ApplicationState.STATUS_WITH_PORT)
+        if (state == ApplicationState.STATUS || state == ApplicationState.STATUS_WITH_PORT)
         {
             String[] pieces = splitValue(value);
             assert (pieces.length > 0);

File: test/unit/org/apache/cassandra/config/DatabaseDescriptorRefTest.java
Patch:
@@ -218,10 +218,10 @@ protected Class<?> findClass(String name) throws ClassNotFoundException
             method.invoke(null);
 
             if ("clientInitialization".equals(methodName) &&
-                threadCount + 1 == threads.getThreadCount())
+                threadCount + 2 == threads.getThreadCount())
             {
-                // ignore the "AsyncAppender-Worker-ASYNC" thread
-                threadCount++;
+                // ignore the "AsyncAppender-Worker-ASYNC" and "logback-1" threads
+                threadCount = threadCount + 2;
             }
 
             if (threadCount != threads.getThreadCount())

File: test/unit/org/apache/cassandra/io/sstable/LegacySSTableTest.java
Patch:
@@ -94,7 +94,7 @@ public class LegacySSTableTest
     public static void defineSchema() throws ConfigurationException
     {
         String scp = System.getProperty(LEGACY_SSTABLE_PROP);
-        Assert.assertNotNull("System property " + LEGACY_SSTABLE_ROOT + " not set", scp);
+        Assert.assertNotNull("System property " + LEGACY_SSTABLE_PROP + " not set", scp);
 
         LEGACY_SSTABLE_ROOT = new File(scp).getAbsoluteFile();
         Assert.assertTrue("System property " + LEGACY_SSTABLE_ROOT + " does not specify a directory", LEGACY_SSTABLE_ROOT.isDirectory());

File: src/java/org/apache/cassandra/config/EncryptionOptions.java
Patch:
@@ -25,7 +25,7 @@ public class EncryptionOptions
     public String truststore_password = "cassandra";
     public String[] cipher_suites = {};
     public String protocol = "TLS";
-    public String algorithm = "SunX509";
+    public String algorithm = null;
     public String store_type = "JKS";
     public boolean require_client_auth = false;
     public boolean require_endpoint_verification = false;

File: src/java/org/apache/cassandra/tools/LoaderOptions.java
Patch:
@@ -610,7 +610,7 @@ private static CmdLineOptions getCmdLineOptions()
         options.addOption("ks", SSL_KEYSTORE, "KEYSTORE", "Client SSL: full path to keystore");
         options.addOption("kspw", SSL_KEYSTORE_PW, "KEYSTORE-PASSWORD", "Client SSL: password of the keystore");
         options.addOption("prtcl", SSL_PROTOCOL, "PROTOCOL", "Client SSL: connections protocol to use (default: TLS)");
-        options.addOption("alg", SSL_ALGORITHM, "ALGORITHM", "Client SSL: algorithm (default: SunX509)");
+        options.addOption("alg", SSL_ALGORITHM, "ALGORITHM", "Client SSL: algorithm");
         options.addOption("st", SSL_STORE_TYPE, "STORE-TYPE", "Client SSL: type of store");
         options.addOption("ciphers", SSL_CIPHER_SUITES, "CIPHER-SUITES", "Client SSL: comma-separated list of encryption suites to use");
         options.addOption("f", CONFIG_PATH, "path to config file", "cassandra.yaml file path for streaming throughput and client/server SSL.");

File: tools/stress/src/org/apache/cassandra/stress/settings/Legacy.java
Patch:
@@ -74,7 +74,7 @@ public class Legacy implements Serializable
         availableOptions.addOption("ts", SSL_TRUSTSTORE,         true, "SSL: full path to truststore");
         availableOptions.addOption("tspw", SSL_TRUSTSTORE_PW,    true, "SSL: full path to truststore");
         availableOptions.addOption("prtcl", SSL_PROTOCOL,        true, "SSL: connections protocol to use (default: TLS)");
-        availableOptions.addOption("alg", SSL_ALGORITHM,         true, "SSL: algorithm (default: SunX509)");
+        availableOptions.addOption("alg", SSL_ALGORITHM,         true, "SSL: algorithm");
         availableOptions.addOption("st", SSL_STORE_TYPE,         true, "SSL: type of store");
         availableOptions.addOption("ciphers", SSL_CIPHER_SUITES, true, "SSL: comma-separated list of encryption suites to use");
         availableOptions.addOption("th",  "throttle",            true,   "Throttle the total number of operations per second to a maximum amount.");

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsTransport.java
Patch:
@@ -73,7 +73,7 @@ static class TOptions extends GroupedOptions implements Serializable
         final OptionSimple keyStore = new OptionSimple("keystore=", ".*", null, "SSL: full path to keystore", false);
         final OptionSimple keyStorePw = new OptionSimple("keystore-password=", ".*", null, "SSL: keystore password", false);
         final OptionSimple protocol = new OptionSimple("ssl-protocol=", ".*", "TLS", "SSL: connection protocol to use", false);
-        final OptionSimple alg = new OptionSimple("ssl-alg=", ".*", "SunX509", "SSL: algorithm", false);
+        final OptionSimple alg = new OptionSimple("ssl-alg=", ".*", null, "SSL: algorithm", false);
         final OptionSimple ciphers = new OptionSimple("ssl-ciphers=", ".*", "TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA", "SSL: comma delimited list of encryption suites to use", false);
 
         @Override

File: src/java/org/apache/cassandra/net/MessageIn.java
Patch:
@@ -32,6 +32,8 @@
 import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.locator.InetAddressAndPort;
 import org.apache.cassandra.net.MessagingService.Verb;
+import org.apache.cassandra.utils.FBUtilities;
+
 /**
  * The receiving node's view of a {@link MessageOut}. See documentation on {@link MessageOut} for details on the
  * serialization format.
@@ -180,7 +182,7 @@ public long getLifetimeInMS()
      */
     public boolean isCrossNode()
     {
-        return !from.address.equals(DatabaseDescriptor.getBroadcastAddress());
+        return !from.equals(FBUtilities.getBroadcastAddressAndPort());
     }
 
     public Stage getMessageType()

File: src/java/org/apache/cassandra/tools/nodetool/Scrub.java
Patch:
@@ -26,6 +26,7 @@
 
 import org.apache.cassandra.tools.NodeProbe;
 import org.apache.cassandra.tools.NodeTool.NodeToolCmd;
+import org.apache.cassandra.tools.StandaloneScrubber;
 
 @Command(name = "scrub", description = "Scrub (rebuild sstables for) one or more tables")
 public class Scrub extends NodeToolCmd
@@ -50,7 +51,7 @@ public class Scrub extends NodeToolCmd
 
     @Option(title = "reinsert_overflowed_ttl",
     name = {"r", "--reinsert-overflowed-ttl"},
-    description = "Reinsert found rows with overflowed TTL affected by CASSANDRA-14092")
+    description = StandaloneScrubber.REINSERT_OVERFLOWED_TTL_OPTION_DESCRIPTION)
     private boolean reinsertOverflowedTTL = false;
 
     @Option(title = "jobs",

File: src/java/org/apache/cassandra/tools/SSTableMetadataViewer.java
Patch:
@@ -425,7 +425,7 @@ private void printSStableMetadata(String fname, boolean scan) throws IOException
             field("EncodingStats minTTL", encodingStats.minTTL,
                     toDurationString(encodingStats.minTTL, TimeUnit.SECONDS));
             field("EncodingStats minLocalDeletionTime", encodingStats.minLocalDeletionTime,
-                    toDateString(encodingStats.minLocalDeletionTime, TimeUnit.MILLISECONDS));
+                    toDateString(encodingStats.minLocalDeletionTime, TimeUnit.SECONDS));
             field("EncodingStats minTimestamp", encodingStats.minTimestamp,
                     toDateString(encodingStats.minTimestamp, tsUnit));
             field("KeyType", keyType.toString());

File: test/unit/org/apache/cassandra/cql3/ViewComplexTest.java
Patch:
@@ -424,7 +424,7 @@ public void testPartialUpdateWithUnselectedCollections(boolean flush) throws Thr
     {
         execute("USE " + keyspace());
         executeNet(protocolVersion, "USE " + keyspace());
-        createTable("CREATE TABLE %s (k int, c int, a int, b int, l list<int>, s set<int>, m map<int,int>, PRIMARY KEY (k, c))");
+        String baseTableName = createTable("CREATE TABLE %s (k int, c int, a int, b int, l list<int>, s set<int>, m map<int,int>, PRIMARY KEY (k, c))");
         createView("mv",
                    "CREATE MATERIALIZED VIEW %s AS SELECT a, b FROM %%s WHERE k IS NOT NULL AND c IS NOT NULL PRIMARY KEY (c, k)");
         Keyspace ks = Keyspace.open(keyspace());
@@ -460,7 +460,7 @@ public void testPartialUpdateWithUnselectedCollections(boolean flush) throws Thr
         assertRowsIgnoringOrder(execute("SELECT k,c,a,b from %s"), row(1, 1, null, null));
         assertRowsIgnoringOrder(execute("SELECT * from mv"), row(1, 1, null, null));
 
-        assertInvalidMessage("Cannot drop column m on base table with materialized views", "ALTER TABLE %s DROP m");
+        assertInvalidMessage("Cannot drop column m on base table " + baseTableName + " with materialized views", "ALTER TABLE %s DROP m");
         // executeNet(protocolVersion, "ALTER TABLE %s DROP m");
         // ks.getColumnFamilyStore("mv").forceMajorCompaction();
         // assertRowsIgnoringOrder(execute("SELECT k,c,a,b from %s WHERE k = 1 AND c = 1"));

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -171,7 +171,7 @@ public Collection<Range<Token>> getPrimaryRangesWithinDC(String keyspace)
         return getPrimaryRangeForEndpointWithinDC(keyspace, FBUtilities.getBroadcastAddressAndPort());
     }
 
-    private final Set<InetAddressAndPort> replicatingNodes = Collections.synchronizedSet(new HashSet<InetAddressAndPort>());
+    private final Set<InetAddressAndPort> replicatingNodes = Sets.newConcurrentHashSet();
     private CassandraDaemon daemon;
 
     private InetAddressAndPort removingNode;
@@ -530,7 +530,7 @@ private synchronized void checkForEndpointCollision(UUID localHostId) throws Con
                     value = entry.getValue().getApplicationState(ApplicationState.STATUS);
                 }
 
-                String[] pieces = splitValue(entry.getValue().getApplicationState(ApplicationState.STATUS));
+                String[] pieces = splitValue(value);
                 assert (pieces.length > 0);
                 String state = pieces[0];
                 if (state.equals(VersionedValue.STATUS_BOOTSTRAPPING) || state.equals(VersionedValue.STATUS_LEAVING) || state.equals(VersionedValue.STATUS_MOVING))

File: src/java/org/apache/cassandra/metrics/TableMetrics.java
Patch:
@@ -122,7 +122,7 @@ public class TableMetrics
     public final Gauge<Double> keyCacheHitRate;
     /** Tombstones scanned in queries on this CF */
     public final TableHistogram tombstoneScannedHistogram;
-    /** Live cells scanned in queries on this CF */
+    /** Live rows scanned in queries on this CF */
     public final TableHistogram liveScannedHistogram;
     /** Column update time delta on this CF */
     public final TableHistogram colUpdateTimeDeltaHistogram;

File: src/java/org/apache/cassandra/metrics/TableMetrics.java
Patch:
@@ -125,7 +125,7 @@ public class TableMetrics
     public final Gauge<Double> keyCacheHitRate;
     /** Tombstones scanned in queries on this CF */
     public final TableHistogram tombstoneScannedHistogram;
-    /** Live cells scanned in queries on this CF */
+    /** Live rows scanned in queries on this CF */
     public final TableHistogram liveScannedHistogram;
     /** Column update time delta on this CF */
     public final TableHistogram colUpdateTimeDeltaHistogram;

File: src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java
Patch:
@@ -237,9 +237,9 @@ public Event.SchemaChange announceMigration(QueryState queryState, boolean isLoc
                 }
 
                 if (!Iterables.isEmpty(views))
-                    throw new InvalidRequestException(String.format("Cannot drop column %s on base table with materialized views.",
+                    throw new InvalidRequestException(String.format("Cannot drop column %s on base table %s with materialized views.",
                                                                     columnName.toString(),
-                                                                    keyspace()));
+                                                                    columnFamily()));
                 break;
             case DROP_COMPACT_STORAGE:
                 if (!meta.isCompactTable())

File: src/java/org/apache/cassandra/repair/RepairRunnable.java
Patch:
@@ -745,7 +745,7 @@ public void runMayThrow() throws Exception
 
                     for (UntypedResultSet.Row r : result)
                     {
-                        if (source.equals(r.getInetAddress("source")))
+                        if (source.address.equals(r.getInetAddress("source")))
                             continue;
                         if ((uuid = r.getUUID("event_id")).timestamp() > (tcur - 1000) * 10000)
                             seen[si].add(uuid);

File: src/java/org/apache/cassandra/net/MessageIn.java
Patch:
@@ -180,7 +180,7 @@ public long getLifetimeInMS()
      */
     public boolean isCrossNode()
     {
-        return !from.equals(DatabaseDescriptor.getBroadcastAddress());
+        return !from.address.equals(DatabaseDescriptor.getBroadcastAddress());
     }
 
     public Stage getMessageType()

File: src/java/org/apache/cassandra/db/compaction/CompactionStrategyManager.java
Patch:
@@ -745,7 +745,7 @@ private void handleDeletingNotification(SSTableReader deleted)
         readLock.lock();
         try
         {
-            getCompactionStrategyFor(deleted).removeSSTable(deleted);
+            compactionStrategyFor(deleted).removeSSTable(deleted);
         }
         finally
         {

File: src/java/org/apache/cassandra/net/OutboundTcpConnection.java
Patch:
@@ -538,13 +538,13 @@ private boolean connect()
             catch (SSLHandshakeException e)
             {
                 logger.error("SSL handshake error for outbound connection to " + socket, e);
-                socket = null;
+                disconnect();
                 // SSL errors won't be recoverable within timeout period so we'll just abort
                 return false;
             }
             catch (IOException e)
             {
-                socket = null;
+                disconnect();
                 if (logger.isTraceEnabled())
                     logger.trace("unable to connect to " + poolReference.endPoint(), e);
                 Uninterruptibles.sleepUninterruptibly(OPEN_RETRY_DELAY, TimeUnit.MILLISECONDS);

File: src/java/org/apache/cassandra/metrics/TableMetrics.java
Patch:
@@ -125,7 +125,7 @@ public class TableMetrics
     public final Gauge<Double> keyCacheHitRate;
     /** Tombstones scanned in queries on this CF */
     public final TableHistogram tombstoneScannedHistogram;
-    /** Live cells scanned in queries on this CF */
+    /** Live rows scanned in queries on this CF */
     public final TableHistogram liveScannedHistogram;
     /** Column update time delta on this CF */
     public final TableHistogram colUpdateTimeDeltaHistogram;

File: src/java/org/apache/cassandra/db/view/ViewBuilder.java
Patch:
@@ -58,7 +58,7 @@
  */
 class ViewBuilder
 {
-    private static final Logger logger = LoggerFactory.getLogger(ViewBuilderTask.class);
+    private static final Logger logger = LoggerFactory.getLogger(ViewBuilder.class);
 
     private static final int NUM_TASKS = Runtime.getRuntime().availableProcessors() * 4;
 

File: src/java/org/apache/cassandra/repair/asymmetric/RangeDenormalizer.java
Patch:
@@ -37,7 +37,7 @@
 
 public class RangeDenormalizer
 {
-    private static final Logger logger = LoggerFactory.getLogger(IncomingRepairStreamTracker.class);
+    private static final Logger logger = LoggerFactory.getLogger(RangeDenormalizer.class);
 
     /**
      * "Denormalizes" (kind of the opposite of what Range.normalize does) the ranges in the keys of {{incoming}}

File: src/java/org/apache/cassandra/schema/MigrationManager.java
Patch:
@@ -95,7 +95,7 @@ private static void maybeScheduleSchemaPull(final UUID theirVersion, final InetA
         if (Schema.instance.isEmpty() || runtimeMXBean.getUptime() < MIGRATION_DELAY_IN_MS)
         {
             // If we think we may be bootstrapping or have recently started, submit MigrationTask immediately
-            logger.debug("Immediately submitting migration task for {} due to {}, " +
+            logger.debug("Immediately submitting migration task for {}, " +
                          "schema versions: local={}, remote={}",
                          endpoint,
                          Schema.schemaVersionToString(Schema.instance.getVersion()),

File: src/java/org/apache/cassandra/db/commitlog/CommitLogReplayer.java
Patch:
@@ -152,7 +152,7 @@ public void replayFiles(File[] clogs) throws IOException
             sawCDCMutation = false;
             commitLogReader.readCommitLogSegment(this, file, globalPosition, i == filteredLogs.size());
             if (sawCDCMutation)
-                handleCDCReplayCompletion(clogs[i]);
+                handleCDCReplayCompletion(file);
         }
     }
 

File: tools/stress/src/org/apache/cassandra/stress/generate/Distribution.java
Patch:
@@ -45,8 +45,8 @@ public long minValue()
     public long average()
     {
         double sum = 0;
-        double d = 0d;
-        for (int count = 0; count < 50 ; count++)
+        float d = 0;
+        for (int count = 0; count < 51 ; count++)
         {
             sum += inverseCumProb(d);
             d += 0.02d;

File: test/unit/org/apache/cassandra/dht/SplitterTest.java
Patch:
@@ -97,7 +97,7 @@ private boolean assertRangeSizeEqual(List<Range<Token>> localRanges, List<Token>
             start = end;
         }
         // when we dont need to keep around full ranges, the difference is small between the partitions
-        BigDecimal delta = splitIndividualRanges ? BigDecimal.valueOf(0.001) : BigDecimal.valueOf(0.2);
+        BigDecimal delta = splitIndividualRanges ? BigDecimal.valueOf(0.001) : BigDecimal.valueOf(0.25);
         boolean allBalanced = true;
         for (BigInteger b : splits)
         {

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -348,7 +348,7 @@ public Object call() throws Exception
         {
             Throwable fail = Throwables.close(null, transactions);
             if (fail != null)
-                logger.error("Failed to cleanup lifecycle transactions {}", fail);
+                logger.error("Failed to cleanup lifecycle transactions", fail);
         }
     }
 

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -525,7 +525,7 @@ public void run()
                         }
                         catch (Exception ex)
                         {
-                            logger.error("Failed paxos prepare locally : {}", ex);
+                            logger.error("Failed paxos prepare locally", ex);
                         }
                     }
                 });
@@ -563,7 +563,7 @@ public void run()
                         }
                         catch (Exception ex)
                         {
-                            logger.error("Failed paxos propose locally : {}", ex);
+                            logger.error("Failed paxos propose locally", ex);
                         }
                     }
                 });

File: src/java/org/apache/cassandra/db/DiskBoundaryManager.java
Patch:
@@ -75,7 +75,8 @@ private static DiskBoundaries getDiskBoundaryValue(ColumnFamilyStore cfs)
         {
             tmd = StorageService.instance.getTokenMetadata();
             ringVersion = tmd.getRingVersion();
-            if (StorageService.instance.isBootstrapMode())
+            if (StorageService.instance.isBootstrapMode()
+                && !StorageService.isReplacingSameAddress()) // When replacing same address, the node marks itself as UN locally
             {
                 localRanges = tmd.getPendingRanges(cfs.keyspace.getName(), FBUtilities.getBroadcastAddress());
             }

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1026,7 +1026,8 @@ private void joinTokenRing(int delay) throws ConfigurationException
 
     public static boolean isReplacingSameAddress()
     {
-        return DatabaseDescriptor.getReplaceAddress().equals(FBUtilities.getBroadcastAddress());
+        InetAddress replaceAddress = DatabaseDescriptor.getReplaceAddress();
+        return replaceAddress != null && replaceAddress.equals(FBUtilities.getBroadcastAddress());
     }
 
     public void gossipSnitchInfo()

File: src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java
Patch:
@@ -140,7 +140,8 @@ public abstract class SSTableReader extends SSTable implements SelfRefCounted<SS
     }
     private static final RateLimiter meterSyncThrottle = RateLimiter.create(100.0);
 
-    public static final Comparator<SSTableReader> maxTimestampComparator = (o1, o2) -> Long.compare(o1.getMaxTimestamp(), o2.getMaxTimestamp());
+    // Descending order
+    public static final Comparator<SSTableReader> maxTimestampComparator = (o1, o2) -> Long.compare(o2.getMaxTimestamp(), o1.getMaxTimestamp());
 
     // it's just an object, which we use regular Object equality on; we introduce a special class just for easy recognition
     public static final class UniqueIdentifier {}

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -916,7 +916,7 @@ static void checkForLowestAcceptedTimeouts(Config conf)
 
         if(conf.counter_write_request_timeout_in_ms < LOWEST_ACCEPTED_TIMEOUT)
         {
-           logInfo("counter_write_request_timeout_in_ms", conf.counter_cache_keys_to_save, LOWEST_ACCEPTED_TIMEOUT);
+           logInfo("counter_write_request_timeout_in_ms", conf.counter_write_request_timeout_in_ms, LOWEST_ACCEPTED_TIMEOUT);
            conf.counter_write_request_timeout_in_ms = LOWEST_ACCEPTED_TIMEOUT;
         }
 

File: src/java/org/apache/cassandra/tools/JsonTransformer.java
Patch:
@@ -347,7 +347,7 @@ private void serializeClustering(ClusteringPrefix clustering) throws IOException
                 }
                 else
                 {
-                    json.writeString(column.cellValueType().getString(clustering.get(i)));
+                    json.writeRawValue(column.cellValueType().toJSONString(clustering.get(i), Server.CURRENT_VERSION));
                 }
             }
             json.writeEndArray();

File: tools/stress/src/org/apache/cassandra/stress/generate/Distribution.java
Patch:
@@ -46,7 +46,7 @@ public long average()
     {
         double sum = 0;
         double d = 0d;
-        for (int count = 0; count < 51 ; count++)
+        for (int count = 0; count < 50 ; count++)
         {
             sum += inverseCumProb(d);
             d += 0.02d;

File: test/unit/org/apache/cassandra/db/compaction/AbstractCompactionStrategyTest.java
Patch:
@@ -134,7 +134,7 @@ private static void insertKeyAndFlush(String table, int key)
         long timestamp = System.currentTimeMillis();
         DecoratedKey dk = Util.dk(String.format("%03d", key));
         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE1).getColumnFamilyStore(table);
-        new RowUpdateBuilder(cfs.metadata, timestamp, dk.getKey())
+        new RowUpdateBuilder(cfs.metadata(), timestamp, dk.getKey())
         .clustering(String.valueOf(key))
         .add("val", "val")
         .build()

File: src/java/org/apache/cassandra/io/sstable/SSTableLoader.java
Patch:
@@ -169,7 +169,7 @@ public StreamResultFuture stream(Set<InetAddress> toIgnore, StreamEventHandler..
             return plan.execute();
         }
 
-        outputHandler.output(String.format("Streaming relevant part of %sto %s", names(sstables), endpointToRanges.keySet()));
+        outputHandler.output(String.format("Streaming relevant part of %s to %s", names(sstables), endpointToRanges.keySet()));
 
         for (Map.Entry<InetAddress, Collection<Range<Token>>> entry : endpointToRanges.entrySet())
         {

File: src/java/org/apache/cassandra/cql3/FieldIdentifier.java
Patch:
@@ -41,7 +41,7 @@ public FieldIdentifier(ByteBuffer bytes)
      */
     public static FieldIdentifier forUnquoted(String text)
     {
-        return new FieldIdentifier(convert(text.toLowerCase(Locale.US)));
+        return new FieldIdentifier(convert(text == null ? null : text.toLowerCase(Locale.US)));
     }
 
     /**

File: src/java/org/apache/cassandra/cql3/RoleName.java
Patch:
@@ -25,7 +25,7 @@ public class RoleName
 
     public void setName(String name, boolean keepCase)
     {
-        this.name = keepCase ? name : name.toLowerCase(Locale.US);
+        this.name = keepCase ? name : (name == null ? name : name.toLowerCase(Locale.US));
     }
 
     public boolean hasName()

File: src/java/org/apache/cassandra/cql3/conditions/ColumnCondition.java
Patch:
@@ -832,7 +832,7 @@ private void validateOperationOnDurations(AbstractType<?> type)
                 checkFalse(type.isCollection(), "Slice conditions are not supported on collections containing durations");
                 checkFalse(type.isTuple(), "Slice conditions are not supported on tuples containing durations");
                 checkFalse(type.isUDT(), "Slice conditions are not supported on UDTs containing durations");
-                throw invalidRequest("Slice conditions are not supported on durations", operator);
+                throw invalidRequest("Slice conditions ( %s ) are not supported on durations", operator);
             }
         }
     }

File: src/java/org/apache/cassandra/cql3/functions/FunctionResolver.java
Patch:
@@ -156,7 +156,7 @@ public static Function get(String keyspace,
                             return toTest;
                     }
                 }
-                throw invalidRequest("Ambiguous '%s' operation: use type casts to disambiguate",
+                throw invalidRequest("Ambiguous '%s' operation with args %s and %s: use type casts to disambiguate",
                                      OperationFcts.getOperator(name), providedArgs.get(0), providedArgs.get(1));
             }
 

File: tools/stress/src/org/apache/cassandra/stress/generate/values/Booleans.java
Patch:
@@ -32,6 +32,6 @@ public Booleans(String name, GeneratorConfig config)
     @Override
     public Boolean generate()
     {
-        return identityDistribution.next() % 1 == 0;
+        return identityDistribution.next() % 2 == 0;
     }
 }

File: src/java/org/apache/cassandra/streaming/compress/CompressedInputStream.java
Patch:
@@ -151,13 +151,12 @@ private void reBuffer(boolean updateCurrent) throws IOException
 
     private void decompress(ByteBuffer compressed) throws IOException
     {
-        final int compressedChunkLength = info.parameters.chunkLength();
         int length = compressed.remaining();
 
-        // uncompress if the buffer size is less than chunk size. else, if the buffer size is equal to the compressedChunkLength,
+        // uncompress if the buffer size is less than the max chunk size. else, if the buffer size is greater than or equal to the maxCompressedLength,
         // we assume the buffer is not compressed. see CASSANDRA-10520
         final boolean releaseCompressedBuffer;
-        if (length - CHECKSUM_LENGTH < compressedChunkLength)
+        if (length - CHECKSUM_LENGTH < info.parameters.maxCompressedLength())
         {
             buffer.clear();
             compressed.limit(length - CHECKSUM_LENGTH);
@@ -191,6 +190,7 @@ private void decompress(ByteBuffer compressed) throws IOException
             FileUtils.clean(compressed);
 
         // buffer offset is always aligned
+        final int compressedChunkLength = info.parameters.chunkLength();
         bufferOffset = current & ~(compressedChunkLength - 1);
     }
 

File: src/java/org/apache/cassandra/db/compaction/DateTieredCompactionStrategyOptions.java
Patch:
@@ -54,7 +54,7 @@ public DateTieredCompactionStrategyOptions(Map<String, String> options)
         String optionValue = options.get(TIMESTAMP_RESOLUTION_KEY);
         timestampResolution = optionValue == null ? DEFAULT_TIMESTAMP_RESOLUTION : TimeUnit.valueOf(optionValue);
         if (timestampResolution != DEFAULT_TIMESTAMP_RESOLUTION)
-            logger.warn("Using a non-default timestamp_resolution {} - are you really doing inserts with USING TIMESTAMP <non_microsecond_timestamp> (or driver equivalent)?", timestampResolution.toString());
+            logger.warn("Using a non-default timestamp_resolution {} - are you really doing inserts with USING TIMESTAMP <non_microsecond_timestamp> (or driver equivalent)?", timestampResolution);
         optionValue = options.get(MAX_SSTABLE_AGE_KEY);
         double fractionalDays = optionValue == null ? DEFAULT_MAX_SSTABLE_AGE_DAYS : Double.parseDouble(optionValue);
         maxSSTableAge = Math.round(fractionalDays * timestampResolution.convert(1, TimeUnit.DAYS));

File: src/java/org/apache/cassandra/db/compaction/TimeWindowCompactionStrategyOptions.java
Patch:
@@ -63,7 +63,7 @@ public TimeWindowCompactionStrategyOptions(Map<String, String> options)
         String optionValue = options.get(TIMESTAMP_RESOLUTION_KEY);
         timestampResolution = optionValue == null ? DEFAULT_TIMESTAMP_RESOLUTION : TimeUnit.valueOf(optionValue);
         if (timestampResolution != DEFAULT_TIMESTAMP_RESOLUTION)
-            logger.warn("Using a non-default timestamp_resolution {} - are you really doing inserts with USING TIMESTAMP <non_microsecond_timestamp> (or driver equivalent)?", timestampResolution.toString());
+            logger.warn("Using a non-default timestamp_resolution {} - are you really doing inserts with USING TIMESTAMP <non_microsecond_timestamp> (or driver equivalent)?", timestampResolution);
 
         optionValue = options.get(COMPACTION_WINDOW_UNIT_KEY);
         sstableWindowUnit = optionValue == null ? DEFAULT_COMPACTION_WINDOW_UNIT : TimeUnit.valueOf(optionValue);

File: src/java/org/apache/cassandra/db/lifecycle/LogTransaction.java
Patch:
@@ -212,7 +212,7 @@ static void delete(File file)
                 {
                     e.printStackTrace(ps);
                 }
-                logger.debug("Unable to delete {} as it does not exist, stack trace:\n {}", file, baos.toString());
+                logger.debug("Unable to delete {} as it does not exist, stack trace:\n {}", file, baos);
             }
         }
         catch (IOException e)

File: src/java/org/apache/cassandra/net/async/InboundHandshakeHandler.java
Patch:
@@ -91,7 +91,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)
                 case HANDSHAKE_FAIL:
                     throw new IllegalStateException("channel should be closed after determining the handshake failed with peer: " + ctx.channel().remoteAddress());
                 default:
-                    logger.error("unhandled state: " + state);
+                    logger.error("unhandled state: {}", state);
                     state = State.HANDSHAKE_FAIL;
                     ctx.close();
             }
@@ -166,7 +166,7 @@ State handleStart(ChannelHandlerContext ctx, ByteBuf in) throws IOException
             // streaming connections are per-session and have a fixed version.  we can't do anything with a wrong-version stream connection, so drop it.
             if (version != StreamMessage.CURRENT_VERSION)
             {
-                logger.warn("Received stream using protocol version %d (my version %d). Terminating connection", version, MessagingService.current_version);
+                logger.warn("Received stream using protocol version {} (my version {}). Terminating connection", version, MessagingService.current_version);
                 ctx.close();
                 return State.HANDSHAKE_FAIL;
             }

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -484,7 +484,7 @@ else if (conf.native_transport_max_frame_size_in_mb >= 2048)
             try
             {
                 // use 1/8th of available space.  See discussion on #10013 and #10199 on the CL, taking half that for CDC
-                minSize = Ints.checkedCast((guessFileStore(conf.cdc_raw_directory).getTotalSpace() / 1048576) / 8);
+                minSize = Ints.saturatedCast((guessFileStore(conf.cdc_raw_directory).getTotalSpace() / 1048576) / 8);
             }
             catch (IOException e)
             {

File: src/java/org/apache/cassandra/cql3/Constants.java
Patch:
@@ -281,7 +281,8 @@ public String toString()
 
     public static class Marker extends AbstractMarker
     {
-        protected Marker(int bindIndex, ColumnSpecification receiver)
+        // Constructor is public only for the SuperColumn tables support
+        public Marker(int bindIndex, ColumnSpecification receiver)
         {
             super(bindIndex, receiver);
             assert !receiver.type.isCollection();

File: src/java/org/apache/cassandra/cql3/restrictions/PrimaryKeyRestrictionSet.java
Patch:
@@ -31,8 +31,6 @@
 import org.apache.cassandra.index.SecondaryIndexManager;
 import org.apache.cassandra.utils.btree.BTreeSet;
 
-import static org.apache.cassandra.cql3.statements.RequestValidations.invalidRequest;
-
 /**
  * A set of single column restrictions on a primary key part (partition key or clustering key).
  */

File: src/java/org/apache/cassandra/cql3/restrictions/TermSlice.java
Patch:
@@ -26,7 +26,7 @@
 import org.apache.cassandra.cql3.statements.Bound;
 import org.apache.cassandra.index.Index;
 
-final class TermSlice
+public final class TermSlice
 {
     /**
      * The slice boundaries.

File: src/java/org/apache/cassandra/cql3/statements/CreateViewStatement.java
Patch:
@@ -137,6 +137,8 @@ public Event.SchemaChange announceMigration(QueryState queryState, boolean isLoc
 
         if (cfm.isCounter())
             throw new InvalidRequestException("Materialized views are not supported on counter tables");
+        if (cfm.isSuper())
+            throw new InvalidRequestException("Materialized views are not supported on SuperColumn tables");
         if (cfm.isView())
             throw new InvalidRequestException("Materialized views cannot be created against other materialized views");
 

File: src/java/org/apache/cassandra/db/Columns.java
Patch:
@@ -422,6 +422,7 @@ public Columns deserialize(DataInputPlus in, CFMetaData metadata) throws IOExcep
             {
                 ByteBuffer name = ByteBufferUtil.readWithVIntLength(in);
                 ColumnDefinition column = metadata.getColumnDefinition(name);
+
                 if (column == null)
                 {
                     // If we don't find the definition, it could be we have data for a dropped column, and we shouldn't

File: src/java/org/apache/cassandra/db/LegacyLayout.java
Patch:
@@ -24,6 +24,7 @@
 import java.security.MessageDigest;
 import java.util.*;
 
+import org.apache.cassandra.cql3.SuperColumnCompatibility;
 import org.apache.cassandra.utils.AbstractIterator;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.Lists;
@@ -298,7 +299,7 @@ public static ByteBuffer encodeCellName(CFMetaData metadata, ClusteringPrefix cl
             // What it is depends if this a cell for a declared "static" column or a "dynamic" column part of the
             // super-column internal map.
             assert columnName != null; // This should never be null for supercolumns, see decodeForSuperColumn() above
-            values[clusteringSize] = columnName.equals(CompactTables.SUPER_COLUMN_MAP_COLUMN)
+            values[clusteringSize] = columnName.equals(SuperColumnCompatibility.SUPER_COLUMN_MAP_COLUMN)
                                    ? collectionElement
                                    : columnName;
         }

File: src/java/org/apache/cassandra/db/SerializationHeader.java
Patch:
@@ -332,6 +332,7 @@ public SerializationHeader toHeader(CFMetaData metadata)
             for (ByteBuffer name : typeMap.keySet())
             {
                 ColumnDefinition column = metadata.getColumnDefinition(name);
+
                 if (column == null)
                 {
                     // TODO: this imply we don't read data for a column we don't yet know about, which imply this is theoretically

File: src/java/org/apache/cassandra/service/DataResolver.java
Patch:
@@ -661,8 +661,7 @@ private SinglePartitionReadCommand makeFetchAdditionalRowsReadCommand(int toQuer
                 if (null != lastClustering)
                     filter = filter.forPaging(metadata.comparator, lastClustering, false);
 
-                return SinglePartitionReadCommand.create(command.isForThrift(),
-                                                         command.metadata(),
+                return SinglePartitionReadCommand.create(command.metadata(),
                                                          command.nowInSec(),
                                                          command.columnFilter(),
                                                          command.rowFilter(),

File: src/java/org/apache/cassandra/db/columniterator/SSTableReversedIterator.java
Patch:
@@ -243,7 +243,7 @@ protected void loadFromDisk(ClusteringBound start,
                 // skipFirstIteratedItem (this is the last item of the block, but we're iterating in reverse order so it will
                 // be the first returned by the iterator).
                 ClusteringBound markerEnd = end == null ? ClusteringBound.TOP : end;
-                buffer.add(new RangeTombstoneBoundMarker(markerEnd, getAndClearOpenMarker()));
+                buffer.add(new RangeTombstoneBoundMarker(markerEnd, openMarker));
                 if (hasPreviousBlock)
                     skipFirstIteratedItem = true;
             }

File: src/java/org/apache/cassandra/db/columniterator/SSTableReversedIterator.java
Patch:
@@ -250,7 +250,7 @@ protected void loadFromDisk(ClusteringBound start,
                 // skipFirstIteratedItem (this is the last item of the block, but we're iterating in reverse order so it will
                 // be the first returned by the iterator).
                 ClusteringBound markerEnd = end == null ? ClusteringBound.TOP : end;
-                buffer.add(new RangeTombstoneBoundMarker(markerEnd, getAndClearOpenMarker()));
+                buffer.add(new RangeTombstoneBoundMarker(markerEnd, openMarker));
                 if (hasPreviousBlock)
                     skipFirstIteratedItem = true;
             }

File: src/java/org/apache/cassandra/db/columniterator/SSTableReversedIterator.java
Patch:
@@ -240,7 +240,7 @@ protected void loadFromDisk(Slice.Bound start,
                 // skipFirstIteratedItem (this is the last item of the block, but we're iterating in reverse order so it will
                 // be the first returned by the iterator).
                 RangeTombstone.Bound markerEnd = end == null ? RangeTombstone.Bound.TOP : RangeTombstone.Bound.fromSliceBound(end);
-                buffer.add(new RangeTombstoneBoundMarker(markerEnd, getAndClearOpenMarker()));
+                buffer.add(new RangeTombstoneBoundMarker(markerEnd, openMarker));
                 if (hasPreviousBlock)
                     skipFirstIteratedItem = true;
             }

File: src/java/org/apache/cassandra/io/compress/CompressedSequentialWriter.java
Patch:
@@ -151,7 +151,7 @@ protected void flushData()
         int compressedLength = compressed.position();
         uncompressedSize += buffer.position();
         ByteBuffer toWrite = compressed;
-        if (compressedLength > maxCompressedLength)
+        if (compressedLength >= maxCompressedLength)
         {
             toWrite = buffer;
             compressedLength = buffer.position();
@@ -240,7 +240,7 @@ public synchronized void resetAndTruncate(DataPosition mark)
                 // Repopulate buffer from compressed data
                 buffer.clear();
                 compressed.flip();
-                if (chunkSize <= maxCompressedLength)
+                if (chunkSize < maxCompressedLength)
                     compressor.uncompress(compressed, buffer);
                 else
                     buffer.put(compressed);

File: src/java/org/apache/cassandra/batchlog/BatchlogManager.java
Patch:
@@ -67,6 +67,7 @@ public class BatchlogManager implements BatchlogManagerMBean
 
     private static final Logger logger = LoggerFactory.getLogger(BatchlogManager.class);
     public static final BatchlogManager instance = new BatchlogManager();
+    public static final long BATCHLOG_REPLAY_TIMEOUT = Long.getLong("cassandra.batchlog.replay_timeout_in_ms", DatabaseDescriptor.getWriteRpcTimeout() * 2);
 
     private volatile long totalBatchesReplayed = 0; // no concurrency protection necessary as only written by replay thread.
     private volatile UUID lastReplayedUuid = UUIDGen.minTimeUUID(0);
@@ -284,7 +285,7 @@ private void finishAndClearBatches(ArrayList<ReplayingBatch> batches, Set<InetAd
 
     public static long getBatchlogTimeout()
     {
-        return DatabaseDescriptor.getWriteRpcTimeout() * 2; // enough time for the actual write + BM removal mutation
+        return BATCHLOG_REPLAY_TIMEOUT; // enough time for the actual write + BM removal mutation
     }
 
     private static class ReplayingBatch

File: src/java/org/apache/cassandra/service/BatchlogResponseHandler.java
Patch:
@@ -50,7 +50,7 @@ public void response(MessageIn<T> msg)
     {
         wrapped.response(msg);
         if (requiredBeforeFinishUpdater.decrementAndGet(this) == 0)
-            cleanup.run();
+            cleanup.ackMutation();
     }
 
     public boolean isLatencyForSnitch()
@@ -107,7 +107,7 @@ public BatchlogCleanup(int mutationsWaitingFor, BatchlogCleanupCallback callback
             this.callback = callback;
         }
 
-        public void run()
+        public void ackMutation()
         {
             if (mutationsWaitingForUpdater.decrementAndGet(this) == 0)
                 callback.invoke();

File: src/java/org/apache/cassandra/streaming/StreamResultFuture.java
Patch:
@@ -212,7 +212,6 @@ synchronized void fireStreamEvent(StreamEvent event)
 
     private synchronized void maybeComplete()
     {
-        logger.warn("[Stream #{}] maybeComplete", planId);
         if (!coordinator.hasActiveSessions())
         {
             StreamState finalState = getCurrentState();

File: src/java/org/apache/cassandra/transport/CBUtil.java
Patch:
@@ -140,7 +140,7 @@ public static String readString(ByteBuf cb)
     public static void writeString(String str, ByteBuf cb)
     {
         int writerIndex = cb.writerIndex();
-        cb.writerIndex(writerIndex + 2);
+        cb.writeShort(0);
         int written = ByteBufUtil.writeUtf8(cb, str);
         cb.setShort(writerIndex, written);
     }
@@ -166,7 +166,7 @@ public static String readLongString(ByteBuf cb)
     public static void writeLongString(String str, ByteBuf cb)
     {
         int writerIndex = cb.writerIndex();
-        cb.writerIndex(writerIndex + 4);
+        cb.writeInt(0);
         int written = ByteBufUtil.writeUtf8(cb, str);
         cb.setInt(writerIndex, written);
     }

File: src/java/org/apache/cassandra/db/rows/ComplexColumnData.java
Patch:
@@ -218,7 +218,7 @@ public boolean equals(Object other)
     @Override
     public int hashCode()
     {
-        return Objects.hash(column(), complexDeletion(), cells);
+        return Objects.hash(column(), complexDeletion(), BTree.hashCode(cells));
     }
 
     public static Builder builder()

File: src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java
Patch:
@@ -1174,9 +1174,9 @@ else if (samplingLevel < indexSummary.getSamplingLevel())
                 saveSummary(ibuilder, dbuilder, newSummary);
             }
 
-            long newSize = bytesOnDisk();
-            StorageMetrics.load.inc(newSize - oldSize);
-            parent.metric.liveDiskSpaceUsed.inc(newSize - oldSize);
+            // The new size will be added in Transactional.commit() as an updated SSTable, more details: CASSANDRA-13738
+            StorageMetrics.load.dec(oldSize);
+            parent.metric.liveDiskSpaceUsed.dec(oldSize);
 
             return cloneAndReplace(first, OpenReason.METADATA_CHANGE, newSummary);
         }

File: src/java/org/apache/cassandra/cql3/UpdateParameters.java
Patch:
@@ -233,6 +233,6 @@ public Row getPrefetchedRow(DecoratedKey key, Clustering clustering)
             return pendingMutations;
 
         return Rows.merge(prefetchedRow, pendingMutations, nowInSec)
-                   .purge(DeletionPurger.PURGE_ALL, nowInSec);
+                   .purge(DeletionPurger.PURGE_ALL, nowInSec, metadata.enforceStrictLiveness());
     }
 }

File: src/java/org/apache/cassandra/db/filter/RowFilter.java
Patch:
@@ -148,7 +148,7 @@ public boolean hasExpressionOnClusteringOrRegularColumns()
     public boolean isSatisfiedBy(CFMetaData metadata, DecoratedKey partitionKey, Row row, int nowInSec)
     {
         // We purge all tombstones as the expressions isSatisfiedBy methods expects it
-        Row purged = row.purge(DeletionPurger.PURGE_ALL, nowInSec);
+        Row purged = row.purge(DeletionPurger.PURGE_ALL, nowInSec, metadata.enforceStrictLiveness());
         if (purged == null)
             return expressions.isEmpty();
 
@@ -290,7 +290,7 @@ public UnfilteredRowIterator applyToPartition(UnfilteredRowIterator partition)
 
                 public Row applyToRow(Row row)
                 {
-                    Row purged = row.purge(DeletionPurger.PURGE_ALL, nowInSec);
+                    Row purged = row.purge(DeletionPurger.PURGE_ALL, nowInSec, metadata.enforceStrictLiveness());
                     if (purged == null)
                         return null;
 

File: src/java/org/apache/cassandra/db/transform/FilteredPartitions.java
Patch:
@@ -52,7 +52,9 @@ public final class FilteredPartitions extends BasePartitions<RowIterator, BasePa
      */
     public static FilteredPartitions filter(UnfilteredPartitionIterator iterator, int nowInSecs)
     {
-        FilteredPartitions filtered = filter(iterator, new Filter(nowInSecs));
+        FilteredPartitions filtered = filter(iterator,
+                                             new Filter(nowInSecs,
+                                                        iterator.metadata().enforceStrictLiveness()));
 
         return iterator.isForThrift()
              ? filtered

File: src/java/org/apache/cassandra/db/transform/FilteredRows.java
Patch:
@@ -55,6 +55,6 @@ public boolean isEmpty()
      */
     public static RowIterator filter(UnfilteredRowIterator iterator, int nowInSecs)
     {
-        return new Filter(nowInSecs).applyToPartition(iterator);
+        return new Filter(nowInSecs, iterator.metadata().enforceStrictLiveness()).applyToPartition(iterator);
     }
 }

File: src/java/org/apache/cassandra/service/DataResolver.java
Patch:
@@ -86,7 +86,9 @@ public PartitionIterator resolve()
         DataLimits.Counter counter = command.limits().newCounter(command.nowInSec(), true, command.selectsFullPartition());
 
         UnfilteredPartitionIterator merged = mergeWithShortReadProtection(iters, sources, counter);
-        FilteredPartitions filtered = FilteredPartitions.filter(merged, new Filter(command.nowInSec()));
+        FilteredPartitions filtered = FilteredPartitions.filter(merged,
+                                                                new Filter(command.nowInSec(),
+                                                                           command.metadata().enforceStrictLiveness()));
         PartitionIterator counted = counter.applyTo(filtered);
 
         return command.isForThrift()

File: test/unit/org/apache/cassandra/cql3/CQLTester.java
Patch:
@@ -1001,7 +1001,7 @@ private static void assertRowsIgnoringOrderInternal(UntypedResultSet result, boo
         assert ignoreExtra || expectedRows.size() == actualRows.size();
     }
 
-    private static List<String> makeRowStrings(UntypedResultSet resultSet)
+    protected static List<String> makeRowStrings(UntypedResultSet resultSet)
     {
         List<List<ByteBuffer>> rows = new ArrayList<>();
         for (UntypedResultSet.Row row : resultSet)

File: src/java/org/apache/cassandra/net/async/InboundHandshakeHandler.java
Patch:
@@ -37,7 +37,7 @@
  */
 class InboundHandshakeHandler extends ByteToMessageDecoder
 {
-    private static final Logger logger = LoggerFactory.getLogger(NettyFactory.class);
+    private static final Logger logger = LoggerFactory.getLogger(InboundHandshakeHandler.class);
 
     enum State { START, AWAITING_HANDSHAKE_BEGIN, AWAIT_MESSAGING_START_RESPONSE, HANDSHAKE_COMPLETE, HANDSHAKE_FAIL }
 

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -906,9 +906,9 @@ public ListenableFuture<ReplayPosition> switchMemtable()
             logFlush();
             Flush flush = new Flush(false);
             ListenableFutureTask<Void> flushTask = ListenableFutureTask.create(flush, null);
-            flushExecutor.submit(flushTask);
+            flushExecutor.execute(flushTask);
             ListenableFutureTask<ReplayPosition> task = ListenableFutureTask.create(flush.postFlush);
-            postFlushExecutor.submit(task);
+            postFlushExecutor.execute(task);
 
             @SuppressWarnings("unchecked")
             ListenableFuture<ReplayPosition> future = 

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -1457,7 +1457,7 @@ public int getActiveCompactions()
         return CompactionMetrics.getCompactions().size();
     }
 
-    private static class CompactionExecutor extends JMXEnabledThreadPoolExecutor
+    static class CompactionExecutor extends JMXEnabledThreadPoolExecutor
     {
         protected CompactionExecutor(int minThreads, int maxThreads, String name, BlockingQueue<Runnable> queue)
         {
@@ -1537,7 +1537,7 @@ public ListenableFuture<?> submitIfRunning(Callable<?> task, String name)
             try
             {
                 ListenableFutureTask ret = ListenableFutureTask.create(task);
-                submit(ret);
+                execute(ret);
                 return ret;
             }
             catch (RejectedExecutionException ex)

File: test/unit/org/apache/cassandra/db/HintedHandOffTest.java
Patch:
@@ -85,7 +85,7 @@ public void testCompactionOfHintsCF() throws Exception
     public void testHintsMetrics() throws Exception
     {
         for (int i = 0; i < 99; i++)
-            HintedHandOffManager.instance.metrics.incrPastWindow(InetAddress.getLocalHost());
+            HintedHandOffManager.instance.metrics.incrPastWindow(InetAddress.getByName("127.0.0.1"));
         HintedHandOffManager.instance.metrics.log();
 
         UntypedResultSet rows = executeInternal("SELECT hints_dropped FROM system." + SystemKeyspace.PEER_EVENTS_CF);

File: src/java/org/apache/cassandra/db/AbstractReadCommandBuilder.java
Patch:
@@ -336,7 +336,7 @@ else if (!startInclusive && endInclusive)
             else
                 bounds = new ExcludingBounds<>(start, end);
 
-            return new PartitionRangeReadCommand(cfs.metadata, nowInSeconds, makeColumnFilter(), filter, makeLimits(), new DataRange(bounds, makeFilter()), Optional.empty());
+            return PartitionRangeReadCommand.create(false, cfs.metadata, nowInSeconds, makeColumnFilter(), filter, makeLimits(), new DataRange(bounds, makeFilter()));
         }
 
         static DecoratedKey makeKey(CFMetaData metadata, Object... partitionKey)

File: src/java/org/apache/cassandra/index/internal/keys/KeysSearcher.java
Patch:
@@ -99,7 +99,8 @@ private boolean prepareNext()
                                                                                            command.rowFilter(),
                                                                                            DataLimits.NONE,
                                                                                            key,
-                                                                                           command.clusteringIndexFilter(key));
+                                                                                           command.clusteringIndexFilter(key),
+                                                                                           null);
 
                     @SuppressWarnings("resource") // filterIfStale closes it's iterator if either it materialize it or if it returns null.
                                                   // Otherwise, we close right away if empty, and if it's assigned to next it will be called either

File: src/java/org/apache/cassandra/service/AbstractReadExecutor.java
Patch:
@@ -88,7 +88,7 @@ protected void makeDataRequests(Iterable<InetAddress> endpoints)
 
     protected void makeDigestRequests(Iterable<InetAddress> endpoints)
     {
-        makeRequests(command.copy().setIsDigestQuery(true), endpoints);
+        makeRequests(command.copyAsDigestQuery(), endpoints);
     }
 
     private void makeRequests(ReadCommand readCommand, Iterable<InetAddress> endpoints)
@@ -284,7 +284,7 @@ public void maybeTryAdditionalReplicas()
                 // Could be waiting on the data, or on enough digests.
                 ReadCommand retryCommand = command;
                 if (handler.resolver.isDataPresent())
-                    retryCommand = command.copy().setIsDigestQuery(true);
+                    retryCommand = command.copyAsDigestQuery();
 
                 InetAddress extraReplica = Iterables.getLast(targetReplicas);
                 if (traceState != null)

File: test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java
Patch:
@@ -604,7 +604,7 @@ private void assertIndexQueryWorks(ColumnFamilyStore indexedCFS)
                                              .columns("birthdate")
                                              .filterOn("birthdate", Operator.EQ, 1L)
                                              .build();
-        Index.Searcher searcher = indexedCFS.indexManager.getBestIndexFor(rc).searcherFor(rc);
+        Index.Searcher searcher = rc.index().searcherFor(rc);
         assertNotNull(searcher);
         try (ReadOrderGroup orderGroup = ReadOrderGroup.forCommand(rc))
         {

File: src/java/org/apache/cassandra/db/transform/FilteredRows.java
Patch:
@@ -55,6 +55,6 @@ public boolean isEmpty()
      */
     public static RowIterator filter(UnfilteredRowIterator iterator, int nowInSecs)
     {
-        return new Filter(false, nowInSecs).applyToPartition(iterator);
+        return new Filter(nowInSecs).applyToPartition(iterator);
     }
 }

File: examples/triggers/src/org/apache/cassandra/triggers/AuditTrigger.java
Patch:
@@ -45,7 +45,7 @@ public Collection<Mutation> augment(Partition update)
 
         audit.row()
              .add("keyspace_name", update.metadata().keyspace)
-             .add("table_name", update.metadata().table)
+             .add("table_name", update.metadata().name)
              .add("primary_key", update.metadata().partitionKeyType.getString(update.partitionKey().getKey()));
 
         return Collections.singletonList(audit.buildAsMutation());

File: src/java/org/apache/cassandra/db/compaction/PendingRepairManager.java
Patch:
@@ -300,6 +300,9 @@ synchronized AbstractCompactionTask getNextBackgroundTask(int gcBefore)
             sessions.add(entry.getKey());
         }
 
+        if (sessions.isEmpty())
+            return null;
+
         // we want the session with the most compactions at the head of the list
         sessions.sort((o1, o2) -> numTasks.get(o2) - numTasks.get(o1));
 

File: src/java/org/apache/cassandra/tools/SSTableExport.java
Patch:
@@ -254,7 +254,7 @@ public static void main(String[] args) throws ConfigurationException
 
     private static void printUsage()
     {
-        String usage = String.format("sstabledump <options> <sstable file path>%n");
+        String usage = String.format("sstabledump <sstable file path> <options>%n");
         String header = "Dump contents of given SSTable to standard output in JSON format.";
         new HelpFormatter().printHelp(usage, header, options, "");
     }

File: test/unit/org/apache/cassandra/db/CounterCellTest.java
Patch:
@@ -276,8 +276,8 @@ public void testUpdateDigest() throws Exception
         ColumnDefinition cDef = cfs.metadata.getColumnDefinition(col);
         Cell cleared = BufferCell.live(cfs.metadata, cDef, 5, CounterContext.instance().clearAllLocal(state.context));
 
-        CounterContext.instance().updateDigest(digest1, original.value());
-        CounterContext.instance().updateDigest(digest2, cleared.value());
+        original.digest(digest1);
+        cleared.digest(digest2);
 
         assert Arrays.equals(digest1.digest(), digest2.digest());
     }

File: src/java/org/apache/cassandra/db/rows/BTreeRow.java
Patch:
@@ -294,7 +294,7 @@ public boolean hasComplexDeletion()
 
     public Row markCounterLocalToBeCleared()
     {
-        return transformAndFilter(primaryKeyLivenessInfo, deletion, (cd) -> cd.column().cellValueType().isCounter()
+        return transformAndFilter(primaryKeyLivenessInfo, deletion, (cd) -> cd.column().isCounterColumn()
                                                                             ? cd.markCounterLocalToBeCleared()
                                                                             : cd);
     }

File: src/java/org/apache/cassandra/db/rows/BufferCell.java
Patch:
@@ -89,7 +89,7 @@ public static BufferCell tombstone(ColumnDefinition column, long timestamp, int
 
     public boolean isCounterCell()
     {
-        return !isTombstone() && column.cellValueType().isCounter();
+        return !isTombstone() && column.isCounterColumn();
     }
 
     public boolean isLive(int nowInSec)

File: src/java/org/apache/cassandra/db/PartitionRangeReadCommand.java
Patch:
@@ -309,7 +309,8 @@ public PartitionIterator postReconciliationProcessing(PartitionIterator result)
     @Override
     public boolean selectsFullPartition()
     {
-        return dataRange.selectsAllPartition() && !rowFilter().hasExpressionOnClusteringOrRegularColumns();
+        return metadata().isStaticCompactTable() ||
+               (dataRange.selectsAllPartition() && !rowFilter().hasExpressionOnClusteringOrRegularColumns());
     }
 
     @Override

File: src/java/org/apache/cassandra/db/SinglePartitionReadCommand.java
Patch:
@@ -918,7 +918,8 @@ private boolean canRemoveRow(Row row, Columns requestedColumns, long sstableTime
     @Override
     public boolean selectsFullPartition()
     {
-        return clusteringIndexFilter.selectsAllPartition() && !rowFilter().hasExpressionOnClusteringOrRegularColumns();
+        return metadata().isStaticCompactTable() ||
+               (clusteringIndexFilter.selectsAllPartition() && !rowFilter().hasExpressionOnClusteringOrRegularColumns());
     }
 
     @Override

File: src/java/org/apache/cassandra/db/filter/ClusteringIndexNamesFilter.java
Patch:
@@ -72,7 +72,9 @@ public NavigableSet<Clustering> requestedRows()
 
     public boolean selectsAllPartition()
     {
-        return false;
+        // if the clusterings set is empty we are selecting a static row and in this case we want to count
+        // static rows so we return true
+        return clusterings.isEmpty();
     }
 
     public boolean selects(Clustering clustering)

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -1016,7 +1016,7 @@ private LegacyLayout.LegacyCell toCounterLegacyCell(CFMetaData metadata, Counter
     private LegacyLayout.LegacyCell toCounterLegacyCell(CFMetaData metadata, ByteBuffer superColumnName, CounterColumn column)
     throws UnknownColumnException
     {
-        return LegacyLayout.LegacyCell.counter(metadata, superColumnName, column.name, column.value);
+        return LegacyLayout.LegacyCell.counterUpdate(metadata, superColumnName, column.name, column.value);
     }
 
     private void sortAndMerge(CFMetaData metadata, List<LegacyLayout.LegacyCell> cells, int nowInSec)
@@ -2169,7 +2169,7 @@ public void add(ByteBuffer key, ColumnParent column_parent, CounterColumn column
                 LegacyLayout.LegacyCellName name = LegacyLayout.decodeCellName(metadata, column_parent.super_column, column.name);
 
                 // See UpdateParameters.addCounter() for more details on this
-                ByteBuffer value = CounterContext.instance().createLocal(column.value);
+                ByteBuffer value = CounterContext.instance().createUpdate(column.value);
                 CellPath path = name.collectionElement == null ? null : CellPath.create(name.collectionElement);
                 Cell cell = BufferCell.live(metadata, name.column, FBUtilities.timestampMicros(), value, path);
 

File: src/java/org/apache/cassandra/utils/CounterId.java
Patch:
@@ -46,10 +46,11 @@ public static CounterId getLocalId()
     }
 
     /**
-     * Function for test purposes, do not use otherwise.
      * Pack an int in a valid CounterId so that the resulting ids respects the
      * numerical ordering. Used for creating handcrafted but easy to
      * understand contexts in unit tests (see CounterContextTest).
+     *
+     * Also used to generate a special ID for special-case update contexts (see CounterContext.createUpdate()).
      */
     public static CounterId fromInt(int n)
     {

File: src/java/org/apache/cassandra/metrics/StorageMetrics.java
Patch:
@@ -29,7 +29,8 @@ public class StorageMetrics
     private static final MetricNameFactory factory = new DefaultNameFactory("Storage");
 
     public static final Counter load = Metrics.counter(factory.createMetricName("Load"));
-    public static final Counter exceptions = Metrics.counter(factory.createMetricName("Exceptions"));
+    public static final Counter uncaughtExceptions = Metrics.counter(factory.createMetricName("Exceptions"));
     public static final Counter totalHintsInProgress  = Metrics.counter(factory.createMetricName("TotalHintsInProgress"));
     public static final Counter totalHints = Metrics.counter(factory.createMetricName("TotalHints"));
+    public static final Counter repairExceptions = Metrics.counter(factory.createMetricName("RepairExceptions"));
 }

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -207,7 +207,7 @@ protected void setup()
         {
             public void uncaughtException(Thread t, Throwable e)
             {
-                StorageMetrics.exceptions.inc();
+                StorageMetrics.uncaughtExceptions.inc();
                 logger.error("Exception in thread " + t, e);
                 Tracing.trace("Exception in thread {}", t, e);
                 for (Throwable e2 = e; e2 != null; e2 = e2.getCause())

File: src/java/org/apache/cassandra/tools/NodeProbe.java
Patch:
@@ -1100,7 +1100,7 @@ public double getTraceProbability()
 
     public int getExceptionCount()
     {
-        return (int)StorageMetrics.exceptions.getCount();
+        return (int)StorageMetrics.uncaughtExceptions.getCount();
     }
 
     public Map<String, Integer> getDroppedMessages()

File: src/java/org/apache/cassandra/gms/FailureDetector.java
Patch:
@@ -453,7 +453,7 @@ synchronized void add(long value, InetAddress ep)
             }
             else
             {
-                logger.debug("Ignoring interval time of {} for {}", interArrivalTime, ep);
+                logger.trace("Ignoring interval time of {} for {}", interArrivalTime, ep);
             }
         }
         else

File: src/java/org/apache/cassandra/schema/SchemaKeyspace.java
Patch:
@@ -731,13 +731,11 @@ public static Mutation makeDropViewMutation(KeyspaceMetadata keyspace, ViewDefin
         return mutation;
     }
 
-    public static Mutation makeUpdateViewMutation(KeyspaceMetadata keyspace,
+    public static Mutation makeUpdateViewMutation(Mutation mutation,
                                                   ViewDefinition oldView,
                                                   ViewDefinition newView,
                                                   long timestamp)
     {
-        Mutation mutation = makeCreateKeyspaceMutation(keyspace.name, keyspace.params, timestamp);
-
         addViewToSchemaMutation(newView, timestamp, false, mutation);
 
         MapDifference<ByteBuffer, ColumnDefinition> columnDiff = Maps.difference(oldView.metadata.getColumnMetadata(),

File: src/java/org/apache/cassandra/hints/ChecksummedDataInput.java
Patch:
@@ -107,7 +107,7 @@ public boolean checkCrc() throws IOException
         {
             updateCrc();
 
-            // we must diable crc updates in case we rebuffer
+            // we must disable crc updates in case we rebuffer
             // when called source.readInt()
             crcUpdateDisabled = true;
             return ((int) crc.getValue()) == readInt();

File: src/java/org/apache/cassandra/hints/HintsDescriptor.java
Patch:
@@ -120,7 +120,7 @@ static int messagingVersion(int hintsVersion)
         switch (hintsVersion)
         {
             case VERSION_30:
-                return MessagingService.VERSION_30;
+                return MessagingService.FORCE_3_0_PROTOCOL_VERSION ? MessagingService.VERSION_30 : MessagingService.VERSION_3014;
             default:
                 throw new AssertionError();
         }

File: src/java/org/apache/cassandra/hints/HintsReader.java
Patch:
@@ -239,7 +239,7 @@ private Hint readHint(int size) throws IOException
                             descriptor.fileName());
                 input.skipBytes(Ints.checkedCast(size - input.bytesPastLimit()));
 
-                return null;
+                hint = null; // set the return value to null and let following code to update/check the CRC
             }
 
             if (input.checkCrc())

File: src/java/org/apache/cassandra/tools/nodetool/TableStats.java
Patch:
@@ -191,7 +191,7 @@ public void execute(NodeProbe probe)
                 {
                     estimatedPartitionCount = 0L;
                 }
-                System.out.println("\t\tNumber of keys (estimate): " + estimatedPartitionCount);
+                System.out.println("\t\tNumber of partitions (estimate): " + estimatedPartitionCount);
 
                 System.out.println("\t\tMemtable cell count: " + probe.getColumnFamilyMetric(keyspaceName, tableName, "MemtableColumnsCount"));
                 System.out.println("\t\tMemtable data size: " + format((Long) probe.getColumnFamilyMetric(keyspaceName, tableName, "MemtableLiveDataSize"), humanReadable));

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -142,7 +142,7 @@ public class Config
     public int internode_send_buff_size_in_bytes = 0;
     public int internode_recv_buff_size_in_bytes = 0;
 
-    public boolean start_native_transport = false;
+    public boolean start_native_transport = true;
     public int native_transport_port = 9042;
     public Integer native_transport_port_ssl = null;
     public int native_transport_max_threads = 128;

File: src/java/org/apache/cassandra/db/ColumnFamily.java
Patch:
@@ -92,7 +92,7 @@ public int liveCQL3RowCount(long now)
     {
         ColumnCounter counter = getComparator().isDense()
                               ? new ColumnCounter(now)
-                              : new ColumnCounter.GroupByPrefix(now, getComparator(), metadata.clusteringColumns().size());
+                              : new ColumnCounter.GroupByPrefix(now, getComparator(), metadata.clusteringColumns().size(), true);
         return counter.countAll(this).live();
     }
 

File: src/java/org/apache/cassandra/db/filter/NamesQueryFilter.java
Patch:
@@ -183,7 +183,7 @@ public boolean countCQL3Rows()
     public ColumnCounter columnCounter(CellNameType comparator, long now)
     {
         return countCQL3Rows
-             ? new ColumnCounter.GroupByPrefix(now, null, 0)
+             ? new ColumnCounter.GroupByPrefix(now, null, 0, false)
              : new ColumnCounter(now);
     }
 

File: src/java/org/apache/cassandra/db/marshal/ListType.java
Patch:
@@ -208,13 +208,14 @@ public Term fromJSONObject(Object parsed) throws MarshalException
 
     public static String setOrListToJsonString(ByteBuffer buffer, AbstractType elementsType, int protocolVersion)
     {
+        ByteBuffer value = buffer.duplicate();
         StringBuilder sb = new StringBuilder("[");
-        int size = CollectionSerializer.readCollectionSize(buffer, protocolVersion);
+        int size = CollectionSerializer.readCollectionSize(value, protocolVersion);
         for (int i = 0; i < size; i++)
         {
             if (i > 0)
                 sb.append(", ");
-            sb.append(elementsType.toJSONString(CollectionSerializer.readValue(buffer, protocolVersion), protocolVersion));
+            sb.append(elementsType.toJSONString(CollectionSerializer.readValue(value, protocolVersion), protocolVersion));
         }
         return sb.append("]").toString();
     }

File: src/java/org/apache/cassandra/db/marshal/TupleType.java
Patch:
@@ -261,13 +261,14 @@ else if (types.size() > list.size())
     @Override
     public String toJSONString(ByteBuffer buffer, int protocolVersion)
     {
+        ByteBuffer duplicated = buffer.duplicate();
         StringBuilder sb = new StringBuilder("[");
         for (int i = 0; i < types.size(); i++)
         {
             if (i > 0)
                 sb.append(", ");
 
-            ByteBuffer value = CollectionSerializer.readValue(buffer, protocolVersion);
+            ByteBuffer value = CollectionSerializer.readValue(duplicated, protocolVersion);
             if (value == null)
                 sb.append("null");
             else

File: src/java/org/apache/cassandra/cql3/UserTypes.java
Patch:
@@ -91,7 +91,7 @@ public Term prepare(String keyspace, ColumnSpecification receiver) throws Invali
         private void validateAssignableTo(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
         {
             if (!(receiver.type instanceof UserType))
-                throw new InvalidRequestException(String.format("Invalid user type literal for %s of type %s", receiver, receiver.type.asCQL3Type()));
+                throw new InvalidRequestException(String.format("Invalid user type literal for %s of type %s", receiver.name, receiver.type.asCQL3Type()));
 
             UserType ut = (UserType)receiver.type;
             for (int i = 0; i < ut.size(); i++)
@@ -103,7 +103,7 @@ private void validateAssignableTo(String keyspace, ColumnSpecification receiver)
 
                 ColumnSpecification fieldSpec = fieldSpecOf(receiver, i);
                 if (!value.testAssignment(keyspace, fieldSpec).isAssignable())
-                    throw new InvalidRequestException(String.format("Invalid user type literal for %s: field %s is not of type %s", receiver, field, fieldSpec.type.asCQL3Type()));
+                    throw new InvalidRequestException(String.format("Invalid user type literal for %s: field %s is not of type %s", receiver.name, field, fieldSpec.type.asCQL3Type()));
             }
         }
 

File: src/java/org/apache/cassandra/db/compaction/PendingRepairManager.java
Patch:
@@ -359,7 +359,7 @@ synchronized Set<ISSTableScanner> getScanners(Collection<SSTableReader> sstables
         Set<ISSTableScanner> scanners = new HashSet<>(sessionSSTables.size());
         for (Map.Entry<UUID, Set<SSTableReader>> entry : sessionSSTables.entrySet())
         {
-            scanners.addAll(get(entry.getKey()).getScanners(entry.getValue(), ranges).scanners);
+            scanners.addAll(getOrCreate(entry.getKey()).getScanners(entry.getValue(), ranges).scanners);
         }
         return scanners;
     }

File: src/java/org/apache/cassandra/cql3/selection/Selection.java
Patch:
@@ -81,7 +81,7 @@ public boolean isWildcard()
      */
     public boolean containsStaticColumns()
     {
-        if (!cfm.hasStaticColumns())
+        if (cfm.isStaticCompactTable() || !cfm.hasStaticColumns())
             return false;
 
         if (isWildcard())

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -598,7 +598,7 @@ public void runMayThrow()
                 catch (Exception ex)
                 {
                     if (!(ex instanceof WriteTimeoutException))
-                        logger.error("Failed to apply paxos commit locally : {}", ex);
+                        logger.error("Failed to apply paxos commit locally : ", ex);
                     responseHandler.onFailure(FBUtilities.getBroadcastAddress(), RequestFailureReason.UNKNOWN);
                 }
             }
@@ -1362,7 +1362,7 @@ public void runMayThrow()
                 }
                 catch (Exception ex)
                 {
-                    logger.error("Failed to apply mutation locally : {}", ex);
+                    logger.error("Failed to apply mutation locally : ", ex);
                 }
             }
 
@@ -1388,7 +1388,7 @@ public void runMayThrow()
                 catch (Exception ex)
                 {
                     if (!(ex instanceof WriteTimeoutException))
-                        logger.error("Failed to apply mutation locally : {}", ex);
+                        logger.error("Failed to apply mutation locally : ", ex);
                     handler.onFailure(FBUtilities.getBroadcastAddress(), RequestFailureReason.UNKNOWN);
                 }
             }

File: src/java/org/apache/cassandra/db/filter/ColumnFilter.java
Patch:
@@ -533,7 +533,7 @@ private static int makeHeaderByte(ColumnFilter selection)
         @VisibleForTesting
         public static ColumnFilter maybeUpdateForBackwardCompatility(ColumnFilter selection, int version)
         {
-            if (version > MessagingService.VERSION_30 || !selection.fetchAllRegulars || selection.queried == null)
+            if (version > MessagingService.VERSION_3014 || !selection.fetchAllRegulars || selection.queried == null)
                 return selection;
 
             // The meaning of fetchAllRegulars changed (at least when queried != null) due to CASSANDRA-12768: in

File: test/unit/org/apache/cassandra/db/filter/ColumnFilterTest.java
Patch:
@@ -53,7 +53,7 @@ public void columnFilterSerialisationRoundTrip() throws Exception
 
         columnFilter = ColumnFilter.all(metadata);
         testRoundTrip(columnFilter, ColumnFilter.Serializer.maybeUpdateForBackwardCompatility(columnFilter, MessagingService.VERSION_30), metadata, MessagingService.VERSION_30);
-        testRoundTrip(ColumnFilter.all(metadata), metadata, MessagingService.VERSION_3014);
+        testRoundTrip(columnFilter, ColumnFilter.Serializer.maybeUpdateForBackwardCompatility(columnFilter, MessagingService.VERSION_3014), metadata, MessagingService.VERSION_3014);
         testRoundTrip(ColumnFilter.all(metadata), metadata, MessagingService.VERSION_40);
 
         testRoundTrip(ColumnFilter.selection(metadata.regularAndStaticColumns().without(v1)), metadata, MessagingService.VERSION_30);
@@ -62,7 +62,7 @@ public void columnFilterSerialisationRoundTrip() throws Exception
 
         columnFilter = ColumnFilter.selection(metadata, metadata.regularAndStaticColumns().without(v1));
         testRoundTrip(columnFilter, ColumnFilter.Serializer.maybeUpdateForBackwardCompatility(columnFilter, MessagingService.VERSION_30), metadata, MessagingService.VERSION_30);
-        testRoundTrip(ColumnFilter.selection(metadata, metadata.regularAndStaticColumns().without(v1)), metadata, MessagingService.VERSION_3014);
+        testRoundTrip(columnFilter, ColumnFilter.Serializer.maybeUpdateForBackwardCompatility(columnFilter, MessagingService.VERSION_3014), metadata, MessagingService.VERSION_3014);
         testRoundTrip(ColumnFilter.selection(metadata, metadata.regularAndStaticColumns().without(v1)), metadata, MessagingService.VERSION_40);
     }
 

File: src/java/org/apache/cassandra/net/MessageIn.java
Patch:
@@ -105,7 +105,7 @@ public static <T2> MessageIn<T2> read(DataInputPlus in, int version, int id, lon
         }
 
         int payloadSize = in.readInt();
-        IVersionedSerializer<T2> serializer = (IVersionedSerializer<T2>) MessagingService.verbSerializers.get(verb);
+        IVersionedSerializer<T2> serializer = (IVersionedSerializer<T2>) MessagingService.instance().verbSerializers.get(verb);
         if (serializer instanceof MessagingService.CallbackDeterminedSerializer)
         {
             CallbackInfo callback = MessagingService.instance().getRegisteredCallback(id);

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -318,7 +318,7 @@ public long getTimeout()
      * intermediary byte[] (See CASSANDRA-3716), we need to wire that up to the CallbackInfo object
      * (see below).
      */
-    public static final EnumMap<Verb, IVersionedSerializer<?>> verbSerializers = new EnumMap<Verb, IVersionedSerializer<?>>(Verb.class)
+    public final EnumMap<Verb, IVersionedSerializer<?>> verbSerializers = new EnumMap<Verb, IVersionedSerializer<?>>(Verb.class)
     {{
         put(Verb.REQUEST_RESPONSE, CallbackDeterminedSerializer.instance);
         put(Verb.INTERNAL_RESPONSE, CallbackDeterminedSerializer.instance);

File: src/java/org/apache/cassandra/utils/BloomFilter.java
Patch:
@@ -59,7 +59,7 @@ public long serializedSize()
 
     // Murmur is faster than an SHA-based approach and provides as-good collision
     // resistance.  The combinatorial generation approach described in
-    // http://www.eecs.harvard.edu/~kirsch/pubs/bbbf/esa06.pdf
+    // https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf
     // does prove to work in actual tests, and is obviously faster
     // than performing further iterations of murmur.
 

File: src/java/org/apache/cassandra/index/sasi/plan/QueryPlan.java
Patch:
@@ -110,6 +110,9 @@ protected UnfilteredRowIterator computeNext()
                     if (!keyRange.right.isMinimum() && keyRange.right.compareTo(key) < 0)
                         return endOfData();
 
+                    if (!keyRange.inclusiveLeft() && key.compareTo(keyRange.left) == 0)
+                        continue;
+
                     try (UnfilteredRowIterator partition = controller.getPartition(key, executionController))
                     {
                         Row staticRow = partition.staticRow();

File: src/java/org/apache/cassandra/db/marshal/DurationType.java
Patch:
@@ -28,7 +28,6 @@
 import org.apache.cassandra.serializers.TypeSerializer;
 import org.apache.cassandra.transport.ProtocolVersion;
 import org.apache.cassandra.utils.ByteBufferUtil;
-import org.apache.cassandra.utils.FastByteOperations;
 
 /**
  * Represents a duration. The duration is stored as  months, days, and nanoseconds. This is done

File: src/java/org/apache/cassandra/repair/RepairSession.java
Patch:
@@ -349,7 +349,7 @@ public void convict(InetAddress endpoint, double phi)
             return;
 
         Exception exception = new IOException(String.format("Endpoint %s died", endpoint));
-        logger.error(String.format("{} session completed with the following error", previewKind.logPrefix(getId())), exception);
+        logger.error("{} session completed with the following error", previewKind.logPrefix(getId()), exception);
         // If a node failed, we stop everything (though there could still be some activity in the background)
         forceShutdown(exception);
     }

File: test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java
Patch:
@@ -1924,7 +1924,7 @@ public void testInvalidIndexOptions()
         try
         {
             // unsupported partition key column
-            SASIIndex.validateOptions(Collections.singletonMap("target", "id"), store.metadata);
+            SASIIndex.validateOptions(Collections.singletonMap("target", "id"), store.metadata());
             Assert.fail();
         }
         catch (ConfigurationException e)

File: src/java/org/apache/cassandra/db/index/AbstractSimplePerColumnSecondaryIndex.java
Patch:
@@ -116,7 +116,7 @@ public void insert(ByteBuffer rowKey, Cell cell, OpOrder.Group opGroup)
         DecoratedKey valueKey = getIndexKeyFor(getIndexedValue(rowKey, cell));
         ColumnFamily cfi = ArrayBackedSortedColumns.factory.create(indexCfs.metadata, false, 1);
         CellName name = makeIndexColumnName(rowKey, cell);
-        if (cell instanceof ExpiringCell)
+        if (!columnDef.isPrimaryKeyColumn() && cell instanceof ExpiringCell)
         {
             ExpiringCell ec = (ExpiringCell) cell;
             cfi.addColumn(new BufferExpiringCell(name, ByteBufferUtil.EMPTY_BYTE_BUFFER, ec.timestamp(), ec.getTimeToLive(), ec.getLocalDeletionTime()));

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -2247,8 +2247,9 @@ private void excise(Collection<Token> tokens, InetAddress endpoint)
     {
         logger.info("Removing tokens {} for {}", tokens, endpoint);
 
-        if (tokenMetadata.isMember(endpoint))
-            HintsService.instance.excise(tokenMetadata.getHostId(endpoint));
+        UUID hostId = tokenMetadata.getHostId(endpoint);
+        if (hostId != null && tokenMetadata.isMember(endpoint))
+            HintsService.instance.excise(hostId);
 
         removeEndpoint(endpoint);
         tokenMetadata.removeEndpoint(endpoint);

File: test/unit/org/apache/cassandra/db/compaction/NeverPurgeTest.java
Patch:
@@ -80,7 +80,7 @@ public void minorNeverPurgeTombstonesTest() throws Throwable
         execute("DELETE FROM %s WHERE a=3");
         cfs.forceBlockingFlush();
         cfs.enableAutoCompaction();
-        while (cfs.getSSTables().size() > 1)
+        while (cfs.getSSTables().size() > 1 || !cfs.getTracker().getCompacting().isEmpty())
             Thread.sleep(100);
         verifyContainsTombstones(cfs.getSSTables(), 3);
     }

File: tools/stress/src/org/apache/cassandra/io/sstable/StressCQLSSTableWriter.java
Patch:
@@ -609,7 +609,9 @@ public static ColumnFamilyStore createOfflineTable(CreateTableStatement.RawState
             KeyspaceMetadata ksm = Schema.instance.getKSMetaData(keyspace);
 
             CFMetaData cfMetaData = ksm.tables.getNullable(schemaStatement.columnFamily());
-            assert cfMetaData == null;
+
+            if (cfMetaData != null)
+                return Schema.instance.getColumnFamilyStoreInstance(cfMetaData.cfId);
 
             CreateTableStatement statement = (CreateTableStatement) schemaStatement.prepare(ksm.types).statement;
             statement.validate(ClientState.forInternalCalls());

File: tools/stress/src/org/apache/cassandra/stress/CompactionStress.java
Patch:
@@ -74,7 +74,7 @@ public abstract class CompactionStress implements Runnable
 
     static
     {
-        DatabaseDescriptor.toolInitialization();
+        DatabaseDescriptor.daemonInitialization();
     }
 
     List<File> getDataDirectories()

File: src/java/org/apache/cassandra/cache/OHCProvider.java
Patch:
@@ -100,7 +100,7 @@ public int size()
 
         public long weightedSize()
         {
-            return ohCache.size();
+            return ohCache.memUsed();
         }
 
         public void clear()

File: src/java/org/apache/cassandra/dht/tokenallocator/TokenAllocation.java
Patch:
@@ -62,8 +62,8 @@ public static Collection<Token> allocateTokens(final TokenMetadata tokenMetadata
             SummaryStatistics os = replicatedOwnershipStats(tokenMetadataCopy, rs, endpoint);
             tokenMetadataCopy.updateNormalTokens(tokens, endpoint);
             SummaryStatistics ns = replicatedOwnershipStats(tokenMetadataCopy, rs, endpoint);
-            logger.warn("Replicated node load in datacentre before allocation {}", statToString(os));
-            logger.warn("Replicated node load in datacentre after allocation {}", statToString(ns));
+            logger.warn("Replicated node load in datacenter before allocation {}", statToString(os));
+            logger.warn("Replicated node load in datacenter after allocation {}", statToString(ns));
 
             // TODO: Is it worth doing the replicated ownership calculation always to be able to raise this alarm?
             if (ns.getStandardDeviation() > os.getStandardDeviation())

File: src/java/org/apache/cassandra/streaming/StreamSession.java
Patch:
@@ -241,7 +241,7 @@ public LifecycleTransaction getTransaction(TableId tableId)
     private boolean isKeepAliveSupported()
     {
         CassandraVersion peerVersion = Gossiper.instance.getReleaseVersion(peer);
-        return peerVersion.compareTo(STREAM_KEEP_ALIVE_VERSION) >= 0;
+        return peerVersion != null && peerVersion.compareTo(STREAM_KEEP_ALIVE_VERSION) >= 0;
     }
 
     /**

File: src/java/org/apache/cassandra/index/SecondaryIndexManager.java
Patch:
@@ -623,7 +623,7 @@ public int calculateIndexingPageSize()
             return DEFAULT_PAGE_SIZE;
 
         int columnsPerRow = baseCfs.metadata.partitionColumns().regulars.size();
-        if (meanCellsPerPartition <= 0)
+        if (columnsPerRow <= 0)
             return DEFAULT_PAGE_SIZE;
 
         int meanRowsPerPartition = meanCellsPerPartition / columnsPerRow;

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -3655,8 +3655,7 @@ private UUID getPreferredHintsStreamTarget()
             // stream to the closest peer as chosen by the snitch
             DatabaseDescriptor.getEndpointSnitch().sortByProximity(FBUtilities.getBroadcastAddress(), candidates);
             InetAddress hintsDestinationHost = candidates.get(0);
-            InetAddress preferred = SystemKeyspace.getPreferredIP(hintsDestinationHost);
-            return tokenMetadata.getHostId(preferred);
+            return tokenMetadata.getHostId(hintsDestinationHost);
         }
     }
 

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -325,9 +325,9 @@ public void uncaughtException(Thread t, Throwable e)
             try
             {
                 // enable metrics provided by metrics-jvm.jar
-                CassandraMetricsRegistry.Metrics.register("jvm.buffers.", new BufferPoolMetricSet(ManagementFactory.getPlatformMBeanServer()));
-                CassandraMetricsRegistry.Metrics.register("jvm.gc.", new GarbageCollectorMetricSet());
-                CassandraMetricsRegistry.Metrics.register("jvm.memory.", new MemoryUsageGaugeSet());
+                CassandraMetricsRegistry.Metrics.register("jvm.buffers", new BufferPoolMetricSet(ManagementFactory.getPlatformMBeanServer()));
+                CassandraMetricsRegistry.Metrics.register("jvm.gc", new GarbageCollectorMetricSet());
+                CassandraMetricsRegistry.Metrics.register("jvm.memory", new MemoryUsageGaugeSet());
                 CassandraMetricsRegistry.Metrics.register("jvm.fd.usage", new FileDescriptorRatioGauge());
                 // initialize metrics-reporter-config from yaml file
                 String reportFileLocation = CassandraDaemon.class.getClassLoader().getResource(metricsReporterConfigFile).getFile();

File: src/java/org/apache/cassandra/streaming/StreamSession.java
Patch:
@@ -125,7 +125,7 @@ public class StreamSession implements IEndpointStateChangeSubscriber
     /**
      * Version where keep-alive support was added
      */
-    private static final CassandraVersion STREAM_KEEP_ALIVE = new CassandraVersion("3.10");
+    private static final CassandraVersion STREAM_KEEP_ALIVE_VERSION = new CassandraVersion("3.10");
     private static final Logger logger = LoggerFactory.getLogger(StreamSession.class);
     private static final DebuggableScheduledThreadPoolExecutor keepAliveExecutor = new DebuggableScheduledThreadPoolExecutor("StreamKeepAliveExecutor");
     static {
@@ -241,7 +241,7 @@ public LifecycleTransaction getTransaction(TableId tableId)
     private boolean isKeepAliveSupported()
     {
         CassandraVersion peerVersion = Gossiper.instance.getReleaseVersion(peer);
-        return STREAM_KEEP_ALIVE.isSupportedBy(peerVersion);
+        return peerVersion.compareTo(STREAM_KEEP_ALIVE_VERSION) >= 0;
     }
 
     /**

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
Patch:
@@ -48,7 +48,7 @@
 import org.apache.cassandra.db.partitions.PartitionUpdate;
 import org.apache.cassandra.io.FSWriteError;
 import org.apache.cassandra.io.util.FileUtils;
-import org.apache.cassandra.utils.CLibrary;
+import org.apache.cassandra.utils.NativeLibrary;
 import org.apache.cassandra.utils.IntegerInterval;
 import org.apache.cassandra.utils.concurrent.OpOrder;
 import org.apache.cassandra.utils.concurrent.WaitQueue;
@@ -156,7 +156,7 @@ static long getNextId()
         try
         {
             channel = FileChannel.open(logFile.toPath(), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE);
-            fd = CLibrary.getfd(channel);
+            fd = NativeLibrary.getfd(channel);
         }
         catch (IOException e)
         {

File: src/java/org/apache/cassandra/db/commitlog/MemoryMappedSegment.java
Patch:
@@ -25,7 +25,7 @@
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.io.FSWriteError;
 import org.apache.cassandra.io.util.FileUtils;
-import org.apache.cassandra.utils.CLibrary;
+import org.apache.cassandra.utils.NativeLibrary;
 import org.apache.cassandra.utils.SyncUtil;
 
 /*
@@ -86,7 +86,7 @@ void write(int startMarker, int nextMarker)
         {
             throw new FSWriteError(e, getPath());
         }
-        CLibrary.trySkipCache(fd, startMarker, nextMarker, logFile.getAbsolutePath());
+        NativeLibrary.trySkipCache(fd, startMarker, nextMarker, logFile.getAbsolutePath());
     }
 
     @Override

File: src/java/org/apache/cassandra/hints/HintsCatalog.java
Patch:
@@ -27,7 +27,7 @@
 import com.google.common.collect.ImmutableMap;
 
 import org.apache.cassandra.io.FSReadError;
-import org.apache.cassandra.utils.CLibrary;
+import org.apache.cassandra.utils.NativeLibrary;
 import org.apache.cassandra.utils.SyncUtil;
 
 import static java.util.stream.Collectors.groupingBy;
@@ -130,11 +130,11 @@ void exciseStore(UUID hostId)
 
     void fsyncDirectory()
     {
-        int fd = CLibrary.tryOpenDirectory(hintsDirectory.getAbsolutePath());
+        int fd = NativeLibrary.tryOpenDirectory(hintsDirectory.getAbsolutePath());
         if (fd != -1)
         {
             SyncUtil.trySync(fd);
-            CLibrary.tryCloseFD(fd);
+            NativeLibrary.tryCloseFD(fd);
         }
     }
 

File: src/java/org/apache/cassandra/hints/HintsReader.java
Patch:
@@ -35,7 +35,7 @@
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.AbstractIterator;
 import org.apache.cassandra.utils.ByteBufferUtil;
-import org.apache.cassandra.utils.CLibrary;
+import org.apache.cassandra.utils.NativeLibrary;
 
 /**
  * A paged non-compressed hints reader that provides two iterators:
@@ -148,7 +148,7 @@ final class PagesIterator extends AbstractIterator<Page>
         @SuppressWarnings("resource")
         protected Page computeNext()
         {
-            CLibrary.trySkipCache(input.getChannel().getFileDescriptor(), 0, input.getFilePointer(), input.getPath());
+            NativeLibrary.trySkipCache(input.getChannel().getFileDescriptor(), 0, input.getFilePointer(), input.getPath());
 
             if (input.isEOF())
                 return endOfData();

File: src/java/org/apache/cassandra/hints/HintsWriter.java
Patch:
@@ -34,7 +34,7 @@
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.io.util.DataOutputBufferFixed;
 import org.apache.cassandra.net.MessagingService;
-import org.apache.cassandra.utils.CLibrary;
+import org.apache.cassandra.utils.NativeLibrary;
 import org.apache.cassandra.utils.SyncUtil;
 import org.apache.cassandra.utils.Throwables;
 
@@ -71,7 +71,7 @@ static HintsWriter create(File directory, HintsDescriptor descriptor) throws IOE
         File file = new File(directory, descriptor.fileName());
 
         FileChannel channel = FileChannel.open(file.toPath(), StandardOpenOption.WRITE, StandardOpenOption.CREATE_NEW);
-        int fd = CLibrary.getfd(channel);
+        int fd = NativeLibrary.getfd(channel);
 
         CRC32 crc = new CRC32();
 
@@ -293,7 +293,7 @@ private void maybeSkipCache()
             // don't skip page cache for tiny files, on the assumption that if they are tiny, the target node is probably
             // alive, and if so, the file will be closed and dispatched shortly (within a minute), and the file will be dropped.
             if (position >= DatabaseDescriptor.getTrickleFsyncIntervalInKb() * 1024L)
-                CLibrary.trySkipCache(fd, 0, position - (position % PAGE_SIZE), file.getPath());
+                NativeLibrary.trySkipCache(fd, 0, position - (position % PAGE_SIZE), file.getPath());
         }
     }
 }

File: src/java/org/apache/cassandra/io/sstable/SSTableRewriter.java
Patch:
@@ -32,7 +32,7 @@
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.io.sstable.format.SSTableWriter;
 import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
-import org.apache.cassandra.utils.CLibrary;
+import org.apache.cassandra.utils.NativeLibrary;
 import org.apache.cassandra.utils.concurrent.Transactional;
 
 /**
@@ -164,7 +164,7 @@ private void maybeReopenEarly(DecoratedKey key)
                 for (SSTableReader reader : transaction.originals())
                 {
                     RowIndexEntry index = reader.getPosition(key, SSTableReader.Operator.GE);
-                    CLibrary.trySkipCache(reader.getFilename(), 0, index == null ? 0 : index.position);
+                    NativeLibrary.trySkipCache(reader.getFilename(), 0, index == null ? 0 : index.position);
                 }
             }
             else

File: src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java
Patch:
@@ -2223,8 +2223,8 @@ public void tidy()
                 obsoletion.run();
 
             // don't ideally want to dropPageCache for the file until all instances have been released
-            CLibrary.trySkipCache(desc.filenameFor(Component.DATA), 0, 0);
-            CLibrary.trySkipCache(desc.filenameFor(Component.PRIMARY_INDEX), 0, 0);
+            NativeLibrary.trySkipCache(desc.filenameFor(Component.DATA), 0, 0);
+            NativeLibrary.trySkipCache(desc.filenameFor(Component.PRIMARY_INDEX), 0, 0);
         }
 
         public String name()

File: src/java/org/apache/cassandra/io/util/ChannelProxy.java
Patch:
@@ -26,7 +26,7 @@
 import java.nio.file.StandardOpenOption;
 
 import org.apache.cassandra.io.FSReadError;
-import org.apache.cassandra.utils.CLibrary;
+import org.apache.cassandra.utils.NativeLibrary;
 import org.apache.cassandra.utils.concurrent.RefCounted;
 import org.apache.cassandra.utils.concurrent.SharedCloseableImpl;
 
@@ -171,7 +171,7 @@ public long size()
 
     public int getFileDescriptor()
     {
-        return CLibrary.getfd(channel);
+        return NativeLibrary.getfd(channel);
     }
 
     @Override

File: src/java/org/apache/cassandra/io/util/SegmentedFile.java
Patch:
@@ -34,7 +34,7 @@
 import org.apache.cassandra.io.sstable.IndexSummaryBuilder;
 import org.apache.cassandra.io.sstable.format.Version;
 import org.apache.cassandra.io.sstable.metadata.StatsMetadata;
-import org.apache.cassandra.utils.CLibrary;
+import org.apache.cassandra.utils.NativeLibrary;
 import org.apache.cassandra.utils.concurrent.RefCounted;
 import org.apache.cassandra.utils.concurrent.SharedCloseableImpl;
 
@@ -137,7 +137,7 @@ public FileDataInput createReader(long position)
 
     public void dropPageCache(long before)
     {
-        CLibrary.trySkipCache(channel.getFileDescriptor(), 0, before, path());
+        NativeLibrary.trySkipCache(channel.getFileDescriptor(), 0, before, path());
     }
 
     /**

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -172,7 +172,7 @@ protected void setup()
 
         logSystemInfo();
 
-        CLibrary.tryMlockall();
+        NativeLibrary.tryMlockall();
 
         try
         {
@@ -717,12 +717,12 @@ static class NativeAccess implements NativeAccessMBean
     {
         public boolean isAvailable()
         {
-            return CLibrary.jnaAvailable();
+            return NativeLibrary.isAvailable();
         }
 
         public boolean isMemoryLockable()
         {
-            return CLibrary.jnaMemoryLockable();
+            return NativeLibrary.jnaMemoryLockable();
         }
     }
 

File: src/java/org/apache/cassandra/utils/HeapUtils.java
Patch:
@@ -168,7 +168,7 @@ private static String getHeapDumpPathOption()
      */
     private static Long getProcessId()
     {
-        long pid = CLibrary.getProcessID();
+        long pid = NativeLibrary.getProcessID();
         if (pid >= 0)
             return pid;
 

File: src/java/org/apache/cassandra/utils/SyncUtil.java
Patch:
@@ -176,22 +176,22 @@ public static void trySync(int fd)
         if (SKIP_SYNC)
             return;
         else
-            CLibrary.trySync(fd);
+            NativeLibrary.trySync(fd);
     }
 
     public static void trySyncDir(File dir)
     {
         if (SKIP_SYNC)
             return;
 
-        int directoryFD = CLibrary.tryOpenDirectory(dir.getPath());
+        int directoryFD = NativeLibrary.tryOpenDirectory(dir.getPath());
         try
         {
             trySync(directoryFD);
         }
         finally
         {
-            CLibrary.tryCloseFD(directoryFD);
+            NativeLibrary.tryCloseFD(directoryFD);
         }
     }
 }

File: src/java/org/apache/cassandra/utils/UUIDGen.java
Patch:
@@ -360,7 +360,7 @@ private static byte[] hash(Collection<InetAddress> data)
                 messageDigest.update(addr.getAddress());
 
             // Identify the process on the load: we use both the PID and class loader hash.
-            long pid = CLibrary.getProcessID();
+            long pid = NativeLibrary.getProcessID();
             if (pid < 0)
                 pid = new Random(System.currentTimeMillis()).nextLong();
             FBUtilities.updateWithLong(messageDigest, pid);

File: test/unit/org/apache/cassandra/utils/NativeLibraryTest.java
Patch:
@@ -25,20 +25,20 @@
 
 import org.apache.cassandra.io.util.FileUtils;
 
-public class CLibraryTest
+public class NativeLibraryTest
 {
     @Test
     public void testSkipCache()
     {
         File file = FileUtils.createTempFile("testSkipCache", "1");
 
-        CLibrary.trySkipCache(file.getPath(), 0, 0);
+        NativeLibrary.trySkipCache(file.getPath(), 0, 0);
     }
 
     @Test
     public void getPid()
     {
-        long pid = CLibrary.getProcessID();
+        long pid = NativeLibrary.getProcessID();
         Assert.assertTrue(pid > 0);
     }
 }

File: src/java/org/apache/cassandra/db/Clustering.java
Patch:
@@ -140,7 +140,7 @@ public ByteBuffer serialize(Clustering clustering, int version, List<AbstractTyp
             }
             catch (IOException e)
             {
-                throw new RuntimeException("Writting to an in-memory buffer shouldn't trigger an IOException", e);
+                throw new RuntimeException("Writing to an in-memory buffer shouldn't trigger an IOException", e);
             }
         }
 

File: src/java/org/apache/cassandra/tools/SSTableMetadataViewer.java
Patch:
@@ -129,8 +129,8 @@ public static void main(String[] args) throws IOException
                             minValues[i] = clusteringTypes.get(i).getString(minClusteringValues.get(i));
                             maxValues[i] = clusteringTypes.get(i).getString(maxClusteringValues.get(i));
                         }
-                        out.printf("minClustringValues: %s%n", Arrays.toString(minValues));
-                        out.printf("maxClustringValues: %s%n", Arrays.toString(maxValues));
+                        out.printf("minClusteringValues: %s%n", Arrays.toString(minValues));
+                        out.printf("maxClusteringValues: %s%n", Arrays.toString(maxValues));
                     }
                     out.printf("Estimated droppable tombstones: %s%n", stats.getEstimatedDroppableTombstoneRatio((int) (System.currentTimeMillis() / 1000) - gcgs));
                     out.printf("SSTable Level: %d%n", stats.sstableLevel);

File: src/java/org/apache/cassandra/db/ClusteringPrefix.java
Patch:
@@ -482,7 +482,7 @@ public int compareNextTo(ClusteringBoundOrBoundary bound) throws IOException
             }
 
             if (bound.size() == nextSize)
-                return nextKind.compareTo(bound.kind());
+                return Kind.compare(nextKind, bound.kind());
 
             // We know that we'll have exited already if nextSize < bound.size
             return -bound.kind().comparedToClustering;

File: src/java/org/apache/cassandra/db/UnfilteredDeserializer.java
Patch:
@@ -690,6 +690,5 @@ public void clearState()
                 }
             }
         }
-
     }
 }

File: src/java/org/apache/cassandra/db/ClusteringPrefix.java
Patch:
@@ -500,7 +500,7 @@ public int compareNextTo(ClusteringBoundOrBoundary bound) throws IOException
             }
 
             if (bound.size() == nextSize)
-                return nextKind.compareTo(bound.kind());
+                return Kind.compare(nextKind, bound.kind());
 
             // We know that we'll have exited already if nextSize < bound.size
             return -bound.kind().comparedToClustering;

File: src/java/org/apache/cassandra/db/ClusteringPrefix.java
Patch:
@@ -482,7 +482,7 @@ public int compareNextTo(ClusteringBoundOrBoundary bound) throws IOException
             }
 
             if (bound.size() == nextSize)
-                return nextKind.compareTo(bound.kind());
+                return Kind.compare(nextKind, bound.kind());
 
             // We know that we'll have exited already if nextSize < bound.size
             return -bound.kind().comparedToClustering;

File: src/java/org/apache/cassandra/db/UnfilteredDeserializer.java
Patch:
@@ -690,6 +690,5 @@ public void clearState()
                 }
             }
         }
-
     }
 }

File: src/java/org/apache/cassandra/db/ClusteringPrefix.java
Patch:
@@ -451,7 +451,7 @@ public int compareNextTo(Slice.Bound bound) throws IOException
             }
 
             if (bound.size() == nextSize)
-                return nextKind.compareTo(bound.kind());
+                return Kind.compare(nextKind, bound.kind());
 
             // We know that we'll have exited already if nextSize < bound.size
             return -bound.kind().comparedToClustering;

File: src/java/org/apache/cassandra/db/UnfilteredDeserializer.java
Patch:
@@ -694,6 +694,5 @@ public void clearState()
                 }
             }
         }
-
     }
 }

File: src/java/org/apache/cassandra/db/SinglePartitionReadCommand.java
Patch:
@@ -553,7 +553,7 @@ private UnfilteredRowIterator queryMemtableAndDiskInternal(ColumnFamilyStore cfs
                 if (!shouldInclude(sstable))
                 {
                     nonIntersectingSSTables++;
-                    if (sstable.hasTombstones())
+                    if (sstable.mayHaveTombstones())
                     { // if sstable has tombstones we need to check after one pass if it can be safely skipped
                         if (skippedSSTablesWithTombstones == null)
                             skippedSSTablesWithTombstones = new ArrayList<>();
@@ -739,7 +739,7 @@ private UnfilteredRowIterator queryMemtableAndSSTablesInTimestampOrder(ColumnFam
                 // however: if it is set, it impacts everything and must be included. Getting that top-level partition deletion costs us
                 // some seek in general however (unless the partition is indexed and is in the key cache), so we first check if the sstable
                 // has any tombstone at all as a shortcut.
-                if (!sstable.hasTombstones())
+                if (!sstable.mayHaveTombstones())
                     continue; // no tombstone at all, we can skip that sstable
 
                 // We need to get the partition deletion and include it if it's live. In any case though, we're done with that sstable.

File: src/java/org/apache/cassandra/db/compaction/CompactionController.java
Patch:
@@ -297,7 +297,7 @@ private UnfilteredRowIterator getShadowIterator(SSTableReader reader, DecoratedK
     {
         if (reader.isMarkedSuspect() ||
             reader.getMaxTimestamp() <= minTimestamp ||
-            tombstoneOnly && !reader.hasTombstones())
+            tombstoneOnly && !reader.mayHaveTombstones())
             return null;
         RowIndexEntry<?> position = reader.getPosition(key, SSTableReader.Operator.EQ);
         if (position == null)

File: src/java/org/apache/cassandra/db/SinglePartitionReadCommand.java
Patch:
@@ -584,7 +584,7 @@ private UnfilteredRowIterator queryMemtableAndDiskInternal(ColumnFamilyStore cfs
                 if (!shouldInclude(sstable))
                 {
                     nonIntersectingSSTables++;
-                    if (sstable.hasTombstones())
+                    if (sstable.mayHaveTombstones())
                     { // if sstable has tombstones we need to check after one pass if it can be safely skipped
                         if (skippedSSTablesWithTombstones == null)
                             skippedSSTablesWithTombstones = new ArrayList<>();
@@ -773,7 +773,7 @@ private UnfilteredRowIterator queryMemtableAndSSTablesInTimestampOrder(ColumnFam
                 // however: if it is set, it impacts everything and must be included. Getting that top-level partition deletion costs us
                 // some seek in general however (unless the partition is indexed and is in the key cache), so we first check if the sstable
                 // has any tombstone at all as a shortcut.
-                if (!sstable.hasTombstones())
+                if (!sstable.mayHaveTombstones())
                     continue; // no tombstone at all, we can skip that sstable
 
                 // We need to get the partition deletion and include it if it's live. In any case though, we're done with that sstable.

File: src/java/org/apache/cassandra/db/compaction/CompactionController.java
Patch:
@@ -297,7 +297,7 @@ private UnfilteredRowIterator getShadowIterator(SSTableReader reader, DecoratedK
     {
         if (reader.isMarkedSuspect() ||
             reader.getMaxTimestamp() <= minTimestamp ||
-            tombstoneOnly && !reader.hasTombstones())
+            tombstoneOnly && !reader.mayHaveTombstones())
             return null;
         RowIndexEntry<?> position = reader.getPosition(key, SSTableReader.Operator.EQ);
         if (position == null)

File: tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java
Patch:
@@ -165,7 +165,7 @@ else if (username != null)
                 connectionsPerHost);
         for (Host host : metadata.getAllHosts())
         {
-            System.out.printf("Datatacenter: %s; Host: %s; Rack: %s%n",
+            System.out.printf("Datacenter: %s; Host: %s; Rack: %s%n",
                     host.getDatacenter(), host.getAddress(), host.getRack());
         }
 

File: src/java/org/apache/cassandra/db/rows/Row.java
Patch:
@@ -129,7 +129,7 @@ public interface Row extends Unfiltered, Collection<ColumnData>
      * The returned object groups all the cells for the column, as well as it's complex deletion (if relevant).
      *
      * @param c the complex column for which to return the complex data.
-     * @return the data for {@code c} or {@code null} is the row has no data for this column.
+     * @return the data for {@code c} or {@code null} if the row has no data for this column.
      */
     public ComplexColumnData getComplexColumnData(ColumnDefinition c);
 

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsSchema.java
Patch:
@@ -222,7 +222,7 @@ public void printSettings(ResultLogger out)
     {
         out.println("  Keyspace: " + keyspace);
         out.println("  Replication Strategy: " + replicationStrategy);
-        out.println("  Replication Strategy Pptions: " + replicationStrategyOptions);
+        out.println("  Replication Strategy Options: " + replicationStrategyOptions);
 
         out.println("  Table Compression: " + compression);
         out.println("  Table Compaction Strategy: " + compactionStrategy);

File: test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java
Patch:
@@ -2061,7 +2061,7 @@ private void testLIKEAndEQSemanticsWithDifferenceKindsOfIndexes(String containsT
             // expected since CONTAINS + analyzed only support LIKE
         }
 
-        QueryProcessor.executeOnceInternal(String.format("SELECT * FROM %s.%s WHERE v LIKE 'Pav%%';", KS_NAME, containsTable));
+        results = QueryProcessor.executeOnceInternal(String.format("SELECT * FROM %s.%s WHERE v LIKE 'Pav%%';", KS_NAME, containsTable));
         Assert.assertNotNull(results);
         Assert.assertEquals(1, results.size());
 

File: src/java/org/apache/cassandra/utils/StreamingHistogram.java
Patch:
@@ -271,7 +271,9 @@ public boolean equals(Object o)
             return false;
 
         StreamingHistogram that = (StreamingHistogram) o;
-        return maxBinSize == that.maxBinSize && bin.equals(that.bin);
+        return maxBinSize == that.maxBinSize
+               && spool.equals(that.spool)
+               && bin.equals(that.bin);
     }
 
     @Override

File: test/unit/org/apache/cassandra/db/compaction/CompactionsTest.java
Patch:
@@ -60,11 +60,12 @@ public static void defineSchema() throws ConfigurationException
     {
         Map<String, String> compactionOptions = new HashMap<>();
         compactionOptions.put("tombstone_compaction_interval", "1");
-        SchemaLoader.prepareServer();
 
         // Disable tombstone histogram rounding for tests
         System.setProperty("cassandra.streaminghistogram.roundseconds", "1");
 
+        SchemaLoader.prepareServer();
+
         SchemaLoader.createKeyspace(KEYSPACE1,
                                     KeyspaceParams.simple(1),
                                     SchemaLoader.denseCFMD(KEYSPACE1, CF_DENSE1)

File: test/unit/org/apache/cassandra/db/compaction/DateTieredCompactionStrategyTest.java
Patch:
@@ -53,11 +53,11 @@ public class DateTieredCompactionStrategyTest extends SchemaLoader
     @BeforeClass
     public static void defineSchema() throws ConfigurationException
     {
-        SchemaLoader.prepareServer();
-
         // Disable tombstone histogram rounding for tests
         System.setProperty("cassandra.streaminghistogram.roundseconds", "1");
 
+        SchemaLoader.prepareServer();
+
         SchemaLoader.createKeyspace(KEYSPACE1,
                 KeyspaceParams.simple(1),
                 SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD1));

File: test/unit/org/apache/cassandra/db/compaction/LeveledCompactionStrategyTest.java
Patch:
@@ -73,11 +73,11 @@ public class LeveledCompactionStrategyTest
     @BeforeClass
     public static void defineSchema() throws ConfigurationException
     {
-        SchemaLoader.prepareServer();
-
         // Disable tombstone histogram rounding for tests
         System.setProperty("cassandra.streaminghistogram.roundseconds", "1");
 
+        SchemaLoader.prepareServer();
+
         SchemaLoader.createKeyspace(KEYSPACE1,
                                     KeyspaceParams.simple(1),
                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARDDLEVELED)

File: test/unit/org/apache/cassandra/db/compaction/SizeTieredCompactionStrategyTest.java
Patch:
@@ -53,11 +53,11 @@ public class SizeTieredCompactionStrategyTest
     @BeforeClass
     public static void defineSchema() throws ConfigurationException
     {
-        SchemaLoader.prepareServer();
-
         // Disable tombstone histogram rounding for tests
         System.setProperty("cassandra.streaminghistogram.roundseconds", "1");
 
+        SchemaLoader.prepareServer();
+
         SchemaLoader.createKeyspace(KEYSPACE1,
                                     KeyspaceParams.simple(1),
                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD1));

File: test/unit/org/apache/cassandra/db/compaction/TTLExpiryTest.java
Patch:
@@ -57,11 +57,11 @@ public class TTLExpiryTest
     @BeforeClass
     public static void defineSchema() throws ConfigurationException
     {
-        SchemaLoader.prepareServer();
-
         // Disable tombstone histogram rounding for tests
         System.setProperty("cassandra.streaminghistogram.roundseconds", "1");
 
+        SchemaLoader.prepareServer();
+
         SchemaLoader.createKeyspace(KEYSPACE1,
                                     KeyspaceParams.simple(1),
                                     CFMetaData.Builder.create(KEYSPACE1, CF_STANDARD1)

File: test/unit/org/apache/cassandra/db/compaction/TimeWindowCompactionStrategyTest.java
Patch:
@@ -61,11 +61,11 @@ public class TimeWindowCompactionStrategyTest extends SchemaLoader
     @BeforeClass
     public static void defineSchema() throws ConfigurationException
     {
-        SchemaLoader.prepareServer();
-
         // Disable tombstone histogram rounding for tests
         System.setProperty("cassandra.streaminghistogram.roundseconds", "1");
 
+        SchemaLoader.prepareServer();
+
         SchemaLoader.createKeyspace(KEYSPACE1,
                                     KeyspaceParams.simple(1),
                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD1));

File: src/java/org/apache/cassandra/io/sstable/SSTable.java
Patch:
@@ -58,7 +58,10 @@ public abstract class SSTable
 {
     static final Logger logger = LoggerFactory.getLogger(SSTable.class);
 
+
     public static final int TOMBSTONE_HISTOGRAM_BIN_SIZE = 100;
+    public static final int TOMBSTONE_HISTOGRAM_SPOOL_SIZE = 100000;
+    public static final int TOMBSTONE_HISTOGRAM_TTL_ROUND_SECONDS = Integer.valueOf(System.getProperty("cassandra.streaminghistogram.roundseconds", "60"));
 
     public final Descriptor descriptor;
     protected final Set<Component> components;

File: src/java/org/apache/cassandra/io/sstable/metadata/MetadataCollector.java
Patch:
@@ -61,7 +61,7 @@ static EstimatedHistogram defaultPartitionSizeHistogram()
 
     static StreamingHistogram defaultTombstoneDropTimeHistogram()
     {
-        return new StreamingHistogram(SSTable.TOMBSTONE_HISTOGRAM_BIN_SIZE);
+        return new StreamingHistogram(SSTable.TOMBSTONE_HISTOGRAM_BIN_SIZE, SSTable.TOMBSTONE_HISTOGRAM_SPOOL_SIZE, SSTable.TOMBSTONE_HISTOGRAM_TTL_ROUND_SECONDS);
     }
 
     public static StatsMetadata defaultStatsMetadata()

File: test/unit/org/apache/cassandra/db/compaction/CompactionsTest.java
Patch:
@@ -62,6 +62,9 @@ public static void defineSchema() throws ConfigurationException
         compactionOptions.put("tombstone_compaction_interval", "1");
         SchemaLoader.prepareServer();
 
+        // Disable tombstone histogram rounding for tests
+        System.setProperty("cassandra.streaminghistogram.roundseconds", "1");
+
         SchemaLoader.createKeyspace(KEYSPACE1,
                                     KeyspaceParams.simple(1),
                                     SchemaLoader.denseCFMD(KEYSPACE1, CF_DENSE1)

File: src/java/org/apache/cassandra/db/marshal/DurationType.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.cassandra.serializers.TypeSerializer;
 import org.apache.cassandra.transport.ProtocolVersion;
 import org.apache.cassandra.utils.ByteBufferUtil;
+import org.apache.cassandra.utils.FastByteOperations;
 
 /**
  * Represents a duration. The duration is stored as  months, days, and nanoseconds. This is done
@@ -39,7 +40,7 @@ public class DurationType extends AbstractType<Duration>
 
     DurationType()
     {
-        super(ComparisonType.NOT_COMPARABLE);
+        super(ComparisonType.BYTE_ORDER);
     } // singleton
 
     public ByteBuffer fromString(String source) throws MarshalException

File: test/unit/org/apache/cassandra/cql3/validation/operations/CreateTest.java
Patch:
@@ -151,10 +151,10 @@ public void testCreateTableWithDurationColumns() throws Throwable
                    row(1, 21, Duration.newInstance(12, 10, 0)),
                    row(1, 22, Duration.newInstance(-12, -10, 0)));
 
-        assertInvalidMessage("Slice restriction are not supported on duration columns",
+        assertInvalidMessage("Slice restrictions are not supported on duration columns",
                              "SELECT * FROM %s WHERE c > 1y ALLOW FILTERING");
 
-        assertInvalidMessage("Slice restriction are not supported on duration columns",
+        assertInvalidMessage("Slice restrictions are not supported on duration columns",
                              "SELECT * FROM %s WHERE c <= 1y ALLOW FILTERING");
 
         assertInvalidMessage("Expected at least 3 bytes for a duration (1)",

File: src/java/org/apache/cassandra/db/compaction/CompactionStrategyManager.java
Patch:
@@ -840,14 +840,15 @@ private static void validateForCompaction(Iterable<SSTableReader> input, ColumnF
         boolean repaired = firstSSTable.isRepaired();
         int firstIndex = getCompactionStrategyIndex(cfs, directories, firstSSTable);
         boolean isPending = firstSSTable.isPendingRepair();
+        UUID pendingRepair = firstSSTable.getSSTableMetadata().pendingRepair;
         for (SSTableReader sstable : input)
         {
             if (sstable.isRepaired() != repaired)
                 throw new UnsupportedOperationException("You can't mix repaired and unrepaired data in a compaction");
             if (firstIndex != getCompactionStrategyIndex(cfs, directories, sstable))
                 throw new UnsupportedOperationException("You can't mix sstables from different directories in a compaction");
-            if (isPending != sstable.isPendingRepair())
-                throw new UnsupportedOperationException("You can't compact sstables pending for repair with non-pending ones");
+            if (isPending && !pendingRepair.equals(sstable.getSSTableMetadata().pendingRepair))
+                throw new UnsupportedOperationException("You can't compact sstables from different pending repair sessions");
         }
     }
 

File: src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java
Patch:
@@ -50,6 +50,7 @@
 import org.apache.cassandra.db.rows.EncodingStats;
 import org.apache.cassandra.db.rows.UnfilteredRowIterator;
 import org.apache.cassandra.dht.AbstractBounds;
+import org.apache.cassandra.dht.Bounds;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.io.FSError;
@@ -1758,7 +1759,7 @@ public boolean isPendingRepair()
 
     public boolean intersects(Collection<Range<Token>> ranges)
     {
-        Range<Token> range = new Range<>(first.getToken(), last.getToken());
+        Bounds<Token> range = new Bounds<>(first.getToken(), last.getToken());
         return Iterables.any(ranges, r -> r.intersects(range));
     }
 

File: src/java/org/apache/cassandra/metrics/DecayingEstimatedHistogramReservoir.java
Patch:
@@ -352,11 +352,12 @@ private class EstimatedHistogramReservoirSnapshot extends Snapshot
         public EstimatedHistogramReservoirSnapshot(DecayingEstimatedHistogramReservoir reservoir)
         {
             final int length = reservoir.decayingBuckets.length();
+            final double rescaleFactor = forwardDecayWeight(clock.getTime());
 
             this.decayingBuckets = new long[length];
 
             for (int i = 0; i < length; i++)
-                this.decayingBuckets[i] = reservoir.decayingBuckets.get(i);
+                this.decayingBuckets[i] = Math.round(reservoir.decayingBuckets.get(i) / rescaleFactor);
         }
 
         /**

File: src/java/org/apache/cassandra/db/compaction/PendingRepairManager.java
Patch:
@@ -228,6 +228,7 @@ int getMaxEstimatedRemainingTasks()
         return tasks;
     }
 
+    @SuppressWarnings("resource")
     private RepairFinishedCompactionTask getRepairFinishedCompactionTask(UUID sessionID)
     {
         Set<SSTableReader> sstables = get(sessionID).getSSTables();

File: src/java/org/apache/cassandra/repair/consistent/PendingAntiCompaction.java
Patch:
@@ -92,6 +92,7 @@ private Iterable<SSTableReader> getSSTables()
             return Iterables.filter(cfs.getLiveSSTables(), s -> !s.isRepaired() && !s.isPendingRepair() && s.intersects(ranges));
         }
 
+        @SuppressWarnings("resource")
         private AcquireResult acquireTuple()
         {
             List<SSTableReader> sstables = Lists.newArrayList(getSSTables());

File: src/java/org/apache/cassandra/db/Memtable.java
Patch:
@@ -508,6 +508,7 @@ public SSTableMultiWriter createFlushWriter(LifecycleTransaction txn,
             return cfs.createSSTableMultiWriter(descriptor,
                                                 toFlush.size(),
                                                 ActiveRepairService.UNREPAIRED_SSTABLE,
+                                                ActiveRepairService.NO_PENDING_REPAIR,
                                                 sstableMetadataCollector,
                                                 new SerializationHeader(true, cfs.metadata(), columns, stats), txn);
         }

File: src/java/org/apache/cassandra/db/compaction/Verifier.java
Patch:
@@ -234,7 +234,7 @@ private void throwIfFatal(Throwable th)
 
     private void markAndThrow() throws IOException
     {
-        sstable.descriptor.getMetadataSerializer().mutateRepairedAt(sstable.descriptor, ActiveRepairService.UNREPAIRED_SSTABLE);
+        sstable.descriptor.getMetadataSerializer().mutateRepaired(sstable.descriptor, ActiveRepairService.UNREPAIRED_SSTABLE, sstable.getSSTableMetadata().pendingRepair);
         throw new CorruptSSTableException(new Exception(String.format("Invalid SSTable %s, please force repair", sstable.getFilename())), sstable.getFilename());
     }
 

File: src/java/org/apache/cassandra/db/compaction/writers/CompactionAwareWriter.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.Collection;
 import java.util.List;
 import java.util.Set;
+import java.util.UUID;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -55,6 +56,7 @@ public abstract class CompactionAwareWriter extends Transactional.AbstractTransa
     protected final long estimatedTotalKeys;
     protected final long maxAge;
     protected final long minRepairedAt;
+    protected final UUID pendingRepair;
 
     protected final SSTableRewriter sstableWriter;
     protected final LifecycleTransaction txn;
@@ -88,6 +90,7 @@ public CompactionAwareWriter(ColumnFamilyStore cfs,
         maxAge = CompactionTask.getMaxDataAge(nonExpiredSSTables);
         sstableWriter = SSTableRewriter.construct(cfs, txn, keepOriginals, maxAge);
         minRepairedAt = CompactionTask.getMinRepairedAt(nonExpiredSSTables);
+        pendingRepair = CompactionTask.getPendingRepair(nonExpiredSSTables);
         locations = cfs.getDirectories().getWriteableLocations();
         diskBoundaries = StorageService.getDiskBoundaries(cfs);
         locationIndex = -1;

File: src/java/org/apache/cassandra/db/compaction/writers/DefaultCompactionWriter.java
Patch:
@@ -71,6 +71,7 @@ public void switchCompactionLocation(Directories.DataDirectory directory)
         SSTableWriter writer = SSTableWriter.create(cfs.newSSTableDescriptor(getDirectories().getLocationForDisk(directory)),
                                                     estimatedTotalKeys,
                                                     minRepairedAt,
+                                                    pendingRepair,
                                                     cfs.metadata,
                                                     new MetadataCollector(txn.originals(), cfs.metadata().comparator, sstableLevel),
                                                     SerializationHeader.make(cfs.metadata(), nonExpiredSSTables),

File: src/java/org/apache/cassandra/db/compaction/writers/MajorLeveledCompactionWriter.java
Patch:
@@ -107,13 +107,13 @@ public void switchCompactionLocation(Directories.DataDirectory location)
         sstableWriter.switchWriter(SSTableWriter.create(cfs.newSSTableDescriptor(getDirectories().getLocationForDisk(sstableDirectory)),
                 keysPerSSTable,
                 minRepairedAt,
+                pendingRepair,
                 cfs.metadata,
                 new MetadataCollector(txn.originals(), cfs.metadata().comparator, currentLevel),
                 SerializationHeader.make(cfs.metadata(), txn.originals()),
                 cfs.indexManager.listIndexes(),
                 txn));
         partitionsWritten = 0;
         sstablesWritten = 0;
-
     }
 }

File: src/java/org/apache/cassandra/db/compaction/writers/MaxSSTableSizeWriter.java
Patch:
@@ -110,6 +110,7 @@ public void switchCompactionLocation(Directories.DataDirectory location)
         SSTableWriter writer = SSTableWriter.create(cfs.newSSTableDescriptor(getDirectories().getLocationForDisk(sstableDirectory)),
                                                     estimatedTotalKeys / estimatedSSTables,
                                                     minRepairedAt,
+                                                    pendingRepair,
                                                     cfs.metadata,
                                                     new MetadataCollector(allSSTables, cfs.metadata().comparator, level),
                                                     SerializationHeader.make(cfs.metadata(), nonExpiredSSTables),

File: src/java/org/apache/cassandra/db/compaction/writers/SplittingSizeTieredCompactionWriter.java
Patch:
@@ -106,6 +106,7 @@ public void switchCompactionLocation(Directories.DataDirectory location)
         SSTableWriter writer = SSTableWriter.create(cfs.newSSTableDescriptor(getDirectories().getLocationForDisk(location)),
                                                     currentPartitionsToWrite,
                                                     minRepairedAt,
+                                                    pendingRepair,
                                                     cfs.metadata,
                                                     new MetadataCollector(allSSTables, cfs.metadata().comparator, 0),
                                                     SerializationHeader.make(cfs.metadata(), nonExpiredSSTables),

File: src/java/org/apache/cassandra/dht/RangeStreamer.java
Patch:
@@ -156,7 +156,7 @@ public RangeStreamer(TokenMetadata metadata,
         this.address = address;
         this.description = description;
         this.streamPlan = new StreamPlan(description, ActiveRepairService.UNREPAIRED_SSTABLE, connectionsPerHost,
-                true, false, connectSequentially);
+                true, false, connectSequentially, null);
         this.useStrictConsistency = useStrictConsistency;
         this.snitch = snitch;
         this.stateStore = stateStore;

File: src/java/org/apache/cassandra/io/sstable/AbstractSSTableSimpleWriter.java
Patch:
@@ -69,12 +69,13 @@ protected SSTableTxnWriter createWriter()
         SerializationHeader header = new SerializationHeader(true, metadata.get(), columns, EncodingStats.NO_STATS);
 
         if (makeRangeAware)
-            return SSTableTxnWriter.createRangeAware(metadata, 0,  ActiveRepairService.UNREPAIRED_SSTABLE, formatType, 0, header);
+            return SSTableTxnWriter.createRangeAware(metadata, 0,  ActiveRepairService.UNREPAIRED_SSTABLE, ActiveRepairService.NO_PENDING_REPAIR, formatType, 0, header);
 
         return SSTableTxnWriter.create(metadata,
                                        createDescriptor(directory, metadata.keyspace, metadata.name, formatType),
                                        0,
                                        ActiveRepairService.UNREPAIRED_SSTABLE,
+                                       ActiveRepairService.NO_PENDING_REPAIR,
                                        0,
                                        header,
                                        Collections.emptySet());

File: src/java/org/apache/cassandra/io/sstable/SSTableLoader.java
Patch:
@@ -159,7 +159,7 @@ public StreamResultFuture stream(Set<InetAddress> toIgnore, StreamEventHandler..
         client.init(keyspace);
         outputHandler.output("Established connection to initial hosts");
 
-        StreamPlan plan = new StreamPlan("Bulk Load", 0, connectionsPerHost, false, false, false).connectionFactory(client.getConnectionFactory());
+        StreamPlan plan = new StreamPlan("Bulk Load", 0, connectionsPerHost, false, false, false, null).connectionFactory(client.getConnectionFactory());
 
         Map<InetAddress, Collection<Range<Token>>> endpointToRanges = client.getEndpointToRangesMap();
         openSSTables(endpointToRanges);

File: src/java/org/apache/cassandra/io/sstable/SimpleSSTableMultiWriter.java
Patch:
@@ -19,6 +19,7 @@
 
 import java.util.Collection;
 import java.util.Collections;
+import java.util.UUID;
 
 import org.apache.cassandra.db.RowIndexEntry;
 import org.apache.cassandra.db.SerializationHeader;
@@ -109,13 +110,14 @@ public void close()
     public static SSTableMultiWriter create(Descriptor descriptor,
                                             long keyCount,
                                             long repairedAt,
+                                            UUID pendingRepair,
                                             TableMetadataRef metadata,
                                             MetadataCollector metadataCollector,
                                             SerializationHeader header,
                                             Collection<Index> indexes,
                                             LifecycleTransaction txn)
     {
-        SSTableWriter writer = SSTableWriter.create(descriptor, keyCount, repairedAt, metadata, metadataCollector, header, indexes, txn);
+        SSTableWriter writer = SSTableWriter.create(descriptor, keyCount, repairedAt, pendingRepair, metadata, metadataCollector, header, indexes, txn);
         return new SimpleSSTableMultiWriter(writer, txn);
     }
 }

File: src/java/org/apache/cassandra/io/sstable/format/Version.java
Patch:
@@ -51,6 +51,8 @@ protected Version(SSTableFormat format, String version)
 
     public abstract boolean hasCommitLogIntervals();
 
+    public abstract boolean hasPendingRepair();
+
     public String getVersion()
     {
         return version;

File: src/java/org/apache/cassandra/io/sstable/metadata/IMetadataSerializer.java
Patch:
@@ -20,6 +20,7 @@
 import java.io.IOException;
 import java.util.EnumSet;
 import java.util.Map;
+import java.util.UUID;
 
 import org.apache.cassandra.io.sstable.Descriptor;
 import org.apache.cassandra.io.sstable.format.Version;
@@ -70,7 +71,7 @@ public interface IMetadataSerializer
     void mutateLevel(Descriptor descriptor, int newLevel) throws IOException;
 
     /**
-     * Mutate repairedAt time
+     * Mutate the repairedAt time and pendingRepair ID
      */
-    void mutateRepairedAt(Descriptor descriptor, long newRepairedAt) throws IOException;
+    void mutateRepaired(Descriptor descriptor, long newRepairedAt, UUID newPendingRepair) throws IOException;
 }

File: src/java/org/apache/cassandra/net/IncomingStreamingConnection.java
Patch:
@@ -73,7 +73,7 @@ public void run()
             // The receiving side distinguish two connections by looking at StreamInitMessage#isForOutgoing.
             // Note: we cannot use the same socket for incoming and outgoing streams because we want to
             // parallelize said streams and the socket is blocking, so we might deadlock.
-            StreamResultFuture.initReceivingSide(init.sessionIndex, init.planId, init.description, init.from, this, init.isForOutgoing, version, init.keepSSTableLevel, init.isIncremental);
+            StreamResultFuture.initReceivingSide(init.sessionIndex, init.planId, init.description, init.from, this, init.isForOutgoing, version, init.keepSSTableLevel, init.isIncremental, init.pendingRepair);
         }
         catch (Throwable t)
         {

File: src/java/org/apache/cassandra/repair/SystemDistributedKeyspace.java
Patch:
@@ -173,7 +173,8 @@ public static void failParentRepair(UUID parent_id, Throwable t)
         PrintWriter pw = new PrintWriter(sw);
         t.printStackTrace(pw);
         String fmtQuery = format(query, SchemaConstants.DISTRIBUTED_KEYSPACE_NAME, PARENT_REPAIR_HISTORY, parent_id.toString());
-        processSilent(fmtQuery, t.getMessage(), sw.toString());
+        String message = t.getMessage();
+        processSilent(fmtQuery, message != null ? message : "", sw.toString());
     }
 
     public static void successfulParentRepair(UUID parent_id, Collection<Range<Token>> successfulRanges)

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -322,6 +322,7 @@ public void uncaughtException(Thread t, Throwable e)
         }
 
         SystemKeyspace.finishStartup();
+        ActiveRepairService.instance.start();
 
         // Prepared statements
         QueryProcessor.preloadPreparedStatement();

File: src/java/org/apache/cassandra/streaming/ConnectionHandler.java
Patch:
@@ -198,7 +198,8 @@ private void sendInitMessage() throws IOException
                     session.description(),
                     !isOutgoingHandler,
                     session.keepSSTableLevel(),
-                    session.isIncremental());
+                    session.isIncremental(),
+                    session.getPendingRepair());
             ByteBuffer messageBuf = message.createMessage(false, protocolVersion);
             DataOutputStreamPlus out = getWriteChannel(socket);
             out.write(messageBuf);

File: src/java/org/apache/cassandra/streaming/compress/CompressedStreamReader.java
Patch:
@@ -73,7 +73,7 @@ public SSTableMultiWriter read(ReadableByteChannel channel) throws IOException
         }
 
         logger.debug("[Stream #{}] Start receiving file #{} from {}, repairedAt = {}, size = {}, ks = '{}', table = '{}'.",
-                     session.planId(), fileSeqNum, session.peer, repairedAt, totalSize, cfs.keyspace.getName(),
+                     session.planId(), fileSeqNum, session.peer, repairedAt, totalSize, cfs.keyspace.getName(), session.getPendingRepair(),
                      cfs.getTableName());
 
         CompressedInputStream cis = new CompressedInputStream(Channels.newInputStream(channel), compressionInfo,
@@ -84,7 +84,7 @@ public SSTableMultiWriter read(ReadableByteChannel channel) throws IOException
         SSTableMultiWriter writer = null;
         try
         {
-            writer = createWriter(cfs, totalSize, repairedAt, format);
+            writer = createWriter(cfs, totalSize, repairedAt, session.getPendingRepair(), format);
             String filename = writer.getFilename();
             int sectionIdx = 0;
             for (Pair<Long, Long> section : sections)

File: src/java/org/apache/cassandra/tools/NodeTool.java
Patch:
@@ -99,6 +99,7 @@ public static void main(String... args)
                 RemoveNode.class,
                 Assassinate.class,
                 Repair.class,
+                RepairAdmin.class,
                 ReplayBatchlog.class,
                 SetCacheCapacity.class,
                 SetHintedHandoffThrottleInKB.class,

File: src/java/org/apache/cassandra/tools/SSTableMetadataViewer.java
Patch:
@@ -135,6 +135,7 @@ public static void main(String[] args) throws IOException
                     out.printf("Estimated droppable tombstones: %s%n", stats.getEstimatedDroppableTombstoneRatio((int) (System.currentTimeMillis() / 1000) - gcgs));
                     out.printf("SSTable Level: %d%n", stats.sstableLevel);
                     out.printf("Repaired at: %d%n", stats.repairedAt);
+                    out.printf("Pending repair: %s%n", stats.pendingRepair);
                     out.printf("Replay positions covered: %s%n", stats.commitLogIntervals);
                     out.printf("totalColumnsSet: %s%n", stats.totalColumnsSet);
                     out.printf("totalRows: %s%n", stats.totalRows);

File: src/java/org/apache/cassandra/tools/SSTableRepairedAtSetter.java
Patch:
@@ -27,7 +27,6 @@
 
 import org.apache.cassandra.io.sstable.Component;
 import org.apache.cassandra.io.sstable.Descriptor;
-import org.apache.cassandra.service.ActiveRepairService;
 
 /**
  * Set repairedAt status on a given set of sstables.
@@ -89,11 +88,11 @@ public static void main(final String[] args) throws IOException
             if (setIsRepaired)
             {
                 FileTime f = Files.getLastModifiedTime(new File(descriptor.filenameFor(Component.DATA)).toPath());
-                descriptor.getMetadataSerializer().mutateRepairedAt(descriptor, f.toMillis());
+                descriptor.getMetadataSerializer().mutateRepaired(descriptor, f.toMillis(), null);
             }
             else
             {
-                descriptor.getMetadataSerializer().mutateRepairedAt(descriptor, ActiveRepairService.UNREPAIRED_SSTABLE);
+                descriptor.getMetadataSerializer().mutateRepaired(descriptor, 0, null);
             }
         }
     }

File: test/unit/org/apache/cassandra/db/RepairedDataTombstonesTest.java
Patch:
@@ -308,7 +308,7 @@ private void verify2(int key, int expectedRows, int minVal, int maxVal, boolean
 
     public static void repair(ColumnFamilyStore cfs, SSTableReader sstable) throws IOException
     {
-        sstable.descriptor.getMetadataSerializer().mutateRepairedAt(sstable.descriptor, 1);
+        sstable.descriptor.getMetadataSerializer().mutateRepaired(sstable.descriptor, 1, null);
         sstable.reloadSSTableMetadata();
         cfs.getTracker().notifySSTableRepairedStatusChanged(Collections.singleton(sstable));
     }

File: test/unit/org/apache/cassandra/db/ScrubTest.java
Patch:
@@ -642,7 +642,7 @@ private static SSTableMultiWriter createTestWriter(Descriptor descriptor, long k
     {
         SerializationHeader header = new SerializationHeader(true, metadata.get(), metadata.get().regularAndStaticColumns(), EncodingStats.NO_STATS);
         MetadataCollector collector = new MetadataCollector(metadata.get().comparator).sstableLevel(0);
-        return new TestMultiWriter(new TestWriter(descriptor, keyCount, 0, metadata, collector, header, txn), txn);
+        return new TestMultiWriter(new TestWriter(descriptor, keyCount, 0, null, metadata, collector, header, txn), txn);
     }
 
     private static class TestMultiWriter extends SimpleSSTableMultiWriter
@@ -658,10 +658,10 @@ private static class TestMultiWriter extends SimpleSSTableMultiWriter
      */
     private static class TestWriter extends BigTableWriter
     {
-        TestWriter(Descriptor descriptor, long keyCount, long repairedAt, TableMetadataRef metadata,
+        TestWriter(Descriptor descriptor, long keyCount, long repairedAt, UUID pendingRepair, TableMetadataRef metadata,
                    MetadataCollector collector, SerializationHeader header, LifecycleTransaction txn)
         {
-            super(descriptor, keyCount, repairedAt, metadata, collector, header, Collections.emptySet(), txn);
+            super(descriptor, keyCount, repairedAt, pendingRepair, metadata, collector, header, Collections.emptySet(), txn);
         }
 
         @Override

File: test/unit/org/apache/cassandra/db/compaction/LeveledCompactionStrategyTest.java
Patch:
@@ -189,7 +189,7 @@ public void testValidationMultipleSSTablePerLevel() throws Exception
         Range<Token> range = new Range<>(Util.token(""), Util.token(""));
         int gcBefore = keyspace.getColumnFamilyStore(CF_STANDARDDLEVELED).gcBefore(FBUtilities.nowInSeconds());
         UUID parentRepSession = UUID.randomUUID();
-        ActiveRepairService.instance.registerParentRepairSession(parentRepSession, FBUtilities.getBroadcastAddress(), Arrays.asList(cfs), Arrays.asList(range), false, System.currentTimeMillis(), true);
+        ActiveRepairService.instance.registerParentRepairSession(parentRepSession, FBUtilities.getBroadcastAddress(), Arrays.asList(cfs), Arrays.asList(range), false, ActiveRepairService.UNREPAIRED_SSTABLE, true);
         RepairJobDesc desc = new RepairJobDesc(parentRepSession, UUID.randomUUID(), KEYSPACE1, CF_STANDARDDLEVELED, Arrays.asList(range));
         Validator validator = new Validator(desc, FBUtilities.getBroadcastAddress(), gcBefore);
         CompactionManager.instance.submitValidation(cfs, validator).get();
@@ -350,7 +350,7 @@ public void testNewRepairedSSTable() throws Exception
         SSTableReader sstable1 = unrepaired.manifest.generations[2].get(0);
         SSTableReader sstable2 = unrepaired.manifest.generations[1].get(0);
 
-        sstable1.descriptor.getMetadataSerializer().mutateRepairedAt(sstable1.descriptor, System.currentTimeMillis());
+        sstable1.descriptor.getMetadataSerializer().mutateRepaired(sstable1.descriptor, System.currentTimeMillis(), null);
         sstable1.reloadSSTableMetadata();
         assertTrue(sstable1.isRepaired());
 

File: test/unit/org/apache/cassandra/db/lifecycle/LogTransactionTest.java
Patch:
@@ -1183,7 +1183,7 @@ private static SSTableReader sstable(File dataFolder, ColumnFamilyStore cfs, int
 
         SerializationHeader header = SerializationHeader.make(cfs.metadata(), Collections.emptyList());
         StatsMetadata metadata = (StatsMetadata) new MetadataCollector(cfs.metadata().comparator)
-                                                 .finalizeMetadata(cfs.metadata().partitioner.getClass().getCanonicalName(), 0.01f, -1, header)
+                                                 .finalizeMetadata(cfs.metadata().partitioner.getClass().getCanonicalName(), 0.01f, -1, null, header)
                                                  .get(MetadataType.STATS);
         SSTableReader reader = SSTableReader.internalOpen(descriptor,
                                                           components,

File: test/unit/org/apache/cassandra/db/lifecycle/RealTransactionsTest.java
Patch:
@@ -163,6 +163,7 @@ private SSTableReader replaceSSTable(ColumnFamilyStore cfs, LifecycleTransaction
                                                            desc,
                                                            0,
                                                            0,
+                                                           null,
                                                            0,
                                                            SerializationHeader.make(cfs.metadata(), txn.originals()),
                                                            cfs.indexManager.listIndexes(),

File: test/unit/org/apache/cassandra/dht/StreamStateStoreTest.java
Patch:
@@ -50,7 +50,7 @@ public void testUpdateAndQueryAvailableRanges()
         Range<Token> range = new Range<>(factory.fromString("0"), factory.fromString("100"));
 
         InetAddress local = FBUtilities.getBroadcastAddress();
-        StreamSession session = new StreamSession(local, local, new DefaultConnectionFactory(), 0, true, false);
+        StreamSession session = new StreamSession(local, local, new DefaultConnectionFactory(), 0, true, false, null);
         session.addStreamRequest("keyspace1", Collections.singleton(range), Collections.singleton("cf"), 0);
 
         StreamStateStore store = new StreamStateStore();
@@ -71,7 +71,7 @@ public void testUpdateAndQueryAvailableRanges()
 
         // add different range within the same keyspace
         Range<Token> range2 = new Range<>(factory.fromString("100"), factory.fromString("200"));
-        session = new StreamSession(local, local, new DefaultConnectionFactory(), 0, true, false);
+        session = new StreamSession(local, local, new DefaultConnectionFactory(), 0, true, false, null);
         session.addStreamRequest("keyspace1", Collections.singleton(range2), Collections.singleton("cf"), 0);
         session.state(StreamSession.State.COMPLETE);
         store.handleStreamEvent(new StreamEvent.SessionCompleteEvent(session));

File: test/unit/org/apache/cassandra/io/sstable/BigTableWriterTest.java
Patch:
@@ -69,7 +69,7 @@ private TestableBTW()
 
         private TestableBTW(Descriptor desc)
         {
-            this(desc, SSTableTxnWriter.create(cfs, desc, 0, 0, new SerializationHeader(true, cfs.metadata(), cfs.metadata().regularAndStaticColumns(), EncodingStats.NO_STATS)));
+            this(desc, SSTableTxnWriter.create(cfs, desc, 0, 0, null, new SerializationHeader(true, cfs.metadata(), cfs.metadata().regularAndStaticColumns(), EncodingStats.NO_STATS)));
         }
 
         private TestableBTW(Descriptor desc, SSTableTxnWriter sw)

File: test/unit/org/apache/cassandra/io/sstable/SSTableRewriterTest.java
Patch:
@@ -936,7 +936,7 @@ public static Set<SSTableReader> writeFiles(ColumnFamilyStore cfs, int fileCount
             File dir = cfs.getDirectories().getDirectoryForNewSSTables();
             Descriptor desc = cfs.newSSTableDescriptor(dir);
 
-            try (SSTableTxnWriter writer = SSTableTxnWriter.create(cfs, desc, 0, 0, new SerializationHeader(true, cfs.metadata(), cfs.metadata().regularAndStaticColumns(), EncodingStats.NO_STATS)))
+            try (SSTableTxnWriter writer = SSTableTxnWriter.create(cfs, desc, 0, 0, null, new SerializationHeader(true, cfs.metadata(), cfs.metadata().regularAndStaticColumns(), EncodingStats.NO_STATS)))
             {
                 int end = f == fileCount - 1 ? partitionCount : ((f + 1) * partitionCount) / fileCount;
                 for ( ; i < end ; i++)

File: test/unit/org/apache/cassandra/io/sstable/SSTableUtils.java
Patch:
@@ -30,9 +30,10 @@
 import org.apache.cassandra.db.partitions.*;
 import org.apache.cassandra.io.sstable.format.SSTableFormat;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
-import org.apache.cassandra.service.ActiveRepairService;
 
 import org.apache.cassandra.Util;
+
+import static org.apache.cassandra.service.ActiveRepairService.*;
 import static org.junit.Assert.assertEquals;
 
 public class SSTableUtils
@@ -217,7 +218,7 @@ public Collection<SSTableReader> write(int expectedSize, Appender appender) thro
             TableMetadata metadata = Schema.instance.getTableMetadata(ksname, cfname);
             ColumnFamilyStore cfs = Schema.instance.getColumnFamilyStoreInstance(metadata.id);
             SerializationHeader header = appender.header();
-            SSTableTxnWriter writer = SSTableTxnWriter.create(cfs, Descriptor.fromFilename(datafile.getAbsolutePath()), expectedSize, ActiveRepairService.UNREPAIRED_SSTABLE, 0, header);
+            SSTableTxnWriter writer = SSTableTxnWriter.create(cfs, Descriptor.fromFilename(datafile.getAbsolutePath()), expectedSize, UNREPAIRED_SSTABLE, NO_PENDING_REPAIR, 0, header);
             while (appender.append(writer)) { /* pass */ }
             Collection<SSTableReader> readers = writer.finish(true);
 

File: test/unit/org/apache/cassandra/io/sstable/SSTableWriterTestBase.java
Patch:
@@ -164,7 +164,7 @@ public static void validateCFS(ColumnFamilyStore cfs)
     public static SSTableWriter getWriter(ColumnFamilyStore cfs, File directory, LifecycleTransaction txn)
     {
         Descriptor desc = cfs.newSSTableDescriptor(directory);
-        return SSTableWriter.create(desc, 0, 0, new SerializationHeader(true, cfs.metadata(), cfs.metadata().regularAndStaticColumns(), EncodingStats.NO_STATS), cfs.indexManager.listIndexes(), txn);
+        return SSTableWriter.create(desc, 0, 0, null, new SerializationHeader(true, cfs.metadata(), cfs.metadata().regularAndStaticColumns(), EncodingStats.NO_STATS), cfs.indexManager.listIndexes(), txn);
     }
 
     public static ByteBuffer random(int i, int size)

File: test/unit/org/apache/cassandra/io/sstable/format/SSTableFlushObserverTest.java
Patch:
@@ -96,7 +96,7 @@ public void testFlushObserver()
                                                                   KS_NAME, CF_NAME,
                                                                   0,
                                                                   sstableFormat),
-                                                   10L, 0L, TableMetadataRef.forOfflineTools(cfm),
+                                                   10L, 0L, null, TableMetadataRef.forOfflineTools(cfm),
                                                    new MetadataCollector(cfm.comparator).sstableLevel(0),
                                                    new SerializationHeader(true, cfm, cfm.regularAndStaticColumns(), EncodingStats.NO_STATS),
                                                    Collections.singletonList(observer),

File: test/unit/org/apache/cassandra/repair/RepairSessionTest.java
Patch:
@@ -62,7 +62,7 @@ public void testConviction() throws Exception
         IPartitioner p = Murmur3Partitioner.instance;
         Range<Token> repairRange = new Range<>(p.getToken(ByteBufferUtil.bytes(0)), p.getToken(ByteBufferUtil.bytes(100)));
         Set<InetAddress> endpoints = Sets.newHashSet(remote);
-        RepairSession session = new RepairSession(parentSessionId, sessionId, Arrays.asList(repairRange), "Keyspace1", RepairParallelism.SEQUENTIAL, endpoints, ActiveRepairService.UNREPAIRED_SSTABLE, false, "Standard1");
+        RepairSession session = new RepairSession(parentSessionId, sessionId, Arrays.asList(repairRange), "Keyspace1", RepairParallelism.SEQUENTIAL, endpoints, ActiveRepairService.UNREPAIRED_SSTABLE, false, false, "Standard1");
 
         // perform convict
         session.convict(remote, Double.MAX_VALUE);

File: test/unit/org/apache/cassandra/repair/ValidatorTest.java
Patch:
@@ -193,7 +193,7 @@ public void simpleValidationTest(int n) throws Exception
                                                                  false);
 
         final CompletableFuture<MessageOut> outgoingMessageSink = registerOutgoingMessageSink();
-        Validator validator = new Validator(desc, FBUtilities.getBroadcastAddress(), 0, true);
+        Validator validator = new Validator(desc, FBUtilities.getBroadcastAddress(), 0, true, false);
         CompactionManager.instance.submitValidation(cfs, validator);
 
         MessageOut message = outgoingMessageSink.get(TEST_TIMEOUT, TimeUnit.SECONDS);

File: test/unit/org/apache/cassandra/schema/MockSchema.java
Patch:
@@ -118,7 +118,7 @@ public static SSTableReader sstable(int generation, int size, boolean keepRef, C
         }
         SerializationHeader header = SerializationHeader.make(cfs.metadata(), Collections.emptyList());
         StatsMetadata metadata = (StatsMetadata) new MetadataCollector(cfs.metadata().comparator)
-                                                 .finalizeMetadata(cfs.metadata().partitioner.getClass().getCanonicalName(), 0.01f, -1, header)
+                                                 .finalizeMetadata(cfs.metadata().partitioner.getClass().getCanonicalName(), 0.01f, -1, null, header)
                                                  .get(MetadataType.STATS);
         SSTableReader reader = SSTableReader.internalOpen(descriptor, components, cfs.metadata,
                                                           RANDOM_ACCESS_READER_FACTORY.sharedCopy(), RANDOM_ACCESS_READER_FACTORY.sharedCopy(), indexSummary.sharedCopy(),

File: test/unit/org/apache/cassandra/streaming/StreamTransferTaskTest.java
Patch:
@@ -74,7 +74,7 @@ public void tearDown()
     public void testScheduleTimeout() throws Exception
     {
         InetAddress peer = FBUtilities.getBroadcastAddress();
-        StreamSession session = new StreamSession(peer, peer, null, 0, true, false);
+        StreamSession session = new StreamSession(peer, peer, null, 0, true, false, null);
         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF_STANDARD);
 
         // create two sstables
@@ -120,9 +120,9 @@ public void testScheduleTimeout() throws Exception
     public void testFailSessionDuringTransferShouldNotReleaseReferences() throws Exception
     {
         InetAddress peer = FBUtilities.getBroadcastAddress();
-        StreamCoordinator streamCoordinator = new StreamCoordinator(1, true, false, null, false);
+        StreamCoordinator streamCoordinator = new StreamCoordinator(1, true, false, null, false, null);
         StreamResultFuture future = StreamResultFuture.init(UUID.randomUUID(), "", Collections.<StreamEventHandler>emptyList(), streamCoordinator);
-        StreamSession session = new StreamSession(peer, peer, null, 0, true, false);
+        StreamSession session = new StreamSession(peer, peer, null, 0, true, false, null);
         session.init(future);
         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE1).getColumnFamilyStore(CF_STANDARD);
 

File: src/java/org/apache/cassandra/dht/tokenallocator/TokenAllocatorFactory.java
Patch:
@@ -34,7 +34,7 @@ public static TokenAllocator<InetAddress> createTokenAllocator(NavigableMap<Toke
                                                      ReplicationStrategy<InetAddress> strategy,
                                                      IPartitioner partitioner)
     {
-        if(strategy.replicas() == 1 || strategy.replicas() == 0)
+        if(strategy.replicas() == 1)
         {
             logger.info("Using NoReplicationTokenAllocator.");
             return new NoReplicationTokenAllocator<>(sortedTokens, strategy, partitioner);

File: src/java/org/apache/cassandra/index/sasi/plan/QueryController.java
Patch:
@@ -236,7 +236,7 @@ private Pair<Expression, Set<SSTableIndex>> calculatePrimary(Collection<Expressi
                 continue;
 
             Set<SSTableIndex> indexes = applyScope(view.match(e));
-            if (primaryIndexes.size() > indexes.size())
+            if (expression == null || primaryIndexes.size() > indexes.size())
             {
                 primaryIndexes = indexes;
                 expression = e;

File: src/java/org/apache/cassandra/tools/nodetool/StopDaemon.java
Patch:
@@ -19,6 +19,7 @@
 
 import io.airlift.command.Command;
 
+import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.tools.NodeProbe;
 import org.apache.cassandra.tools.NodeTool.NodeToolCmd;
 import org.apache.cassandra.utils.JVMStabilityInspector;
@@ -31,6 +32,7 @@ public void execute(NodeProbe probe)
     {
         try
         {
+            DatabaseDescriptor.toolInitialization();
             probe.stopCassandraDaemon();
         } catch (Exception e)
         {

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -384,7 +384,7 @@ public ColumnFamilyStore(Keyspace keyspace,
         this.indexManager = new SecondaryIndexManager(this);
         this.metric = new ColumnFamilyMetrics(this);
         fileIndexGenerator.set(generation);
-        sampleLatencyNanos = DatabaseDescriptor.getReadRpcTimeout() / 2;
+        sampleLatencyNanos = TimeUnit.MILLISECONDS.toNanos(DatabaseDescriptor.getReadRpcTimeout() / 2);
 
         logger.info("Initializing {}.{}", keyspace.getName(), name);
 
@@ -443,7 +443,7 @@ public void run()
                     {
                         case PERCENTILE:
                             // get percentile in nanos
-                            sampleLatencyNanos = (long) (metric.coordinatorReadLatency.getSnapshot().getValue(retryPolicy.value) * 1000d);
+                            sampleLatencyNanos = (long) (metric.coordinatorReadLatency.getSnapshot().getValue(retryPolicy.value));
                             break;
                         case CUSTOM:
                             // convert to nanos, since configuration is in millisecond

File: src/java/org/apache/cassandra/schema/Views.java
Patch:
@@ -73,7 +73,7 @@ public boolean isEmpty()
 
     public Iterable<ViewMetadata> forTable(UUID tableId)
     {
-        return Iterables.filter(this, v -> v.baseTableId.equals(tableId));
+        return Iterables.filter(this, v -> v.baseTableId.asUUID().equals(tableId));
     }
 
     /**

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -89,7 +89,8 @@ public final class MessagingService implements MessagingServiceMBean
 
     // 8 bits version, so don't waste versions
     public static final int VERSION_30 = 10;
-    public static final int current_version = VERSION_30;
+    public static final int VERSION_40 = 11;
+    public static final int current_version = VERSION_40;
 
     public static final String FAILURE_CALLBACK_PARAM = "CAL_BAC";
     public static final byte[] ONE_BYTE = new byte[1];

File: src/java/org/apache/cassandra/db/rows/BTreeRow.java
Patch:
@@ -263,7 +263,7 @@ public Row filter(ColumnFilter filter, DeletionTime activeDeletion, boolean setA
     {
         Map<ByteBuffer, CFMetaData.DroppedColumn> droppedColumns = metadata.getDroppedColumns();
 
-        boolean mayFilterColumns = !filter.fetchesAllColumns(isStatic());
+        boolean mayFilterColumns = !filter.fetchesAllColumns() || !filter.allFetchedColumnsAreQueried();
         boolean mayHaveShadowed = activeDeletion.supersedes(deletion.time());
 
         if (!mayFilterColumns && !mayHaveShadowed && droppedColumns.isEmpty())

File: src/java/org/apache/cassandra/schema/SchemaKeyspace.java
Patch:
@@ -391,7 +391,7 @@ private static PartitionUpdate makeUpdateForSchema(UnfilteredRowIterator partiti
 
         // We want to skip the 'cdc' column. A simple solution for that is based on the fact that
         // 'PartitionUpdate.fromIterator()' will ignore any columns that are marked as 'fetched' but not 'queried'.
-        ColumnFilter.Builder builder = ColumnFilter.allRegularColumnsBuilder(partition.metadata());
+        ColumnFilter.Builder builder = ColumnFilter.allColumnsBuilder(partition.metadata());
         for (ColumnDefinition column : filter.fetchedColumns())
         {
             if (!column.name.toString().equals("cdc"))

File: test/unit/org/apache/cassandra/db/ReadCommandTest.java
Patch:
@@ -213,7 +213,7 @@ public void testSinglePartitionGroupMerge() throws Exception
 
         List<ByteBuffer> buffers = new ArrayList<>(groups.length);
         int nowInSeconds = FBUtilities.nowInSeconds();
-        ColumnFilter columnFilter = ColumnFilter.allRegularColumnsBuilder(cfs.metadata).build();
+        ColumnFilter columnFilter = ColumnFilter.allColumnsBuilder(cfs.metadata).build();
         RowFilter rowFilter = RowFilter.create();
         Slice slice = Slice.make(ClusteringBound.BOTTOM, ClusteringBound.TOP);
         ClusteringIndexSliceFilter sliceFilter = new ClusteringIndexSliceFilter(Slices.with(cfs.metadata.comparator, slice), false);

File: src/java/org/apache/cassandra/db/rows/BTreeRow.java
Patch:
@@ -237,7 +237,7 @@ public Row filter(ColumnFilter filter, DeletionTime activeDeletion, boolean setA
     {
         Map<ByteBuffer, CFMetaData.DroppedColumn> droppedColumns = metadata.getDroppedColumns();
 
-        if (filter.includesAllColumns(isStatic()) && (activeDeletion.isLive() || deletion.supersedes(activeDeletion)) && droppedColumns.isEmpty())
+        if (filter.includesAllColumns() && (activeDeletion.isLive() || deletion.supersedes(activeDeletion)) && droppedColumns.isEmpty())
             return this;
 
         boolean mayHaveShadowed = activeDeletion.supersedes(deletion.time());

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -96,7 +96,7 @@ public class Config
     public volatile long truncate_request_timeout_in_ms = 60000L;
 
     /**
-     * @deprecated use {@link this#streaming_keep_alive_period_in_secs} instead
+     * @deprecated use {@link #streaming_keep_alive_period_in_secs} instead
      */
     @Deprecated
     public int streaming_socket_timeout_in_ms = 86400000; //24 hours

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -2016,7 +2016,7 @@ public static void setStreamingSocketTimeout(int value)
     }
 
     /**
-     * @deprecated use {@link this#getStreamingKeepAlivePeriod()} instead
+     * @deprecated use {@link #getStreamingKeepAlivePeriod()} instead
      * @return streaming_socket_timeout_in_ms property
      */
     @Deprecated

File: src/java/org/apache/cassandra/cql3/Maps.java
Patch:
@@ -81,7 +81,7 @@ public static <T extends AssignmentTestable> AssignmentTestable.TestResult testM
     /**
      * Create a <code>String</code> representation of the list containing the specified elements.
      *
-     * @param elements the list elements
+     * @param entries the list elements
      * @return a <code>String</code> representation of the list
      */
     public static <T> String mapToString(List<Pair<T, T>> entries)

File: src/java/org/apache/cassandra/cql3/UserTypes.java
Patch:
@@ -96,7 +96,6 @@ public static <T extends AssignmentTestable> AssignmentTestable.TestResult testU
      * the user type entries.
      *
      * @param items items associated to the user type entries
-     * @param mapper the mapper used to user type the items to the {@code String} representation of the map entries
      * @return a {@code String} representation of the user type
      */
     public static <T> String userTypeToString(Map<FieldIdentifier, T> items)

File: src/java/org/apache/cassandra/cql3/statements/ParsedStatement.java
Patch:
@@ -50,7 +50,7 @@ public static class Prepared
     {
         /**
          * Contains the CQL statement source if the statement has been "regularly" perpared via
-         * {@link org.apache.cassandra.cql3.QueryProcessor#prepare(java.lang.String, org.apache.cassandra.service.ClientState, boolean)} /
+         * {@link org.apache.cassandra.cql3.QueryProcessor#prepare(java.lang.String, org.apache.cassandra.service.ClientState)} /
          * {@link QueryHandler#prepare(java.lang.String, org.apache.cassandra.service.QueryState, java.util.Map)}.
          * Other usages of this class may or may not contain the CQL statement source.
          */

File: src/java/org/apache/cassandra/db/Keyspace.java
Patch:
@@ -452,7 +452,6 @@ public void apply(final Mutation mutation,
      * @param writeCommitLog false to disable commitlog append entirely
      * @param updateIndexes  false to disable index updates (used by CollationController "defragmenting")
      * @param isDroppable    true if this should throw WriteTimeoutException if it does not acquire lock within write_request_timeout_in_ms
-     * @throws ExecutionException
      */
     public void apply(final Mutation mutation,
                       final boolean writeCommitLog,

File: src/java/org/apache/cassandra/db/ReadQuery.java
Patch:
@@ -114,7 +114,7 @@ public boolean selectsClustering(DecoratedKey key, Clustering clustering)
      * Execute the query locally. This is similar to {@link ReadQuery#executeInternal(ReadExecutionController)}
      * but it returns an unfiltered partition iterator that can be merged later on.
      *
-     * @param controller the {@code ReadExecutionController} protecting the read.
+     * @param executionController the {@code ReadExecutionController} protecting the read.
      * @return the result of the read query.
      */
     public UnfilteredPartitionIterator executeLocally(ReadExecutionController executionController);

File: src/java/org/apache/cassandra/db/commitlog/CommitLogReader.java
Patch:
@@ -105,7 +105,7 @@ public void readCommitLogSegment(CommitLogReadHandler handler, File file, int mu
      * Reads mutations from file, handing them off to handler
      * @param handler Handler that will take action based on deserialized Mutations
      * @param file CommitLogSegment file to read
-     * @param minPosition Optional minimum CommitLogPosition - all segments with id > or matching w/greater position will be read
+     * @param minPosition Optional minimum CommitLogPosition - all segments with id larger or matching w/greater position will be read
      * @param mutationLimit Optional limit on # of mutations to replay. Local ALL_MUTATIONS serves as marker to play all.
      * @param tolerateTruncation Whether or not we should allow truncation of this file or throw if EOF found
      *

File: src/java/org/apache/cassandra/dht/IPartitioner.java
Patch:
@@ -45,7 +45,7 @@ public interface IPartitioner
     public Token midpoint(Token left, Token right);
 
     /**
-     * Calculate a Token which take approximate 0 <= ratioToLeft <= 1 ownership of the given range.
+     * Calculate a Token which take {@code approximate 0 <= ratioToLeft <= 1} ownership of the given range.
      */
     public Token split(Token left, Token right, double ratioToLeft);
 

File: src/java/org/apache/cassandra/index/sasi/analyzer/StandardTokenizerInterface.java
Patch:
@@ -46,7 +46,7 @@ public interface StandardTokenizerInterface
      * Resumes scanning until the next regular expression is matched,
      * the end of input is encountered or an I/O-Error occurs.
      *
-     * @return      the next token, {@link #YYEOF} on end of stream
+     * @return      the next token, {@link StandardTokenizerImpl#YYEOF} on end of stream
      * @exception   java.io.IOException  if any I/O-Error occurs
      */
     int getNextToken() throws IOException;

File: src/java/org/apache/cassandra/net/BackPressureStrategy.java
Patch:
@@ -23,9 +23,10 @@
 
 /**
  * Back-pressure algorithm interface.
- * <br/>
+ * <p>
  * For experts usage only. Implementors must provide a constructor accepting a single {@code Map<String, Object>} argument,
  * representing any parameters eventually required by the specific implementation.
+ * </p>
  */
 public interface BackPressureStrategy<S extends BackPressureState>
 {

File: src/java/org/apache/cassandra/utils/SlidingTimeRate.java
Patch:
@@ -42,9 +42,10 @@ public class SlidingTimeRate
 
     /**
      * Creates a sliding rate whose time window is of the given size, with the given precision and time unit.
-     * <br/>
+     * <p>
      * The precision defines how accurate the rate computation is, as it will be computed over window size +/-
      * precision.
+     * </p>
      */
     public SlidingTimeRate(TimeSource timeSource, long size, long precision, TimeUnit unit)
     {

File: test/unit/org/apache/cassandra/dht/BootStrapperTest.java
Patch:
@@ -98,7 +98,7 @@ private RangeStreamer testSourceTargetComputation(String keyspaceName, int numOl
         InetAddress myEndpoint = InetAddress.getByName("127.0.0.1");
 
         assertEquals(numOldNodes, tmd.sortedTokens().size());
-        RangeStreamer s = new RangeStreamer(tmd, null, myEndpoint, "Bootstrap", true, DatabaseDescriptor.getEndpointSnitch(), new StreamStateStore(), false);
+        RangeStreamer s = new RangeStreamer(tmd, null, myEndpoint, "Bootstrap", true, DatabaseDescriptor.getEndpointSnitch(), new StreamStateStore(), false, 1);
         IFailureDetector mockFailureDetector = new IFailureDetector()
         {
             public boolean isAlive(InetAddress ep)

File: test/unit/org/apache/cassandra/cql3/validation/entities/UserTypesTest.java
Patch:
@@ -550,7 +550,6 @@ private void assertComplexInvalidAlterDropStatements(String type1, String fArgTy
     private void assertInvalidAlterDropStatements(String t) throws Throwable
     {
         assertInvalidMessage("Cannot alter user type " + typeWithKs(t), "ALTER TYPE " + typeWithKs(t) + " RENAME foo TO bar;");
-        assertInvalidMessage("Cannot alter user type " + typeWithKs(t), "ALTER TYPE " + typeWithKs(t) + " ALTER foo TYPE text;");
         assertInvalidMessage("Cannot drop user type " + typeWithKs(t), "DROP TYPE " + typeWithKs(t) + ';');
     }
 

File: src/java/org/apache/cassandra/db/UnfilteredDeserializer.java
Patch:
@@ -647,7 +647,7 @@ public Unfiltered openNew(LegacyLayout.LegacyRangeTombstone tombstone)
                     // If the new tombstone don't supersedes the currently open tombstone, we don't have anything to return, we
                     // just add the new tombstone (because we know tombstone is not fully shadowed, this imply the new tombstone
                     // simply extend after the first one and we'll deal with it later)
-                    assert metadata.comparator.compare(tombstone.start.bound, first.stop.bound) > 0;
+                    assert metadata.comparator.compare(tombstone.start.bound, first.stop.bound) <= 0;
                     openTombstones.add(tombstone);
                     return null;
                 }

File: src/java/org/apache/cassandra/cql3/statements/AlterKeyspaceStatement.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.cassandra.schema.KeyspaceParams;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class AlterKeyspaceStatement extends SchemaAlteringStatement
@@ -76,7 +77,7 @@ public void validate(ClientState state) throws RequestValidationException
         }
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         KeyspaceMetadata oldKsm = Schema.instance.getKSMetaData(name);
         // In the (very) unlikely case the keyspace was dropped since validate()

File: src/java/org/apache/cassandra/cql3/statements/AlterTypeStatement.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public abstract class AlterTypeStatement extends SchemaAlteringStatement
@@ -83,7 +84,7 @@ public String keyspace()
         return name.getKeyspace();
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
     {
         KeyspaceMetadata ksm = Schema.instance.getKSMetaData(name.getKeyspace());
         if (ksm == null)

File: src/java/org/apache/cassandra/cql3/statements/AlterViewStatement.java
Patch:
@@ -30,6 +30,7 @@
 import org.apache.cassandra.schema.TableParams;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class AlterViewStatement extends SchemaAlteringStatement
@@ -54,7 +55,7 @@ public void validate(ClientState state)
         // validated in announceMigration()
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         CFMetaData meta = Validation.validateColumnFamily(keyspace(), columnFamily());
         if (!meta.isView())

File: src/java/org/apache/cassandra/cql3/statements/CreateAggregateStatement.java
Patch:
@@ -207,7 +207,7 @@ public void validate(ClientState state) throws InvalidRequestException
             throw new InvalidRequestException(String.format("Cannot add aggregate '%s' to non existing keyspace '%s'.", functionName.name, functionName.keyspace));
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         Function old = Schema.instance.findFunction(functionName, argTypes).orElse(null);
         boolean replaced = old != null;

File: src/java/org/apache/cassandra/cql3/statements/CreateFunctionStatement.java
Patch:
@@ -138,7 +138,7 @@ public void validate(ClientState state) throws InvalidRequestException
             throw new InvalidRequestException(String.format("Cannot add function '%s' to non existing keyspace '%s'.", functionName.name, functionName.keyspace));
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         Function old = Schema.instance.findFunction(functionName, argTypes).orElse(null);
         boolean replaced = old != null;

File: src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java
Patch:
@@ -42,6 +42,7 @@
 import org.apache.cassandra.schema.Indexes;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 /** A <code>CREATE INDEX</code> statement parsed from a CQL query. */
@@ -180,7 +181,7 @@ private void validateTargetsForMultiColumnIndex(List<IndexTarget> targets)
                 throw new InvalidRequestException("Duplicate column " + target.column + " in index target list");
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         CFMetaData cfm = Schema.instance.getCFMetaData(keyspace(), columnFamily()).copy();
         List<IndexTarget> targets = new ArrayList<>(rawTargets.size());

File: src/java/org/apache/cassandra/cql3/statements/CreateKeyspaceStatement.java
Patch:
@@ -96,7 +96,7 @@ public void validate(ClientState state) throws RequestValidationException
             throw new ConfigurationException("Unable to use given strategy class: LocalStrategy is reserved for internal use.");
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         KeyspaceMetadata ksm = KeyspaceMetadata.create(name, attrs.asNewKeyspaceParams());
         try

File: src/java/org/apache/cassandra/cql3/statements/CreateTableStatement.java
Patch:
@@ -82,7 +82,7 @@ public void validate(ClientState state)
         // validated in announceMigration()
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         try
         {

File: src/java/org/apache/cassandra/cql3/statements/CreateTriggerStatement.java
Patch:
@@ -32,6 +32,7 @@
 import org.apache.cassandra.schema.Triggers;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 import org.apache.cassandra.triggers.TriggerExecutor;
 
@@ -72,7 +73,7 @@ public void validate(ClientState state) throws RequestValidationException
         }
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws ConfigurationException, InvalidRequestException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws ConfigurationException, InvalidRequestException
     {
         CFMetaData cfm = Schema.instance.getCFMetaData(keyspace(), columnFamily()).copy();
         Triggers triggers = cfm.getTriggers();

File: src/java/org/apache/cassandra/cql3/statements/CreateTypeStatement.java
Patch:
@@ -30,6 +30,7 @@
 import org.apache.cassandra.schema.Types;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class CreateTypeStatement extends SchemaAlteringStatement
@@ -117,7 +118,7 @@ public UserType createType() throws InvalidRequestException
         return new UserType(name.getKeyspace(), name.getUserTypeName(), columnNames, types, true);
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
     {
         KeyspaceMetadata ksm = Schema.instance.getKSMetaData(name.getKeyspace());
         assert ksm != null; // should haven't validate otherwise

File: src/java/org/apache/cassandra/cql3/statements/CreateViewStatement.java
Patch:
@@ -43,6 +43,7 @@
 import org.apache.cassandra.schema.TableParams;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class CreateViewStatement extends SchemaAlteringStatement
@@ -111,7 +112,7 @@ else if (desc && !type.isReversed())
         }
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         // We need to make sure that:
         //  - primary key includes all columns in base table's primary key

File: src/java/org/apache/cassandra/cql3/statements/DropAggregateStatement.java
Patch:
@@ -32,6 +32,7 @@
 import org.apache.cassandra.exceptions.UnauthorizedException;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 /**
@@ -77,7 +78,7 @@ public void validate(ClientState state) throws RequestValidationException
     {
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         Collection<Function> olds = Schema.instance.getFunctions(functionName);
 

File: src/java/org/apache/cassandra/cql3/statements/DropFunctionStatement.java
Patch:
@@ -36,6 +36,7 @@
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 /**
@@ -127,7 +128,7 @@ public void validate(ClientState state)
                                                             functionName, functionName, functionName));
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         Function old = findFunction();
         if (old == null)

File: src/java/org/apache/cassandra/cql3/statements/DropIndexStatement.java
Patch:
@@ -66,11 +66,11 @@ public void validate(ClientState state)
     @Override
     public ResultMessage execute(QueryState state, QueryOptions options, long queryStartNanoTime) throws RequestValidationException
     {
-        Event.SchemaChange ce = announceMigration(false);
+        Event.SchemaChange ce = announceMigration(state, false);
         return ce == null ? null : new ResultMessage.SchemaChange(ce);
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
     {
         CFMetaData cfm = lookupIndexedTable();
         if (cfm == null)

File: src/java/org/apache/cassandra/cql3/statements/DropKeyspaceStatement.java
Patch:
@@ -25,6 +25,7 @@
 import org.apache.cassandra.exceptions.UnauthorizedException;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class DropKeyspaceStatement extends SchemaAlteringStatement
@@ -55,7 +56,7 @@ public String keyspace()
         return keyspace;
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws ConfigurationException
     {
         try
         {

File: src/java/org/apache/cassandra/cql3/statements/DropTableStatement.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class DropTableStatement extends SchemaAlteringStatement
@@ -58,7 +59,7 @@ public void validate(ClientState state)
         // validated in announceMigration()
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws ConfigurationException
     {
         try
         {

File: src/java/org/apache/cassandra/cql3/statements/DropTriggerStatement.java
Patch:
@@ -31,6 +31,7 @@
 import org.apache.cassandra.schema.Triggers;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class DropTriggerStatement extends SchemaAlteringStatement
@@ -58,7 +59,7 @@ public void validate(ClientState state) throws RequestValidationException
         Validation.validateColumnFamily(keyspace(), columnFamily());
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws ConfigurationException, InvalidRequestException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws ConfigurationException, InvalidRequestException
     {
         CFMetaData cfm = Schema.instance.getCFMetaData(keyspace(), columnFamily()).copy();
         Triggers triggers = cfm.getTriggers();

File: src/java/org/apache/cassandra/cql3/statements/DropTypeStatement.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class DropTypeStatement extends SchemaAlteringStatement
@@ -103,7 +104,7 @@ public String keyspace()
         return name.getKeyspace();
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
     {
         KeyspaceMetadata ksm = Schema.instance.getKSMetaData(name.getKeyspace());
         if (ksm == null)

File: src/java/org/apache/cassandra/cql3/statements/DropViewStatement.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.cassandra.exceptions.UnauthorizedException;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class DropViewStatement extends SchemaAlteringStatement
@@ -51,7 +52,7 @@ public void validate(ClientState state)
         // validated in findIndexedCf()
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
     {
         try
         {

File: src/java/org/apache/cassandra/cql3/statements/SchemaAlteringStatement.java
Patch:
@@ -84,13 +84,13 @@ protected void grantPermissionsToCreator(QueryState state)
      *
      * @throws RequestValidationException
      */
-    public abstract Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException;
+    protected abstract Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException;
 
     public ResultMessage execute(QueryState state, QueryOptions options, long queryStartNanoTime) throws RequestValidationException
     {
         // If an IF [NOT] EXISTS clause was used, this may not result in an actual schema change.  To avoid doing
         // extra work in the drivers to handle schema changes, we return an empty message in this case. (CASSANDRA-7600)
-        Event.SchemaChange ce = announceMigration(false);
+        Event.SchemaChange ce = announceMigration(state, false);
         if (ce == null)
             return new ResultMessage.Void();
 
@@ -117,7 +117,7 @@ public ResultMessage execute(QueryState state, QueryOptions options, long queryS
 
     public ResultMessage executeInternal(QueryState state, QueryOptions options)
     {
-        Event.SchemaChange ce = announceMigration(true);
+        Event.SchemaChange ce = announceMigration(state, true);
         return ce == null ? new ResultMessage.Void() : new ResultMessage.SchemaChange(ce);
     }
 }

File: src/java/org/apache/cassandra/cql3/statements/AlterKeyspaceStatement.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.cassandra.schema.KeyspaceParams;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class AlterKeyspaceStatement extends SchemaAlteringStatement
@@ -76,7 +77,7 @@ public void validate(ClientState state) throws RequestValidationException
         }
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         KeyspaceMetadata oldKsm = Schema.instance.getKSMetaData(name);
         // In the (very) unlikely case the keyspace was dropped since validate()

File: src/java/org/apache/cassandra/cql3/statements/AlterTypeStatement.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public abstract class AlterTypeStatement extends SchemaAlteringStatement
@@ -83,7 +84,7 @@ public String keyspace()
         return name.getKeyspace();
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
     {
         KeyspaceMetadata ksm = Schema.instance.getKSMetaData(name.getKeyspace());
         if (ksm == null)

File: src/java/org/apache/cassandra/cql3/statements/AlterViewStatement.java
Patch:
@@ -29,6 +29,7 @@
 import org.apache.cassandra.schema.TableParams;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 import static org.apache.cassandra.thrift.ThriftValidation.validateColumnFamily;
@@ -55,7 +56,7 @@ public void validate(ClientState state)
         // validated in announceMigration()
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         CFMetaData meta = validateColumnFamily(keyspace(), columnFamily());
         if (!meta.isView())

File: src/java/org/apache/cassandra/cql3/statements/CreateAggregateStatement.java
Patch:
@@ -208,7 +208,7 @@ public void validate(ClientState state) throws InvalidRequestException
             throw new InvalidRequestException(String.format("Cannot add aggregate '%s' to non existing keyspace '%s'.", functionName.name, functionName.keyspace));
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         Function old = Schema.instance.findFunction(functionName, argTypes).orElse(null);
         boolean replaced = old != null;

File: src/java/org/apache/cassandra/cql3/statements/CreateFunctionStatement.java
Patch:
@@ -138,7 +138,7 @@ public void validate(ClientState state) throws InvalidRequestException
             throw new InvalidRequestException(String.format("Cannot add function '%s' to non existing keyspace '%s'.", functionName.name, functionName.keyspace));
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         Function old = Schema.instance.findFunction(functionName, argTypes).orElse(null);
         boolean replaced = old != null;

File: src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java
Patch:
@@ -41,6 +41,7 @@
 import org.apache.cassandra.schema.Indexes;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.transport.Event;
 
@@ -180,7 +181,7 @@ private void validateTargetsForMultiColumnIndex(List<IndexTarget> targets)
                 throw new InvalidRequestException("Duplicate column " + target.column + " in index target list");
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         CFMetaData cfm = Schema.instance.getCFMetaData(keyspace(), columnFamily()).copy();
         List<IndexTarget> targets = new ArrayList<>(rawTargets.size());

File: src/java/org/apache/cassandra/cql3/statements/CreateKeyspaceStatement.java
Patch:
@@ -96,7 +96,7 @@ public void validate(ClientState state) throws RequestValidationException
             throw new ConfigurationException("Unable to use given strategy class: LocalStrategy is reserved for internal use.");
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         KeyspaceMetadata ksm = KeyspaceMetadata.create(name, attrs.asNewKeyspaceParams());
         try

File: src/java/org/apache/cassandra/cql3/statements/CreateTableStatement.java
Patch:
@@ -82,7 +82,7 @@ public void validate(ClientState state)
         // validated in announceMigration()
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         try
         {

File: src/java/org/apache/cassandra/cql3/statements/CreateTriggerStatement.java
Patch:
@@ -31,6 +31,7 @@
 import org.apache.cassandra.schema.Triggers;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.transport.Event;
 import org.apache.cassandra.triggers.TriggerExecutor;
@@ -72,7 +73,7 @@ public void validate(ClientState state) throws RequestValidationException
         }
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws ConfigurationException, InvalidRequestException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws ConfigurationException, InvalidRequestException
     {
         CFMetaData cfm = Schema.instance.getCFMetaData(keyspace(), columnFamily()).copy();
         Triggers triggers = cfm.getTriggers();

File: src/java/org/apache/cassandra/cql3/statements/CreateTypeStatement.java
Patch:
@@ -30,6 +30,7 @@
 import org.apache.cassandra.schema.Types;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class CreateTypeStatement extends SchemaAlteringStatement
@@ -117,7 +118,7 @@ public UserType createType() throws InvalidRequestException
         return new UserType(name.getKeyspace(), name.getUserTypeName(), columnNames, types, true);
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
     {
         KeyspaceMetadata ksm = Schema.instance.getKSMetaData(name.getKeyspace());
         assert ksm != null; // should haven't validate otherwise

File: src/java/org/apache/cassandra/cql3/statements/CreateViewStatement.java
Patch:
@@ -43,6 +43,7 @@
 import org.apache.cassandra.schema.TableParams;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.transport.Event;
 
@@ -112,7 +113,7 @@ else if (desc && !type.isReversed())
         }
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         // We need to make sure that:
         //  - primary key includes all columns in base table's primary key

File: src/java/org/apache/cassandra/cql3/statements/DropAggregateStatement.java
Patch:
@@ -31,6 +31,7 @@
 import org.apache.cassandra.exceptions.UnauthorizedException;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.transport.Event;
 
@@ -77,7 +78,7 @@ public void validate(ClientState state) throws RequestValidationException
     {
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         Collection<Function> olds = Schema.instance.getFunctions(functionName);
 

File: src/java/org/apache/cassandra/cql3/statements/DropFunctionStatement.java
Patch:
@@ -35,6 +35,7 @@
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.transport.Event;
 
@@ -127,7 +128,7 @@ public void validate(ClientState state)
                                                             functionName, functionName, functionName));
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         Function old = findFunction();
         if (old == null)

File: src/java/org/apache/cassandra/cql3/statements/DropIndexStatement.java
Patch:
@@ -66,11 +66,11 @@ public void validate(ClientState state)
     @Override
     public ResultMessage execute(QueryState state, QueryOptions options, long queryStartNanoTime) throws RequestValidationException
     {
-        Event.SchemaChange ce = announceMigration(false);
+        Event.SchemaChange ce = announceMigration(state, false);
         return ce == null ? null : new ResultMessage.SchemaChange(ce);
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
     {
         CFMetaData cfm = lookupIndexedTable();
         if (cfm == null)

File: src/java/org/apache/cassandra/cql3/statements/DropKeyspaceStatement.java
Patch:
@@ -24,6 +24,7 @@
 import org.apache.cassandra.exceptions.UnauthorizedException;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.transport.Event;
 
@@ -55,7 +56,7 @@ public String keyspace()
         return keyspace;
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws ConfigurationException
     {
         try
         {

File: src/java/org/apache/cassandra/cql3/statements/DropTableStatement.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class DropTableStatement extends SchemaAlteringStatement
@@ -58,7 +59,7 @@ public void validate(ClientState state)
         // validated in announceMigration()
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws ConfigurationException
     {
         try
         {

File: src/java/org/apache/cassandra/cql3/statements/DropTriggerStatement.java
Patch:
@@ -30,6 +30,7 @@
 import org.apache.cassandra.schema.Triggers;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.transport.Event;
 
@@ -58,7 +59,7 @@ public void validate(ClientState state) throws RequestValidationException
         ThriftValidation.validateColumnFamily(keyspace(), columnFamily());
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws ConfigurationException, InvalidRequestException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws ConfigurationException, InvalidRequestException
     {
         CFMetaData cfm = Schema.instance.getCFMetaData(keyspace(), columnFamily()).copy();
         Triggers triggers = cfm.getTriggers();

File: src/java/org/apache/cassandra/cql3/statements/DropTypeStatement.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class DropTypeStatement extends SchemaAlteringStatement
@@ -103,7 +104,7 @@ public String keyspace()
         return name.getKeyspace();
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
     {
         KeyspaceMetadata ksm = Schema.instance.getKSMetaData(name.getKeyspace());
         if (ksm == null)

File: src/java/org/apache/cassandra/cql3/statements/DropViewStatement.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.cassandra.exceptions.UnauthorizedException;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class DropViewStatement extends SchemaAlteringStatement
@@ -51,7 +52,7 @@ public void validate(ClientState state)
         // validated in findIndexedCf()
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
     {
         try
         {

File: src/java/org/apache/cassandra/cql3/statements/SchemaAlteringStatement.java
Patch:
@@ -84,13 +84,13 @@ protected void grantPermissionsToCreator(QueryState state)
      *
      * @throws RequestValidationException
      */
-    public abstract Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException;
+    protected abstract Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException;
 
     public ResultMessage execute(QueryState state, QueryOptions options, long queryStartNanoTime) throws RequestValidationException
     {
         // If an IF [NOT] EXISTS clause was used, this may not result in an actual schema change.  To avoid doing
         // extra work in the drivers to handle schema changes, we return an empty message in this case. (CASSANDRA-7600)
-        Event.SchemaChange ce = announceMigration(false);
+        Event.SchemaChange ce = announceMigration(state, false);
         if (ce == null)
             return new ResultMessage.Void();
 
@@ -117,7 +117,7 @@ public ResultMessage execute(QueryState state, QueryOptions options, long queryS
 
     public ResultMessage executeInternal(QueryState state, QueryOptions options)
     {
-        Event.SchemaChange ce = announceMigration(true);
+        Event.SchemaChange ce = announceMigration(state, true);
         return ce == null ? new ResultMessage.Void() : new ResultMessage.SchemaChange(ce);
     }
 }

File: src/java/org/apache/cassandra/cql3/statements/AlterKeyspaceStatement.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.cassandra.schema.KeyspaceParams;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class AlterKeyspaceStatement extends SchemaAlteringStatement
@@ -76,7 +77,7 @@ public void validate(ClientState state) throws RequestValidationException
         }
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         KeyspaceMetadata oldKsm = Schema.instance.getKSMetaData(name);
         // In the (very) unlikely case the keyspace was dropped since validate()

File: src/java/org/apache/cassandra/cql3/statements/AlterTypeStatement.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public abstract class AlterTypeStatement extends SchemaAlteringStatement
@@ -83,7 +84,7 @@ public String keyspace()
         return name.getKeyspace();
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
     {
         KeyspaceMetadata ksm = Schema.instance.getKSMetaData(name.getKeyspace());
         if (ksm == null)

File: src/java/org/apache/cassandra/cql3/statements/AlterViewStatement.java
Patch:
@@ -29,6 +29,7 @@
 import org.apache.cassandra.schema.TableParams;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 import static org.apache.cassandra.thrift.ThriftValidation.validateColumnFamily;
@@ -55,7 +56,7 @@ public void validate(ClientState state)
         // validated in announceMigration()
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         CFMetaData meta = validateColumnFamily(keyspace(), columnFamily());
         if (!meta.isView())

File: src/java/org/apache/cassandra/cql3/statements/CreateAggregateStatement.java
Patch:
@@ -208,7 +208,7 @@ public void validate(ClientState state) throws InvalidRequestException
             throw new InvalidRequestException(String.format("Cannot add aggregate '%s' to non existing keyspace '%s'.", functionName.name, functionName.keyspace));
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         Function old = Schema.instance.findFunction(functionName, argTypes).orElse(null);
         boolean replaced = old != null;

File: src/java/org/apache/cassandra/cql3/statements/CreateFunctionStatement.java
Patch:
@@ -138,7 +138,7 @@ public void validate(ClientState state) throws InvalidRequestException
             throw new InvalidRequestException(String.format("Cannot add function '%s' to non existing keyspace '%s'.", functionName.name, functionName.keyspace));
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         Function old = Schema.instance.findFunction(functionName, argTypes).orElse(null);
         boolean replaced = old != null;

File: src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java
Patch:
@@ -41,6 +41,7 @@
 import org.apache.cassandra.schema.Indexes;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.transport.Event;
 
@@ -180,7 +181,7 @@ private void validateTargetsForMultiColumnIndex(List<IndexTarget> targets)
                 throw new InvalidRequestException("Duplicate column " + target.column + " in index target list");
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         CFMetaData cfm = Schema.instance.getCFMetaData(keyspace(), columnFamily()).copy();
         List<IndexTarget> targets = new ArrayList<>(rawTargets.size());

File: src/java/org/apache/cassandra/cql3/statements/CreateKeyspaceStatement.java
Patch:
@@ -96,7 +96,7 @@ public void validate(ClientState state) throws RequestValidationException
             throw new ConfigurationException("Unable to use given strategy class: LocalStrategy is reserved for internal use.");
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         KeyspaceMetadata ksm = KeyspaceMetadata.create(name, attrs.asNewKeyspaceParams());
         try

File: src/java/org/apache/cassandra/cql3/statements/CreateTableStatement.java
Patch:
@@ -82,7 +82,7 @@ public void validate(ClientState state)
         // validated in announceMigration()
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         try
         {

File: src/java/org/apache/cassandra/cql3/statements/CreateTriggerStatement.java
Patch:
@@ -31,6 +31,7 @@
 import org.apache.cassandra.schema.Triggers;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.transport.Event;
 import org.apache.cassandra.triggers.TriggerExecutor;
@@ -72,7 +73,7 @@ public void validate(ClientState state) throws RequestValidationException
         }
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws ConfigurationException, InvalidRequestException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws ConfigurationException, InvalidRequestException
     {
         CFMetaData cfm = Schema.instance.getCFMetaData(keyspace(), columnFamily()).copy();
         Triggers triggers = cfm.getTriggers();

File: src/java/org/apache/cassandra/cql3/statements/CreateTypeStatement.java
Patch:
@@ -30,6 +30,7 @@
 import org.apache.cassandra.schema.Types;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class CreateTypeStatement extends SchemaAlteringStatement
@@ -117,7 +118,7 @@ public UserType createType() throws InvalidRequestException
         return new UserType(name.getKeyspace(), name.getUserTypeName(), columnNames, types, true);
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
     {
         KeyspaceMetadata ksm = Schema.instance.getKSMetaData(name.getKeyspace());
         assert ksm != null; // should haven't validate otherwise

File: src/java/org/apache/cassandra/cql3/statements/CreateViewStatement.java
Patch:
@@ -43,6 +43,7 @@
 import org.apache.cassandra.schema.TableParams;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.transport.Event;
 
@@ -112,7 +113,7 @@ else if (desc && !type.isReversed())
         }
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         // We need to make sure that:
         //  - primary key includes all columns in base table's primary key

File: src/java/org/apache/cassandra/cql3/statements/DropAggregateStatement.java
Patch:
@@ -31,6 +31,7 @@
 import org.apache.cassandra.exceptions.UnauthorizedException;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.transport.Event;
 
@@ -77,7 +78,7 @@ public void validate(ClientState state) throws RequestValidationException
     {
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         Collection<Function> olds = Schema.instance.getFunctions(functionName);
 

File: src/java/org/apache/cassandra/cql3/statements/DropFunctionStatement.java
Patch:
@@ -35,6 +35,7 @@
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.transport.Event;
 
@@ -127,7 +128,7 @@ public void validate(ClientState state)
                                                             functionName, functionName, functionName));
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         Function old = findFunction();
         if (old == null)

File: src/java/org/apache/cassandra/cql3/statements/DropIndexStatement.java
Patch:
@@ -66,11 +66,11 @@ public void validate(ClientState state)
     @Override
     public ResultMessage execute(QueryState state, QueryOptions options, long queryStartNanoTime) throws RequestValidationException
     {
-        Event.SchemaChange ce = announceMigration(false);
+        Event.SchemaChange ce = announceMigration(state, false);
         return ce == null ? null : new ResultMessage.SchemaChange(ce);
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
     {
         CFMetaData cfm = lookupIndexedTable();
         if (cfm == null)

File: src/java/org/apache/cassandra/cql3/statements/DropKeyspaceStatement.java
Patch:
@@ -24,6 +24,7 @@
 import org.apache.cassandra.exceptions.UnauthorizedException;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.transport.Event;
 
@@ -55,7 +56,7 @@ public String keyspace()
         return keyspace;
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws ConfigurationException
     {
         try
         {

File: src/java/org/apache/cassandra/cql3/statements/DropTableStatement.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class DropTableStatement extends SchemaAlteringStatement
@@ -58,7 +59,7 @@ public void validate(ClientState state)
         // validated in announceMigration()
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws ConfigurationException
     {
         try
         {

File: src/java/org/apache/cassandra/cql3/statements/DropTriggerStatement.java
Patch:
@@ -30,6 +30,7 @@
 import org.apache.cassandra.schema.Triggers;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.transport.Event;
 
@@ -58,7 +59,7 @@ public void validate(ClientState state) throws RequestValidationException
         ThriftValidation.validateColumnFamily(keyspace(), columnFamily());
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws ConfigurationException, InvalidRequestException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws ConfigurationException, InvalidRequestException
     {
         CFMetaData cfm = Schema.instance.getCFMetaData(keyspace(), columnFamily()).copy();
         Triggers triggers = cfm.getTriggers();

File: src/java/org/apache/cassandra/cql3/statements/DropTypeStatement.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class DropTypeStatement extends SchemaAlteringStatement
@@ -103,7 +104,7 @@ public String keyspace()
         return name.getKeyspace();
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
     {
         KeyspaceMetadata ksm = Schema.instance.getKSMetaData(name.getKeyspace());
         if (ksm == null)

File: src/java/org/apache/cassandra/cql3/statements/DropViewStatement.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.cassandra.exceptions.UnauthorizedException;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class DropViewStatement extends SchemaAlteringStatement
@@ -51,7 +52,7 @@ public void validate(ClientState state)
         // validated in findIndexedCf()
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
     {
         try
         {

File: src/java/org/apache/cassandra/cql3/statements/SchemaAlteringStatement.java
Patch:
@@ -84,13 +84,13 @@ protected void grantPermissionsToCreator(QueryState state)
      *
      * @throws RequestValidationException
      */
-    public abstract Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException;
+    protected abstract Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException;
 
     public ResultMessage execute(QueryState state, QueryOptions options, long queryStartNanoTime) throws RequestValidationException
     {
         // If an IF [NOT] EXISTS clause was used, this may not result in an actual schema change.  To avoid doing
         // extra work in the drivers to handle schema changes, we return an empty message in this case. (CASSANDRA-7600)
-        Event.SchemaChange ce = announceMigration(false);
+        Event.SchemaChange ce = announceMigration(state, false);
         if (ce == null)
             return new ResultMessage.Void();
 
@@ -117,7 +117,7 @@ public ResultMessage execute(QueryState state, QueryOptions options, long queryS
 
     public ResultMessage executeInternal(QueryState state, QueryOptions options)
     {
-        Event.SchemaChange ce = announceMigration(true);
+        Event.SchemaChange ce = announceMigration(state, true);
         return ce == null ? new ResultMessage.Void() : new ResultMessage.SchemaChange(ce);
     }
 }

File: src/java/org/apache/cassandra/cql3/statements/AlterKeyspaceStatement.java
Patch:
@@ -25,6 +25,7 @@
 import org.apache.cassandra.schema.KeyspaceParams;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class AlterKeyspaceStatement extends SchemaAlteringStatement
@@ -75,7 +76,7 @@ public void validate(ClientState state) throws RequestValidationException
         }
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         KeyspaceMetadata oldKsm = Schema.instance.getKSMetaData(name);
         // In the (very) unlikely case the keyspace was dropped since validate()

File: src/java/org/apache/cassandra/cql3/statements/AlterTypeStatement.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public abstract class AlterTypeStatement extends SchemaAlteringStatement
@@ -83,7 +84,7 @@ public String keyspace()
         return name.getKeyspace();
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
     {
         KeyspaceMetadata ksm = Schema.instance.getKSMetaData(name.getKeyspace());
         if (ksm == null)

File: src/java/org/apache/cassandra/cql3/statements/AlterViewStatement.java
Patch:
@@ -29,6 +29,7 @@
 import org.apache.cassandra.schema.TableParams;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 import static org.apache.cassandra.thrift.ThriftValidation.validateColumnFamily;
@@ -55,7 +56,7 @@ public void validate(ClientState state)
         // validated in announceMigration()
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         CFMetaData meta = validateColumnFamily(keyspace(), columnFamily());
         if (!meta.isView())

File: src/java/org/apache/cassandra/cql3/statements/CreateAggregateStatement.java
Patch:
@@ -208,7 +208,7 @@ public void validate(ClientState state) throws InvalidRequestException
             throw new InvalidRequestException(String.format("Cannot add aggregate '%s' to non existing keyspace '%s'.", functionName.name, functionName.keyspace));
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         Function old = Schema.instance.findFunction(functionName, argTypes).orElse(null);
         boolean replaced = old != null;

File: src/java/org/apache/cassandra/cql3/statements/CreateFunctionStatement.java
Patch:
@@ -138,7 +138,7 @@ public void validate(ClientState state) throws InvalidRequestException
             throw new InvalidRequestException(String.format("Cannot add function '%s' to non existing keyspace '%s'.", functionName.name, functionName.keyspace));
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         Function old = Schema.instance.findFunction(functionName, argTypes).orElse(null);
         boolean replaced = old != null;

File: src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java
Patch:
@@ -40,6 +40,7 @@
 import org.apache.cassandra.schema.Indexes;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.transport.Event;
 
@@ -188,7 +189,7 @@ private void validateTargetsForMultiColumnIndex(List<IndexTarget> targets)
                 throw new InvalidRequestException("Duplicate column " + target.column + " in index target list");
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         CFMetaData cfm = Schema.instance.getCFMetaData(keyspace(), columnFamily()).copy();
         List<IndexTarget> targets = new ArrayList<>(rawTargets.size());

File: src/java/org/apache/cassandra/cql3/statements/CreateKeyspaceStatement.java
Patch:
@@ -92,7 +92,7 @@ public void validate(ClientState state) throws RequestValidationException
             throw new ConfigurationException("Unable to use given strategy class: LocalStrategy is reserved for internal use.");
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         KeyspaceMetadata ksm = KeyspaceMetadata.create(name, attrs.asNewKeyspaceParams());
         try

File: src/java/org/apache/cassandra/cql3/statements/CreateTableStatement.java
Patch:
@@ -80,7 +80,7 @@ public void validate(ClientState state)
         // validated in announceMigration()
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         try
         {

File: src/java/org/apache/cassandra/cql3/statements/CreateTriggerStatement.java
Patch:
@@ -31,6 +31,7 @@
 import org.apache.cassandra.schema.Triggers;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.transport.Event;
 import org.apache.cassandra.triggers.TriggerExecutor;
@@ -72,7 +73,7 @@ public void validate(ClientState state) throws RequestValidationException
         }
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws ConfigurationException, InvalidRequestException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws ConfigurationException, InvalidRequestException
     {
         CFMetaData cfm = Schema.instance.getCFMetaData(keyspace(), columnFamily()).copy();
         Triggers triggers = cfm.getTriggers();

File: src/java/org/apache/cassandra/cql3/statements/CreateTypeStatement.java
Patch:
@@ -30,6 +30,7 @@
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class CreateTypeStatement extends SchemaAlteringStatement
@@ -112,7 +113,7 @@ private UserType createType() throws InvalidRequestException
         return new UserType(name.getKeyspace(), name.getUserTypeName(), names, types);
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
     {
         KeyspaceMetadata ksm = Schema.instance.getKSMetaData(name.getKeyspace());
         assert ksm != null; // should haven't validate otherwise

File: src/java/org/apache/cassandra/cql3/statements/CreateViewStatement.java
Patch:
@@ -43,6 +43,7 @@
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.ClientWarn;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.transport.Event;
 
@@ -111,7 +112,7 @@ else if (desc && !type.isReversed())
         }
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         // We need to make sure that:
         //  - primary key includes all columns in base table's primary key

File: src/java/org/apache/cassandra/cql3/statements/DropAggregateStatement.java
Patch:
@@ -31,6 +31,7 @@
 import org.apache.cassandra.exceptions.UnauthorizedException;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.transport.Event;
 
@@ -77,7 +78,7 @@ public void validate(ClientState state) throws RequestValidationException
     {
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         Collection<Function> olds = Schema.instance.getFunctions(functionName);
 

File: src/java/org/apache/cassandra/cql3/statements/DropFunctionStatement.java
Patch:
@@ -35,6 +35,7 @@
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.transport.Event;
 
@@ -127,7 +128,7 @@ public void validate(ClientState state)
                                                             functionName, functionName, functionName));
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException
     {
         Function old = findFunction();
         if (old == null)

File: src/java/org/apache/cassandra/cql3/statements/DropIndexStatement.java
Patch:
@@ -66,11 +66,11 @@ public void validate(ClientState state)
     @Override
     public ResultMessage execute(QueryState state, QueryOptions options) throws RequestValidationException
     {
-        Event.SchemaChange ce = announceMigration(false);
+        Event.SchemaChange ce = announceMigration(state, false);
         return ce == null ? null : new ResultMessage.SchemaChange(ce);
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
     {
         CFMetaData cfm = lookupIndexedTable();
         if (cfm == null)

File: src/java/org/apache/cassandra/cql3/statements/DropKeyspaceStatement.java
Patch:
@@ -24,6 +24,7 @@
 import org.apache.cassandra.exceptions.UnauthorizedException;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.transport.Event;
 
@@ -55,7 +56,7 @@ public String keyspace()
         return keyspace;
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws ConfigurationException
     {
         try
         {

File: src/java/org/apache/cassandra/cql3/statements/DropTableStatement.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class DropTableStatement extends SchemaAlteringStatement
@@ -58,7 +59,7 @@ public void validate(ClientState state)
         // validated in announceMigration()
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws ConfigurationException
     {
         try
         {

File: src/java/org/apache/cassandra/cql3/statements/DropTriggerStatement.java
Patch:
@@ -30,6 +30,7 @@
 import org.apache.cassandra.schema.Triggers;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.transport.Event;
 
@@ -58,7 +59,7 @@ public void validate(ClientState state) throws RequestValidationException
         ThriftValidation.validateColumnFamily(keyspace(), columnFamily());
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws ConfigurationException, InvalidRequestException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws ConfigurationException, InvalidRequestException
     {
         CFMetaData cfm = Schema.instance.getCFMetaData(keyspace(), columnFamily()).copy();
         Triggers triggers = cfm.getTriggers();

File: src/java/org/apache/cassandra/cql3/statements/DropTypeStatement.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class DropTypeStatement extends SchemaAlteringStatement
@@ -103,7 +104,7 @@ public String keyspace()
         return name.getKeyspace();
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
     {
         KeyspaceMetadata ksm = Schema.instance.getKSMetaData(name.getKeyspace());
         if (ksm == null)

File: src/java/org/apache/cassandra/cql3/statements/DropViewStatement.java
Patch:
@@ -29,6 +29,7 @@
 import org.apache.cassandra.exceptions.UnauthorizedException;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.transport.Event;
 
 public class DropViewStatement extends SchemaAlteringStatement
@@ -53,7 +54,7 @@ public void validate(ClientState state)
         // validated in findIndexedCf()
     }
 
-    public Event.SchemaChange announceMigration(boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
+    public Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws InvalidRequestException, ConfigurationException
     {
         try
         {

File: src/java/org/apache/cassandra/cql3/statements/SchemaAlteringStatement.java
Patch:
@@ -84,13 +84,13 @@ protected void grantPermissionsToCreator(QueryState state)
      *
      * @throws RequestValidationException
      */
-    public abstract Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestValidationException;
+    protected abstract Event.SchemaChange announceMigration(QueryState queryState, boolean isLocalOnly) throws RequestValidationException;
 
     public ResultMessage execute(QueryState state, QueryOptions options) throws RequestValidationException
     {
         // If an IF [NOT] EXISTS clause was used, this may not result in an actual schema change.  To avoid doing
         // extra work in the drivers to handle schema changes, we return an empty message in this case. (CASSANDRA-7600)
-        Event.SchemaChange ce = announceMigration(false);
+        Event.SchemaChange ce = announceMigration(state, false);
         if (ce == null)
             return new ResultMessage.Void();
 
@@ -117,7 +117,7 @@ public ResultMessage execute(QueryState state, QueryOptions options) throws Requ
 
     public ResultMessage executeInternal(QueryState state, QueryOptions options)
     {
-        Event.SchemaChange ce = announceMigration(true);
+        Event.SchemaChange ce = announceMigration(state, true);
         return ce == null ? new ResultMessage.Void() : new ResultMessage.SchemaChange(ce);
     }
 }

File: src/java/org/apache/cassandra/io/util/FileUtils.java
Patch:
@@ -168,7 +168,7 @@ public static void renameWithConfirm(String from, String to)
 
     public static void renameWithConfirm(File from, File to)
     {
-        assert from.exists();
+        assert from.exists() : from + " should exist";
         if (logger.isTraceEnabled())
             logger.trace((String.format("Renaming %s to %s", from.getPath(), to.getPath())));
         // this is not FSWE because usually when we see it it's because we didn't close the file before renaming it,

File: src/java/org/apache/cassandra/service/pager/RangeSliceQueryPager.java
Patch:
@@ -74,7 +74,8 @@ protected List<Row> queryNextPage(int pageSize, ConsistencyLevel consistencyLeve
     {
         SliceQueryFilter sf = (SliceQueryFilter)columnFilter;
         AbstractBounds<RowPosition> keyRange = lastReturnedKey == null ? command.keyRange : makeIncludingKeyBounds(lastReturnedKey);
-        Composite start = lastReturnedName == null ? sf.start() : lastReturnedName;
+        // For DISTINCT queries we can and must ignore the lastReturnedName (see CASSANDRA-13017)
+        Composite start = lastReturnedName == null || isDistinct() ? sf.start() : lastReturnedName;
         PagedRangeCommand pageCmd = new PagedRangeCommand(command.keyspace,
                                                           command.columnFamily,
                                                           command.timestamp,

File: test/unit/org/apache/cassandra/service/QueryPagerTest.java
Patch:
@@ -146,7 +146,7 @@ private static RangeSliceCommand rangeNamesQuery(AbstractBounds<RowPosition> ran
     private static RangeSliceCommand rangeSliceQuery(AbstractBounds<RowPosition> range, int count, String start, String end)
     {
         SliceQueryFilter filter = new SliceQueryFilter(CellNames.simpleDense(bytes(start)), CellNames.simpleDense(bytes(end)), false, Integer.MAX_VALUE);
-        return new RangeSliceCommand(KS, CF, System.currentTimeMillis(), filter, range, count);
+        return new RangeSliceCommand(KS, CF, System.currentTimeMillis(), filter, range, null, count, true, false);
     }
 
     private static void assertRow(Row r, String key, String... names)

File: src/java/org/apache/cassandra/db/ColumnFamilyStoreCQLHelper.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Licensed to the Apache Softw≤are Foundation (ASF) under one
+ * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
  * regarding copyright ownership.  The ASF licenses this file

File: src/java/org/apache/cassandra/thrift/CustomTThreadPoolServer.java
Patch:
@@ -75,13 +75,15 @@ public class CustomTThreadPoolServer extends TServer
     private final TThreadPoolServer.Args args;
 
     //Track and Limit the number of connected clients
-    private final AtomicInteger activeClients = new AtomicInteger(0);
+    private final AtomicInteger activeClients;
 
 
     public CustomTThreadPoolServer(TThreadPoolServer.Args args, ExecutorService executorService) {
         super(args);
         this.executorService = executorService;
+        this.stopped = false;
         this.args = args;
+        this.activeClients = new AtomicInteger(0);
     }
 
     public void serve()
@@ -96,7 +98,6 @@ public void serve()
             return;
         }
 
-        stopped = false;
         while (!stopped)
         {
             // block until we are under max clients

File: src/java/org/apache/cassandra/dht/tokenallocator/TokenAllocatorFactory.java
Patch:
@@ -34,7 +34,7 @@ public static TokenAllocator<InetAddress> createTokenAllocator(NavigableMap<Toke
                                                      ReplicationStrategy<InetAddress> strategy,
                                                      IPartitioner partitioner)
     {
-        if(strategy.replicas() == 1 || strategy.replicas() == 0)
+        if(strategy.replicas() == 1)
         {
             logger.info("Using NoReplicationTokenAllocator.");
             return new NoReplicationTokenAllocator<>(sortedTokens, strategy, partitioner);

File: src/java/org/apache/cassandra/dht/tokenallocator/TokenAllocatorFactory.java
Patch:
@@ -34,7 +34,7 @@ public static TokenAllocator<InetAddress> createTokenAllocator(NavigableMap<Toke
                                                      ReplicationStrategy<InetAddress> strategy,
                                                      IPartitioner partitioner)
     {
-        if(strategy.replicas() == 1 || strategy.replicas() == 0)
+        if(strategy.replicas() == 1)
         {
             logger.info("Using NoReplicationTokenAllocator.");
             return new NoReplicationTokenAllocator<>(sortedTokens, strategy, partitioner);

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -3876,7 +3876,7 @@ public void decommission(boolean force) throws InterruptedException
             if (operationMode != Mode.NORMAL)
                 throw new UnsupportedOperationException("Node in " + operationMode + " state; wait for status to become normal or restart");
         }
-        if (isDecommissioning.compareAndSet(true, true))
+        if (!isDecommissioning.compareAndSet(false, true))
             throw new IllegalStateException("Node is still decommissioning. Check nodetool netstats.");
 
         if (logger.isDebugEnabled())

File: src/java/org/apache/cassandra/db/SinglePartitionReadCommand.java
Patch:
@@ -634,7 +634,7 @@ private UnfilteredRowIterator queryMemtableAndDiskInternal(ColumnFamilyStore cfs
                 return EmptyIterators.unfilteredRow(cfs.metadata, partitionKey(), filter.isReversed());
 
             StorageHook.instance.reportRead(cfs.metadata.cfId, partitionKey());
-            return withStateTracking(withSSTablesIterated(iterators, cfs.metric));
+            return withSSTablesIterated(iterators, cfs.metric);
         }
         catch (RuntimeException | Error e)
         {
@@ -832,7 +832,7 @@ private UnfilteredRowIterator queryMemtableAndSSTablesInTimestampOrder(ColumnFam
             }
         }
 
-        return withStateTracking(result.unfilteredIterator(columnFilter(), Slices.ALL, clusteringIndexFilter().isReversed()));
+        return result.unfilteredIterator(columnFilter(), Slices.ALL, clusteringIndexFilter().isReversed());
     }
 
     private ImmutableBTreePartition add(UnfilteredRowIterator iter, ImmutableBTreePartition result, ClusteringIndexNamesFilter filter, boolean isRepaired)

File: src/java/org/apache/cassandra/index/SecondaryIndexManager.java
Patch:
@@ -426,7 +426,7 @@ private Index createInstance(IndexMetadata indexDef)
             {
                 Class<? extends Index> indexClass = FBUtilities.classForName(className, "Index");
                 Constructor<? extends Index> ctor = indexClass.getConstructor(ColumnFamilyStore.class, IndexMetadata.class);
-                newIndex = (Index)ctor.newInstance(baseCfs, indexDef);
+                newIndex = ctor.newInstance(baseCfs, indexDef);
             }
             catch (Exception e)
             {
@@ -615,7 +615,7 @@ public int calculateIndexingPageSize()
             return DEFAULT_PAGE_SIZE;
 
         int columnsPerRow = baseCfs.metadata.partitionColumns().regulars.size();
-        if (meanCellsPerPartition <= 0)
+        if (columnsPerRow <= 0)
             return DEFAULT_PAGE_SIZE;
 
         int meanRowsPerPartition = meanCellsPerPartition / columnsPerRow;

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
Patch:
@@ -428,6 +428,7 @@ synchronized void close()
         discardUnusedTail();
         waitForModifications();
         lastSyncedOffset = buffer.capacity();
+        syncComplete.signalAll();
         internalClose();
     }
 

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -505,6 +505,7 @@ public void activate()
             try
             {
                 DatabaseDescriptor.forceStaticInitialization();
+                DatabaseDescriptor.setDaemonInitialized();
             }
             catch (ExceptionInInitializerError e)
             {

File: src/java/org/apache/cassandra/service/EmbeddedCassandraService.java
Patch:
@@ -19,6 +19,7 @@
 
 import java.io.IOException;
 
+import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.service.CassandraDaemon;
 
 /**
@@ -49,6 +50,7 @@ public class EmbeddedCassandraService
     public void start() throws IOException
     {
         cassandraDaemon = new CassandraDaemon();
+        DatabaseDescriptor.setDaemonInitialized();
         cassandraDaemon.init(null);
         cassandraDaemon.start();
     }

File: test/long/org/apache/cassandra/io/sstable/CQLSSTableWriterLongTest.java
Patch:
@@ -30,6 +30,7 @@
 import org.junit.Test;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.config.Config;
+import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.db.Keyspace;
 import org.apache.cassandra.service.StorageService;
@@ -39,6 +40,7 @@ public class CQLSSTableWriterLongTest
     @BeforeClass
     public static void setup() throws Exception
     {
+        DatabaseDescriptor.setDaemonInitialized();
         SchemaLoader.cleanupAndLeaveDirs();
         Keyspace.setInitialized();
         StorageService.instance.initServer();

File: test/unit/org/apache/cassandra/SchemaLoader.java
Patch:
@@ -90,6 +90,7 @@ public void uncaughtException(Thread t, Throwable e)
             }
         });
 
+        DatabaseDescriptor.setDaemonInitialized();
         Keyspace.setInitialized();
     }
 

File: test/unit/org/apache/cassandra/db/CounterCellTest.java
Patch:
@@ -30,6 +30,7 @@
 import org.junit.Test;
 
 import org.apache.cassandra.Util;
+import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.composites.CellNameType;
 import org.apache.cassandra.db.composites.SimpleDenseCellNameType;
 import org.apache.cassandra.db.context.CounterContext;
@@ -57,6 +58,8 @@ public class CounterCellTest
         countLength   = 8; // size of long
 
         stepLength    = idLength + clockLength + countLength;
+        // TODO: CounterId accesses SystemKespace to get local host ID, so need to mark as daemon initialized
+        DatabaseDescriptor.setDaemonInitialized();
     }
 
     @Test

File: test/unit/org/apache/cassandra/db/NativeCellTest.java
Patch:
@@ -32,6 +32,7 @@
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.ColumnDefinition;
+import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.cql3.ColumnIdentifier;
 import org.apache.cassandra.db.composites.CellName;
 import org.apache.cassandra.db.composites.CellNameType;
@@ -128,6 +129,8 @@ private static String hugestr(char ch, int count)
         {
             throw new AssertionError();
         }
+        // TODO: CounterId accesses SystemKespace to get local host ID, so need to mark as daemon initialized
+        DatabaseDescriptor.setDaemonInitialized();
     }
 
     @Test

File: test/unit/org/apache/cassandra/db/SystemKeyspaceTest.java
Patch:
@@ -42,6 +42,8 @@ public class SystemKeyspaceTest
     @BeforeClass
     public static void prepSnapshotTracker()
     {
+        DatabaseDescriptor.setDaemonInitialized();
+
         if (FBUtilities.isWindows())
             WindowsFailedSnapshotTracker.deleteOldSnapshots();
     }

File: test/unit/org/apache/cassandra/gms/FailureDetectorTest.java
Patch:
@@ -45,6 +45,8 @@ public static void setup()
     {
         // slow unit tests can cause problems with FailureDetector's GC pause handling
         System.setProperty("cassandra.max_local_pause_in_ms", "20000");
+
+        DatabaseDescriptor.setDaemonInitialized();
     }
 
     @Test

File: test/unit/org/apache/cassandra/io/sstable/CQLSSTableWriterTest.java
Patch:
@@ -34,6 +34,7 @@
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.Config;
+import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.cql3.QueryProcessor;
 import org.apache.cassandra.cql3.UntypedResultSet;
@@ -52,6 +53,7 @@ public class CQLSSTableWriterTest
     @BeforeClass
     public static void setup() throws Exception
     {
+        DatabaseDescriptor.setDaemonInitialized();
         SchemaLoader.cleanupAndLeaveDirs();
         Keyspace.setInitialized();
         StorageService.instance.initServer();

File: test/unit/org/apache/cassandra/locator/CloudstackSnitchTest.java
Patch:
@@ -27,6 +27,7 @@
 import org.junit.Test;
 
 import org.apache.cassandra.SchemaLoader;
+import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.gms.ApplicationState;
 import org.apache.cassandra.gms.Gossiper;
@@ -43,6 +44,7 @@ public class CloudstackSnitchTest
     @BeforeClass
     public static void setup() throws Exception
     {
+        DatabaseDescriptor.setDaemonInitialized();
         SchemaLoader.mkdirs();
         SchemaLoader.cleanup();
         Keyspace.setInitialized();

File: test/unit/org/apache/cassandra/locator/EC2SnitchTest.java
Patch:
@@ -33,6 +33,7 @@
 import org.junit.Test;
 
 import org.apache.cassandra.SchemaLoader;
+import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.Keyspace;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.gms.ApplicationState;
@@ -51,6 +52,7 @@ public class EC2SnitchTest
     @BeforeClass
     public static void setup() throws Exception
     {
+        DatabaseDescriptor.setDaemonInitialized();
         SchemaLoader.mkdirs();
         SchemaLoader.cleanup();
         Keyspace.setInitialized();

File: test/unit/org/apache/cassandra/locator/GoogleCloudSnitchTest.java
Patch:
@@ -31,6 +31,7 @@
 import org.junit.Test;
 
 import org.apache.cassandra.SchemaLoader;
+import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.Keyspace;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.gms.ApplicationState;
@@ -47,6 +48,7 @@ public class GoogleCloudSnitchTest
     @BeforeClass
     public static void setup() throws Exception
     {
+        DatabaseDescriptor.setDaemonInitialized();
         SchemaLoader.mkdirs();
         SchemaLoader.cleanup();
         Keyspace.setInitialized();

File: test/unit/org/apache/cassandra/service/StorageServiceServerTest.java
Patch:
@@ -63,6 +63,7 @@ public class StorageServiceServerTest
     @BeforeClass
     public static void setUp() throws ConfigurationException
     {
+        DatabaseDescriptor.setDaemonInitialized();
         IEndpointSnitch snitch = new PropertyFileSnitch();
         DatabaseDescriptor.setEndpointSnitch(snitch);
         Keyspace.setInitialized();

File: test/unit/org/apache/cassandra/hints/HintsBufferPoolTest.java
Patch:
@@ -64,7 +64,7 @@ public void testBackpressure() throws Exception
         });
         blocked.start();
 
-        Util.spinAssertEquals(State.WAITING, () -> blocked.getState(), 1);
+        Util.spinAssertEquals(true, () -> blockedOnBackpressure, 60);
 
         while (blocked.isAlive())
             if (!returnedBuffers.isEmpty())

File: src/java/org/apache/cassandra/tools/nodetool/StopDaemon.java
Patch:
@@ -19,6 +19,7 @@
 
 import io.airlift.command.Command;
 
+import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.tools.NodeProbe;
 import org.apache.cassandra.tools.NodeTool.NodeToolCmd;
 import org.apache.cassandra.utils.JVMStabilityInspector;
@@ -31,6 +32,7 @@ public void execute(NodeProbe probe)
     {
         try
         {
+            DatabaseDescriptor.toolInitialization();
             probe.stopCassandraDaemon();
         } catch (Exception e)
         {

File: src/java/org/apache/cassandra/index/sasi/plan/QueryController.java
Patch:
@@ -236,7 +236,7 @@ private Pair<Expression, Set<SSTableIndex>> calculatePrimary(Collection<Expressi
                 continue;
 
             Set<SSTableIndex> indexes = applyScope(view.match(e));
-            if (primaryIndexes.size() > indexes.size())
+            if (expression == null || primaryIndexes.size() > indexes.size())
             {
                 primaryIndexes = indexes;
                 expression = e;

File: src/java/org/apache/cassandra/repair/messages/SyncRequest.java
Patch:
@@ -69,7 +69,7 @@ public boolean equals(Object o)
                initiator.equals(req.initiator) &&
                src.equals(req.src) &&
                dst.equals(req.dst) &&
-               ranges.equals(ranges);
+               ranges.equals(req.ranges);
     }
 
     @Override

File: src/java/org/apache/cassandra/repair/messages/SyncRequest.java
Patch:
@@ -69,7 +69,7 @@ public boolean equals(Object o)
                initiator.equals(req.initiator) &&
                src.equals(req.src) &&
                dst.equals(req.dst) &&
-               ranges.equals(ranges);
+               ranges.equals(req.ranges);
     }
 
     @Override

File: src/java/org/apache/cassandra/repair/messages/SyncRequest.java
Patch:
@@ -69,7 +69,7 @@ public boolean equals(Object o)
                initiator.equals(req.initiator) &&
                src.equals(req.src) &&
                dst.equals(req.dst) &&
-               ranges.equals(ranges);
+               ranges.equals(req.ranges);
     }
 
     @Override

File: src/java/org/apache/cassandra/repair/AnticompactionTask.java
Patch:
@@ -54,7 +54,7 @@ public class AnticompactionTask extends AbstractFuture<InetAddress> implements R
      * If Cassandra version is more than this, we need to wait for anticompaction response.
      */
     private static final CassandraVersion VERSION_CHECKER = new CassandraVersion("2.1.5");
-    private static Logger logger = LoggerFactory.getLogger(RepairSession.class);
+    private static Logger logger = LoggerFactory.getLogger(AnticompactionTask.class);
 
     private final UUID parentSession;
     private final InetAddress neighbor;

File: src/java/org/apache/cassandra/thrift/ThriftValidation.java
Patch:
@@ -454,8 +454,7 @@ public static void validateColumnData(CFMetaData metadata, ByteBuffer scName, Co
         try
         {
             LegacyLayout.LegacyCellName cn = LegacyLayout.decodeCellName(metadata, scName, column.name);
-            cn.column.validateCellValue(column.value);
-
+            cn.column.type.validateCellValue(column.value);
         }
         catch (UnknownColumnException e)
         {

File: src/java/org/apache/cassandra/db/compaction/CompactionInfo.java
Patch:
@@ -65,17 +65,17 @@ public CompactionInfo forProgress(long complete, long total)
 
     public UUID getId()
     {
-        return cfm.cfId;
+        return cfm != null ? cfm.cfId : null;
     }
 
     public String getKeyspace()
     {
-        return cfm.ksName;
+        return cfm != null ? cfm.ksName : null;
     }
 
     public String getColumnFamily()
     {
-        return cfm.cfName;
+        return cfm != null ? cfm.cfName : null;
     }
 
     public CFMetaData getCFMetaData()

File: src/java/org/apache/cassandra/locator/IEndpointSnitch.java
Patch:
@@ -22,15 +22,15 @@
 import java.util.List;
 
 /**
- * This interface helps determine location of node in the data center relative to another node.
+ * This interface helps determine location of node in the datacenter relative to another node.
  * Give a node A and another node B it can tell if A and B are on the same rack or in the same
- * data center.
+ * datacenter.
  */
 
 public interface IEndpointSnitch
 {
     /**
-     * returns a String repesenting the rack this endpoint belongs to
+     * returns a String representing the rack this endpoint belongs to
      */
     public String getRack(InetAddress endpoint);
 

File: tools/stress/src/org/apache/cassandra/stress/StressAction.java
Patch:
@@ -62,7 +62,8 @@ public void run()
         if (!settings.command.noWarmup)
             warmup(settings.command.getFactory(settings));
 
-        if (settings.command.truncate == SettingsCommand.TruncateWhen.ONCE)
+        if ((settings.command.truncate == SettingsCommand.TruncateWhen.ONCE) ||
+            ((settings.rate.threadCount != -1) && (settings.command.truncate == SettingsCommand.TruncateWhen.ALWAYS)))
             settings.command.truncateTables(settings);
 
         // Required for creating a graph from the output file

File: src/java/org/apache/cassandra/db/ReadCommandVerbHandler.java
Patch:
@@ -41,7 +41,7 @@ public void doVerb(MessageIn<ReadCommand> message, int id)
         }
 
         ReadCommand command = message.payload;
-        command.setMonitoringTime(message.constructionTime, message.getTimeout(), message.getSlowQueryTimeout());
+        command.setMonitoringTime(message.constructionTime, message.isCrossNode(), message.getTimeout(), message.getSlowQueryTimeout());
 
         ReadResponse response;
         try (ReadExecutionController executionController = command.executionController();
@@ -53,7 +53,7 @@ public void doVerb(MessageIn<ReadCommand> message, int id)
         if (!command.complete())
         {
             Tracing.trace("Discarding partial response to {} (timed out)", message.from);
-            MessagingService.instance().incrementDroppedMessages(message, System.currentTimeMillis() - message.constructionTime.timestamp);
+            MessagingService.instance().incrementDroppedMessages(message, message.getLifetimeInMS());
             return;
         }
 

File: src/java/org/apache/cassandra/db/monitoring/Monitorable.java
Patch:
@@ -21,14 +21,15 @@
 public interface Monitorable
 {
     String name();
-    ConstructionTime constructionTime();
+    long constructionTime();
     long timeout();
     long slowTimeout();
 
     boolean isInProgress();
     boolean isAborted();
     boolean isCompleted();
     boolean isSlow();
+    boolean isCrossNode();
 
     boolean abort();
     boolean complete();

File: src/java/org/apache/cassandra/net/IncomingTcpConnection.java
Patch:
@@ -188,7 +188,7 @@ private InetAddress receiveMessage(DataInputPlus input, int version) throws IOEx
         else
             id = input.readInt();
 
-        MessageIn message = MessageIn.read(input, version, id, MessageIn.readTimestamp(from, input, System.currentTimeMillis()));
+        MessageIn message = MessageIn.read(input, version, id, MessageIn.readConstructionTime(from, input));
         if (message == null)
         {
             // callback expired; nothing to do

File: src/java/org/apache/cassandra/net/MessageDeliveryTask.java
Patch:
@@ -46,7 +46,7 @@ public MessageDeliveryTask(MessageIn message, int id)
     public void run()
     {
         MessagingService.Verb verb = message.verb;
-        long timeTaken = System.currentTimeMillis() - message.constructionTime.timestamp;
+        long timeTaken = message.getLifetimeInMS();
         if (MessagingService.DROPPABLE_VERBS.contains(verb)
             && timeTaken > message.getTimeout())
         {
@@ -82,7 +82,7 @@ public void run()
         }
 
         if (GOSSIP_VERBS.contains(message.verb))
-            Gossiper.instance.setLastProcessedMessageAt(message.constructionTime.timestamp);
+            Gossiper.instance.setLastProcessedMessageAt(message.constructionTime);
     }
 
     private void handleFailure(Throwable t)

File: src/java/org/apache/cassandra/service/ReadCallback.java
Patch:
@@ -198,8 +198,7 @@ public void response(ReadResponse result)
                                                            result,
                                                            Collections.<String, byte[]>emptyMap(),
                                                            MessagingService.Verb.INTERNAL_RESPONSE,
-                                                           MessagingService.current_version,
-                                                           MessageIn.createTimestamp());
+                                                           MessagingService.current_version);
         response(message);
     }
 

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -52,7 +52,6 @@
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.filter.DataLimits;
 import org.apache.cassandra.db.filter.TombstoneOverwhelmingException;
-import org.apache.cassandra.db.monitoring.ConstructionTime;
 import org.apache.cassandra.db.partitions.*;
 import org.apache.cassandra.db.rows.RowIterator;
 import org.apache.cassandra.db.view.ViewUtils;
@@ -1876,7 +1875,7 @@ protected void runMayThrow()
         {
             try
             {
-                command.setMonitoringTime(new ConstructionTime(constructionTime), verb.getTimeout(), DatabaseDescriptor.getSlowQueryTimeout());
+                command.setMonitoringTime(constructionTime, false, verb.getTimeout(), DatabaseDescriptor.getSlowQueryTimeout());
 
                 ReadResponse response;
                 try (ReadExecutionController executionController = command.executionController();

File: test/unit/org/apache/cassandra/hints/HintTest.java
Patch:
@@ -232,7 +232,7 @@ public void testChangedTopology() throws Exception
         // Process hint message.
         HintMessage message = new HintMessage(localId, hint);
         MessagingService.instance().getVerbHandler(MessagingService.Verb.HINT).doVerb(
-                MessageIn.create(local, message, Collections.emptyMap(), MessagingService.Verb.HINT, MessagingService.current_version, MessageIn.createTimestamp()),
+                MessageIn.create(local, message, Collections.emptyMap(), MessagingService.Verb.HINT, MessagingService.current_version),
                 -1);
 
         // hint should not be applied as we no longer are a replica
@@ -277,7 +277,7 @@ public void testChangedTopologyNotHintable() throws Exception
             // Process hint message.
             HintMessage message = new HintMessage(localId, hint);
             MessagingService.instance().getVerbHandler(MessagingService.Verb.HINT).doVerb(
-                    MessageIn.create(local, message, Collections.emptyMap(), MessagingService.Verb.HINT, MessagingService.current_version, MessageIn.createTimestamp()),
+                    MessageIn.create(local, message, Collections.emptyMap(), MessagingService.Verb.HINT, MessagingService.current_version),
                     -1);
 
             // hint should not be applied as we no longer are a replica

File: test/unit/org/apache/cassandra/hints/HintsServiceTest.java
Patch:
@@ -184,8 +184,7 @@ private MockMessagingSpy sendHintsAndResponses(int noOfHints, int noOfResponses)
                 HintResponse.instance,
                 Collections.emptyMap(),
                 MessagingService.Verb.REQUEST_RESPONSE,
-                MessagingService.current_version,
-                MessageIn.createTimestamp());
+                MessagingService.current_version);
 
         MockMessagingSpy spy;
         if (noOfResponses != -1)

File: test/unit/org/apache/cassandra/net/MatcherResponse.java
Patch:
@@ -106,7 +106,7 @@ public <T, S> MockMessagingSpy respondNWithPayloadForEachReceiver(Function<Messa
                     if (payload == null)
                         return null;
                     else
-                        return MessageIn.create(to, payload, Collections.emptyMap(), verb, MessagingService.current_version, MessageIn.createTimestamp());
+                        return MessageIn.create(to, payload, Collections.emptyMap(), verb, MessagingService.current_version);
                 },
                 limit);
     }

File: test/unit/org/apache/cassandra/service/DataResolverTest.java
Patch:
@@ -828,8 +828,7 @@ public MessageIn<ReadResponse> readResponseMessage(InetAddress from, UnfilteredP
                                 ReadResponse.createRemoteDataResponse(partitionIterator, cmd),
                                 Collections.EMPTY_MAP,
                                 MessagingService.Verb.REQUEST_RESPONSE,
-                                MessagingService.current_version,
-                                MessageIn.createTimestamp());
+                                MessagingService.current_version);
     }
 
     private RangeTombstone tombstone(Object start, Object end, long markedForDeleteAt, int localDeletionTime)

File: src/java/org/apache/cassandra/index/sasi/sa/SuffixSA.java
Patch:
@@ -24,10 +24,10 @@
 import org.apache.cassandra.index.sasi.disk.OnDiskIndexBuilder;
 import org.apache.cassandra.index.sasi.disk.TokenTreeBuilder;
 import org.apache.cassandra.db.marshal.AbstractType;
+import org.apache.cassandra.utils.LongTimSort;
 import org.apache.cassandra.utils.Pair;
 
 import com.google.common.base.Charsets;
-import net.mintern.primitive.Primitive;
 
 public class SuffixSA extends SA<CharBuffer>
 {
@@ -81,7 +81,7 @@ public SASuffixIterator()
                 isComplete = false;
             }
 
-            Primitive.sort(suffixes, (a, b) -> {
+            LongTimSort.sort(suffixes, (a, b) -> {
                 Term aTerm = terms.get((int) (a >>> 32));
                 Term bTerm = terms.get((int) (b >>> 32));
                 return comparator.compare(aTerm.getSuffix(clearCompleteBit(a) - aTerm.getPosition()),

File: src/java/org/apache/cassandra/schema/CachingParams.java
Patch:
@@ -20,6 +20,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
+import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Objects;
 import com.google.common.collect.ImmutableMap;
 import org.apache.commons.lang3.StringUtils;
@@ -53,7 +54,8 @@ public String toString()
     public static final CachingParams CACHE_KEYS = new CachingParams(true, 0);
     public static final CachingParams CACHE_EVERYTHING = new CachingParams(true, Integer.MAX_VALUE);
 
-    static final CachingParams DEFAULT = new CachingParams(DEFAULT_CACHE_KEYS, DEFAULT_ROWS_PER_PARTITION_TO_CACHE);
+    @VisibleForTesting
+    public static CachingParams DEFAULT = new CachingParams(DEFAULT_CACHE_KEYS, DEFAULT_ROWS_PER_PARTITION_TO_CACHE);
 
     final boolean cacheKeys;
     final int rowsPerPartitionToCache;

File: src/java/org/apache/cassandra/tracing/TraceState.java
Patch:
@@ -52,7 +52,7 @@ public class TraceState implements ProgressEventNotifier
 {
     private static final Logger logger = LoggerFactory.getLogger(TraceState.class);
     private static final int WAIT_FOR_PENDING_EVENTS_TIMEOUT_SECS =
-    Integer.valueOf(System.getProperty("cassandra.wait_for_tracing_events_timeout_secs", "1"));
+    Integer.valueOf(System.getProperty("cassandra.wait_for_tracing_events_timeout_secs", "0"));
 
     public final UUID sessionId;
     public final InetAddress coordinator;

File: tools/stress/src/org/apache/cassandra/stress/settings/OptionDistribution.java
Patch:
@@ -124,7 +124,7 @@ public List<String> multiLineDisplay()
                 GroupedOptions.formatMultiLine("GAUSSIAN(min..max,mean,stdev)", "A gaussian/normal distribution, with explicitly defined mean and stdev"),
                 GroupedOptions.formatMultiLine("UNIFORM(min..max)", "A uniform distribution over the range [min, max]"),
                 GroupedOptions.formatMultiLine("FIXED(val)", "A fixed distribution, always returning the same value"),
-                GroupedOptions.formatMultiLine("SEQ(min..max)", "A fixed sequence, returning values from min to max sequentially, wrapping if necessary."),
+                GroupedOptions.formatMultiLine("SEQ(min..max)", "A fixed sequence, returning values in the range min to max sequentially (starting based on seed), wrapping if necessary."),
                 "Preceding the name with ~ will invert the distribution, e.g. ~exp(1..10) will yield 10 most, instead of least, often",
                 "Aliases: extr, qextr, gauss, normal, norm, weibull"
         );

File: src/java/org/apache/cassandra/io/sstable/format/big/BigTableWriter.java
Patch:
@@ -208,7 +208,7 @@ private void maybeLogLargePartitionWarning(DecoratedKey key, long rowSize)
         if (rowSize > DatabaseDescriptor.getCompactionLargePartitionWarningThreshold())
         {
             String keyString = metadata.getKeyValidator().getString(key.getKey());
-            logger.warn("Writing large partition {}/{}:{} ({}) to sstable {}", metadata.ksName, metadata.cfName, keyString, rowSize, FBUtilities.prettyPrintMemory(rowSize), getFilename());
+            logger.warn("Writing large partition {}/{}:{} ({}) to sstable {}", metadata.ksName, metadata.cfName, keyString, FBUtilities.prettyPrintMemory(rowSize), getFilename());
         }
     }
 

File: src/java/org/apache/cassandra/io/sstable/format/big/BigTableWriter.java
Patch:
@@ -208,7 +208,7 @@ private void maybeLogLargePartitionWarning(DecoratedKey key, long rowSize)
         if (rowSize > DatabaseDescriptor.getCompactionLargePartitionWarningThreshold())
         {
             String keyString = metadata.getKeyValidator().getString(key.getKey());
-            logger.warn("Writing large partition {}/{}:{} ({}) to sstable {}", metadata.ksName, metadata.cfName, keyString, rowSize, FBUtilities.prettyPrintMemory(rowSize), getFilename());
+            logger.warn("Writing large partition {}/{}:{} ({}) to sstable {}", metadata.ksName, metadata.cfName, keyString, FBUtilities.prettyPrintMemory(rowSize), getFilename());
         }
     }
 

File: src/java/org/apache/cassandra/dht/RandomPartitioner.java
Patch:
@@ -93,7 +93,7 @@ public BigIntegerToken getRandomToken()
 
     public BigIntegerToken getRandomToken(Random random)
     {
-        BigInteger token = FBUtilities.hashToBigInteger(GuidGenerator.guidAsBytes(random, 0));
+        BigInteger token = FBUtilities.hashToBigInteger(GuidGenerator.guidAsBytes(random, "host/127.0.0.1", 0));
         if ( token.signum() == -1 )
             token = token.multiply(BigInteger.valueOf(-1L));
         return new BigIntegerToken(token);

File: test/unit/org/apache/cassandra/db/ColumnFamilyStoreCQLHelperTest.java
Patch:
@@ -635,10 +635,10 @@ public void testDynamicComposite() throws Throwable
 
         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
         "CREATE TABLE IF NOT EXISTS " + DYNAMIC_COMPOSITE + "." + DYNAMIC_COMPOSITE + " (\n" +
-        "\t\"key\" ascii,\n" +
+        "\tkey ascii,\n" +
         "\tcols 'org.apache.cassandra.db.marshal.DynamicCompositeType(a=>org.apache.cassandra.db.marshal.BytesType,b=>org.apache.cassandra.db.marshal.BytesType,c=>org.apache.cassandra.db.marshal.BytesType)',\n" +
         "\tval ascii,\n" +
-        "\tPRIMARY KEY (\"key\", cols))\n" +
+        "\tPRIMARY KEY (key, cols))\n" +
         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
         "\tAND COMPACT STORAGE"));
     }

File: test/unit/org/apache/cassandra/db/ColumnFamilyStoreCQLHelperTest.java
Patch:
@@ -649,10 +649,10 @@ public void testDynamicComposite() throws Throwable
 
         assertTrue(ColumnFamilyStoreCQLHelper.getCFMetadataAsCQL(cfs.metadata, true).startsWith(
         "CREATE TABLE IF NOT EXISTS " + DYNAMIC_COMPOSITE + "." + DYNAMIC_COMPOSITE + " (\n" +
-        "\t\"key\" ascii,\n" +
+        "\tkey ascii,\n" +
         "\tcols 'org.apache.cassandra.db.marshal.DynamicCompositeType(a=>org.apache.cassandra.db.marshal.BytesType,b=>org.apache.cassandra.db.marshal.BytesType,c=>org.apache.cassandra.db.marshal.BytesType)',\n" +
         "\tval ascii,\n" +
-        "\tPRIMARY KEY (\"key\", cols))\n" +
+        "\tPRIMARY KEY (key, cols))\n" +
         "\tWITH ID = " + cfs.metadata.cfId + "\n" +
         "\tAND COMPACT STORAGE"));
     }

File: src/java/org/apache/cassandra/cql3/SingleColumnRelation.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.cassandra.cql3.restrictions.SingleColumnRestriction;
 import org.apache.cassandra.cql3.statements.Bound;
 import org.apache.cassandra.db.marshal.CollectionType;
+import org.apache.cassandra.db.marshal.DurationType;
 import org.apache.cassandra.db.marshal.ListType;
 import org.apache.cassandra.db.marshal.MapType;
 import org.apache.cassandra.exceptions.InvalidRequestException;
@@ -197,6 +198,8 @@ protected Restriction newSliceRestriction(CFMetaData cfm,
                                               boolean inclusive) throws InvalidRequestException
     {
         ColumnDefinition columnDef = entity.prepare(cfm);
+        checkFalse(columnDef.type instanceof DurationType, "Slice restriction are not supported on duration columns");
+
         Term term = toTerm(toReceivers(columnDef), value, cfm.ksName, boundNames);
         return new SingleColumnRestriction.SliceRestriction(columnDef, bound, inclusive, term);
     }

File: test/unit/org/apache/cassandra/cql3/CQLTester.java
Patch:
@@ -1528,6 +1528,9 @@ private static AbstractType typeFor(Object value)
         if (value instanceof Float)
             return FloatType.instance;
 
+        if (value instanceof Duration)
+            return DurationType.instance;
+
         if (value instanceof Double)
             return DoubleType.instance;
 

File: src/java/org/apache/cassandra/cql3/SingleColumnRelation.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.cassandra.cql3.restrictions.SingleColumnRestriction;
 import org.apache.cassandra.cql3.statements.Bound;
 import org.apache.cassandra.db.marshal.CollectionType;
+import org.apache.cassandra.db.marshal.DurationType;
 import org.apache.cassandra.db.marshal.ListType;
 import org.apache.cassandra.db.marshal.MapType;
 import org.apache.cassandra.exceptions.InvalidRequestException;
@@ -197,6 +198,8 @@ protected Restriction newSliceRestriction(CFMetaData cfm,
                                               boolean inclusive) throws InvalidRequestException
     {
         ColumnDefinition columnDef = entity.prepare(cfm);
+        checkFalse(columnDef.type instanceof DurationType, "Slice restriction are not supported on duration columns");
+
         Term term = toTerm(toReceivers(columnDef), value, cfm.ksName, boundNames);
         return new SingleColumnRestriction.SliceRestriction(columnDef, bound, inclusive, term);
     }

File: test/unit/org/apache/cassandra/cql3/CQLTester.java
Patch:
@@ -1517,6 +1517,9 @@ private static AbstractType typeFor(Object value)
         if (value instanceof Float)
             return FloatType.instance;
 
+        if (value instanceof Duration)
+            return DurationType.instance;
+
         if (value instanceof Double)
             return DoubleType.instance;
 

File: src/java/org/apache/cassandra/dht/RandomPartitioner.java
Patch:
@@ -93,7 +93,7 @@ public BigIntegerToken getRandomToken()
 
     public BigIntegerToken getRandomToken(Random random)
     {
-        BigInteger token = FBUtilities.hashToBigInteger(GuidGenerator.guidAsBytes(random));
+        BigInteger token = FBUtilities.hashToBigInteger(GuidGenerator.guidAsBytes(random, 0));
         if ( token.signum() == -1 )
             token = token.multiply(BigInteger.valueOf(-1L));
         return new BigIntegerToken(token);

File: src/java/org/apache/cassandra/utils/GuidGenerator.java
Patch:
@@ -76,10 +76,9 @@ public static String guidToString(byte[] bytes)
         return convertToStandardFormat( sb.toString() );
     }
 
-    public static ByteBuffer guidAsBytes(Random random)
+    public static ByteBuffer guidAsBytes(Random random, long time)
     {
         StringBuilder sbValueBeforeMD5 = new StringBuilder();
-        long time = System.currentTimeMillis();
         long rand = 0;
         rand = random.nextLong();
         sbValueBeforeMD5.append(s_id)
@@ -94,7 +93,7 @@ public static ByteBuffer guidAsBytes(Random random)
 
     public static ByteBuffer guidAsBytes()
     {
-        return guidAsBytes(myRand);
+        return guidAsBytes(myRand, System.currentTimeMillis());
     }
 
     /*

File: src/java/org/apache/cassandra/tools/nodetool/StopDaemon.java
Patch:
@@ -37,6 +37,5 @@ public void execute(NodeProbe probe)
             JVMStabilityInspector.inspectThrowable(e);
             // ignored
         }
-        System.out.println("Cassandra has shutdown.");
     }
-}
\ No newline at end of file
+}

File: test/unit/org/apache/cassandra/cql3/validation/operations/AggregationTest.java
Patch:
@@ -1381,14 +1381,14 @@ public void testWrongKeyspace() throws Throwable
                              "FINALFUNC " + shortFunctionName(fFinal) + ' ' +
                              "INITCOND 1");
 
-        assertInvalidMessage("missing EOF", // specifying a function using "keyspace.functionname" is a syntax error
+        assertInvalidMessage("expecting EOF", // specifying a function using "keyspace.functionname" is a syntax error
                              "CREATE AGGREGATE " + KEYSPACE_PER_TEST + ".test_wrong_ks(int) " +
                              "SFUNC " + shortFunctionName(fState) + ' ' +
                              "STYPE " + type + " " +
                              "FINALFUNC " + fFinalWrong + ' ' +
                              "INITCOND 1");
 
-        assertInvalidMessage("missing EOF", // specifying a function using "keyspace.functionname" is a syntax error
+        assertInvalidMessage("expecting EOF", // specifying a function using "keyspace.functionname" is a syntax error
                              "CREATE AGGREGATE " + KEYSPACE_PER_TEST + ".test_wrong_ks(int) " +
                              "SFUNC " + shortFunctionName(fState) + ' ' +
                              "STYPE " + type + ' ' +

File: tools/stress/src/org/apache/cassandra/stress/generate/values/UUIDs.java
Patch:
@@ -34,6 +34,7 @@ public UUIDs(String name, GeneratorConfig config)
     @Override
     public UUID generate()
     {
-        return new UUID(identityDistribution.next(), identityDistribution.next());
+        long seed = identityDistribution.next();
+        return new UUID(seed, seed);
     }
 }

File: src/java/org/apache/cassandra/concurrent/DebuggableScheduledThreadPoolExecutor.java
Patch:
@@ -54,7 +54,7 @@ public void rejectedExecution(Runnable task, ThreadPoolExecutor executor)
                 if (task instanceof Future)
                     ((Future) task).cancel(false);
 
-                logger.trace("ScheduledThreadPoolExecutor has shut down as part of C* shutdown");
+                logger.debug("ScheduledThreadPoolExecutor has shut down as part of C* shutdown");
             }
             else
             {

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -769,7 +769,8 @@ public void shutdown()
         assert !StageManager.getStage(Stage.MUTATION).isShutdown();
 
         // the important part
-        callbacks.shutdownBlocking();
+        if (!callbacks.shutdownBlocking())
+            logger.warn("Failed to wait for messaging service callbacks shutdown");
 
         // attempt to humor tests that try to stop and restart MS
         try

File: src/java/org/apache/cassandra/utils/ExpiringMap.java
Patch:
@@ -105,12 +105,12 @@ public void run()
         service.scheduleWithFixedDelay(runnable, defaultExpiration / 2, defaultExpiration / 2, TimeUnit.MILLISECONDS);
     }
 
-    public void shutdownBlocking()
+    public boolean shutdownBlocking()
     {
         service.shutdown();
         try
         {
-            service.awaitTermination(defaultExpiration * 2, TimeUnit.MILLISECONDS);
+            return service.awaitTermination(defaultExpiration * 2, TimeUnit.MILLISECONDS);
         }
         catch (InterruptedException e)
         {

File: src/java/org/apache/cassandra/db/SystemKeyspace.java
Patch:
@@ -808,7 +808,7 @@ public static synchronized void updateTokens(Collection<Token> tokens)
 
     public static void forceBlockingFlush(String cfname)
     {
-        if (!Boolean.getBoolean("cassandra.unsafesystem"))
+        if (!DatabaseDescriptor.isUnsafeSystem())
             FBUtilities.waitOnFuture(Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(cfname).forceFlush());
     }
 

File: src/java/org/apache/cassandra/db/commitlog/CommitLogReplayer.java
Patch:
@@ -38,6 +38,7 @@
 import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.concurrent.StageManager;
 import org.apache.cassandra.config.CFMetaData;
+import org.apache.cassandra.config.Config;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.config.SchemaConstants;
 import org.apache.cassandra.db.ColumnFamilyStore;
@@ -55,9 +56,9 @@ public class CommitLogReplayer implements CommitLogReadHandler
     public static long MAX_OUTSTANDING_REPLAY_BYTES = Long.getLong("cassandra.commitlog_max_outstanding_replay_bytes", 1024 * 1024 * 64);
     @VisibleForTesting
     public static MutationInitiator mutationInitiator = new MutationInitiator();
-    static final String IGNORE_REPLAY_ERRORS_PROPERTY = "cassandra.commitlog.ignorereplayerrors";
+    static final String IGNORE_REPLAY_ERRORS_PROPERTY = Config.PROPERTY_PREFIX + "commitlog.ignorereplayerrors";
     private static final Logger logger = LoggerFactory.getLogger(CommitLogReplayer.class);
-    private static final int MAX_OUTSTANDING_REPLAY_COUNT = Integer.getInteger("cassandra.commitlog_max_outstanding_replay_count", 1024);
+    private static final int MAX_OUTSTANDING_REPLAY_COUNT = Integer.getInteger(Config.PROPERTY_PREFIX + "commitlog_max_outstanding_replay_count", 1024);
 
     private final Set<Keyspace> keyspacesReplayed;
     private final Queue<Future<Integer>> futures;

File: src/java/org/apache/cassandra/net/IncomingTcpConnection.java
Patch:
@@ -62,7 +62,7 @@ public IncomingTcpConnection(int version, boolean compressed, Socket socket, Set
         this.compressed = compressed;
         this.socket = socket;
         this.group = group;
-        if (DatabaseDescriptor.getInternodeRecvBufferSize() != null)
+        if (DatabaseDescriptor.getInternodeRecvBufferSize() > 0)
         {
             try
             {

File: src/java/org/apache/cassandra/net/OutboundTcpConnection.java
Patch:
@@ -403,7 +403,7 @@ private boolean connect()
                 {
                     socket.setTcpNoDelay(DatabaseDescriptor.getInterDCTcpNoDelay());
                 }
-                if (DatabaseDescriptor.getInternodeSendBufferSize() != null)
+                if (DatabaseDescriptor.getInternodeSendBufferSize() > 0)
                 {
                     try
                     {

File: src/java/org/apache/cassandra/repair/SystemDistributedKeyspace.java
Patch:
@@ -38,6 +38,7 @@
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.config.CFMetaData;
+import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.SchemaConstants;
 import org.apache.cassandra.cql3.QueryProcessor;
 import org.apache.cassandra.cql3.UntypedResultSet;
@@ -310,7 +311,7 @@ private static void processSilent(String fmtQry, String... values)
 
     public static void forceBlockingFlush(String table)
     {
-        if (!Boolean.getBoolean("cassandra.unsafesystem"))
+        if (!DatabaseDescriptor.isUnsafeSystem())
             FBUtilities.waitOnFuture(Keyspace.open(SchemaConstants.DISTRIBUTED_KEYSPACE_NAME).getColumnFamilyStore(table).forceFlush());
     }
 

File: src/java/org/apache/cassandra/schema/SchemaKeyspace.java
Patch:
@@ -276,7 +276,7 @@ public static void truncate()
 
     static void flush()
     {
-        if (!Boolean.getBoolean("cassandra.unsafesystem"))
+        if (!DatabaseDescriptor.isUnsafeSystem())
             ALL.forEach(table -> FBUtilities.waitOnFuture(getSchemaCFS(table).forceFlush()));
     }
 

File: src/java/org/apache/cassandra/dht/tokenallocator/TokenAllocation.java
Patch:
@@ -51,15 +51,15 @@ public static Collection<Token> allocateTokens(final TokenMetadata tokenMetadata
                                                    final InetAddress endpoint,
                                                    int numTokens)
     {
-        StrategyAdapter strategy = getStrategy(tokenMetadata, rs, endpoint);
+        TokenMetadata tokenMetadataCopy = tokenMetadata.cloneOnlyTokenMap();
+        StrategyAdapter strategy = getStrategy(tokenMetadataCopy, rs, endpoint);
         Collection<Token> tokens = create(tokenMetadata, strategy).addUnit(endpoint, numTokens);
         tokens = adjustForCrossDatacenterClashes(tokenMetadata, strategy, tokens);
 
         if (logger.isWarnEnabled())
         {
             logger.warn("Selected tokens {}", tokens);
-            SummaryStatistics os = replicatedOwnershipStats(tokenMetadata, rs, endpoint);
-            TokenMetadata tokenMetadataCopy = tokenMetadata.cloneOnlyTokenMap();
+            SummaryStatistics os = replicatedOwnershipStats(tokenMetadataCopy, rs, endpoint);
             tokenMetadataCopy.updateNormalTokens(tokens, endpoint);
             SummaryStatistics ns = replicatedOwnershipStats(tokenMetadataCopy, rs, endpoint);
             logger.warn("Replicated node load in datacentre before allocation " + statToString(os));

File: test/unit/org/apache/cassandra/dht/BootStrapperTest.java
Patch:
@@ -178,7 +178,7 @@ public void testAllocateTokensNetworkStrategy(int rackCount, int replicas) throw
             String ks = "BootStrapperTestNTSKeyspace" + rackCount + replicas;
             String dc = "1";
             SchemaLoader.createKeyspace(ks, KeyspaceParams.nts(dc, replicas, "15", 15), SchemaLoader.standardCFMD(ks, "Standard1"));
-            TokenMetadata tm = new TokenMetadata();
+            TokenMetadata tm = StorageService.instance.getTokenMetadata();
             tm.clearUnsafe();
             for (int i = 0; i < rackCount; ++i)
                 generateFakeEndpoints(tm, 10, vn, dc, Integer.toString(i));
@@ -222,11 +222,11 @@ public void testAllocateTokensNetworkStrategyOneRackOneReplica() throws UnknownH
 
     private void allocateTokensForNode(int vn, String ks, TokenMetadata tm, InetAddress addr)
     {
-        SummaryStatistics os = TokenAllocation.replicatedOwnershipStats(tm, Keyspace.open(ks).getReplicationStrategy(), addr);
+        SummaryStatistics os = TokenAllocation.replicatedOwnershipStats(tm.cloneOnlyTokenMap(), Keyspace.open(ks).getReplicationStrategy(), addr);
         Collection<Token> tokens = BootStrapper.allocateTokens(tm, addr, ks, vn);
         assertEquals(vn, tokens.size());
         tm.updateNormalTokens(tokens, addr);
-        SummaryStatistics ns = TokenAllocation.replicatedOwnershipStats(tm, Keyspace.open(ks).getReplicationStrategy(), addr);
+        SummaryStatistics ns = TokenAllocation.replicatedOwnershipStats(tm.cloneOnlyTokenMap(), Keyspace.open(ks).getReplicationStrategy(), addr);
         verifyImprovement(os, ns);
     }
 

File: src/java/org/apache/cassandra/db/Slices.java
Patch:
@@ -745,7 +745,7 @@ public static ComponentOfSlice fromSlice(int component, Slice slice)
 
             public boolean isEQ()
             {
-                return startValue.equals(endValue);
+                return Objects.equals(startValue, endValue);
             }
         }
     }

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -44,7 +44,6 @@
 import org.apache.cassandra.config.Config.CommitLogSync;
 import org.apache.cassandra.config.Config.RequestSchedulerId;
 import org.apache.cassandra.dht.IPartitioner;
-import org.apache.cassandra.dht.Murmur3Partitioner;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.io.FSWriteError;
 import org.apache.cassandra.io.util.DiskOptimizationStrategy;
@@ -220,7 +219,6 @@ public static void clientInitialization(boolean failIfDaemonOrTool)
         Config.setClientMode(true);
         conf = new Config();
         diskOptimizationStrategy = new SpinningDiskOptimizationStrategy();
-        partitioner = Murmur3Partitioner.instance;
     }
 
     public static boolean isClientInitialized()

File: src/java/org/apache/cassandra/io/sstable/CQLSSTableWriter.java
Patch:
@@ -53,7 +53,6 @@
 import org.apache.cassandra.exceptions.RequestValidationException;
 import org.apache.cassandra.exceptions.SyntaxException;
 import org.apache.cassandra.io.sstable.format.SSTableFormat;
-import org.apache.cassandra.io.util.SpinningDiskOptimizationStrategy;
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.schema.KeyspaceParams;
 import org.apache.cassandra.schema.Types;
@@ -106,6 +105,9 @@ public class CQLSSTableWriter implements Closeable
     static
     {
         DatabaseDescriptor.clientInitialization(false);
+        // Partitioner is not set in client mode.
+        if (DatabaseDescriptor.getPartitioner() == null)
+            DatabaseDescriptor.setPartitionerUnsafe(Murmur3Partitioner.instance);
     }
 
     private final AbstractSSTableSimpleWriter writer;

File: test/microbench/org/apache/cassandra/test/microbench/MutationBench.java
Patch:
@@ -65,6 +65,9 @@ public class MutationBench
     static
     {
         DatabaseDescriptor.clientInitialization(false);
+        // Partitioner is not set in client mode.
+        if (DatabaseDescriptor.getPartitioner() == null)
+            DatabaseDescriptor.setPartitionerUnsafe(Murmur3Partitioner.instance);
     }
 
     static String keyspace = "keyspace1";

File: test/unit/org/apache/cassandra/config/DatabaseDescriptorRefTest.java
Patch:
@@ -99,6 +99,7 @@ public class DatabaseDescriptorRefTest
     "org.apache.cassandra.io.util.DataOutputStreamPlus",
     "org.apache.cassandra.io.util.DataOutputPlus",
     "org.apache.cassandra.io.util.DiskOptimizationStrategy",
+    "org.apache.cassandra.io.util.SpinningDiskOptimizationStrategy",
     "org.apache.cassandra.locator.SimpleSeedProvider",
     "org.apache.cassandra.locator.SeedProvider",
     "org.apache.cassandra.net.BackPressureStrategy",

File: tools/stress/src/org/apache/cassandra/io/sstable/StressCQLSSTableWriter.java
Patch:
@@ -99,6 +99,9 @@ public class StressCQLSSTableWriter implements Closeable
     static
     {
         DatabaseDescriptor.clientInitialization(false);
+        // Partitioner is not set in client mode.
+        if (DatabaseDescriptor.getPartitioner() == null)
+            DatabaseDescriptor.setPartitionerUnsafe(Murmur3Partitioner.instance);
     }
 
     private final AbstractSSTableSimpleWriter writer;

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -1112,8 +1112,8 @@ private void doValidationCompaction(ColumnFamilyStore cfs, Validator validator)
             {
                 numPartitions += sstable.estimatedKeysForRanges(singleton(validator.desc.range));
             }
-            // determine tree depth from number of partitions, but cap at 20 to prevent large tree.
-            int depth = numPartitions > 0 ? (int) Math.min(Math.floor(Math.log(numPartitions)), 20) : 0;
+            // determine tree depth from number of partitions, but cap at 20 to prevent large tree (CASSANDRA-5263)
+            int depth = numPartitions > 0 ? (int) Math.min(Math.ceil(Math.log(numPartitions) / Math.log(2)), 20) : 0;
             MerkleTree tree = new MerkleTree(cfs.partitioner, validator.desc.range, MerkleTree.RECOMMENDED_DEPTH, (int) Math.pow(2, depth));
 
             long start = System.nanoTime();

File: test/unit/org/apache/cassandra/db/compaction/CompactionsTest.java
Patch:
@@ -125,7 +125,7 @@ public ColumnFamilyStore testSingleSSTableCompaction(String strategyClassName) t
         return store;
     }
 
-    private long populate(String ks, String cf, int startRowKey, int endRowKey, int ttl)
+    public static long populate(String ks, String cf, int startRowKey, int endRowKey, int ttl)
     {
         long timestamp = System.currentTimeMillis();
         for (int i = startRowKey; i <= endRowKey; i++)

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -1865,8 +1865,8 @@ public void stopCompactionById(String compactionId)
 
     public void setConcurrentCompactors(int value)
     {
-        executor.setCorePoolSize(value);
         executor.setMaximumPoolSize(value);
+        executor.setCorePoolSize(value);
     }
 
     public int getCoreCompactorThreads()

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -1446,7 +1446,7 @@ public void addLocalApplicationStates(List<Pair<ApplicationState, VersionedValue
     public void stop()
     {
         EndpointState mystate = endpointStateMap.get(FBUtilities.getBroadcastAddress());
-        if (mystate != null && !isSilentShutdownState(mystate))
+        if (mystate != null && !isSilentShutdownState(mystate) && StorageService.instance.isJoined())
         {
             logger.info("Announcing shutdown");
             addLocalApplicationState(ApplicationState.STATUS, StorageService.instance.valueFactory.shutdown(true));
@@ -1456,7 +1456,7 @@ public void stop()
             Uninterruptibles.sleepUninterruptibly(Integer.getInteger("cassandra.shutdown_announce_in_ms", 2000), TimeUnit.MILLISECONDS);
         }
         else
-            logger.warn("No local state or state is in silent shutdown, not announcing shutdown");
+            logger.warn("No local state, state is in silent shutdown, or node hasn't joined, not announcing shutdown");
         if (scheduledGossipTask != null)
             scheduledGossipTask.cancel(false);
     }

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -44,6 +44,7 @@
 import org.apache.cassandra.config.Config.CommitLogSync;
 import org.apache.cassandra.config.Config.RequestSchedulerId;
 import org.apache.cassandra.dht.IPartitioner;
+import org.apache.cassandra.dht.Murmur3Partitioner;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.io.FSWriteError;
 import org.apache.cassandra.io.util.DiskOptimizationStrategy;
@@ -218,6 +219,8 @@ public static void clientInitialization(boolean failIfDaemonOrTool)
 
         Config.setClientMode(true);
         conf = new Config();
+        diskOptimizationStrategy = new SpinningDiskOptimizationStrategy();
+        partitioner = Murmur3Partitioner.instance;
     }
 
     public static boolean isClientInitialized()

File: src/java/org/apache/cassandra/io/sstable/CQLSSTableWriter.java
Patch:
@@ -53,6 +53,7 @@
 import org.apache.cassandra.exceptions.RequestValidationException;
 import org.apache.cassandra.exceptions.SyntaxException;
 import org.apache.cassandra.io.sstable.format.SSTableFormat;
+import org.apache.cassandra.io.util.SpinningDiskOptimizationStrategy;
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.schema.KeyspaceParams;
 import org.apache.cassandra.schema.Types;
@@ -105,9 +106,6 @@ public class CQLSSTableWriter implements Closeable
     static
     {
         DatabaseDescriptor.clientInitialization(false);
-        // Partitioner is not set in client mode.
-        if (DatabaseDescriptor.getPartitioner() == null)
-            DatabaseDescriptor.setPartitionerUnsafe(Murmur3Partitioner.instance);
     }
 
     private final AbstractSSTableSimpleWriter writer;

File: test/microbench/org/apache/cassandra/test/microbench/MutationBench.java
Patch:
@@ -65,9 +65,6 @@ public class MutationBench
     static
     {
         DatabaseDescriptor.clientInitialization(false);
-        // Partitioner is not set in client mode.
-        if (DatabaseDescriptor.getPartitioner() == null)
-            DatabaseDescriptor.setPartitionerUnsafe(Murmur3Partitioner.instance);
     }
 
     static String keyspace = "keyspace1";

File: tools/stress/src/org/apache/cassandra/io/sstable/StressCQLSSTableWriter.java
Patch:
@@ -99,9 +99,6 @@ public class StressCQLSSTableWriter implements Closeable
     static
     {
         DatabaseDescriptor.clientInitialization(false);
-        // Partitioner is not set in client mode.
-        if (DatabaseDescriptor.getPartitioner() == null)
-            DatabaseDescriptor.setPartitionerUnsafe(Murmur3Partitioner.instance);
     }
 
     private final AbstractSSTableSimpleWriter writer;

File: tools/stress/src/org/apache/cassandra/stress/Stress.java
Patch:
@@ -23,9 +23,9 @@
 
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.stress.settings.StressSettings;
+import org.apache.cassandra.stress.util.MultiResultLogger;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.WindowsTimer;
-import org.apache.cassandra.stress.util.MultiPrintStream;
 
 public final class Stress
 {
@@ -88,7 +88,7 @@ private static int run(String[] arguments)
                 return 1;
             }
 
-            MultiPrintStream logout = settings.log.getOutput();
+            MultiResultLogger logout = settings.log.getOutput();
 
             if (! settings.log.noSettings)
             {

File: tools/stress/src/org/apache/cassandra/stress/StressGraph.java
Patch:
@@ -201,7 +201,8 @@ else if (mode == ReadingMode.AGGREGATES)
                     {
                         continue;
                     }
-                    json.put(parts[0].trim(), parts[1].trim());
+                    // the graphing js expects lower case names
+                    json.put(parts[0].trim().toLowerCase(), parts[1].trim());
                 }
                 else if (mode == ReadingMode.NEXTITERATION)
                 {
@@ -227,7 +228,7 @@ else if (mode == ReadingMode.NEXTITERATION)
         {
             throw new RuntimeException("Couldn't read from temporary stress log file");
         }
-        stats.add(json);
+        if (json.size() != 0) stats.add(json);
         return stats;
     }
 

File: tools/stress/src/org/apache/cassandra/stress/StressProfile.java
Patch:
@@ -53,7 +53,7 @@
 import org.apache.cassandra.stress.report.Timer;
 import org.apache.cassandra.stress.settings.*;
 import org.apache.cassandra.stress.util.JavaDriverClient;
-import org.apache.cassandra.stress.util.MultiPrintStream;
+import org.apache.cassandra.stress.util.ResultLogger;
 import org.apache.cassandra.stress.util.ThriftClient;
 import org.apache.cassandra.thrift.Compression;
 import org.apache.cassandra.thrift.ThriftConversion;
@@ -99,7 +99,7 @@ public class StressProfile implements Serializable
     private static final Pattern lowercaseAlphanumeric = Pattern.compile("[a-z0-9_]+");
 
 
-    public void printSettings(MultiPrintStream out, StressSettings stressSettings)
+    public void printSettings(ResultLogger out, StressSettings stressSettings)
     {
         out.printf("  Keyspace Name: %s%n", keyspaceName);
         out.printf("  Keyspace CQL: %n***%n%s***%n%n", keyspaceCql);

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsColumn.java
Patch:
@@ -33,7 +33,7 @@
 import org.apache.cassandra.stress.generate.Distribution;
 import org.apache.cassandra.stress.generate.DistributionFactory;
 import org.apache.cassandra.stress.generate.DistributionFixed;
-import org.apache.cassandra.stress.util.MultiPrintStream;
+import org.apache.cassandra.stress.util.ResultLogger;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
 /**
@@ -178,7 +178,7 @@ public List<? extends Option> options()
     }
 
     // CLI Utility Methods
-    public void printSettings(MultiPrintStream out)
+    public void printSettings(ResultLogger out)
     {
         out.printf("  Max Columns Per Key: %d%n",maxColumnsPerKey);
         out.printf("  Column Names: %s%n",namestrs);

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsCommand.java
Patch:
@@ -31,7 +31,7 @@
 
 import org.apache.cassandra.stress.operations.OpDistributionFactory;
 import org.apache.cassandra.stress.util.JavaDriverClient;
-import org.apache.cassandra.stress.util.MultiPrintStream;
+import org.apache.cassandra.stress.util.ResultLogger;
 import org.apache.cassandra.thrift.ConsistencyLevel;
 
 // Generic command settings - common to read/write/etc
@@ -173,7 +173,7 @@ protected void truncateTables(StressSettings settings, String ks, String ... tab
 
     // CLI Utility Methods
 
-    public void printSettings(MultiPrintStream out)
+    public void printSettings(ResultLogger out)
     {
         out.printf("  Type: %s%n", type.toString().toLowerCase());
         out.printf("  Count: %,d%n", count);

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsCommandPreDefined.java
Patch:
@@ -39,7 +39,7 @@
 import org.apache.cassandra.stress.operations.OpDistributionFactory;
 import org.apache.cassandra.stress.operations.predefined.PredefinedOperation;
 import org.apache.cassandra.stress.report.Timer;
-import org.apache.cassandra.stress.util.MultiPrintStream;
+import org.apache.cassandra.stress.util.ResultLogger;
 
 // Settings unique to the mixed command type
 public class SettingsCommandPreDefined extends SettingsCommand
@@ -122,7 +122,7 @@ public void truncateTables(StressSettings settings)
 
     // CLI utility methods
 
-    public void printSettings(MultiPrintStream out)
+    public void printSettings(ResultLogger out)
     {
         super.printSettings(out);
         out.printf("  Key Size (bytes): %d%n", keySize);

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsCommandPreDefinedMixed.java
Patch:
@@ -31,7 +31,7 @@
 import org.apache.cassandra.stress.operations.SampledOpDistributionFactory;
 import org.apache.cassandra.stress.operations.predefined.PredefinedOperation;
 import org.apache.cassandra.stress.report.Timer;
-import org.apache.cassandra.stress.util.MultiPrintStream;
+import org.apache.cassandra.stress.util.ResultLogger;
 
 // Settings unique to the mixed command type
 public class SettingsCommandPreDefinedMixed extends SettingsCommandPreDefined
@@ -112,7 +112,7 @@ public List<? extends Option> options()
 
     }
 
-    public void printSettings(MultiPrintStream out)
+    public void printSettings(ResultLogger out)
     {
         super.printSettings(out);
         out.printf("  Command Ratios: %s%n", ratios);

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsCommandUser.java
Patch:
@@ -37,7 +37,7 @@
 import org.apache.cassandra.stress.operations.OpDistributionFactory;
 import org.apache.cassandra.stress.operations.SampledOpDistributionFactory;
 import org.apache.cassandra.stress.report.Timer;
-import org.apache.cassandra.stress.util.MultiPrintStream;
+import org.apache.cassandra.stress.util.ResultLogger;
 
 // Settings unique to the mixed command type
 public class SettingsCommandUser extends SettingsCommand
@@ -125,7 +125,7 @@ public List<? extends Option> options()
 
     // CLI utility methods
 
-    public void printSettings(MultiPrintStream out)
+    public void printSettings(ResultLogger out)
     {
         super.printSettings(out);
         out.printf("  Command Ratios: %s%n", ratios);

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsErrors.java
Patch:
@@ -26,7 +26,7 @@
 import java.util.List;
 import java.util.Map;
 
-import org.apache.cassandra.stress.util.MultiPrintStream;
+import org.apache.cassandra.stress.util.ResultLogger;
 
 public class SettingsErrors implements Serializable
 {
@@ -55,7 +55,7 @@ public List<? extends Option> options()
     }
 
     // CLI Utility Methods
-    public void printSettings(MultiPrintStream out)
+    public void printSettings(ResultLogger out)
     {
         out.printf("  Ignore: %b%n", ignore);
         out.printf("  Tries: %d%n", tries);

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsGraph.java
Patch:
@@ -30,7 +30,7 @@
 import java.util.List;
 import java.util.Map;
 
-import org.apache.cassandra.stress.util.MultiPrintStream;
+import org.apache.cassandra.stress.util.ResultLogger;
 
 public class SettingsGraph implements Serializable
 {
@@ -90,7 +90,7 @@ public List<? extends Option> options()
     }
 
     // CLI Utility Methods
-    public void printSettings(MultiPrintStream out)
+    public void printSettings(ResultLogger out)
     {
         out.println("  File: " + file);
         out.println("  Revision: " + revision);

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsInsert.java
Patch:
@@ -29,7 +29,7 @@
 import com.datastax.driver.core.BatchStatement;
 import org.apache.cassandra.stress.generate.DistributionFactory;
 import org.apache.cassandra.stress.generate.RatioDistributionFactory;
-import org.apache.cassandra.stress.util.MultiPrintStream;
+import org.apache.cassandra.stress.util.ResultLogger;
 
 public class SettingsInsert implements Serializable
 {
@@ -73,7 +73,7 @@ public List<? extends Option> options()
     }
 
     // CLI Utility Methods
-    public void printSettings(MultiPrintStream out)
+    public void printSettings(ResultLogger out)
     {
 
         if (revisit != null)

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsMode.java
Patch:
@@ -30,7 +30,7 @@
 import com.datastax.driver.core.PlainTextAuthProvider;
 import com.datastax.driver.core.ProtocolOptions;
 import com.datastax.driver.core.ProtocolVersion;
-import org.apache.cassandra.stress.util.MultiPrintStream;
+import org.apache.cassandra.stress.util.ResultLogger;
 
 public class SettingsMode implements Serializable
 {
@@ -207,7 +207,7 @@ public List<? extends Option> options()
     }
 
     // CLI Utility Methods
-    public void printSettings(MultiPrintStream out)
+    public void printSettings(ResultLogger out)
     {
         out.printf("  API: %s%n", api);
         out.printf("  Connection Style: %s%n", style);

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsNode.java
Patch:
@@ -28,7 +28,7 @@
 import java.util.*;
 
 import com.datastax.driver.core.Host;
-import org.apache.cassandra.stress.util.MultiPrintStream;
+import org.apache.cassandra.stress.util.ResultLogger;
 
 public class SettingsNode implements Serializable
 {
@@ -149,7 +149,7 @@ public List<? extends Option> options()
     }
 
     // CLI Utility Methods
-    public void printSettings(MultiPrintStream out)
+    public void printSettings(ResultLogger out)
     {
         out.println("  Nodes: " + nodes);
         out.println("  Is White List: " + isWhiteList);

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsPopulation.java
Patch:
@@ -30,7 +30,7 @@
 
 import org.apache.cassandra.stress.generate.DistributionFactory;
 import org.apache.cassandra.stress.generate.PartitionGenerator;
-import org.apache.cassandra.stress.util.MultiPrintStream;
+import org.apache.cassandra.stress.util.ResultLogger;
 
 public class SettingsPopulation implements Serializable
 {
@@ -127,7 +127,7 @@ public List<? extends Option> options()
 
     // CLI Utility Methods
 
-    public void printSettings(MultiPrintStream out)
+    public void printSettings(ResultLogger out)
     {
         if (distribution != null)
         {

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsPort.java
Patch:
@@ -26,7 +26,7 @@
 import java.util.List;
 import java.util.Map;
 
-import org.apache.cassandra.stress.util.MultiPrintStream;
+import org.apache.cassandra.stress.util.ResultLogger;
 
 public class SettingsPort implements Serializable
 {
@@ -58,7 +58,7 @@ public List<? extends Option> options()
     }
 
     // CLI Utility Methods
-    public void printSettings(MultiPrintStream out)
+    public void printSettings(ResultLogger out)
     {
         out.printf("  Native Port: %d%n", nativePort);
         out.printf("  Thrift Port: %d%n", thriftPort);

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsSchema.java
Patch:
@@ -27,7 +27,7 @@
 
 import com.datastax.driver.core.exceptions.AlreadyExistsException;
 import org.apache.cassandra.stress.util.JavaDriverClient;
-import org.apache.cassandra.stress.util.MultiPrintStream;
+import org.apache.cassandra.stress.util.ResultLogger;
 import org.apache.cassandra.thrift.*;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
@@ -300,7 +300,7 @@ public List<? extends Option> options()
     }
 
     // CLI Utility Methods
-    public void printSettings(MultiPrintStream out)
+    public void printSettings(ResultLogger out)
     {
         out.println("  Keyspace: " + keyspace);
         out.println("  Replication Strategy: " + replicationStrategy);
@@ -309,7 +309,6 @@ public void printSettings(MultiPrintStream out)
         out.println("  Table Compression: " + compression);
         out.println("  Table Compaction Strategy: " + compactionStrategy);
         out.println("  Table Compaction Strategy Options: " + compactionStrategyOptions);
-
     }
 
 

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsTokenRange.java
Patch:
@@ -25,7 +25,7 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.primitives.Ints;
 
-import org.apache.cassandra.stress.util.MultiPrintStream;
+import org.apache.cassandra.stress.util.ResultLogger;
 
 public class SettingsTokenRange implements Serializable
 {
@@ -70,7 +70,7 @@ public static SettingsTokenRange get(Map<String, String[]> clArgs)
         return new SettingsTokenRange(options);
     }
 
-    public void printSettings(MultiPrintStream out)
+    public void printSettings(ResultLogger out)
     {
         out.printf("  Wrap: %b%n", wrap);
         out.printf("  Split Factor: %d%n", splitFactor);

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsTransport.java
Patch:
@@ -28,7 +28,7 @@
 import java.util.Map;
 
 import org.apache.cassandra.config.EncryptionOptions;
-import org.apache.cassandra.stress.util.MultiPrintStream;
+import org.apache.cassandra.stress.util.ResultLogger;
 import org.apache.cassandra.thrift.ITransportFactory;
 import org.apache.cassandra.thrift.SSLTransportFactory;
 import org.apache.cassandra.thrift.TFramedTransportFactory;
@@ -146,7 +146,7 @@ public List<? extends Option> options()
     }
 
     // CLI Utility Methods
-    public void printSettings(MultiPrintStream out)
+    public void printSettings(ResultLogger out)
     {
         out.println("  " + options.getOptionAsString());
     }

File: tools/stress/src/org/apache/cassandra/stress/settings/StressSettings.java
Patch:
@@ -22,13 +22,13 @@
 
 
 import java.io.Serializable;
-import org.apache.cassandra.stress.util.MultiPrintStream;
 import java.util.*;
 
 import com.datastax.driver.core.Metadata;
 import com.google.common.collect.ImmutableMap;
 import org.apache.cassandra.config.EncryptionOptions;
 import org.apache.cassandra.stress.util.JavaDriverClient;
+import org.apache.cassandra.stress.util.ResultLogger;
 import org.apache.cassandra.stress.util.SimpleThriftClient;
 import org.apache.cassandra.stress.util.SmartThriftClient;
 import org.apache.cassandra.stress.util.ThriftClient;
@@ -338,7 +338,7 @@ public static void printHelp()
         SettingsMisc.printHelp();
     }
 
-    public void printSettings(MultiPrintStream out)
+    public void printSettings(ResultLogger out)
     {
         out.println("******************** Stress Settings ********************");
         // done

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -2283,7 +2283,7 @@ else if (Gossiper.instance.compareEndpointStartup(endpoint, currentOwner) > 0)
             }
             else
             {
-                logger.info("Nodes {} and {} have the same token {}.  Ignoring %s",
+                logger.info("Nodes {} and {} have the same token {}.  Ignoring {}",
                             endpoint,
                             currentOwner,
                             token,

File: src/java/org/apache/cassandra/io/sstable/SSTableSimpleUnsortedWriter.java
Patch:
@@ -27,7 +27,7 @@
 
 import com.google.common.base.Throwables;
 
-import com.datastax.shaded.netty.util.concurrent.FastThreadLocalThread;
+import io.netty.util.concurrent.FastThreadLocalThread;
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.rows.Row;

File: tools/stress/src/org/apache/cassandra/stress/StressGraph.java
Patch:
@@ -35,7 +35,7 @@
 
 import com.google.common.io.ByteStreams;
 import org.apache.commons.lang3.StringUtils;
-
+import org.apache.cassandra.stress.report.StressMetrics;
 import org.apache.cassandra.stress.settings.StressSettings;
 import org.json.simple.JSONArray;
 import org.json.simple.JSONObject;

File: tools/stress/src/org/apache/cassandra/stress/StressProfile.java
Patch:
@@ -50,11 +50,11 @@
 import org.apache.cassandra.stress.operations.userdefined.SchemaInsert;
 import org.apache.cassandra.stress.operations.userdefined.SchemaQuery;
 import org.apache.cassandra.stress.operations.userdefined.ValidatingSchemaQuery;
+import org.apache.cassandra.stress.report.Timer;
 import org.apache.cassandra.stress.settings.*;
 import org.apache.cassandra.stress.util.JavaDriverClient;
 import org.apache.cassandra.stress.util.MultiPrintStream;
 import org.apache.cassandra.stress.util.ThriftClient;
-import org.apache.cassandra.stress.util.Timer;
 import org.apache.cassandra.thrift.Compression;
 import org.apache.cassandra.thrift.ThriftConversion;
 import org.apache.thrift.TException;

File: tools/stress/src/org/apache/cassandra/stress/operations/OpDistribution.java
Patch:
@@ -25,8 +25,5 @@
 
 public interface OpDistribution
 {
-
     Operation next();
-
-    public void closeTimers();
 }

File: tools/stress/src/org/apache/cassandra/stress/operations/OpDistributionFactory.java
Patch:
@@ -21,11 +21,11 @@
  */
 
 
-import org.apache.cassandra.stress.util.Timing;
+import org.apache.cassandra.stress.StressAction.MeasurementSink;
 
 public interface OpDistributionFactory
 {
-    public OpDistribution get(Timing timing, boolean isWarmup);
+    public OpDistribution get(boolean isWarmup, MeasurementSink sink);
     public String desc();
     Iterable<OpDistributionFactory> each();
 }

File: tools/stress/src/org/apache/cassandra/stress/operations/PartitionOperation.java
Patch:
@@ -29,9 +29,9 @@
 import org.apache.cassandra.stress.generate.RatioDistribution;
 import org.apache.cassandra.stress.generate.Seed;
 import org.apache.cassandra.stress.generate.SeedManager;
+import org.apache.cassandra.stress.report.Timer;
 import org.apache.cassandra.stress.settings.OptionRatioDistribution;
 import org.apache.cassandra.stress.settings.StressSettings;
-import org.apache.cassandra.stress.util.Timer;
 
 public abstract class PartitionOperation extends Operation
 {

File: tools/stress/src/org/apache/cassandra/stress/operations/predefined/CqlCounterAdder.java
Patch:
@@ -29,9 +29,9 @@
 import org.apache.cassandra.stress.generate.DistributionFactory;
 import org.apache.cassandra.stress.generate.PartitionGenerator;
 import org.apache.cassandra.stress.generate.SeedManager;
+import org.apache.cassandra.stress.report.Timer;
 import org.apache.cassandra.stress.settings.Command;
 import org.apache.cassandra.stress.settings.StressSettings;
-import org.apache.cassandra.stress.util.Timer;
 
 public class CqlCounterAdder extends CqlOperation<Integer>
 {

File: tools/stress/src/org/apache/cassandra/stress/operations/predefined/CqlCounterGetter.java
Patch:
@@ -27,9 +27,9 @@
 
 import org.apache.cassandra.stress.generate.PartitionGenerator;
 import org.apache.cassandra.stress.generate.SeedManager;
+import org.apache.cassandra.stress.report.Timer;
 import org.apache.cassandra.stress.settings.Command;
 import org.apache.cassandra.stress.settings.StressSettings;
-import org.apache.cassandra.stress.util.Timer;
 
 public class CqlCounterGetter extends CqlOperation<Integer>
 {

File: tools/stress/src/org/apache/cassandra/stress/operations/predefined/CqlInserter.java
Patch:
@@ -27,9 +27,9 @@
 
 import org.apache.cassandra.stress.generate.PartitionGenerator;
 import org.apache.cassandra.stress.generate.SeedManager;
+import org.apache.cassandra.stress.report.Timer;
 import org.apache.cassandra.stress.settings.Command;
 import org.apache.cassandra.stress.settings.StressSettings;
-import org.apache.cassandra.stress.util.Timer;
 
 public class CqlInserter extends CqlOperation<Integer>
 {

File: tools/stress/src/org/apache/cassandra/stress/operations/predefined/CqlOperation.java
Patch:
@@ -31,12 +31,12 @@
 import com.datastax.driver.core.Row;
 import org.apache.cassandra.stress.generate.PartitionGenerator;
 import org.apache.cassandra.stress.generate.SeedManager;
+import org.apache.cassandra.stress.report.Timer;
 import org.apache.cassandra.stress.settings.Command;
 import org.apache.cassandra.stress.settings.ConnectionStyle;
 import org.apache.cassandra.stress.settings.StressSettings;
 import org.apache.cassandra.stress.util.JavaDriverClient;
 import org.apache.cassandra.stress.util.ThriftClient;
-import org.apache.cassandra.stress.util.Timer;
 import org.apache.cassandra.thrift.Compression;
 import org.apache.cassandra.thrift.CqlResult;
 import org.apache.cassandra.thrift.CqlRow;

File: tools/stress/src/org/apache/cassandra/stress/operations/predefined/CqlReader.java
Patch:
@@ -28,9 +28,9 @@
 
 import org.apache.cassandra.stress.generate.PartitionGenerator;
 import org.apache.cassandra.stress.generate.SeedManager;
+import org.apache.cassandra.stress.report.Timer;
 import org.apache.cassandra.stress.settings.Command;
 import org.apache.cassandra.stress.settings.StressSettings;
-import org.apache.cassandra.stress.util.Timer;
 
 public class CqlReader extends CqlOperation<ByteBuffer[][]>
 {

File: tools/stress/src/org/apache/cassandra/stress/operations/predefined/PredefinedOperation.java
Patch:
@@ -26,10 +26,10 @@
 import org.apache.cassandra.stress.Operation;
 import org.apache.cassandra.stress.generate.*;
 import org.apache.cassandra.stress.operations.PartitionOperation;
+import org.apache.cassandra.stress.report.Timer;
 import org.apache.cassandra.stress.settings.Command;
 import org.apache.cassandra.stress.settings.CqlVersion;
 import org.apache.cassandra.stress.settings.StressSettings;
-import org.apache.cassandra.stress.util.Timer;
 import org.apache.cassandra.thrift.SlicePredicate;
 import org.apache.cassandra.thrift.SliceRange;
 

File: tools/stress/src/org/apache/cassandra/stress/operations/predefined/ThriftCounterAdder.java
Patch:
@@ -28,10 +28,10 @@
 import org.apache.cassandra.stress.generate.DistributionFactory;
 import org.apache.cassandra.stress.generate.PartitionGenerator;
 import org.apache.cassandra.stress.generate.SeedManager;
+import org.apache.cassandra.stress.report.Timer;
 import org.apache.cassandra.stress.settings.Command;
 import org.apache.cassandra.stress.settings.StressSettings;
 import org.apache.cassandra.stress.util.ThriftClient;
-import org.apache.cassandra.stress.util.Timer;
 import org.apache.cassandra.thrift.ColumnOrSuperColumn;
 import org.apache.cassandra.thrift.CounterColumn;
 import org.apache.cassandra.thrift.Mutation;

File: tools/stress/src/org/apache/cassandra/stress/operations/predefined/ThriftCounterGetter.java
Patch:
@@ -23,10 +23,10 @@
 
 import org.apache.cassandra.stress.generate.PartitionGenerator;
 import org.apache.cassandra.stress.generate.SeedManager;
+import org.apache.cassandra.stress.report.Timer;
 import org.apache.cassandra.stress.settings.Command;
 import org.apache.cassandra.stress.settings.StressSettings;
 import org.apache.cassandra.stress.util.ThriftClient;
-import org.apache.cassandra.stress.util.Timer;
 import org.apache.cassandra.thrift.ColumnParent;
 import org.apache.cassandra.thrift.SlicePredicate;
 

File: tools/stress/src/org/apache/cassandra/stress/operations/predefined/ThriftInserter.java
Patch:
@@ -26,10 +26,10 @@
 
 import org.apache.cassandra.stress.generate.PartitionGenerator;
 import org.apache.cassandra.stress.generate.SeedManager;
+import org.apache.cassandra.stress.report.Timer;
 import org.apache.cassandra.stress.settings.Command;
 import org.apache.cassandra.stress.settings.StressSettings;
 import org.apache.cassandra.stress.util.ThriftClient;
-import org.apache.cassandra.stress.util.Timer;
 import org.apache.cassandra.thrift.Column;
 import org.apache.cassandra.thrift.ColumnOrSuperColumn;
 import org.apache.cassandra.thrift.Mutation;

File: tools/stress/src/org/apache/cassandra/stress/operations/predefined/ThriftReader.java
Patch:
@@ -23,10 +23,10 @@
 
 import org.apache.cassandra.stress.generate.PartitionGenerator;
 import org.apache.cassandra.stress.generate.SeedManager;
+import org.apache.cassandra.stress.report.Timer;
 import org.apache.cassandra.stress.settings.Command;
 import org.apache.cassandra.stress.settings.StressSettings;
 import org.apache.cassandra.stress.util.ThriftClient;
-import org.apache.cassandra.stress.util.Timer;
 import org.apache.cassandra.thrift.ColumnOrSuperColumn;
 import org.apache.cassandra.thrift.ColumnParent;
 

File: tools/stress/src/org/apache/cassandra/stress/operations/userdefined/SchemaInsert.java
Patch:
@@ -43,10 +43,10 @@
 import org.apache.cassandra.io.sstable.CQLSSTableWriter;
 import org.apache.cassandra.stress.WorkManager;
 import org.apache.cassandra.stress.generate.*;
+import org.apache.cassandra.stress.report.Timer;
 import org.apache.cassandra.stress.settings.StressSettings;
 import org.apache.cassandra.stress.util.JavaDriverClient;
 import org.apache.cassandra.stress.util.ThriftClient;
-import org.apache.cassandra.stress.util.Timer;
 
 public class SchemaInsert extends SchemaStatement
 {

File: tools/stress/src/org/apache/cassandra/stress/operations/userdefined/SchemaQuery.java
Patch:
@@ -33,10 +33,10 @@
 import com.datastax.driver.core.ResultSet;
 import org.apache.cassandra.db.ConsistencyLevel;
 import org.apache.cassandra.stress.generate.*;
+import org.apache.cassandra.stress.report.Timer;
 import org.apache.cassandra.stress.settings.StressSettings;
 import org.apache.cassandra.stress.util.JavaDriverClient;
 import org.apache.cassandra.stress.util.ThriftClient;
-import org.apache.cassandra.stress.util.Timer;
 import org.apache.cassandra.thrift.CqlResult;
 import org.apache.cassandra.thrift.ThriftConversion;
 

File: tools/stress/src/org/apache/cassandra/stress/operations/userdefined/SchemaStatement.java
Patch:
@@ -32,9 +32,9 @@
 import org.apache.cassandra.db.ConsistencyLevel;
 import org.apache.cassandra.stress.generate.Row;
 import org.apache.cassandra.stress.operations.PartitionOperation;
+import org.apache.cassandra.stress.report.Timer;
 import org.apache.cassandra.stress.settings.StressSettings;
 import org.apache.cassandra.stress.util.JavaDriverClient;
-import org.apache.cassandra.stress.util.Timer;
 
 public abstract class SchemaStatement extends PartitionOperation
 {

File: tools/stress/src/org/apache/cassandra/stress/operations/userdefined/TokenRangeQuery.java
Patch:
@@ -39,10 +39,10 @@
 import org.apache.cassandra.stress.StressYaml;
 import org.apache.cassandra.stress.WorkManager;
 import org.apache.cassandra.stress.generate.TokenRangeIterator;
+import org.apache.cassandra.stress.report.Timer;
 import org.apache.cassandra.stress.settings.StressSettings;
 import org.apache.cassandra.stress.util.JavaDriverClient;
 import org.apache.cassandra.stress.util.ThriftClient;
-import org.apache.cassandra.stress.util.Timer;
 
 public class TokenRangeQuery extends Operation
 {

File: tools/stress/src/org/apache/cassandra/stress/operations/userdefined/ValidatingSchemaQuery.java
Patch:
@@ -33,10 +33,10 @@
 import org.apache.cassandra.stress.generate.*;
 import org.apache.cassandra.stress.generate.Row;
 import org.apache.cassandra.stress.operations.PartitionOperation;
+import org.apache.cassandra.stress.report.Timer;
 import org.apache.cassandra.stress.settings.StressSettings;
 import org.apache.cassandra.stress.util.JavaDriverClient;
 import org.apache.cassandra.stress.util.ThriftClient;
-import org.apache.cassandra.stress.util.Timer;
 import org.apache.cassandra.thrift.Compression;
 import org.apache.cassandra.thrift.CqlResult;
 import org.apache.cassandra.thrift.CqlRow;

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsCommandPreDefinedMixed.java
Patch:
@@ -30,8 +30,8 @@
 import org.apache.cassandra.stress.operations.OpDistributionFactory;
 import org.apache.cassandra.stress.operations.SampledOpDistributionFactory;
 import org.apache.cassandra.stress.operations.predefined.PredefinedOperation;
+import org.apache.cassandra.stress.report.Timer;
 import org.apache.cassandra.stress.util.MultiPrintStream;
-import org.apache.cassandra.stress.util.Timer;
 
 // Settings unique to the mixed command type
 public class SettingsCommandPreDefinedMixed extends SettingsCommandPreDefined

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsCommandUser.java
Patch:
@@ -36,8 +36,8 @@
 import org.apache.cassandra.stress.generate.TokenRangeIterator;
 import org.apache.cassandra.stress.operations.OpDistributionFactory;
 import org.apache.cassandra.stress.operations.SampledOpDistributionFactory;
+import org.apache.cassandra.stress.report.Timer;
 import org.apache.cassandra.stress.util.MultiPrintStream;
-import org.apache.cassandra.stress.util.Timer;
 
 // Settings unique to the mixed command type
 public class SettingsCommandUser extends SettingsCommand

File: src/java/org/apache/cassandra/tools/BulkLoader.java
Patch:
@@ -77,7 +77,7 @@ public static void main(String args[])
         LoaderOptions options = LoaderOptions.parseArgs(args).validateArguments();
         OutputHandler handler = new OutputHandler.SystemOutput(options.verbose, options.debug);
         SSTableLoader loader = new SSTableLoader(
-                options.directory,
+                options.directory.getAbsoluteFile(),
                 new ExternalClient(
                         options.hosts,
                         options.nativePort,

File: src/java/org/apache/cassandra/tools/JsonTransformer.java
Patch:
@@ -193,6 +193,7 @@ private void serializePartition(UnfilteredRowIterator partition)
             if (!partition.partitionLevelDeletion().isLive())
             {
                 serializeDeletion(partition.partitionLevelDeletion());
+                json.writeEndObject();
             }
             else
             {

File: tools/stress/src/org/apache/cassandra/stress/settings/OptionDistribution.java
Patch:
@@ -482,7 +482,7 @@ public Distribution get()
         }
 
         @Override
-        public String getConfigAsString(){return String.format("Gaussian:  min=%d,max=%d,mean=%f,stdev=%f", min, max, stdev, mean);}
+        public String getConfigAsString(){return String.format("Gaussian:  min=%d,max=%d,mean=%f,stdev=%f", min, max, mean, stdev);}
 
     }
 

File: tools/stress/src/org/apache/cassandra/stress/settings/OptionRatioDistribution.java
Patch:
@@ -160,7 +160,7 @@ public RatioDistribution get()
         }
 
         @Override
-        public String getConfigAsString(){return String.format("Ration: divisor=%f;delegate=%s",divisor, delegate.getConfigAsString());};
+        public String getConfigAsString(){return String.format("Ratio: divisor=%f;delegate=%s",divisor, delegate.getConfigAsString());};
 
     }
 

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsLog.java
Patch:
@@ -101,7 +101,7 @@ public List<? extends Option> options()
     public void printSettings(MultiPrintStream out)
     {
         out.printf("  No Summary: %b%n", noSummary);
-        out.printf("  Print Setting: %b%n", noSettings);
+        out.printf("  No Settings: %b%n", noSettings);
         out.printf("  File: %s%n", file);
         out.printf("  Interval Millis: %d%n", intervalMillis);
         out.printf("  Level: %s%n", level);

File: src/java/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -811,7 +811,7 @@ public void serialize(ReadCommand command, DataOutputPlus out, int version) thro
                     out.writeInt(LegacyReadCommandSerializer.updateLimitForQuery(rangeCommand.limits().count(), filter.requestedSlices()));
 
                 int compositesToGroup;
-                boolean selectsStatics = !rangeCommand.columnFilter().fetchedColumns().statics.isEmpty() || filter.requestedSlices().selects(Clustering.STATIC_CLUSTERING);
+                boolean selectsStatics = !rangeCommand.columnFilter().fetchedColumns().statics.isEmpty() && filter.requestedSlices().selects(Clustering.STATIC_CLUSTERING);
                 if (limits.kind() == DataLimits.Kind.THRIFT_LIMIT)
                     compositesToGroup = -1;
                 else if (limits.isDistinct() && !selectsStatics)

File: src/java/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -744,7 +744,7 @@ public void serialize(ReadCommand command, DataOutputPlus out, int version) thro
                     out.writeInt(LegacyReadCommandSerializer.updateLimitForQuery(rangeCommand.limits().count(), filter.requestedSlices()));
 
                 int compositesToGroup;
-                boolean selectsStatics = !rangeCommand.columnFilter().fetchedColumns().statics.isEmpty() || filter.requestedSlices().selects(Clustering.STATIC_CLUSTERING);
+                boolean selectsStatics = !rangeCommand.columnFilter().fetchedColumns().statics.isEmpty() && filter.requestedSlices().selects(Clustering.STATIC_CLUSTERING);
                 if (limits.kind() == DataLimits.Kind.THRIFT_LIMIT)
                     compositesToGroup = -1;
                 else if (limits.isDistinct() && !selectsStatics)

File: src/java/org/apache/cassandra/io/sstable/Descriptor.java
Patch:
@@ -184,7 +184,7 @@ public List<File> getTemporaryFiles()
 
     private final static String LEGACY_COMP_IN_PROG_REGEX_STR = "^compactions_in_progress(\\-[\\d,a-f]{32})?$";
     private final static Pattern LEGACY_COMP_IN_PROG_REGEX = Pattern.compile(LEGACY_COMP_IN_PROG_REGEX_STR);
-    private final static String LEGACY_TMP_REGEX_STR = "^((.*)\\-(.*)\\-)?tmp(link)?\\-(la|ka)\\-(\\d)*\\-(.*)$";
+    private final static String LEGACY_TMP_REGEX_STR = "^((.*)\\-(.*)\\-)?tmp(link)?\\-((?:l|k).)\\-(\\d)*\\-(.*)$";
     private final static Pattern LEGACY_TMP_REGEX = Pattern.compile(LEGACY_TMP_REGEX_STR);
 
     public static boolean isLegacyFile(File file)

File: src/java/org/apache/cassandra/net/IncomingStreamingConnection.java
Patch:
@@ -75,10 +75,9 @@ public void run()
             // parallelize said streams and the socket is blocking, so we might deadlock.
             StreamResultFuture.initReceivingSide(init.sessionIndex, init.planId, init.description, init.from, this, init.isForOutgoing, version, init.keepSSTableLevel, init.isIncremental);
         }
-        catch (IOException e)
+        catch (Throwable t)
         {
-            logger.error(String.format("IOException while reading from socket from %s, closing: %s",
-                                       socket.getRemoteSocketAddress(), e));
+            logger.error("Error while reading from socket from {}.", socket.getRemoteSocketAddress(), t);
             close();
         }
     }

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -1233,9 +1233,9 @@ public void run()
                     logger.error("SSL handshake error for inbound connection from " + socket, e);
                     FileUtils.closeQuietly(socket);
                 }
-                catch (IOException e)
+                catch (Throwable t)
                 {
-                    logger.trace("Error reading the socket " + socket, e);
+                    logger.trace("Error reading the socket {}", socket, t);
                     FileUtils.closeQuietly(socket);
                 }
             }

File: src/java/org/apache/cassandra/service/LoadBroadcaster.java
Patch:
@@ -32,7 +32,7 @@
 
 public class LoadBroadcaster implements IEndpointStateChangeSubscriber
 {
-    static final int BROADCAST_INTERVAL = 60 * 1000;
+    static final int BROADCAST_INTERVAL = Integer.getInteger("cassandra.broadcast_interval_ms", 60 * 1000);
 
     public static final LoadBroadcaster instance = new LoadBroadcaster();
 

File: src/java/org/apache/cassandra/streaming/StreamReader.java
Patch:
@@ -128,7 +128,7 @@ public SSTableMultiWriter read(ReadableByteChannel channel) throws IOException
         {
             if (deserializer != null)
                 logger.warn("[Stream {}] Error while reading partition {} from stream on ks='{}' and table='{}'.",
-                            session.planId(), deserializer.partitionKey(), cfs.keyspace.getName(), cfs.getTableName());
+                            session.planId(), deserializer.partitionKey(), cfs.keyspace.getName(), cfs.getTableName(), e);
             if (writer != null)
             {
                 writer.abort(e);

File: src/java/org/apache/cassandra/utils/CassandraVersion.java
Patch:
@@ -142,7 +142,7 @@ public CassandraVersion findSupportingVersion(CassandraVersion... versions)
 
     public boolean isSupportedBy(CassandraVersion version)
     {
-        return major == version.major && this.compareTo(version) <= 0;
+        return version != null && major == version.major && this.compareTo(version) <= 0;
     }
 
     private static int compareIdentifiers(String[] ids1, String[] ids2, int defaultPred)

File: tools/stress/src/org/apache/cassandra/stress/settings/Option.java
Patch:
@@ -21,9 +21,10 @@
  */
 
 
+import java.io.Serializable;
 import java.util.List;
 
-abstract class Option
+abstract class Option implements Serializable
 {
 
     abstract boolean accept(String param);

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsTokenRange.java
Patch:
@@ -18,6 +18,7 @@
 
 package org.apache.cassandra.stress.settings;
 
+import java.io.Serializable;
 import java.util.List;
 import java.util.Map;
 
@@ -26,13 +27,13 @@
 
 import org.apache.cassandra.stress.util.MultiPrintStream;
 
-public class SettingsTokenRange
+public class SettingsTokenRange implements Serializable
 {
     public final boolean wrap;
     public final int splitFactor;
     private final TokenRangeOptions options;
 
-    public SettingsTokenRange(TokenRangeOptions options)
+    private SettingsTokenRange(TokenRangeOptions options)
     {
         this.options = options;
         this.wrap = options.wrap.setByUser();

File: src/java/org/apache/cassandra/io/sstable/Descriptor.java
Patch:
@@ -186,7 +186,7 @@ public List<File> getTemporaryFiles()
 
     private final static String LEGACY_COMP_IN_PROG_REGEX_STR = "^compactions_in_progress(\\-[\\d,a-f]{32})?$";
     private final static Pattern LEGACY_COMP_IN_PROG_REGEX = Pattern.compile(LEGACY_COMP_IN_PROG_REGEX_STR);
-    private final static String LEGACY_TMP_REGEX_STR = "^((.*)\\-(.*)\\-)?tmp(link)?\\-(la|ka)\\-(\\d)*\\-(.*)$";
+    private final static String LEGACY_TMP_REGEX_STR = "^((.*)\\-(.*)\\-)?tmp(link)?\\-((?:l|k).)\\-(\\d)*\\-(.*)$";
     private final static Pattern LEGACY_TMP_REGEX = Pattern.compile(LEGACY_TMP_REGEX_STR);
 
     public static boolean isLegacyFile(File file)

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -2801,7 +2801,7 @@ public int repairAsync(String keyspace, Map<String, String> repairSpec)
                 if (option.getDataCenters().isEmpty() && option.getHosts().isEmpty())
                     option.getRanges().addAll(getPrimaryRanges(keyspace));
                     // except dataCenters only contain local DC (i.e. -local)
-                else if (option.getDataCenters().size() == 1 && option.getDataCenters().contains(DatabaseDescriptor.getLocalDataCenter()))
+                else if (option.isInLocalDCOnly())
                     option.getRanges().addAll(getPrimaryRangesWithinDC(keyspace));
                 else
                     throw new IllegalArgumentException("You need to run primary range repair on all nodes in the cluster.");

File: src/java/org/apache/cassandra/cache/AutoSavingCache.java
Patch:
@@ -164,7 +164,8 @@ public Integer call()
                 return loadSaved();
             }
         });
-        cacheLoad.addListener(new Runnable() {
+        cacheLoad.addListener(new Runnable()
+        {
             @Override
             public void run()
             {

File: src/java/org/apache/cassandra/cache/ChunkCache.java
Patch:
@@ -36,7 +36,7 @@
 import org.apache.cassandra.metrics.CacheMissMetrics;
 import org.apache.cassandra.utils.memory.BufferPool;
 
-public class ChunkCache 
+public class ChunkCache
         implements CacheLoader<ChunkCache.Key, ChunkCache.Buffer>, RemovalListener<ChunkCache.Key, ChunkCache.Buffer>, CacheSize
 {
     public static final int RESERVED_POOL_SPACE_IN_MB = 32;
@@ -106,7 +106,7 @@ Buffer reference()
             {
                 refCount = references.get();
                 if (refCount == 0)
-                    // Buffer was released before we managed to reference it. 
+                    // Buffer was released before we managed to reference it.
                     return null;
             } while (!references.compareAndSet(refCount, refCount + 1));
 

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -33,7 +33,6 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
-import com.google.common.collect.Iterators;
 import com.google.common.collect.Sets;
 import org.apache.commons.lang3.ArrayUtils;
 import org.apache.commons.lang3.builder.HashCodeBuilder;
@@ -856,7 +855,8 @@ public ColumnDefinition getColumnDefinition(ByteBuffer name)
         return columnMetadata.get(name);
     }
 
-    public static boolean isNameValid(String name) {
+    public static boolean isNameValid(String name)
+    {
         return name != null && !name.isEmpty()
                && name.length() <= SchemaConstants.NAME_LENGTH && PATTERN_WORD_CHARS.matcher(name).matches();
     }

File: src/java/org/apache/cassandra/config/Schema.java
Patch:
@@ -141,7 +141,8 @@ public Keyspace getKeyspaceInstance(String keyspaceName)
      * @param ksNameAndCFName
      * @return The named CFS or null if the keyspace, base table, or index don't exist
      */
-    public ColumnFamilyStore getColumnFamilyStoreIncludingIndexes(Pair<String, String> ksNameAndCFName) {
+    public ColumnFamilyStore getColumnFamilyStoreIncludingIndexes(Pair<String, String> ksNameAndCFName)
+    {
         String ksName = ksNameAndCFName.left;
         String cfName = ksNameAndCFName.right;
         Pair<String, String> baseTable;

File: src/java/org/apache/cassandra/config/ViewDefinition.java
Patch:
@@ -130,8 +130,8 @@ public String toString()
     /**
      * Replace the column 'from' with 'to' in this materialized view definition's partition,
      * clustering, or included columns.
-     * @param from the existing column 
-     * @param to the new column 
+     * @param from the existing column
+     * @param to the new column
      */
     public void renameColumn(ColumnIdentifier from, ColumnIdentifier to)
     {

File: src/java/org/apache/cassandra/cql3/QueryProcessor.java
Patch:
@@ -622,7 +622,8 @@ private static void removeInvalidPersistentPreparedStatements(Iterator<Map.Entry
             while (iterator.hasNext())
             {
                 Map.Entry<MD5Digest, ParsedStatement.Prepared> entry = iterator.next();
-                if (shouldInvalidate(ksName, cfName, entry.getValue().statement)) {
+                if (shouldInvalidate(ksName, cfName, entry.getValue().statement)) 
+                {
                     SystemKeyspace.removePreparedStatement(entry.getKey());
                     iterator.remove();
                 }

File: src/java/org/apache/cassandra/cql3/restrictions/ClusteringColumnRestrictions.java
Patch:
@@ -218,7 +218,8 @@ public void addRowFilterTo(RowFilter filter,
         }
     }
 
-    private boolean handleInFilter(SingleRestriction restriction, int index) {
+    private boolean handleInFilter(SingleRestriction restriction, int index)
+    {
         return restriction.isContains() || restriction.isLIKE() || index != restriction.getFirstColumn().position();
     }
 

File: src/java/org/apache/cassandra/cql3/restrictions/TermSlice.java
Patch:
@@ -62,7 +62,7 @@ private TermSlice(Term start, boolean includeStart, Term end, boolean includeEnd
      */
     public static TermSlice newInstance(Bound bound, boolean include, Term term)
     {
-        return  bound.isStart() ? new TermSlice(term, include, null, false) 
+        return  bound.isStart() ? new TermSlice(term, include, null, false)
                                 : new TermSlice(null, false, term, include);
     }
 
@@ -112,14 +112,14 @@ public TermSlice merge(TermSlice otherSlice)
         {
             assert !otherSlice.hasBound(Bound.START);
 
-            return new TermSlice(bound(Bound.START), 
+            return new TermSlice(bound(Bound.START),
                                   isInclusive(Bound.START),
                                   otherSlice.bound(Bound.END),
                                   otherSlice.isInclusive(Bound.END));
         }
         assert !otherSlice.hasBound(Bound.END);
 
-        return new TermSlice(otherSlice.bound(Bound.START), 
+        return new TermSlice(otherSlice.bound(Bound.START),
                               otherSlice.isInclusive(Bound.START),
                               bound(Bound.END),
                               isInclusive(Bound.END));

File: src/java/org/apache/cassandra/cql3/selection/Selectable.java
Patch:
@@ -150,7 +150,7 @@ public AbstractType<?> getExactTypeIfKnown(String keyspace)
         {
             return rawTerm.getExactTypeIfKnown(keyspace);
         }
- 
+
         @Override
         public String toString()
         {

File: src/java/org/apache/cassandra/cql3/selection/Selection.java
Patch:
@@ -77,7 +77,7 @@ protected Selection(CFMetaData cfm,
     public boolean isWildcard()
     {
         return false;
-    }    
+    }
 
     /**
      * Checks if this selection contains static columns.
@@ -249,7 +249,7 @@ public ResultSetBuilder resultSetBuilder(QueryOptions options, boolean isJson)
 
     public ResultSetBuilder resultSetBuilder(QueryOptions options, boolean isJson, AggregationSpecification aggregationSpec)
     {
-        return aggregationSpec == null ? new ResultSetBuilder(options, isJson) 
+        return aggregationSpec == null ? new ResultSetBuilder(options, isJson)
                 : new ResultSetBuilder(options, isJson, aggregationSpec.newGroupMaker());
     }
 

File: src/java/org/apache/cassandra/cql3/selection/Selector.java
Patch:
@@ -30,9 +30,9 @@
 import org.apache.cassandra.exceptions.InvalidRequestException;
 
 /**
- * A <code>Selector</code> is used to convert the data returned by the storage engine into the data requested by the 
+ * A <code>Selector</code> is used to convert the data returned by the storage engine into the data requested by the
  * user. They correspond to the &lt;selector&gt; elements from the select clause.
- * <p>Since the introduction of aggregation, <code>Selector</code>s cannot be called anymore by multiple threads 
+ * <p>Since the introduction of aggregation, <code>Selector</code>s cannot be called anymore by multiple threads
  * as they have an internal state.</p>
  */
 public abstract class Selector

File: src/java/org/apache/cassandra/cql3/statements/CreateViewStatement.java
Patch:
@@ -86,7 +86,8 @@ public void validate(ClientState state) throws RequestValidationException
         // We do validation in announceMigration to reduce doubling up of work
     }
 
-    private interface AddColumn {
+    private interface AddColumn
+    {
         void add(ColumnIdentifier identifier, AbstractType<?> type);
     }
 

File: src/java/org/apache/cassandra/db/ColumnIndex.java
Patch:
@@ -221,7 +221,8 @@ private void addIndexBlock() throws IOException
 
     private DataOutputBuffer useBuffer()
     {
-        if (reusableBuffer != null) {
+        if (reusableBuffer != null) 
+        {
             buffer = reusableBuffer;
             buffer.clear();
         }

File: src/java/org/apache/cassandra/db/Directories.java
Patch:
@@ -146,7 +146,8 @@ public static boolean hasPrivilege(File file, FileAction action)
         {
             boolean privilege = false;
 
-            switch (action) {
+            switch (action)
+            {
                 case X:
                     privilege = file.canExecute();
                     break;
@@ -1028,7 +1029,7 @@ static void resetDataDirectoriesAfterTest()
         for (int i = 0; i < locations.length; ++i)
             dataDirectories[i] = new DataDirectory(new File(locations[i]));
     }
-    
+
     private class SSTableSizeSummer extends DirectorySizeCalculator
     {
         private final HashSet<File> toSkip;

File: src/java/org/apache/cassandra/db/Memtable.java
Patch:
@@ -115,7 +115,8 @@ public int compareTo(Memtable that)
 
     public static final class LastCommitLogPosition extends CommitLogPosition
     {
-        public LastCommitLogPosition(CommitLogPosition copy) {
+        public LastCommitLogPosition(CommitLogPosition copy) 
+        {
             super(copy.segmentId, copy.position);
         }
     }

File: src/java/org/apache/cassandra/db/RowIndexEntry.java
Patch:
@@ -140,7 +140,8 @@ public class RowIndexEntry<T> implements IMeasurableMemory
     static final Histogram indexEntrySizeHistogram;
     static final Histogram indexInfoCountHistogram;
     static final Histogram indexInfoGetsHistogram;
-    static {
+    static 
+    {
         MetricNameFactory factory = new DefaultNameFactory("Index", "RowIndexEntry");
         indexEntrySizeHistogram = Metrics.histogram(factory.createMetricName("IndexedEntrySize"), false);
         indexInfoCountHistogram = Metrics.histogram(factory.createMetricName("IndexInfoCount"), false);

File: src/java/org/apache/cassandra/db/columniterator/SSTableReversedIterator.java
Patch:
@@ -287,7 +287,7 @@ protected boolean hasNextInternal() throws IOException
             if (previousBlockIdx < 0 || previousBlockIdx < lastBlockIdx)
                 return false;
 
-            // The slice start can be in 
+            // The slice start can be in
             indexState.setToBlock(previousBlockIdx);
             readCurrentBlock(false);
             setIterator(slice);

File: src/java/org/apache/cassandra/db/commitlog/CommitLogReplayer.java
Patch:
@@ -270,9 +270,9 @@ public static IntervalSet<CommitLogPosition> persistedIntervals(Iterable<SSTable
     public static CommitLogPosition firstNotCovered(Collection<IntervalSet<CommitLogPosition>> ranges)
     {
         return ranges.stream()
-                .map(intervals -> Iterables.getFirst(intervals.ends(), CommitLogPosition.NONE)) 
+                .map(intervals -> Iterables.getFirst(intervals.ends(), CommitLogPosition.NONE))
                 .min(Ordering.natural())
-                .get(); // iteration is per known-CF, there must be at least one. 
+                .get(); // iteration is per known-CF, there must be at least one.
     }
 
     abstract static class ReplayFilter

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
Patch:
@@ -54,7 +54,8 @@ public abstract class CommitLogSegment
     private final static long idBase;
 
     private CDCState cdcState = CDCState.PERMITTED;
-    public enum CDCState {
+    public enum CDCState
+    {
         PERMITTED,
         FORBIDDEN,
         CONTAINS

File: src/java/org/apache/cassandra/db/commitlog/IntervalSet.java
Patch:
@@ -40,7 +40,7 @@ public IntervalSet(T start, T end)
     @SuppressWarnings("unchecked")
     public static <T extends Comparable<T>> IntervalSet<T> empty()
     {
-        return (IntervalSet<T>) EMPTY;
+        return EMPTY;
     }
 
     public boolean contains(T position)
@@ -105,7 +105,7 @@ public void serialize(IntervalSet<T> intervals, DataOutputPlus out) throws IOExc
                     pointSerializer.serialize(en.getValue(), out);
                 }
             }
-    
+
             public IntervalSet<T> deserialize(DataInputPlus in) throws IOException
             {
                 int count = in.readInt();
@@ -114,7 +114,7 @@ public IntervalSet<T> deserialize(DataInputPlus in) throws IOException
                     ranges.put(pointSerializer.deserialize(in), pointSerializer.deserialize(in));
                 return new IntervalSet<T>(ImmutableSortedMap.copyOfSorted(ranges));
             }
-    
+
             public long serializedSize(IntervalSet<T> intervals)
             {
                 long size = TypeSizes.sizeof(intervals.ranges.size());

File: src/java/org/apache/cassandra/db/commitlog/MemoryMappedSegment.java
Patch:
@@ -91,7 +91,8 @@ void write(int startMarker, int nextMarker)
         // we don't chain the crcs here to ensure this method is idempotent if it fails
         writeSyncMarker(buffer, startMarker, startMarker, nextMarker);
 
-        try {
+        try
+        {
             SyncUtil.force((MappedByteBuffer) buffer);
         }
         catch (Exception e) // MappedByteBuffer.force() does not declare IOException but can actually throw it

File: src/java/org/apache/cassandra/db/compaction/CompactionHistoryTabularData.java
Patch:
@@ -46,7 +46,8 @@ public class CompactionHistoryTabularData
 
     private static final TabularType TABULAR_TYPE;
 
-    static {
+    static 
+    {
         try
         {
             ITEM_TYPES = new OpenType[]{ SimpleType.STRING, SimpleType.STRING, SimpleType.STRING, SimpleType.LONG,

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -570,7 +570,8 @@ public ListenableFuture<?> submitAntiCompaction(final ColumnFamilyStore cfs,
                                           final Refs<SSTableReader> sstables,
                                           final long repairedAt)
     {
-        Runnable runnable = new WrappedRunnable() {
+        Runnable runnable = new WrappedRunnable() 
+        {
             @Override
             @SuppressWarnings("resource")
             public void runMayThrow() throws Exception

File: src/java/org/apache/cassandra/db/compaction/DateTieredCompactionStrategy.java
Patch:
@@ -462,7 +462,8 @@ public static Map<String, String> validateOptions(Map<String, String> options) t
         return uncheckedOptions;
     }
 
-    public CompactionLogger.Strategy strategyLogger() {
+    public CompactionLogger.Strategy strategyLogger() 
+    {
         return new CompactionLogger.Strategy()
         {
             public JsonNode sstable(SSTableReader sstable)

File: src/java/org/apache/cassandra/db/compaction/SSTableSplitter.java
Patch:
@@ -25,8 +25,8 @@
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
 
-public class SSTableSplitter {
-
+public class SSTableSplitter 
+{
     private final SplittingCompactionTask task;
 
     private CompactionInfo.Holder info;

File: src/java/org/apache/cassandra/db/marshal/DynamicCompositeType.java
Patch:
@@ -123,7 +123,8 @@ protected AbstractType<?> getComparator(int i, ByteBuffer bb1, ByteBuffer bb2)
          * If both types are ReversedType(Type), we need to compare on the wrapped type (which may differ between the two types) to avoid
          * incompatible comparisons being made.
          */
-        if ((comp1 instanceof ReversedType) && (comp2 instanceof ReversedType)) {
+        if ((comp1 instanceof ReversedType) && (comp2 instanceof ReversedType)) 
+        {
             comp1 = ((ReversedType<?>) comp1).baseType;
             comp2 = ((ReversedType<?>) comp2).baseType;
         }

File: src/java/org/apache/cassandra/dht/ByteOrderedPartitioner.java
Patch:
@@ -214,7 +214,8 @@ public BytesToken getRandomToken(Random random)
         return new BytesToken(buffer);
     }
 
-    private final Token.TokenFactory tokenFactory = new Token.TokenFactory() {
+    private final Token.TokenFactory tokenFactory = new Token.TokenFactory() 
+    {
         public ByteBuffer toByteArray(Token token)
         {
             BytesToken bytesToken = (BytesToken) token;

File: src/java/org/apache/cassandra/hadoop/cql3/CqlRecordReader.java
Patch:
@@ -248,7 +248,8 @@ public Row createValue()
      * Return native version protocol of the cluster connection
      * @return serialization protocol version.
      */
-    public int getNativeProtocolVersion() {
+    public int getNativeProtocolVersion() 
+    {
         return nativeProtocolVersion;
     }
 

File: src/java/org/apache/cassandra/index/sasi/analyzer/StandardTokenizerOptions.java
Patch:
@@ -124,7 +124,8 @@ public void setMaxTokenLength(int maxTokenLength)
         this.maxTokenLength = maxTokenLength;
     }
 
-    public static class OptionsBuilder {
+    public static class OptionsBuilder 
+    {
         private boolean stemTerms;
         private boolean ignoreStopTerms;
         private Locale locale;

File: src/java/org/apache/cassandra/index/sasi/analyzer/filter/StemmerFactory.java
Patch:
@@ -48,7 +48,8 @@ public Constructor<?> load(Class aClass) throws Exception
                     {
                         return aClass.getConstructor();
                     }
-                    catch (Exception e) {
+                    catch (Exception e) 
+                    {
                         logger.error("Failed to get stemmer constructor", e);
                     }
                     return null;

File: src/java/org/apache/cassandra/io/sstable/CQLSSTableWriter.java
Patch:
@@ -290,7 +290,8 @@ public CQLSSTableWriter rawAddRow(Map<String, ByteBuffer> values)
     {
         int size = Math.min(values.size(), boundNames.size());
         List<ByteBuffer> rawValues = new ArrayList<>(size);
-        for (int i = 0; i < size; i++) {
+        for (int i = 0; i < size; i++) 
+        {
             ColumnSpecification spec = boundNames.get(i);
             rawValues.add(values.get(spec.name.toString()));
         }

File: src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java
Patch:
@@ -1500,7 +1500,8 @@ public RowIndexEntry getCachedPosition(DecoratedKey key, boolean updateStats)
 
     protected RowIndexEntry getCachedPosition(KeyCacheKey unifiedKey, boolean updateStats)
     {
-        if (keyCache != null && keyCache.getCapacity() > 0 && metadata.params.caching.cacheKeys()) {
+        if (keyCache != null && keyCache.getCapacity() > 0 && metadata.params.caching.cacheKeys()) 
+        {
             if (updateStats)
             {
                 RowIndexEntry cachedEntry = keyCache.get(unifiedKey);

File: src/java/org/apache/cassandra/io/util/DataIntegrityMetadata.java
Patch:
@@ -122,7 +122,8 @@ public void validate() throws IOException
 
             while( checkedInputStream.read(chunk) > 0 ) { }
             long calculatedDigestValue = checkedInputStream.getChecksum().getValue();
-            if (storedDigestValue != calculatedDigestValue) {
+            if (storedDigestValue != calculatedDigestValue)
+            {
                 throw new IOException("Corrupted SSTable : " + descriptor.filenameFor(Component.DATA));
             }
         }

File: src/java/org/apache/cassandra/io/util/FileHandle.java
Patch:
@@ -432,7 +432,8 @@ private void updateRegions(ChannelProxy channel, long length)
     }
 
     @Override
-    public String toString() {
+    public String toString()
+    {
         return getClass().getSimpleName() + "(path='" + path() + '\'' +
                ", length=" + rebuffererFactory.fileLength() +
                ')';

File: src/java/org/apache/cassandra/io/util/RebufferingInputStream.java
Patch:
@@ -69,8 +69,8 @@ public void readFully(byte[] b, int off, int len) throws IOException
     }
 
     @Override
-    public int read(byte[] b, int off, int len) throws IOException {
-
+    public int read(byte[] b, int off, int len) throws IOException
+    {
         // avoid int overflow
         if (off < 0 || off > b.length || len < 0 || len > b.length - off)
             throw new IndexOutOfBoundsException();

File: src/java/org/apache/cassandra/locator/DynamicEndpointSnitchMBean.java
Patch:
@@ -22,7 +22,8 @@
 import java.util.Map;
 import java.util.List;
 
-public interface DynamicEndpointSnitchMBean {
+public interface DynamicEndpointSnitchMBean 
+{
     public Map<InetAddress, Double> getScores();
     public int getUpdateInterval();
     public int getResetInterval();

File: src/java/org/apache/cassandra/locator/SnitchProperties.java
Patch:
@@ -42,9 +42,9 @@ public SnitchProperties()
             URL url;
             if (configURL == null)
                 url = SnitchProperties.class.getClassLoader().getResource(RACKDC_PROPERTY_FILENAME);
-            else 
+            else
             	url = new URL(configURL);
-            
+
             stream = url.openStream(); // catch block handles potential NPE
             properties.load(stream);
         }

File: src/java/org/apache/cassandra/metrics/CASClientRequestMetrics.java
Patch:
@@ -32,7 +32,8 @@ public class CASClientRequestMetrics extends ClientRequestMetrics
 
     public final Counter unfinishedCommit;
 
-    public CASClientRequestMetrics(String scope) {
+    public CASClientRequestMetrics(String scope) 
+    {
         super(scope);
         contention = Metrics.histogram(factory.createMetricName("ContentionHistogram"), false);
         conditionNotMet =  Metrics.counter(factory.createMetricName("ConditionNotMet"));

File: src/java/org/apache/cassandra/metrics/CompactionMetrics.java
Patch:
@@ -77,7 +77,8 @@ public Integer getValue()
             new Gauge<Map<String, Map<String, Integer>>>()
         {
             @Override
-            public Map<String, Map<String, Integer>> getValue() {
+            public Map<String, Map<String, Integer>> getValue() 
+            {
                 Map<String, Map<String, Integer>> resultMap = new HashMap<>();
                 // estimation of compactions need to be done
                 for (String keyspaceName : Schema.instance.getKeyspaces())

File: src/java/org/apache/cassandra/metrics/ViewWriteMetrics.java
Patch:
@@ -31,7 +31,8 @@ public class ViewWriteMetrics extends ClientRequestMetrics
     // time between when mutation is applied to local memtable to when CL.ONE is achieved on MV
     public final Timer viewWriteLatency;
 
-    public ViewWriteMetrics(String scope) {
+    public ViewWriteMetrics(String scope)
+    {
         super(scope);
         viewReplicasAttempted = Metrics.counter(factory.createMetricName("ViewReplicasAttempted"));
         viewReplicasSuccess = Metrics.counter(factory.createMetricName("ViewReplicasSuccess"));

File: src/java/org/apache/cassandra/repair/SystemDistributedKeyspace.java
Patch:
@@ -269,7 +269,9 @@ public static Map<UUID, String> viewStatus(String keyspace, String view)
                                              ConsistencyLevel.ONE,
                                              keyspace,
                                              view);
-        } catch (Exception e) {
+        }
+        catch (Exception e)
+        {
             return Collections.emptyMap();
         }
 

File: src/java/org/apache/cassandra/schema/CompressionParams.java
Patch:
@@ -265,7 +265,8 @@ private static ICompressor createCompressor(Class<?> compressorClass, Map<String
         }
     }
 
-    public static ICompressor createCompressor(ParameterizedClass compression) throws ConfigurationException {
+    public static ICompressor createCompressor(ParameterizedClass compression) throws ConfigurationException
+    {
         return createCompressor(parseCompressorClass(compression.class_name), copyOptions(compression.parameters));
     }
 
@@ -282,7 +283,7 @@ private static Map<String, String> copyOptions(Map<? extends CharSequence, ? ext
 
     /**
      * Parse the chunk length (in KB) and returns it as bytes.
-     * 
+     *
      * @param chLengthKB the length of the chunk to parse
      * @return the chunk length in bytes
      * @throws ConfigurationException if the chunk size is too large

File: src/java/org/apache/cassandra/serializers/UTF8Serializer.java
Patch:
@@ -37,7 +37,8 @@ public void validate(ByteBuffer bytes) throws MarshalException
 
     static class UTF8Validator
     {
-        enum State {
+        enum State
+        {
             START,
             TWO,
             TWO_80,

File: src/java/org/apache/cassandra/streaming/management/ProgressInfoCompositeData.java
Patch:
@@ -53,7 +53,8 @@ public class ProgressInfoCompositeData
                                                                    SimpleType.LONG};
 
     public static final CompositeType COMPOSITE_TYPE;
-    static  {
+    static
+    {
         try
         {
             COMPOSITE_TYPE = new CompositeType(ProgressInfo.class.getName(),

File: src/java/org/apache/cassandra/streaming/management/SessionCompleteEventCompositeData.java
Patch:
@@ -38,7 +38,8 @@ public class SessionCompleteEventCompositeData
                                                                    SimpleType.BOOLEAN};
 
     public static final CompositeType COMPOSITE_TYPE;
-    static  {
+    static
+    {
         try
         {
             COMPOSITE_TYPE = new CompositeType(StreamEvent.SessionCompleteEvent.class.getName(),

File: src/java/org/apache/cassandra/streaming/management/SessionInfoCompositeData.java
Patch:
@@ -55,7 +55,8 @@ public class SessionInfoCompositeData
     private static final OpenType<?>[] ITEM_TYPES;
 
     public static final CompositeType COMPOSITE_TYPE;
-    static  {
+    static
+    {
         try
         {
             ITEM_TYPES = new OpenType[]{SimpleType.STRING,

File: src/java/org/apache/cassandra/streaming/management/StreamStateCompositeData.java
Patch:
@@ -48,7 +48,8 @@ public class StreamStateCompositeData
     private static final OpenType<?>[] ITEM_TYPES;
 
     public static final CompositeType COMPOSITE_TYPE;
-    static  {
+    static
+    {
         try
         {
             ITEM_TYPES = new OpenType[]{SimpleType.STRING,

File: src/java/org/apache/cassandra/streaming/management/StreamSummaryCompositeData.java
Patch:
@@ -41,7 +41,8 @@ public class StreamSummaryCompositeData
                                                                    SimpleType.LONG};
 
     public static final CompositeType COMPOSITE_TYPE;
-    static  {
+    static
+    {
         try
         {
             COMPOSITE_TYPE = new CompositeType(StreamSummary.class.getName(),

File: src/java/org/apache/cassandra/thrift/CustomTThreadPoolServer.java
Patch:
@@ -78,7 +78,8 @@ public class CustomTThreadPoolServer extends TServer
     private final AtomicInteger activeClients = new AtomicInteger(0);
 
 
-    public CustomTThreadPoolServer(TThreadPoolServer.Args args, ExecutorService executorService) {
+    public CustomTThreadPoolServer(TThreadPoolServer.Args args, ExecutorService executorService)
+    {
         super(args);
         this.executorService = executorService;
         this.args = args;

File: src/java/org/apache/cassandra/tracing/Tracing.java
Patch:
@@ -91,7 +91,8 @@ public int getTTL()
 
     public static final Tracing instance;
 
-    static {
+    static
+    {
         Tracing tracing = null;
         String customTracingClass = System.getProperty("cassandra.custom_tracing_class");
         if (null != customTracingClass)

File: src/java/org/apache/cassandra/tracing/TracingImpl.java
Patch:
@@ -35,7 +35,8 @@
  */
 class TracingImpl extends Tracing
 {
-    public void stopSessionImpl() {
+    public void stopSessionImpl()
+    {
         final TraceStateImpl state = getStateImpl();
         if (state == null)
             return;

File: src/java/org/apache/cassandra/transport/Client.java
Patch:
@@ -69,7 +69,8 @@ public void run() throws IOException
             System.out.print(">> ");
             System.out.flush();
             String line = in.readLine();
-            if (line == null) {
+            if (line == null)
+            {
                 break;
             }
             Message.Request req = parseLine(line.trim());

File: src/java/org/apache/cassandra/transport/Event.java
Patch:
@@ -27,7 +27,8 @@
 
 public abstract class Event
 {
-    public enum Type {
+    public enum Type
+    {
         TOPOLOGY_CHANGE(Server.VERSION_3),
         STATUS_CHANGE(Server.VERSION_3),
         SCHEMA_CHANGE(Server.VERSION_3),

File: src/java/org/apache/cassandra/triggers/TriggerExecutor.java
Patch:
@@ -6,9 +6,9 @@
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- * 
+ *
  *   http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY

File: src/java/org/apache/cassandra/utils/Architecture.java
Patch:
@@ -35,9 +35,9 @@ public final class Architecture
         "x86_64",
         "s390x"
     ));
-    
+
     public static final boolean IS_UNALIGNED = UNALIGNED_ARCH.contains(System.getProperty("os.arch"));
-    
+
     private Architecture()
     {
     }

File: src/java/org/apache/cassandra/utils/ByteBufferUtil.java
Patch:
@@ -514,7 +514,8 @@ public int available()
      */
     public static String bytesToHex(ByteBuffer bytes)
     {
-        if (bytes.hasArray()) {
+        if (bytes.hasArray())
+        {
             return Hex.bytesToHex(bytes.array(), bytes.arrayOffset() + bytes.position(), bytes.remaining());
         }
 

File: src/java/org/apache/cassandra/utils/EstimatedHistogram.java
Patch:
@@ -372,7 +372,8 @@ public EstimatedHistogram deserialize(DataInputPlus in) throws IOException
             long[] offsets = new long[size - 1];
             long[] buckets = new long[size];
 
-            for (int i = 0; i < size; i++) {
+            for (int i = 0; i < size; i++)
+            {
                 offsets[i == 0 ? 0 : i - 1] = in.readLong();
                 buckets[i] = in.readLong();
             }

File: src/java/org/apache/cassandra/utils/FastByteOperations.java
Patch:
@@ -266,7 +266,8 @@ public static void copy(Object src, long srcOffset, byte[] trg, int trgPosition,
 
         public static void copy(Object src, long srcOffset, Object dst, long dstOffset, long length)
         {
-            while (length > 0) {
+            while (length > 0)
+            {
                 long size = (length > UNSAFE_COPY_THRESHOLD) ? UNSAFE_COPY_THRESHOLD : length;
                 // if src or dst are null, the offsets are absolute base addresses:
                 theUnsafe.copyMemory(src, srcOffset, dst, dstOffset, size);

File: src/java/org/apache/cassandra/utils/Hex.java
Patch:
@@ -102,7 +102,8 @@ public static String wrapCharArray(char[] c)
             {
                 s = stringConstructor.newInstance(0, c.length, c);
             }
-            catch (InvocationTargetException ite) {
+            catch (InvocationTargetException ite)
+            {
                 // The underlying constructor failed. Unwrapping the exception.
                 Throwable cause = ite.getCause();
                 logger.error("Underlying string constructor threw an error: {}",

File: src/java/org/apache/cassandra/utils/IntegerInterval.java
Patch:
@@ -133,7 +133,7 @@ public synchronized void add(int start, int end)
                     if (extend > end)
                         end = extend;
                 }
-    
+
                 // record directly preceding our start may extend into us; if it does, we take it as our start
                 int lpos = Arrays.binarySearch(ranges, ((start & 0xFFFFFFFFL) << 32) | 0); // lower (i.e. greatest <) of the start position
                 if (lpos < 0)
@@ -147,7 +147,7 @@ public synchronized void add(int start, int end)
                         --lpos;
                     }
                 }
-    
+
                 newRanges = new long[ranges.length - (rpos - lpos) + 1];
                 int dest = 0;
                 for (int i = 0; i <= lpos; ++i)

File: src/java/org/apache/cassandra/utils/JMXServerUtils.java
Patch:
@@ -223,7 +223,8 @@ private static Map<String, Object> configureJmxSocketFactories(InetAddress serve
             env.put("com.sun.jndi.rmi.factory.socket", clientFactory);
             logJmxSslConfig(serverFactory);
         }
-        else if (localOnly){
+        else if (localOnly)
+        {
             env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE,
                     new RMIServerSocketFactoryImpl(serverAddress));
         }

File: src/java/org/apache/cassandra/utils/JVMStabilityInspector.java
Patch:
@@ -111,7 +111,8 @@ public static void userFunctionTimeout(Throwable t)
     }
 
     @VisibleForTesting
-    public static Killer replaceKiller(Killer newKiller) {
+    public static Killer replaceKiller(Killer newKiller)
+    {
         Killer oldKiller = JVMStabilityInspector.killer;
         JVMStabilityInspector.killer = newKiller;
         return oldKiller;

File: src/java/org/apache/cassandra/utils/UUIDGen.java
Patch:
@@ -233,7 +233,8 @@ public static long microsTimestamp(UUID uuid)
      * @param timestamp milliseconds since Unix epoch
      * @return
      */
-    private static long fromUnixTimestamp(long timestamp) {
+    private static long fromUnixTimestamp(long timestamp)
+    {
         return fromUnixTimestamp(timestamp, 0L);
     }
 

File: src/java/org/apache/cassandra/utils/concurrent/Ref.java
Patch:
@@ -341,7 +341,8 @@ public String toString()
         }
     }
 
-    private static final Class<?>[] concurrentIterableClasses = new Class<?>[] {
+    private static final Class<?>[] concurrentIterableClasses = new Class<?>[]
+    {
         ConcurrentLinkedQueue.class,
         ConcurrentLinkedDeque.class,
         ConcurrentSkipListSet.class,

File: src/java/org/apache/cassandra/utils/memory/BufferPool.java
Patch:
@@ -68,7 +68,8 @@ public class BufferPool
     private static final GlobalPool globalPool = new GlobalPool();
 
     /** A thread local pool of chunks, where chunks come from the global pool */
-    private static final FastThreadLocal<LocalPool> localPool = new FastThreadLocal<LocalPool>() {
+    private static final FastThreadLocal<LocalPool> localPool = new FastThreadLocal<LocalPool>()
+    {
         @Override
         protected LocalPool initialValue()
         {

File: src/java/org/apache/cassandra/db/lifecycle/LogFile.java
Patch:
@@ -216,7 +216,7 @@ static void verifyRecord(LogRecord record)
         // it matches. Because we delete files from oldest to newest, the latest update time should
         // always match.
         record.status.onDiskRecord = record.withExistingFiles();
-        if (record.updateTime != record.status.onDiskRecord.updateTime && record.status.onDiskRecord.numFiles > 0)
+        if (record.updateTime != record.status.onDiskRecord.updateTime && record.status.onDiskRecord.updateTime > 0)
         {
             record.setError(String.format("Unexpected files detected for sstable [%s], " +
                                           "record [%s]: last update time [%tT] should have been [%tT]",

File: src/java/org/apache/cassandra/schema/LegacySchemaMigrator.java
Patch:
@@ -282,7 +282,7 @@ private static CFMetaData decodeTableMetadata(UntypedResultSet.Row tableRow,
         AbstractType<?> rawComparator = TypeParser.parse(tableRow.getString("comparator"));
         AbstractType<?> subComparator = tableRow.has("subcomparator") ? TypeParser.parse(tableRow.getString("subcomparator")) : null;
 
-        boolean isSuper = "super".equals(tableRow.getString("type").toLowerCase());
+        boolean isSuper = "super".equals(tableRow.getString("type").toLowerCase(Locale.ENGLISH));
         boolean isCompound = rawComparator instanceof CompositeType || isSuper;
 
         /*

File: src/java/org/apache/cassandra/db/lifecycle/LogFile.java
Patch:
@@ -52,7 +52,7 @@
  *
  * @see LogTransaction
  */
-final class LogFile
+final class LogFile implements AutoCloseable
 {
     private static final Logger logger = LoggerFactory.getLogger(LogFile.class);
 
@@ -374,7 +374,7 @@ boolean exists()
         return replicas.exists();
     }
 
-    void close()
+    public void close()
     {
         replicas.close();
     }

File: src/java/org/apache/cassandra/db/lifecycle/LogReplica.java
Patch:
@@ -34,7 +34,7 @@
  *
  * @see LogFile
  */
-final class LogReplica
+final class LogReplica implements AutoCloseable
 {
     private final File file;
     private int folderDescriptor;
@@ -88,7 +88,7 @@ boolean exists()
         return file.exists();
     }
 
-    void close()
+    public void close()
     {
         if (folderDescriptor >= 0)
         {

File: src/java/org/apache/cassandra/db/lifecycle/LogReplicaSet.java
Patch:
@@ -41,7 +41,7 @@
  *
  * @see LogReplica, LogFile
  */
-public class LogReplicaSet
+public class LogReplicaSet implements AutoCloseable
 {
     private static final Logger logger = LoggerFactory.getLogger(LogReplicaSet.class);
 
@@ -72,6 +72,7 @@ void maybeCreateReplica(File folder, String fileName, Set<LogRecord> records)
         if (replicasByFile.containsKey(folder))
             return;
 
+        @SuppressWarnings("resource")  // LogReplicas are closed in LogReplicaSet::close
         final LogReplica replica = LogReplica.create(folder, fileName);
 
         records.forEach(replica::append);
@@ -201,7 +202,7 @@ boolean exists()
                : false;
     }
 
-    void close()
+    public void close()
     {
         Throwables.maybeFail(Throwables.perform(null, replicas().stream().map(r -> r::close)));
     }

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegmentReader.java
Patch:
@@ -273,6 +273,7 @@ public CompressedSegmenter(ICompressor compressor, RandomAccessReader reader)
             nextLogicalStart = reader.getFilePointer();
         }
 
+        @SuppressWarnings("resource")
         public SyncSegment nextSegment(final int startPosition, final int nextSectionStartPosition) throws IOException
         {
             reader.seek(startPosition);
@@ -352,6 +353,7 @@ public EncryptedSegmenter(CommitLogDescriptor descriptor, RandomAccessReader rea
             };
         }
 
+        @SuppressWarnings("resource")
         public SyncSegment nextSegment(int startPosition, int nextSectionStartPosition) throws IOException
         {
             int totalPlainTextLength = reader.readInt();

File: src/java/org/apache/cassandra/db/compaction/LeveledCompactionStrategy.java
Patch:
@@ -98,7 +98,7 @@ public void startup()
      * the only difference between background and maximal in LCS is that maximal is still allowed
      * (by explicit user request) even when compaction is disabled.
      */
-    @SuppressWarnings("resource")
+    @SuppressWarnings("resource") // transaction is closed by AbstractCompactionTask::execute
     public AbstractCompactionTask getNextBackgroundTask(int gcBefore)
     {
         while (true)
@@ -134,7 +134,7 @@ public AbstractCompactionTask getNextBackgroundTask(int gcBefore)
         }
     }
 
-    @SuppressWarnings("resource")
+    @SuppressWarnings("resource") // transaction is closed by AbstractCompactionTask::execute
     public synchronized Collection<AbstractCompactionTask> getMaximalTask(int gcBefore, boolean splitOutput)
     {
         Iterable<SSTableReader> sstables = manifest.getAllSSTables();
@@ -150,6 +150,7 @@ public synchronized Collection<AbstractCompactionTask> getMaximalTask(int gcBefo
     }
 
     @Override
+    @SuppressWarnings("resource") // transaction is closed by AbstractCompactionTask::execute
     public AbstractCompactionTask getUserDefinedTask(Collection<SSTableReader> sstables, int gcBefore)
     {
 

File: src/java/org/apache/cassandra/index/sasi/disk/PerSSTableIndexWriter.java
Patch:
@@ -305,6 +305,7 @@ public void complete(final CountDownLatch latch)
 
                     for (Future<OnDiskIndex> f : segments)
                     {
+                        @SuppressWarnings("resource")
                         OnDiskIndex part = f.get();
                         if (part == null)
                             continue;
@@ -330,6 +331,7 @@ public void complete(final CountDownLatch latch)
 
                     for (int segment = 0; segment < segmentNumber; segment++)
                     {
+                        @SuppressWarnings("resource")
                         OnDiskIndex part = parts[segment];
 
                         if (part != null)

File: src/java/org/apache/cassandra/index/sasi/disk/StaticTokenTreeBuilder.java
Patch:
@@ -53,6 +53,7 @@
  *
  * See https://issues.apache.org/jira/browse/CASSANDRA-11383 for more details.
  */
+@SuppressWarnings("resource")
 public class StaticTokenTreeBuilder extends AbstractTokenTreeBuilder
 {
     private final CombinedTerm combinedTerm;

File: src/java/org/apache/cassandra/index/sasi/plan/QueryController.java
Patch:
@@ -141,6 +141,7 @@ public RangeIterator.Builder<Long, Token> getIndexes(OperationType op, Collectio
 
         for (Map.Entry<Expression, Set<SSTableIndex>> e : getView(op, expressions).entrySet())
         {
+            @SuppressWarnings("resource") // RangeIterators are closed by releaseIndexes
             RangeIterator<Long, Token> index = TermIterator.build(e.getKey(), e.getValue());
 
             if (index == null)

File: src/java/org/apache/cassandra/io/sstable/IndexSummaryBuilder.java
Patch:
@@ -85,7 +85,6 @@ public ReadableBoundary(DecoratedKey lastKey, long indexLength, long dataLength,
         }
     }
 
-    @SuppressWarnings("resource")
     public IndexSummaryBuilder(long expectedKeys, int minIndexInterval, int samplingLevel)
     {
         this.samplingLevel = samplingLevel;
@@ -282,6 +281,7 @@ public static int calculateSamplingLevel(int currentSamplingLevel, int currentNu
      * @param partitioner the partitioner used for the index summary
      * @return a new IndexSummary
      */
+    @SuppressWarnings("resource")
     public static IndexSummary downsample(IndexSummary existing, int newSamplingLevel, int minIndexInterval, IPartitioner partitioner)
     {
         // To downsample the old index summary, we'll go through (potentially) several rounds of downsampling.

File: src/java/org/apache/cassandra/io/sstable/SSTableTxnWriter.java
Patch:
@@ -96,7 +96,7 @@ public Collection<SSTableReader> finish(boolean openResult)
         return writer.finished();
     }
 
-    @SuppressWarnings("resource") // log and writer closed during postCleanup
+    @SuppressWarnings("resource") // log and writer closed during doPostCleanup
     public static SSTableTxnWriter create(ColumnFamilyStore cfs, Descriptor descriptor, long keyCount, long repairedAt, int sstableLevel, SerializationHeader header)
     {
         LifecycleTransaction txn = LifecycleTransaction.offline(OperationType.WRITE);
@@ -105,6 +105,7 @@ public static SSTableTxnWriter create(ColumnFamilyStore cfs, Descriptor descript
     }
 
 
+    @SuppressWarnings("resource") // log and writer closed during doPostCleanup
     public static SSTableTxnWriter createRangeAware(ColumnFamilyStore cfs, long keyCount, long repairedAt, SSTableFormat.Type type, int sstableLevel, SerializationHeader header)
     {
         LifecycleTransaction txn = LifecycleTransaction.offline(OperationType.WRITE);
@@ -123,7 +124,7 @@ public static SSTableTxnWriter createRangeAware(ColumnFamilyStore cfs, long keyC
         return new SSTableTxnWriter(txn, writer);
     }
 
-    @SuppressWarnings("resource") // log and writer closed during postCleanup
+    @SuppressWarnings("resource") // log and writer closed during doPostCleanup
     public static SSTableTxnWriter create(CFMetaData cfm,
                                           Descriptor descriptor,
                                           long keyCount,

File: src/java/org/apache/cassandra/io/util/ChecksummedRandomAccessReader.java
Patch:
@@ -24,6 +24,7 @@
 
 public final class ChecksummedRandomAccessReader
 {
+    @SuppressWarnings("resource") // The Rebufferer owns both the channel and the validator and handles closing both.
     public static RandomAccessReader open(File file, File crcFile) throws IOException
     {
         ChannelProxy channel = new ChannelProxy(file);
@@ -33,7 +34,6 @@ public static RandomAccessReader open(File file, File crcFile) throws IOExceptio
                                                                                                             RandomAccessReader.open(crcFile),
                                                                                                             file.getPath());
             Rebufferer rebufferer = new ChecksummedRebufferer(channel, validator);
-            // Always own and close the channel.
             return new RandomAccessReader.RandomAccessReaderWithOwnChannel(rebufferer);
         }
         catch (Throwable t)

File: src/java/org/apache/cassandra/io/util/ChecksummedRebufferer.java
Patch:
@@ -27,6 +27,7 @@ class ChecksummedRebufferer extends BufferManagingRebufferer
 {
     private final DataIntegrityMetadata.ChecksumValidator validator;
 
+    @SuppressWarnings("resource") // chunk reader is closed by super::close()
     ChecksummedRebufferer(ChannelProxy channel, DataIntegrityMetadata.ChecksumValidator validator)
     {
         super(new SimpleChunkReader(channel, channel.size(), BufferType.ON_HEAP, validator.chunkSize));

File: src/java/org/apache/cassandra/security/EncryptionUtils.java
Patch:
@@ -114,6 +114,7 @@ public static ByteBuffer encryptAndWrite(ByteBuffer inputBuffer, WritableByteCha
         return outputBuffer;
     }
 
+    @SuppressWarnings("resource")
     public static ByteBuffer encrypt(ByteBuffer inputBuffer, ByteBuffer outputBuffer, boolean allowBufferResize, Cipher cipher) throws IOException
     {
         Preconditions.checkNotNull(outputBuffer, "output buffer may not be null");
@@ -165,6 +166,7 @@ public static ByteBuffer decrypt(ReadableByteChannel channel, ByteBuffer outputB
     }
 
     // path used when decrypting commit log files
+    @SuppressWarnings("resource")
     public static ByteBuffer decrypt(FileDataInput fileDataInput, ByteBuffer outputBuffer, boolean allowBufferResize, Cipher cipher) throws IOException
     {
         return decrypt(new DataInputReadChannel(fileDataInput), outputBuffer, allowBufferResize, cipher);

File: src/java/org/apache/cassandra/db/compaction/TimeWindowCompactionStrategy.java
Patch:
@@ -71,6 +71,7 @@ public TimeWindowCompactionStrategy(ColumnFamilyStore cfs, Map<String, String> o
     }
 
     @Override
+    @SuppressWarnings("resource") // transaction is closed by AbstractCompactionTask::execute
     public AbstractCompactionTask getNextBackgroundTask(int gcBefore)
     {
         while (true)
@@ -323,6 +324,7 @@ static List<SSTableReader> trimToThreshold(Set<SSTableReader> bucket, int maxThr
     }
 
     @Override
+    @SuppressWarnings("resource") // transaction is closed by AbstractCompactionTask::execute
     public synchronized Collection<AbstractCompactionTask> getMaximalTask(int gcBefore, boolean splitOutput)
     {
         Iterable<SSTableReader> filteredSSTables = filterSuspectSSTables(sstables);
@@ -335,6 +337,7 @@ public synchronized Collection<AbstractCompactionTask> getMaximalTask(int gcBefo
     }
 
     @Override
+    @SuppressWarnings("resource") // transaction is closed by AbstractCompactionTask::execute
     public synchronized AbstractCompactionTask getUserDefinedTask(Collection<SSTableReader> sstables, int gcBefore)
     {
         assert !sstables.isEmpty(); // checked for by CM.submitUserDefined

File: src/java/org/apache/cassandra/service/paxos/ProposeCallback.java
Patch:
@@ -59,7 +59,7 @@ public ProposeCallback(int totalTargets, int requiredTargets, boolean failFast,
 
     public void response(MessageIn<Boolean> msg)
     {
-        logger.debug("Propose response {} from {}", msg.payload, msg.from);
+        logger.trace("Propose response {} from {}", msg.payload, msg.from);
 
         if (msg.payload)
             accepts.incrementAndGet();

File: src/java/org/apache/cassandra/db/SystemKeyspace.java
Patch:
@@ -33,6 +33,7 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
+import com.google.common.collect.Sets;
 import com.google.common.io.ByteStreams;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -1331,8 +1332,8 @@ public static synchronized Map<InetAddress, Set<Range<Token>>> getTransferredRan
         for (UntypedResultSet.Row row : rs)
         {
             InetAddress peer = row.getInetAddress("peer");
-            Set<ByteBuffer> rawRanges = rawRanges = row.getSet("ranges", BytesType.instance);
-            Set<Range<Token>> ranges = new HashSet<>();
+            Set<ByteBuffer> rawRanges = row.getSet("ranges", BytesType.instance);
+            Set<Range<Token>> ranges = Sets.newHashSetWithExpectedSize(rawRanges.size());
             for (ByteBuffer rawRange : rawRanges)
             {
                 ranges.add(byteBufferToRange(rawRange, partitioner));

File: src/java/org/apache/cassandra/hints/HintsDispatcher.java
Patch:
@@ -27,6 +27,7 @@
 
 import com.google.common.util.concurrent.RateLimiter;
 
+import org.apache.cassandra.exceptions.RequestFailureReason;
 import org.apache.cassandra.net.IAsyncCallbackWithFailure;
 import org.apache.cassandra.net.MessageIn;
 import org.apache.cassandra.net.MessagingService;
@@ -192,7 +193,7 @@ Outcome await()
             return timedOut ? Outcome.TIMEOUT : outcome;
         }
 
-        public void onFailure(InetAddress from)
+        public void onFailure(InetAddress from, RequestFailureReason failureReason)
         {
             outcome = Outcome.FAILURE;
             condition.signalAll();

File: src/java/org/apache/cassandra/net/IAsyncCallbackWithFailure.java
Patch:
@@ -19,11 +19,13 @@
 
 import java.net.InetAddress;
 
+import org.apache.cassandra.exceptions.RequestFailureReason;
+
 public interface IAsyncCallbackWithFailure<T> extends IAsyncCallback<T>
 {
 
     /**
      * Called when there is an exception on the remote node or timeout happens
      */
-    void onFailure(InetAddress from);
+    void onFailure(InetAddress from, RequestFailureReason failureReason);
 }

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -54,6 +54,7 @@
 import org.apache.cassandra.dht.BootStrapper;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.exceptions.ConfigurationException;
+import org.apache.cassandra.exceptions.RequestFailureReason;
 import org.apache.cassandra.gms.EchoMessage;
 import org.apache.cassandra.gms.GossipDigestAck;
 import org.apache.cassandra.gms.GossipDigestAck2;
@@ -93,6 +94,7 @@ public final class MessagingService implements MessagingServiceMBean
     public static final String FAILURE_CALLBACK_PARAM = "CAL_BAC";
     public static final byte[] ONE_BYTE = new byte[1];
     public static final String FAILURE_RESPONSE_PARAM = "FAIL";
+    public static final String FAILURE_REASON_PARAM = "FAIL_REASON";
 
     /**
      * we preface every message with this number so the recipient can validate the sender is sane
@@ -510,7 +512,7 @@ public Object apply(Pair<Integer, ExpiringMap.CacheableObject<CallbackInfo>> pai
                     StageManager.getStage(Stage.INTERNAL_RESPONSE).submit(new Runnable() {
                         @Override
                         public void run() {
-                            ((IAsyncCallbackWithFailure)expiredCallbackInfo.callback).onFailure(expiredCallbackInfo.target);
+                            ((IAsyncCallbackWithFailure)expiredCallbackInfo.callback).onFailure(expiredCallbackInfo.target, RequestFailureReason.UNKNOWN);
                         }
                     });
                 }

File: src/java/org/apache/cassandra/net/ResponseVerbHandler.java
Patch:
@@ -44,7 +44,7 @@ public void doVerb(MessageIn message, int id)
         IAsyncCallback cb = callbackInfo.callback;
         if (message.isFailureResponse())
         {
-            ((IAsyncCallbackWithFailure) cb).onFailure(message.from);
+            ((IAsyncCallbackWithFailure) cb).onFailure(message.from, message.getFailureReason());
         }
         else
         {

File: src/java/org/apache/cassandra/repair/AnticompactionTask.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.cassandra.db.SystemKeyspace;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.Token;
+import org.apache.cassandra.exceptions.RequestFailureReason;
 import org.apache.cassandra.gms.FailureDetector;
 import org.apache.cassandra.net.IAsyncCallbackWithFailure;
 import org.apache.cassandra.net.MessageIn;
@@ -99,7 +100,7 @@ public boolean isLatencyForSnitch()
             return false;
         }
 
-        public void onFailure(InetAddress from)
+        public void onFailure(InetAddress from, RequestFailureReason failureReason)
         {
             task.setException(new RuntimeException("Anticompaction failed or timed out in " + from));
         }

File: src/java/org/apache/cassandra/repair/SnapshotTask.java
Patch:
@@ -23,6 +23,7 @@
 
 import com.google.common.util.concurrent.AbstractFuture;
 
+import org.apache.cassandra.exceptions.RequestFailureReason;
 import org.apache.cassandra.net.IAsyncCallbackWithFailure;
 import org.apache.cassandra.net.MessageIn;
 import org.apache.cassandra.net.MessagingService;
@@ -73,7 +74,7 @@ public void response(MessageIn msg)
 
         public boolean isLatencyForSnitch() { return false; }
 
-        public void onFailure(InetAddress from)
+        public void onFailure(InetAddress from, RequestFailureReason failureReason)
         {
             //listener.failedSnapshot();
             task.setException(new RuntimeException("Could not create snapshot at " + from));

File: src/java/org/apache/cassandra/service/ActiveRepairService.java
Patch:
@@ -43,6 +43,7 @@
 import org.apache.cassandra.dht.Bounds;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.Token;
+import org.apache.cassandra.exceptions.RequestFailureReason;
 import org.apache.cassandra.gms.ApplicationState;
 import org.apache.cassandra.gms.EndpointState;
 import org.apache.cassandra.gms.FailureDetector;
@@ -279,7 +280,7 @@ public boolean isLatencyForSnitch()
                 return false;
             }
 
-            public void onFailure(InetAddress from)
+            public void onFailure(InetAddress from, RequestFailureReason failureReason)
             {
                 status.set(false);
                 failedNodes.add(from.getHostAddress());

File: src/java/org/apache/cassandra/index/sasi/SASIIndex.java
Patch:
@@ -73,6 +73,7 @@ public SecondaryIndexBuilder getIndexBuildTask(ColumnFamilyStore cfs,
                    .filter((i) -> i instanceof SASIIndex)
                    .forEach((i) -> {
                        SASIIndex sasi = (SASIIndex) i;
+                       sasi.index.dropData(sstablesToRebuild);
                        sstablesToRebuild.stream()
                                         .filter((sstable) -> !sasi.index.hasSSTable(sstable))
                                         .forEach((sstable) -> {

File: src/java/org/apache/cassandra/index/sasi/SASIIndexBuilder.java
Patch:
@@ -99,7 +99,8 @@ public void build()
                             try (SSTableIdentityIterator partition = SSTableIdentityIterator.create(sstable, dataFile, key))
                             {
                                 // if the row has statics attached, it has to be indexed separately
-                                indexWriter.nextUnfilteredCluster(partition.staticRow());
+                                if (cfs.metadata.hasStaticColumns())
+                                    indexWriter.nextUnfilteredCluster(partition.staticRow());
 
                                 while (partition.hasNext())
                                     indexWriter.nextUnfilteredCluster(partition.next());

File: test/unit/org/apache/cassandra/SchemaLoader.java
Patch:
@@ -596,6 +596,7 @@ public static CFMetaData clusteringSASICFMD(String ksName, String cfName, String
                                            .addClusteringColumn("age", Int32Type.instance)
                                            .addRegularColumn("height", Int32Type.instance)
                                            .addRegularColumn("score", DoubleType.instance)
+                                           .addStaticColumn("nickname", UTF8Type.instance)
                                            .build();
 
         Indexes indexes = cfm.getIndexes();

File: src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java
Patch:
@@ -84,7 +84,7 @@ public void addUpdateForKey(ColumnFamily cf,
         if (cfm.comparator.isDense())
         {
             if (prefix.isEmpty())
-                throw new InvalidRequestException(String.format("Missing PRIMARY KEY part %s", cfm.clusteringColumns().iterator().next()));
+                throw new InvalidRequestException(String.format("Missing PRIMARY KEY part %s", cfm.clusteringColumns().iterator().next().name));
 
             // An empty name for the compact value is what we use to recognize the case where there is not column
             // outside the PK, see CreateStatement.

File: test/unit/org/apache/cassandra/db/marshal/ReversedTypeTest.java
Patch:
@@ -34,7 +34,7 @@ public void testReverseComparison()
         assert t.compare(bytes(4L), bytes(2L)) < 0;
 
         // the empty byte buffer is always the smaller
-        assert t.compare(EMPTY_BYTE_BUFFER, bytes(2L)) < 0;
-        assert t.compare(bytes(2L), EMPTY_BYTE_BUFFER) > 0;
+        assert t.compare(EMPTY_BYTE_BUFFER, bytes(2L)) > 0;
+        assert t.compare(bytes(2L), EMPTY_BYTE_BUFFER) < 0;
     }
 }

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -321,8 +321,9 @@ public void discardCompletedSegments(final UUID cfId, final CommitLogPosition lo
             }
             else
             {
-                logger.trace("Not safe to delete{} commit log segment {}; dirty is {}",
-                        (iter.hasNext() ? "" : " active"), segment, segment.dirtyString());
+                if (logger.isTraceEnabled())
+                    logger.trace("Not safe to delete{} commit log segment {}; dirty is {}",
+                            (iter.hasNext() ? "" : " active"), segment, segment.dirtyString());
             }
 
             // Don't mark or try to delete any newer segments once we've reached the one containing the

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -313,8 +313,9 @@ public void discardCompletedSegments(final UUID cfId, final ReplayPosition lower
             }
             else
             {
-                logger.trace("Not safe to delete{} commit log segment {}; dirty is {}",
-                        (iter.hasNext() ? "" : " active"), segment, segment.dirtyString());
+                if (logger.isTraceEnabled())
+                    logger.trace("Not safe to delete{} commit log segment {}; dirty is {}",
+                            (iter.hasNext() ? "" : " active"), segment, segment.dirtyString());
             }
 
             // Don't mark or try to delete any newer segments once we've reached the one containing the

File: src/java/org/apache/cassandra/db/compaction/CompactionController.java
Patch:
@@ -72,8 +72,7 @@ protected CompactionController(ColumnFamilyStore cfs, int maxValue)
 
     public CompactionController(ColumnFamilyStore cfs, Set<SSTableReader> compacting, int gcBefore)
     {
-        this(cfs, compacting, gcBefore,
-             CompactionManager.instance.getRateLimiter(),
+        this(cfs, compacting, gcBefore, null,
              cfs.getCompactionStrategyManager().getCompactionParams().tombstoneOption());
     }
 

File: src/java/org/apache/cassandra/io/sstable/ISSTableScanner.java
Patch:
@@ -28,6 +28,8 @@
 public interface ISSTableScanner extends UnfilteredPartitionIterator
 {
     public long getLengthInBytes();
+    public long getCompressedLengthInBytes();
     public long getCurrentPosition();
+    public long getBytesScanned();
     public String getBackingFiles();
 }

File: src/java/org/apache/cassandra/metrics/TableMetrics.java
Patch:
@@ -36,6 +36,7 @@
 import org.apache.cassandra.index.SecondaryIndexManager;
 import org.apache.cassandra.io.compress.CompressionMetadata;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
+import org.apache.cassandra.io.sstable.metadata.MetadataCollector;
 import org.apache.cassandra.repair.SystemDistributedKeyspace;
 import org.apache.cassandra.utils.EstimatedHistogram;
 import org.apache.cassandra.utils.TopKSampler;
@@ -819,7 +820,7 @@ private static Double computeCompressionRatio(Iterable<SSTableReader> sstables)
                 dataLengthSum += compressionMetadata.dataLength;
             }
         }
-        return dataLengthSum != 0 ? compressedLengthSum / dataLengthSum : 0;
+        return dataLengthSum != 0 ? compressedLengthSum / dataLengthSum : MetadataCollector.NO_COMPRESSION_RATIO;
     }
 
     /**

File: src/java/org/apache/cassandra/cql3/selection/Selection.java
Patch:
@@ -407,8 +407,6 @@ public void newRow(DecoratedKey partitionKey, Clustering clustering)
 
         /**
          * Builds the <code>ResultSet</code>
-         *
-         * @param protocolVersion the protocol version
          */
         public ResultSet build()
         {

File: src/java/org/apache/cassandra/db/aggregation/GroupingState.java
Patch:
@@ -35,7 +35,8 @@
  * </p>
  * <p>
  * {@code GroupingState} is only used for internal paging. When a new page is requested by a client the initial state
- * will always be empty.<br/>
+ * will always be empty.</p>
+ * <p>
  * If the state has a partition key but no clustering, it means that the previous group ended at the end of the
  * previous partition. If the clustering is not null it means that we are in the middle of a group.
  * </p>

File: src/java/org/apache/cassandra/db/commitlog/IntervalSet.java
Patch:
@@ -15,7 +15,7 @@
  * to a single interval covering both).
  *
  * The set is stored as a sorted map from interval starts to the corresponding end. The map satisfies
- *   curr().getKey() <= curr().getValue() < next().getKey()
+ *   {@code curr().getKey() <= curr().getValue() < next().getKey()}
  */
 public class IntervalSet<T extends Comparable<T>>
 {
@@ -132,7 +132,7 @@ public long serializedSize(IntervalSet<T> intervals)
      * Builder of interval sets, applying the necessary normalization while adding ranges.
      *
      * Data is stored as above, as a sorted map from interval starts to the corresponding end, which satisfies
-     *   curr().getKey() <= curr().getValue() < next().getKey()
+     *   {@code curr().getKey() <= curr().getValue() < next().getKey()}
      */
     static public class Builder<T extends Comparable<T>>
     {

File: src/java/org/apache/cassandra/db/compaction/CompactionController.java
Patch:
@@ -138,7 +138,7 @@ public Set<SSTableReader> getFullyExpiredSSTables()
      * works something like this;
      * 1. find "global" minTimestamp of overlapping sstables, compacting sstables and memtables containing any non-expired data
      * 2. build a list of fully expired candidates
-     * 3. check if the candidates to be dropped actually can be dropped (maxTimestamp < global minTimestamp)
+     * 3. check if the candidates to be dropped actually can be dropped {@code (maxTimestamp < global minTimestamp)}
      *    - if not droppable, remove from candidates
      * 4. return candidates.
      *

File: src/java/org/apache/cassandra/db/filter/ColumnFilter.java
Patch:
@@ -271,12 +271,12 @@ else if (cmp < 0) // The path is before this sub-selection, it's not included by
      * A builder for a {@code ColumnFilter} object.
      *
      * Note that the columns added to this build are the _queried_ column. Whether or not all columns
-     * are _fetched_ depends on which ctor you've used to obtained this builder, allColumnsBuilder (all
+     * are _fetched_ depends on which constructor you've used to obtained this builder, allColumnsBuilder (all
      * columns are fetched) or selectionBuilder (only the queried columns are fetched).
      *
      * Note that for a allColumnsBuilder, if no queried columns are added, this is interpreted as querying
      * all columns, not querying none (but if you know you want to query all columns, prefer
-     * {@link ColumnFilter#all)}. For selectionBuilder, adding no queried columns means no column will be
+     * {@link ColumnFilter#all(CFMetaData)}. For selectionBuilder, adding no queried columns means no column will be
      * fetched (so the builder will return {@code PartitionColumns.NONE}).
      */
     public static class Builder

File: src/java/org/apache/cassandra/db/partitions/PartitionUpdate.java
Patch:
@@ -722,7 +722,7 @@ public interface RangeTombstoneBuilder
              * Sets the start for the built range using the provided values.
              *
              * @param values the value for the start of the range. They act like the {@code clusteringValues} argument
-             * of the {@link PartitionUpdate.SimpleBuilder#row()} method, except that it doesn't have to be a full
+             * of the {@link SimpleBuilder#row(Object...)} method, except that it doesn't have to be a full
              * clustering, it can only be a prefix.
              * @return this builder.
              */
@@ -732,7 +732,7 @@ public interface RangeTombstoneBuilder
              * Sets the end for the built range using the provided values.
              *
              * @param values the value for the end of the range. They act like the {@code clusteringValues} argument
-             * of the {@link PartitionUpdate.SimpleBuilder#row()} method, except that it doesn't have to be a full
+             * of the {@link SimpleBuilder#row(Object...)} method, except that it doesn't have to be a full
              * clustering, it can only be a prefix.
              * @return this builder.
              */

File: src/java/org/apache/cassandra/db/rows/LazilyInitializedUnfilteredRowIterator.java
Patch:
@@ -27,7 +27,7 @@
  *
  * This is used during partition range queries when we know the partition key but want
  * to defer the initialization of the rest of the UnfilteredRowIterator until we need those informations.
- * See {@link org.apache.cassandra.io.sstable.format.big.BigTableScanner#KeyScanningIterator} for instance.
+ * See {@link org.apache.cassandra.io.sstable.format.big.BigTableScanner.KeyScanningIterator} for instance.
  */
 public abstract class LazilyInitializedUnfilteredRowIterator extends AbstractIterator<Unfiltered> implements UnfilteredRowIterator
 {

File: src/java/org/apache/cassandra/db/rows/WrappingUnfilteredRowIterator.java
Patch:
@@ -29,7 +29,7 @@
  * some of the methods.
  * <p>
  * Note that if most of what you want to do is modifying/filtering the returned
- * {@code Unfiltered}, {@link org.apache.cassandra.db.transform.Transformation.apply} can be a simpler option.
+ * {@code Unfiltered}, {@link org.apache.cassandra.db.transform.Transformation#apply(UnfilteredRowIterator,Transformation)} can be a simpler option.
  */
 public abstract class WrappingUnfilteredRowIterator extends UnmodifiableIterator<Unfiltered>  implements UnfilteredRowIterator
 {

File: src/java/org/apache/cassandra/db/view/ViewUpdateGenerator.java
Patch:
@@ -134,7 +134,7 @@ public void addBaseTableUpdate(Row existingBaseRow, Row mergedBaseRow)
 
     /**
      * Returns the updates that needs to be done to the view given the base table updates
-     * passed to {@link #generateViewMutations}.
+     * passed to {@link #addBaseTableUpdate}.
      *
      * @return the updates to do to the view.
      */

File: src/java/org/apache/cassandra/index/SecondaryIndexManager.java
Patch:
@@ -65,11 +65,11 @@
  * a table, (re)building during bootstrap or other streaming operations, flushing, reloading metadata
  * and so on.
  *
- * The Index interface defines a number of methods which return Callable<?>. These are primarily the
+ * The Index interface defines a number of methods which return {@code Callable<?>}. These are primarily the
  * management tasks for an index implementation. Most of them are currently executed in a blocking
  * fashion via submission to SIM's blockingExecutor. This provides the desired behaviour in pretty
  * much all cases, as tasks like flushing an index needs to be executed synchronously to avoid potentially
- * deadlocking on the FlushWriter or PostFlusher. Several of these Callable<?> returning methods on Index could
+ * deadlocking on the FlushWriter or PostFlusher. Several of these {@code Callable<?>} returning methods on Index could
  * then be defined with as void and called directly from SIM (rather than being run via the executor service).
  * Separating the task defintion from execution gives us greater flexibility though, so that in future, for example,
  * if the flush process allows it we leave open the possibility of executing more of these tasks asynchronously.

File: src/java/org/apache/cassandra/service/pager/AggregationQueryPager.java
Patch:
@@ -386,8 +386,8 @@ public Row next()
 
     /**
      * <code>PartitionIterator</code> for queries without Group By but with aggregates.
-     * <p>For maintaining backward compatibility we are forced to use the {@link DataLimits.CQLLimits} instead of the
-     * {@link DataLimits.CQLGroupByLimits}. Due to that pages need to be fetched in a different way.</p>
+     * <p>For maintaining backward compatibility we are forced to use the {@link org.apache.cassandra.db.filter.DataLimits.CQLLimits} instead of the
+     * {@link org.apache.cassandra.db.filter.DataLimits.CQLGroupByLimits}. Due to that pages need to be fetched in a different way.</p>
      */
     public final class AggregationPartitionIterator extends GroupByPartitionIterator
     {

File: src/java/org/apache/cassandra/utils/concurrent/OpOrder.java
Patch:
@@ -422,7 +422,7 @@ public void await()
         }
 
         /**
-         * returns the Group we are waiting on - any Group with .compareTo(getSyncPoint()) <= 0
+         * returns the Group we are waiting on - any Group with {@code .compareTo(getSyncPoint()) <= 0}
          * must complete before await() returns
          */
         public Group getSyncPoint()

File: test/unit/org/apache/cassandra/streaming/StreamTransferTaskTest.java
Patch:
@@ -134,7 +134,7 @@ public void testFailSessionDuringTransferShouldNotReleaseReferences() throws Exc
 
         // create streaming task that streams those two sstables
         StreamTransferTask task = new StreamTransferTask(session, cfs.metadata.cfId);
-        List<Ref<SSTableReader>> refs = new ArrayList<>(cfs.getSSTables().size());
+        List<Ref<SSTableReader>> refs = new ArrayList<>(cfs.getLiveSSTables().size());
         for (SSTableReader sstable : cfs.getLiveSSTables())
         {
             List<Range<Token>> ranges = new ArrayList<>();

File: test/unit/org/apache/cassandra/streaming/StreamTransferTaskTest.java
Patch:
@@ -134,7 +134,7 @@ public void testFailSessionDuringTransferShouldNotReleaseReferences() throws Exc
 
         // create streaming task that streams those two sstables
         StreamTransferTask task = new StreamTransferTask(session, cfs.metadata.cfId);
-        List<Ref<SSTableReader>> refs = new ArrayList<>(cfs.getSSTables().size());
+        List<Ref<SSTableReader>> refs = new ArrayList<>(cfs.getLiveSSTables().size());
         for (SSTableReader sstable : cfs.getLiveSSTables())
         {
             List<Range<Token>> ranges = new ArrayList<>();

File: src/java/org/apache/cassandra/tools/nodetool/stats/TableStatsPrinter.java
Patch:
@@ -75,6 +75,7 @@ public void printFormat(StatsHolder data, PrintStream out)
                 for (StatsTable table : tables)
                 {
                     out.println("\t\tTable" + (table.isIndex ? " (index): " + table.name : ": ") + table.name);
+                    out.println("\t\tSSTable count: " + table.sstableCount);
                     if (table.isLeveledSstable)
                         out.println("\t\tSSTables in each level: [" + String.join(", ",
                                                                                   table.sstablesInEachLevel) + "]");

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -113,7 +113,7 @@ public class Config
     @Deprecated
     public Integer concurrent_replicates = null;
 
-    public Integer memtable_flush_writers = 1;
+    public Integer memtable_flush_writers = null;
     public Integer memtable_heap_space_in_mb;
     public Integer memtable_offheap_space_in_mb;
     public Float memtable_cleanup_threshold = null;

File: src/java/org/apache/cassandra/transport/Event.java
Patch:
@@ -345,7 +345,7 @@ public int eventSerializedSize(int version)
         {
             if (target == Target.FUNCTION || target == Target.AGGREGATE)
             {
-                if (version >= Server.VERSION_3)
+                if (version >= Server.VERSION_4)
                     return CBUtil.sizeOfEnumValue(change)
                                + CBUtil.sizeOfEnumValue(target)
                                + CBUtil.sizeOfString(keyspace)

File: src/java/org/apache/cassandra/cql3/statements/TableAttributes.java
Patch:
@@ -142,7 +142,7 @@ private Double getDeprecatedCrcCheckChance(Map<String, String> compressionOpts)
         String value = compressionOpts.get(Option.CRC_CHECK_CHANCE.toString().toLowerCase());
         try
         {
-            return Double.parseDouble(value);
+            return Double.valueOf(value);
         }
         catch (NumberFormatException e)
         {

File: src/java/org/apache/cassandra/index/sasi/conf/IndexMode.java
Patch:
@@ -141,11 +141,11 @@ public static IndexMode getMode(ColumnDefinition column, Map<String, String> ind
             {
                 analyzerClass = Class.forName(indexOptions.get(INDEX_ANALYZER_CLASS_OPTION));
                 isAnalyzed = indexOptions.get(INDEX_ANALYZED_OPTION) == null
-                              ? true : Boolean.valueOf(indexOptions.get(INDEX_ANALYZED_OPTION));
+                              ? true : Boolean.parseBoolean(indexOptions.get(INDEX_ANALYZED_OPTION));
             }
             else if (indexOptions.get(INDEX_ANALYZED_OPTION) != null)
             {
-                isAnalyzed = Boolean.valueOf(indexOptions.get(INDEX_ANALYZED_OPTION));
+                isAnalyzed = Boolean.parseBoolean(indexOptions.get(INDEX_ANALYZED_OPTION));
             }
         }
         catch (ClassNotFoundException e)
@@ -163,7 +163,7 @@ else if (indexOptions.get(INDEX_ANALYZED_OPTION) != null)
 
             isLiteral = literalOption == null
                             ? (validator instanceof UTF8Type || validator instanceof AsciiType)
-                            : Boolean.valueOf(literalOption);
+                            : Boolean.parseBoolean(literalOption);
         }
         catch (Exception e)
         {

File: src/java/org/apache/cassandra/io/compress/LZ4Compressor.java
Patch:
@@ -207,7 +207,7 @@ public static Integer validateCompressionLevel(String compressionLevel) throws C
         Integer level;
         try
         {
-            level = Integer.parseInt(compressionLevel);
+            level = Integer.valueOf(compressionLevel);
         }
         catch (NumberFormatException e)
         {

File: src/java/org/apache/cassandra/io/sstable/format/SSTableFormat.java
Patch:
@@ -28,7 +28,7 @@
  */
 public interface SSTableFormat
 {
-    static boolean enableSSTableDevelopmentTestMode = Boolean.valueOf(System.getProperty("cassandra.test.sstableformatdevelopment","false"));
+    static boolean enableSSTableDevelopmentTestMode = Boolean.getBoolean("cassandra.test.sstableformatdevelopment");
 
 
     Version getLatestVersion();

File: src/java/org/apache/cassandra/net/OutboundTcpConnection.java
Patch:
@@ -74,7 +74,7 @@ public class OutboundTcpConnection extends FastThreadLocalThread
      * Enabled/disable TCP_NODELAY for intradc connections. Defaults to enabled.
      */
     private static final String INTRADC_TCP_NODELAY_PROPERTY = PREFIX + "otc_intradc_tcp_nodelay";
-    private static final boolean INTRADC_TCP_NODELAY = Boolean.valueOf(System.getProperty(INTRADC_TCP_NODELAY_PROPERTY, "true"));
+    private static final boolean INTRADC_TCP_NODELAY = Boolean.parseBoolean(System.getProperty(INTRADC_TCP_NODELAY_PROPERTY, "true"));
 
     /*
      * Size of buffer in output stream

File: src/java/org/apache/cassandra/schema/SchemaKeyspace.java
Patch:
@@ -66,7 +66,7 @@ private SchemaKeyspace()
 
     private static final Logger logger = LoggerFactory.getLogger(SchemaKeyspace.class);
 
-    private static final boolean FLUSH_SCHEMA_TABLES = Boolean.valueOf(System.getProperty("cassandra.test.flush_local_schema_changes", "true"));
+    private static final boolean FLUSH_SCHEMA_TABLES = Boolean.parseBoolean(System.getProperty("cassandra.test.flush_local_schema_changes", "true"));
 
     public static final String NAME = "system_schema";
 

File: src/java/org/apache/cassandra/service/NativeTransportService.java
Patch:
@@ -158,7 +158,7 @@ public void destroy()
      */
     public static boolean useEpoll()
     {
-        final boolean enableEpoll = Boolean.valueOf(System.getProperty("cassandra.native.epoll.enabled", "true"));
+        final boolean enableEpoll = Boolean.parseBoolean(System.getProperty("cassandra.native.epoll.enabled", "true"));
         return enableEpoll && Epoll.isAvailable();
     }
 

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -196,7 +196,7 @@ private static enum Mode { STARTING, NORMAL, JOINING, LEAVING, DECOMMISSIONED, M
 
     // true when keeping strict consistency while bootstrapping
     private boolean useStrictConsistency = Boolean.parseBoolean(System.getProperty("cassandra.consistent.rangemovement", "true"));
-    private static final boolean allowSimultaneousMoves = Boolean.valueOf(System.getProperty("cassandra.consistent.simultaneousmoves.allow","false"));
+    private static final boolean allowSimultaneousMoves = Boolean.parseBoolean(System.getProperty("cassandra.consistent.simultaneousmoves.allow","false"));
     private boolean replacing;
 
     private final StreamStateStore streamStateStore = new StreamStateStore();

File: src/java/org/apache/cassandra/tools/nodetool/TopPartitions.java
Patch:
@@ -59,7 +59,7 @@ public void execute(NodeProbe probe)
         checkArgument(topCount < size, "TopK count (-k) option must be smaller then the summary capacity (-s)");
         String keyspace = args.get(0);
         String cfname = args.get(1);
-        Integer duration = Integer.parseInt(args.get(2));
+        Integer duration = Integer.valueOf(args.get(2));
         // generate the list of samplers
         List<Sampler> targets = Lists.newArrayList();
         for (String s : samplers.split(","))
@@ -97,7 +97,7 @@ public int compare(CompositeData left, CompositeData right)
             if(!first)
                 System.out.println();
             System.out.println(result.getKey().toString()+ " Sampler:");
-            System.out.printf("  Cardinality: ~%d (%d capacity)%n", (long) sampling.get("cardinality"), size);
+            System.out.printf("  Cardinality: ~%d (%d capacity)%n", sampling.get("cardinality"), size);
             System.out.printf("  Top %d partitions:%n", topCount);
             if (topk.size() == 0)
             {

File: src/java/org/apache/cassandra/tracing/TraceStateImpl.java
Patch:
@@ -47,7 +47,7 @@ public class TraceStateImpl extends TraceState
 {
     private static final Logger logger = LoggerFactory.getLogger(TraceStateImpl.class);
     private static final int WAIT_FOR_PENDING_EVENTS_TIMEOUT_SECS =
-      Integer.valueOf(System.getProperty("cassandra.wait_for_tracing_events_timeout_secs", "1"));
+      Integer.parseInt(System.getProperty("cassandra.wait_for_tracing_events_timeout_secs", "1"));
 
     private final Set<Future<?>> pendingFutures = ConcurrentHashMap.newKeySet();
 

File: src/java/org/apache/cassandra/utils/HeapUtils.java
Patch:
@@ -188,7 +188,7 @@ private static Long getProcessIdFromJvmName()
         String jvmName = ManagementFactory.getRuntimeMXBean().getName();
         try
         {
-            return Long.parseLong(jvmName.split("@")[0]);
+            return Long.valueOf(jvmName.split("@")[0]);
         }
         catch (NumberFormatException e)
         {

File: src/java/org/apache/cassandra/metrics/TableMetrics.java
Patch:
@@ -20,6 +20,7 @@
 import java.nio.ByteBuffer;
 import java.util.*;
 import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.TimeUnit;
 
 import com.codahale.metrics.*;
@@ -788,7 +789,7 @@ protected TableTimer createTableTimer(String name, String alias, Timer keyspaceT
      */
     private boolean register(String name, String alias, Metric metric)
     {
-        boolean ret = allTableMetrics.putIfAbsent(name,  new HashSet<>()) == null;
+        boolean ret = allTableMetrics.putIfAbsent(name, ConcurrentHashMap.newKeySet()) == null;
         allTableMetrics.get(name).add(metric);
         all.put(name, alias);
         return ret;

File: src/java/org/apache/cassandra/db/partitions/AbstractBTreePartition.java
Patch:
@@ -169,7 +169,7 @@ public Row next(Clustering clustering)
 
     public UnfilteredRowIterator unfilteredIterator()
     {
-        return unfilteredIterator(metadata().getAllColumnFilter(), Slices.ALL, false);
+        return unfilteredIterator(ColumnFilter.selection(columns()), Slices.ALL, false);
     }
 
     public UnfilteredRowIterator unfilteredIterator(ColumnFilter selection, Slices slices, boolean reversed)

File: src/java/org/apache/cassandra/db/transform/BaseRows.java
Patch:
@@ -105,7 +105,8 @@ void add(Transformation transformation)
         super.add(transformation);
 
         // transform any existing data
-        staticRow = transformation.applyToStatic(staticRow);
+        if (staticRow != null)
+            staticRow = transformation.applyToStatic(staticRow);
         next = applyOne(next, transformation);
         partitionKey = transformation.applyToPartitionKey(partitionKey);
     }

File: test/unit/org/apache/cassandra/config/CFMetaDataTest.java
Patch:
@@ -150,7 +150,7 @@ private void checkInverses(CFMetaData cfm) throws Exception
         assert before.equals(after) : String.format("%n%s%n!=%n%s", before, after);
 
         // Test schema conversion
-        Mutation rm = SchemaKeyspace.makeCreateTableMutation(keyspace, cfm, FBUtilities.timestampMicros());
+        Mutation rm = SchemaKeyspace.makeCreateTableMutation(keyspace, cfm, FBUtilities.timestampMicros()).build();
         PartitionUpdate cfU = rm.getPartitionUpdate(Schema.instance.getId(SchemaKeyspace.NAME, SchemaKeyspace.TABLES));
         PartitionUpdate cdU = rm.getPartitionUpdate(Schema.instance.getId(SchemaKeyspace.NAME, SchemaKeyspace.COLUMNS));
 

File: test/unit/org/apache/cassandra/db/RecoveryManagerMissingHeaderTest.java
Patch:
@@ -118,7 +118,7 @@ public void testMissingHeader() throws IOException
 
         CommitLog.instance.resetUnsafe(false);
 
-        Assert.assertTrue(Util.equal(upd1, Util.getOnlyPartitionUnfiltered(Util.cmd(keyspace1.getColumnFamilyStore(CF_STANDARD1), dk).build()).unfilteredIterator()));
-        Assert.assertTrue(Util.equal(upd2, Util.getOnlyPartitionUnfiltered(Util.cmd(keyspace2.getColumnFamilyStore(CF_STANDARD3), dk).build()).unfilteredIterator()));
+        Assert.assertTrue(Util.sameContent(upd1, Util.getOnlyPartitionUnfiltered(Util.cmd(keyspace1.getColumnFamilyStore(CF_STANDARD1), dk).build()).unfilteredIterator()));
+        Assert.assertTrue(Util.sameContent(upd2, Util.getOnlyPartitionUnfiltered(Util.cmd(keyspace2.getColumnFamilyStore(CF_STANDARD3), dk).build()).unfilteredIterator()));
     }
 }

File: test/unit/org/apache/cassandra/db/compaction/TTLExpiryTest.java
Patch:
@@ -171,7 +171,7 @@ public void testSimpleExpire(boolean force10944Bug) throws InterruptedException
 
         new RowUpdateBuilder(cfs.metadata, timestamp, 1, key)
             .add("col2", ByteBufferUtil.EMPTY_BYTE_BUFFER)
-            .addMapEntry("col8", "bar", "foo")
+            .add("col8", Collections.singletonMap("bar", "foo"))
             .delete("col1")
             .build()
             .applyUnsafe();

File: test/unit/org/apache/cassandra/hints/LegacyHintsMigratorTest.java
Patch:
@@ -27,6 +27,7 @@
 import org.junit.Test;
 
 import org.apache.cassandra.SchemaLoader;
+import org.apache.cassandra.Util;
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.db.*;
@@ -159,7 +160,7 @@ private static void testMigrationIsComplete(File directory)
 
                 assertEquals(timestamp, hint.creationTime);
                 assertEquals(ttl, hint.gcgs);
-                assertMutationsEqual(mutation, hint.mutation);
+                assertTrue(mutation + " != " + hint.mutation, Util.sameContent(mutation, hint.mutation));
             }
         }
     }

File: test/unit/org/apache/cassandra/schema/DefsTest.java
Patch:
@@ -498,7 +498,7 @@ public void testUpdateColumnFamilyNoIndexes() throws ConfigurationException
     public void testDropIndex() throws ConfigurationException
     {
         // persist keyspace definition in the system keyspace
-        SchemaKeyspace.makeCreateKeyspaceMutation(Schema.instance.getKSMetaData(KEYSPACE6), FBUtilities.timestampMicros()).applyUnsafe();
+        SchemaKeyspace.makeCreateKeyspaceMutation(Schema.instance.getKSMetaData(KEYSPACE6), FBUtilities.timestampMicros()).build().applyUnsafe();
         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE6).getColumnFamilyStore(TABLE1i);
         String indexName = "birthdate_key_index";
 

File: test/unit/org/apache/cassandra/schema/SchemaKeyspaceTest.java
Patch:
@@ -164,7 +164,7 @@ public void testExtensions() throws IOException
     private static void updateTable(String keyspace, CFMetaData oldTable, CFMetaData newTable)
     {
         KeyspaceMetadata ksm = Schema.instance.getKeyspaceInstance(keyspace).getMetadata();
-        Mutation mutation = SchemaKeyspace.makeUpdateTableMutation(ksm, oldTable, newTable, FBUtilities.timestampMicros());
+        Mutation mutation = SchemaKeyspace.makeUpdateTableMutation(ksm, oldTable, newTable, FBUtilities.timestampMicros()).build();
         SchemaKeyspace.mergeSchema(Collections.singleton(mutation));
     }
 
@@ -173,7 +173,7 @@ private static void createTable(String keyspace, String cql)
         CFMetaData table = CFMetaData.compile(cql, keyspace);
 
         KeyspaceMetadata ksm = KeyspaceMetadata.create(keyspace, KeyspaceParams.simple(1), Tables.of(table));
-        Mutation mutation = SchemaKeyspace.makeCreateTableMutation(ksm, table, FBUtilities.timestampMicros());
+        Mutation mutation = SchemaKeyspace.makeCreateTableMutation(ksm, table, FBUtilities.timestampMicros()).build();
         SchemaKeyspace.mergeSchema(Collections.singleton(mutation));
     }
 
@@ -187,7 +187,7 @@ private static void checkInverses(CFMetaData cfm) throws Exception
         assert before.equals(after) : String.format("%n%s%n!=%n%s", before, after);
 
         // Test schema conversion
-        Mutation rm = SchemaKeyspace.makeCreateTableMutation(keyspace, cfm, FBUtilities.timestampMicros());
+        Mutation rm = SchemaKeyspace.makeCreateTableMutation(keyspace, cfm, FBUtilities.timestampMicros()).build();
         PartitionUpdate serializedCf = rm.getPartitionUpdate(Schema.instance.getId(SchemaKeyspace.NAME, SchemaKeyspace.TABLES));
         PartitionUpdate serializedCD = rm.getPartitionUpdate(Schema.instance.getId(SchemaKeyspace.NAME, SchemaKeyspace.COLUMNS));
 

File: test/unit/org/apache/cassandra/service/DataResolverTest.java
Patch:
@@ -246,7 +246,7 @@ public void testResolveDisjointMultipleRowsWithRangeTombstones()
 
         RangeTombstone tombstone1 = tombstone("1", "11", 1, nowInSec);
         RangeTombstone tombstone2 = tombstone("3", "31", 1, nowInSec);
-        PartitionUpdate update =new RowUpdateBuilder(cfm, nowInSec, 1L, dk).addRangeTombstone(tombstone1)
+        PartitionUpdate update = new RowUpdateBuilder(cfm, nowInSec, 1L, dk).addRangeTombstone(tombstone1)
                                                                                   .addRangeTombstone(tombstone2)
                                                                                   .buildUpdate();
 

File: test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java
Patch:
@@ -363,7 +363,7 @@ public void testTransferRangeTombstones() throws Exception
 
 
         updates = new RowUpdateBuilder(cfs.metadata, FBUtilities.timestampMicros() + 1, key);
-        updates.addRangeTombstone(Slice.make(comparator.make(5), comparator.make(7)))
+        updates.addRangeTombstone(5, 7)
                 .build()
                 .apply();
 

File: src/java/org/apache/cassandra/db/commitlog/CommitLogReader.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.zip.CRC32;
 
 import com.google.common.annotations.VisibleForTesting;
-import org.apache.commons.lang.StringUtils;
+import org.apache.commons.lang3.StringUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: src/java/org/apache/cassandra/db/partitions/AbstractBTreePartition.java
Patch:
@@ -169,7 +169,7 @@ public Row next(Clustering clustering)
 
     public UnfilteredRowIterator unfilteredIterator()
     {
-        return unfilteredIterator(ColumnFilter.all(metadata()), Slices.ALL, false);
+        return unfilteredIterator(ColumnFilter.selection(columns()), Slices.ALL, false);
     }
 
     public UnfilteredRowIterator unfilteredIterator(ColumnFilter selection, Slices slices, boolean reversed)

File: src/java/org/apache/cassandra/db/transform/BaseRows.java
Patch:
@@ -105,7 +105,8 @@ void add(Transformation transformation)
         super.add(transformation);
 
         // transform any existing data
-        staticRow = transformation.applyToStatic(staticRow);
+        if (staticRow != null)
+            staticRow = transformation.applyToStatic(staticRow);
         next = applyOne(next, transformation);
         partitionKey = transformation.applyToPartitionKey(partitionKey);
     }

File: test/unit/org/apache/cassandra/config/CFMetaDataTest.java
Patch:
@@ -150,7 +150,7 @@ private void checkInverses(CFMetaData cfm) throws Exception
         assert before.equals(after) : String.format("%n%s%n!=%n%s", before, after);
 
         // Test schema conversion
-        Mutation rm = SchemaKeyspace.makeCreateTableMutation(keyspace, cfm, FBUtilities.timestampMicros());
+        Mutation rm = SchemaKeyspace.makeCreateTableMutation(keyspace, cfm, FBUtilities.timestampMicros()).build();
         PartitionUpdate cfU = rm.getPartitionUpdate(Schema.instance.getId(SchemaKeyspace.NAME, SchemaKeyspace.TABLES));
         PartitionUpdate cdU = rm.getPartitionUpdate(Schema.instance.getId(SchemaKeyspace.NAME, SchemaKeyspace.COLUMNS));
 

File: test/unit/org/apache/cassandra/db/RecoveryManagerMissingHeaderTest.java
Patch:
@@ -118,7 +118,7 @@ public void testMissingHeader() throws IOException
 
         CommitLog.instance.resetUnsafe(false);
 
-        Assert.assertTrue(Util.equal(upd1, Util.getOnlyPartitionUnfiltered(Util.cmd(keyspace1.getColumnFamilyStore(CF_STANDARD1), dk).build()).unfilteredIterator()));
-        Assert.assertTrue(Util.equal(upd2, Util.getOnlyPartitionUnfiltered(Util.cmd(keyspace2.getColumnFamilyStore(CF_STANDARD3), dk).build()).unfilteredIterator()));
+        Assert.assertTrue(Util.sameContent(upd1, Util.getOnlyPartitionUnfiltered(Util.cmd(keyspace1.getColumnFamilyStore(CF_STANDARD1), dk).build()).unfilteredIterator()));
+        Assert.assertTrue(Util.sameContent(upd2, Util.getOnlyPartitionUnfiltered(Util.cmd(keyspace2.getColumnFamilyStore(CF_STANDARD3), dk).build()).unfilteredIterator()));
     }
 }

File: test/unit/org/apache/cassandra/db/compaction/TTLExpiryTest.java
Patch:
@@ -172,7 +172,7 @@ public void testSimpleExpire(boolean force10944Bug) throws InterruptedException
 
         new RowUpdateBuilder(cfs.metadata, timestamp, 1, key)
             .add("col2", ByteBufferUtil.EMPTY_BYTE_BUFFER)
-            .addMapEntry("col8", "bar", "foo")
+            .add("col8", Collections.singletonMap("bar", "foo"))
             .delete("col1")
             .build()
             .applyUnsafe();

File: test/unit/org/apache/cassandra/hints/LegacyHintsMigratorTest.java
Patch:
@@ -27,6 +27,7 @@
 import org.junit.Test;
 
 import org.apache.cassandra.SchemaLoader;
+import org.apache.cassandra.Util;
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.db.*;
@@ -159,7 +160,7 @@ private static void testMigrationIsComplete(File directory)
 
                 assertEquals(timestamp, hint.creationTime);
                 assertEquals(ttl, hint.gcgs);
-                assertMutationsEqual(mutation, hint.mutation);
+                assertTrue(mutation + " != " + hint.mutation, Util.sameContent(mutation, hint.mutation));
             }
         }
     }

File: test/unit/org/apache/cassandra/schema/DefsTest.java
Patch:
@@ -498,7 +498,7 @@ public void testUpdateColumnFamilyNoIndexes() throws ConfigurationException
     public void testDropIndex() throws ConfigurationException
     {
         // persist keyspace definition in the system keyspace
-        SchemaKeyspace.makeCreateKeyspaceMutation(Schema.instance.getKSMetaData(KEYSPACE6), FBUtilities.timestampMicros()).applyUnsafe();
+        SchemaKeyspace.makeCreateKeyspaceMutation(Schema.instance.getKSMetaData(KEYSPACE6), FBUtilities.timestampMicros()).build().applyUnsafe();
         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE6).getColumnFamilyStore(TABLE1i);
         String indexName = "birthdate_key_index";
 

File: test/unit/org/apache/cassandra/schema/SchemaKeyspaceTest.java
Patch:
@@ -164,7 +164,7 @@ public void testExtensions() throws IOException
     private static void updateTable(String keyspace, CFMetaData oldTable, CFMetaData newTable)
     {
         KeyspaceMetadata ksm = Schema.instance.getKeyspaceInstance(keyspace).getMetadata();
-        Mutation mutation = SchemaKeyspace.makeUpdateTableMutation(ksm, oldTable, newTable, FBUtilities.timestampMicros());
+        Mutation mutation = SchemaKeyspace.makeUpdateTableMutation(ksm, oldTable, newTable, FBUtilities.timestampMicros()).build();
         SchemaKeyspace.mergeSchema(Collections.singleton(mutation));
     }
 
@@ -173,7 +173,7 @@ private static void createTable(String keyspace, String cql)
         CFMetaData table = CFMetaData.compile(cql, keyspace);
 
         KeyspaceMetadata ksm = KeyspaceMetadata.create(keyspace, KeyspaceParams.simple(1), Tables.of(table));
-        Mutation mutation = SchemaKeyspace.makeCreateTableMutation(ksm, table, FBUtilities.timestampMicros());
+        Mutation mutation = SchemaKeyspace.makeCreateTableMutation(ksm, table, FBUtilities.timestampMicros()).build();
         SchemaKeyspace.mergeSchema(Collections.singleton(mutation));
     }
 
@@ -187,7 +187,7 @@ private static void checkInverses(CFMetaData cfm) throws Exception
         assert before.equals(after) : String.format("%n%s%n!=%n%s", before, after);
 
         // Test schema conversion
-        Mutation rm = SchemaKeyspace.makeCreateTableMutation(keyspace, cfm, FBUtilities.timestampMicros());
+        Mutation rm = SchemaKeyspace.makeCreateTableMutation(keyspace, cfm, FBUtilities.timestampMicros()).build();
         PartitionUpdate serializedCf = rm.getPartitionUpdate(Schema.instance.getId(SchemaKeyspace.NAME, SchemaKeyspace.TABLES));
         PartitionUpdate serializedCD = rm.getPartitionUpdate(Schema.instance.getId(SchemaKeyspace.NAME, SchemaKeyspace.COLUMNS));
 

File: test/unit/org/apache/cassandra/service/DataResolverTest.java
Patch:
@@ -246,7 +246,7 @@ public void testResolveDisjointMultipleRowsWithRangeTombstones()
 
         RangeTombstone tombstone1 = tombstone("1", "11", 1, nowInSec);
         RangeTombstone tombstone2 = tombstone("3", "31", 1, nowInSec);
-        PartitionUpdate update =new RowUpdateBuilder(cfm, nowInSec, 1L, dk).addRangeTombstone(tombstone1)
+        PartitionUpdate update = new RowUpdateBuilder(cfm, nowInSec, 1L, dk).addRangeTombstone(tombstone1)
                                                                                   .addRangeTombstone(tombstone2)
                                                                                   .buildUpdate();
 

File: test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java
Patch:
@@ -363,7 +363,7 @@ public void testTransferRangeTombstones() throws Exception
 
 
         updates = new RowUpdateBuilder(cfs.metadata, FBUtilities.timestampMicros() + 1, key);
-        updates.addRangeTombstone(Slice.make(comparator.make(5), comparator.make(7)))
+        updates.addRangeTombstone(5, 7)
                 .build()
                 .apply();
 

File: src/java/org/apache/cassandra/db/partitions/AbstractBTreePartition.java
Patch:
@@ -169,7 +169,7 @@ public Row next(Clustering clustering)
 
     public UnfilteredRowIterator unfilteredIterator()
     {
-        return unfilteredIterator(ColumnFilter.all(metadata()), Slices.ALL, false);
+        return unfilteredIterator(ColumnFilter.selection(columns()), Slices.ALL, false);
     }
 
     public UnfilteredRowIterator unfilteredIterator(ColumnFilter selection, Slices slices, boolean reversed)

File: src/java/org/apache/cassandra/db/transform/BaseRows.java
Patch:
@@ -105,7 +105,8 @@ void add(Transformation transformation)
         super.add(transformation);
 
         // transform any existing data
-        staticRow = transformation.applyToStatic(staticRow);
+        if (staticRow != null)
+            staticRow = transformation.applyToStatic(staticRow);
         next = applyOne(next, transformation);
         partitionKey = transformation.applyToPartitionKey(partitionKey);
     }

File: test/unit/org/apache/cassandra/config/CFMetaDataTest.java
Patch:
@@ -150,7 +150,7 @@ private void checkInverses(CFMetaData cfm) throws Exception
         assert before.equals(after) : String.format("%n%s%n!=%n%s", before, after);
 
         // Test schema conversion
-        Mutation rm = SchemaKeyspace.makeCreateTableMutation(keyspace, cfm, FBUtilities.timestampMicros());
+        Mutation rm = SchemaKeyspace.makeCreateTableMutation(keyspace, cfm, FBUtilities.timestampMicros()).build();
         PartitionUpdate cfU = rm.getPartitionUpdate(Schema.instance.getId(SchemaKeyspace.NAME, SchemaKeyspace.TABLES));
         PartitionUpdate cdU = rm.getPartitionUpdate(Schema.instance.getId(SchemaKeyspace.NAME, SchemaKeyspace.COLUMNS));
 

File: test/unit/org/apache/cassandra/db/RecoveryManagerMissingHeaderTest.java
Patch:
@@ -118,7 +118,7 @@ public void testMissingHeader() throws IOException
 
         CommitLog.instance.resetUnsafe(false);
 
-        Assert.assertTrue(Util.equal(upd1, Util.getOnlyPartitionUnfiltered(Util.cmd(keyspace1.getColumnFamilyStore(CF_STANDARD1), dk).build()).unfilteredIterator()));
-        Assert.assertTrue(Util.equal(upd2, Util.getOnlyPartitionUnfiltered(Util.cmd(keyspace2.getColumnFamilyStore(CF_STANDARD3), dk).build()).unfilteredIterator()));
+        Assert.assertTrue(Util.sameContent(upd1, Util.getOnlyPartitionUnfiltered(Util.cmd(keyspace1.getColumnFamilyStore(CF_STANDARD1), dk).build()).unfilteredIterator()));
+        Assert.assertTrue(Util.sameContent(upd2, Util.getOnlyPartitionUnfiltered(Util.cmd(keyspace2.getColumnFamilyStore(CF_STANDARD3), dk).build()).unfilteredIterator()));
     }
 }

File: test/unit/org/apache/cassandra/db/compaction/TTLExpiryTest.java
Patch:
@@ -172,7 +172,7 @@ public void testSimpleExpire(boolean force10944Bug) throws InterruptedException
 
         new RowUpdateBuilder(cfs.metadata, timestamp, 1, key)
             .add("col2", ByteBufferUtil.EMPTY_BYTE_BUFFER)
-            .addMapEntry("col8", "bar", "foo")
+            .add("col8", Collections.singletonMap("bar", "foo"))
             .delete("col1")
             .build()
             .applyUnsafe();

File: test/unit/org/apache/cassandra/hints/LegacyHintsMigratorTest.java
Patch:
@@ -27,6 +27,7 @@
 import org.junit.Test;
 
 import org.apache.cassandra.SchemaLoader;
+import org.apache.cassandra.Util;
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.db.*;
@@ -159,7 +160,7 @@ private static void testMigrationIsComplete(File directory)
 
                 assertEquals(timestamp, hint.creationTime);
                 assertEquals(ttl, hint.gcgs);
-                assertMutationsEqual(mutation, hint.mutation);
+                assertTrue(mutation + " != " + hint.mutation, Util.sameContent(mutation, hint.mutation));
             }
         }
     }

File: test/unit/org/apache/cassandra/schema/DefsTest.java
Patch:
@@ -498,7 +498,7 @@ public void testUpdateColumnFamilyNoIndexes() throws ConfigurationException
     public void testDropIndex() throws ConfigurationException
     {
         // persist keyspace definition in the system keyspace
-        SchemaKeyspace.makeCreateKeyspaceMutation(Schema.instance.getKSMetaData(KEYSPACE6), FBUtilities.timestampMicros()).applyUnsafe();
+        SchemaKeyspace.makeCreateKeyspaceMutation(Schema.instance.getKSMetaData(KEYSPACE6), FBUtilities.timestampMicros()).build().applyUnsafe();
         ColumnFamilyStore cfs = Keyspace.open(KEYSPACE6).getColumnFamilyStore(TABLE1i);
         String indexName = "birthdate_key_index";
 

File: test/unit/org/apache/cassandra/schema/SchemaKeyspaceTest.java
Patch:
@@ -164,7 +164,7 @@ public void testExtensions() throws IOException
     private static void updateTable(String keyspace, CFMetaData oldTable, CFMetaData newTable)
     {
         KeyspaceMetadata ksm = Schema.instance.getKeyspaceInstance(keyspace).getMetadata();
-        Mutation mutation = SchemaKeyspace.makeUpdateTableMutation(ksm, oldTable, newTable, FBUtilities.timestampMicros());
+        Mutation mutation = SchemaKeyspace.makeUpdateTableMutation(ksm, oldTable, newTable, FBUtilities.timestampMicros()).build();
         SchemaKeyspace.mergeSchema(Collections.singleton(mutation));
     }
 
@@ -173,7 +173,7 @@ private static void createTable(String keyspace, String cql)
         CFMetaData table = CFMetaData.compile(cql, keyspace);
 
         KeyspaceMetadata ksm = KeyspaceMetadata.create(keyspace, KeyspaceParams.simple(1), Tables.of(table));
-        Mutation mutation = SchemaKeyspace.makeCreateTableMutation(ksm, table, FBUtilities.timestampMicros());
+        Mutation mutation = SchemaKeyspace.makeCreateTableMutation(ksm, table, FBUtilities.timestampMicros()).build();
         SchemaKeyspace.mergeSchema(Collections.singleton(mutation));
     }
 
@@ -187,7 +187,7 @@ private static void checkInverses(CFMetaData cfm) throws Exception
         assert before.equals(after) : String.format("%n%s%n!=%n%s", before, after);
 
         // Test schema conversion
-        Mutation rm = SchemaKeyspace.makeCreateTableMutation(keyspace, cfm, FBUtilities.timestampMicros());
+        Mutation rm = SchemaKeyspace.makeCreateTableMutation(keyspace, cfm, FBUtilities.timestampMicros()).build();
         PartitionUpdate serializedCf = rm.getPartitionUpdate(Schema.instance.getId(SchemaKeyspace.NAME, SchemaKeyspace.TABLES));
         PartitionUpdate serializedCD = rm.getPartitionUpdate(Schema.instance.getId(SchemaKeyspace.NAME, SchemaKeyspace.COLUMNS));
 

File: test/unit/org/apache/cassandra/service/DataResolverTest.java
Patch:
@@ -245,7 +245,7 @@ public void testResolveDisjointMultipleRowsWithRangeTombstones()
 
         RangeTombstone tombstone1 = tombstone("1", "11", 1, nowInSec);
         RangeTombstone tombstone2 = tombstone("3", "31", 1, nowInSec);
-        PartitionUpdate update =new RowUpdateBuilder(cfm, nowInSec, 1L, dk).addRangeTombstone(tombstone1)
+        PartitionUpdate update = new RowUpdateBuilder(cfm, nowInSec, 1L, dk).addRangeTombstone(tombstone1)
                                                                                   .addRangeTombstone(tombstone2)
                                                                                   .buildUpdate();
 

File: test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java
Patch:
@@ -363,7 +363,7 @@ public void testTransferRangeTombstones() throws Exception
 
 
         updates = new RowUpdateBuilder(cfs.metadata, FBUtilities.timestampMicros() + 1, key);
-        updates.addRangeTombstone(Slice.make(comparator.make(5), comparator.make(7)))
+        updates.addRangeTombstone(5, 7)
                 .build()
                 .apply();
 

File: test/unit/org/apache/cassandra/io/sstable/CQLSSTableWriterTest.java
Patch:
@@ -503,7 +503,7 @@ public void testUnsetValues() throws Exception
         writer.addRow(5, 5, 5, "5");
 
         writer.close();
-        loadSSTables(dataDir, KS);
+        loadSSTables(writer.getInnermostDirectory(), KS);
 
         UntypedResultSet resultSet = QueryProcessor.executeInternal("SELECT * FROM " + KS + "." + TABLE);
         Iterator<UntypedResultSet.Row> iter = resultSet.iterator();

File: src/java/org/apache/cassandra/db/view/ViewUpdateGenerator.java
Patch:
@@ -190,7 +190,7 @@ private UpdateAction updateAction(Row existingBaseRow, Row mergedBaseRow)
 
         // If the update didn't modified this column, the cells will be the same object so it's worth checking
         if (before == after)
-            return before == null ? UpdateAction.NONE : UpdateAction.UPDATE_EXISTING;
+            return isLive(before) ? UpdateAction.UPDATE_EXISTING : UpdateAction.NONE;
 
         if (!isLive(before))
             return isLive(after) ? UpdateAction.NEW_ENTRY : UpdateAction.NONE;
@@ -451,7 +451,7 @@ private LivenessInfo computeLivenessInfoForEntry(Row baseRow)
 
         ColumnDefinition baseColumn = view.baseNonPKColumnsInViewPK.get(0);
         Cell cell = baseRow.getCell(baseColumn);
-        assert isLive(cell) : "We shouldn't have got there is the base row had no associated entry";
+        assert isLive(cell) : "We shouldn't have got there if the base row had no associated entry";
 
         long timestamp = Math.max(baseLiveness.timestamp(), cell.timestamp());
         return LivenessInfo.withExpirationTime(timestamp, cell.ttl(), cell.localDeletionTime());

File: src/java/org/apache/cassandra/db/view/ViewUpdateGenerator.java
Patch:
@@ -191,7 +191,7 @@ private UpdateAction updateAction(Row existingBaseRow, Row mergedBaseRow)
 
         // If the update didn't modified this column, the cells will be the same object so it's worth checking
         if (before == after)
-            return before == null ? UpdateAction.NONE : UpdateAction.UPDATE_EXISTING;
+            return isLive(before) ? UpdateAction.UPDATE_EXISTING : UpdateAction.NONE;
 
         if (!isLive(before))
             return isLive(after) ? UpdateAction.NEW_ENTRY : UpdateAction.NONE;
@@ -452,7 +452,7 @@ private LivenessInfo computeLivenessInfoForEntry(Row baseRow)
 
         ColumnDefinition baseColumn = view.baseNonPKColumnsInViewPK.get(0);
         Cell cell = baseRow.getCell(baseColumn);
-        assert isLive(cell) : "We shouldn't have got there is the base row had no associated entry";
+        assert isLive(cell) : "We shouldn't have got there if the base row had no associated entry";
 
         long timestamp = Math.max(baseLiveness.timestamp(), cell.timestamp());
         return LivenessInfo.withExpirationTime(timestamp, cell.ttl(), cell.localDeletionTime());

File: src/java/org/apache/cassandra/db/view/ViewUpdateGenerator.java
Patch:
@@ -191,7 +191,7 @@ private UpdateAction updateAction(Row existingBaseRow, Row mergedBaseRow)
 
         // If the update didn't modified this column, the cells will be the same object so it's worth checking
         if (before == after)
-            return before == null ? UpdateAction.NONE : UpdateAction.UPDATE_EXISTING;
+            return isLive(before) ? UpdateAction.UPDATE_EXISTING : UpdateAction.NONE;
 
         if (!isLive(before))
             return isLive(after) ? UpdateAction.NEW_ENTRY : UpdateAction.NONE;
@@ -452,7 +452,7 @@ private LivenessInfo computeLivenessInfoForEntry(Row baseRow)
 
         ColumnDefinition baseColumn = view.baseNonPKColumnsInViewPK.get(0);
         Cell cell = baseRow.getCell(baseColumn);
-        assert isLive(cell) : "We shouldn't have got there is the base row had no associated entry";
+        assert isLive(cell) : "We shouldn't have got there if the base row had no associated entry";
 
         long timestamp = Math.max(baseLiveness.timestamp(), cell.timestamp());
         return LivenessInfo.create(timestamp, cell.ttl(), cell.localDeletionTime());

File: src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java
Patch:
@@ -445,8 +445,8 @@ public static SSTableReader openForBatch(Descriptor descriptor, Set<Component> c
             long indexFileLength = new File(descriptor.filenameFor(Component.PRIMARY_INDEX)).length();
             int dataBufferSize = sstable.optimizationStrategy.bufferSize(statsMetadata.estimatedPartitionSize.percentile(DatabaseDescriptor.getDiskOptimizationEstimatePercentile()));
             int indexBufferSize = sstable.optimizationStrategy.bufferSize(indexFileLength / sstable.indexSummary.size());
-            sstable.ifile = ibuilder.bufferSize(sstable.optimizationStrategy.bufferSize(indexBufferSize)).complete();
-            sstable.dfile = dbuilder.bufferSize(sstable.optimizationStrategy.bufferSize(dataBufferSize)).complete();
+            sstable.ifile = ibuilder.bufferSize(indexBufferSize).complete();
+            sstable.dfile = dbuilder.bufferSize(dataBufferSize).complete();
             sstable.bf = FilterFactory.AlwaysPresent;
             sstable.setup(false);
             return sstable;

File: src/java/org/apache/cassandra/db/compaction/DateTieredCompactionStrategyOptions.java
Patch:
@@ -27,7 +27,7 @@
 
 public final class DateTieredCompactionStrategyOptions
 {
-    private static final Logger logger = LoggerFactory.getLogger(DateTieredCompactionStrategy.class);
+    private static final Logger logger = LoggerFactory.getLogger(DateTieredCompactionStrategyOptions.class);
     protected static final TimeUnit DEFAULT_TIMESTAMP_RESOLUTION = TimeUnit.MICROSECONDS;
     @Deprecated
     protected static final double DEFAULT_MAX_SSTABLE_AGE_DAYS = 365*1000;

File: test/long/org/apache/cassandra/db/commitlog/CommitLogStressTest.java
Patch:
@@ -130,12 +130,12 @@ static public void initialize() throws IOException
 
         SchemaLoader.loadSchema();
         SchemaLoader.schemaDefinition(""); // leave def. blank to maintain old behaviour
+        CommitLog.instance.stopUnsafe(true);
     }
 
     @Before
     public void cleanDir() throws IOException
     {
-        CommitLog.instance.stopUnsafe(true);
         File dir = new File(location);
         if (dir.isDirectory())
         {
@@ -208,9 +208,9 @@ public void testLog(ParameterizedClass compression, EncryptionContext encryption
             for (CommitLogSync sync : CommitLogSync.values())
             {
                 DatabaseDescriptor.setCommitLogSync(sync);
-                CommitLog commitLog = new CommitLog(CommitLogArchiver.disabled()).start();
-                // Need to enable reserve segment creation as close to test start as possible to minimize race
+                CommitLog commitLog = new CommitLog(CommitLogArchiver.disabled());
                 commitLog.segmentManager.enableReserveSegmentCreation();
+                commitLog.start();
                 testLog(commitLog);
                 assert !failed;
             }

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -137,7 +137,6 @@ private void maybeInitJmx()
             jmxServer = JMXServerUtils.createJMXServer(Integer.parseInt(jmxPort), localOnly);
             if (jmxServer == null)
                 return;
-            jmxServer.start();
         }
         catch (IOException e)
         {

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -32,6 +32,7 @@
 import com.google.common.base.Objects;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import org.apache.commons.lang3.ArrayUtils;
 import org.apache.commons.lang3.builder.HashCodeBuilder;
@@ -304,7 +305,7 @@ private void rebuild()
     {
         this.comparator = new ClusteringComparator(extractTypes(clusteringColumns));
 
-        Map<ByteBuffer, ColumnDefinition> newColumnMetadata = new HashMap<>();
+        Map<ByteBuffer, ColumnDefinition> newColumnMetadata = Maps.newHashMapWithExpectedSize(partitionKeyColumns.size() + clusteringColumns.size() + partitionColumns.size());
         for (ColumnDefinition def : partitionKeyColumns)
             newColumnMetadata.put(def.name.bytes, def);
         for (ColumnDefinition def : clusteringColumns)
@@ -1260,7 +1261,7 @@ public Builder addStaticColumn(ColumnIdentifier name, AbstractType type)
 
         public Set<String> usedColumnNames()
         {
-            Set<String> usedNames = new HashSet<>();
+            Set<String> usedNames = Sets.newHashSetWithExpectedSize(partitionKeys.size() + clusteringColumns.size() + staticColumns.size() + regularColumns.size());
             for (Pair<ColumnIdentifier, AbstractType> p : partitionKeys)
                 usedNames.add(p.left.toString());
             for (Pair<ColumnIdentifier, AbstractType> p : clusteringColumns)

File: src/java/org/apache/cassandra/cql3/statements/BatchStatement.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.concurrent.TimeUnit;
 
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Maps;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.slf4j.helpers.MessageFormatter;
@@ -554,7 +555,7 @@ public void addAll(CFMetaData table, PartitionColumns columns)
 
         public Map<UUID, PartitionColumns> build()
         {
-            Map<UUID, PartitionColumns> m = new HashMap<>();
+            Map<UUID, PartitionColumns> m = Maps.newHashMapWithExpectedSize(perTableBuilders.size());
             for (Map.Entry<UUID, PartitionColumns.Builder> p : perTableBuilders.entrySet())
                 m.put(p.getKey(), p.getValue().build());
             return m;

File: src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java
Patch:
@@ -22,6 +22,7 @@
 import com.google.common.base.Optional;
 import com.google.common.base.Strings;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Sets;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -173,7 +174,7 @@ private void validateTargetsForMultiColumnIndex(List<IndexTarget> targets)
         if (!properties.isCustom)
             throw new InvalidRequestException("Only CUSTOM indexes support multiple columns");
 
-        Set<ColumnIdentifier> columns = new HashSet<>();
+        Set<ColumnIdentifier> columns = Sets.newHashSetWithExpectedSize(targets.size());
         for (IndexTarget target : targets)
             if (!columns.add(target.column))
                 throw new InvalidRequestException("Duplicate column " + target.column + " in index target list");

File: src/java/org/apache/cassandra/cql3/statements/CreateViewStatement.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.stream.Collectors;
 
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Sets;
 
 import org.apache.cassandra.auth.Permission;
 import org.apache.cassandra.config.CFMetaData;
@@ -148,7 +149,7 @@ public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestV
                                                             baseName.getColumnFamily()));
         }
 
-        Set<ColumnIdentifier> included = new HashSet<>();
+        Set<ColumnIdentifier> included = Sets.newHashSetWithExpectedSize(selectClause.size());
         for (RawSelector selector : selectClause)
         {
             Selectable.Raw selectable = selector.selectable;

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -1279,7 +1279,7 @@ private static MerkleTrees createMerkleTrees(Iterable<SSTableReader> sstables, C
     {
         MerkleTrees tree = new MerkleTrees(cfs.getPartitioner());
         long allPartitions = 0;
-        Map<Range<Token>, Long> rangePartitionCounts = new HashMap<>();
+        Map<Range<Token>, Long> rangePartitionCounts = Maps.newHashMapWithExpectedSize(ranges.size());
         for (Range<Token> range : ranges)
         {
             long numPartitions = 0;

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -324,6 +324,7 @@ public void run()
                 {
                     keyspace.viewManager.buildAllViews();
                 }
+                logger.debug("Completed submission of build tasks for any materialized views defined at startup");
             }
         };
 

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -384,6 +384,7 @@ public void uncaughtException(Thread t, Throwable e)
             {
                 keyspace.viewManager.buildAllViews();
             }
+            logger.debug("Completed submission of build tasks for any materialized views defined at startup");
         };
 
         ScheduledExecutors.optionalTasks.schedule(viewRebuild, StorageService.RING_DELAY, TimeUnit.MILLISECONDS);

File: src/java/org/apache/cassandra/db/rows/BufferCell.java
Patch:
@@ -39,6 +39,7 @@ public class BufferCell extends AbstractCell
     public BufferCell(ColumnDefinition column, long timestamp, int ttl, int localDeletionTime, ByteBuffer value, CellPath path)
     {
         super(column);
+        assert !column.isPrimaryKeyColumn();
         assert column.isComplex() == (path != null);
         this.timestamp = timestamp;
         this.ttl = ttl;

File: test/unit/org/apache/cassandra/db/RowIndexEntryTest.java
Patch:
@@ -225,7 +225,7 @@ protected Unfiltered computeNext()
         private Unfiltered buildRow(Clustering clustering)
         {
             BTree.Builder<ColumnData> builder = BTree.builder(ColumnData.comparator);
-            builder.add(BufferCell.live(cfMeta.allColumns().iterator().next(),
+            builder.add(BufferCell.live(cfMeta.partitionColumns().iterator().next(),
                                         1L,
                                         ByteBuffer.allocate(0)));
             return BTreeRow.create(clustering, primaryKeyLivenessInfo, deletion, builder.build());

File: src/java/org/apache/cassandra/db/rows/BufferCell.java
Patch:
@@ -39,6 +39,7 @@ public class BufferCell extends AbstractCell
     public BufferCell(ColumnDefinition column, long timestamp, int ttl, int localDeletionTime, ByteBuffer value, CellPath path)
     {
         super(column);
+        assert !column.isPrimaryKeyColumn();
         assert column.isComplex() == (path != null);
         this.timestamp = timestamp;
         this.ttl = ttl;

File: test/unit/org/apache/cassandra/db/RowIndexEntryTest.java
Patch:
@@ -226,7 +226,7 @@ protected Unfiltered computeNext()
         private Unfiltered buildRow(Clustering clustering)
         {
             BTree.Builder<ColumnData> builder = BTree.builder(ColumnData.comparator);
-            builder.add(BufferCell.live(cfMeta.allColumns().iterator().next(),
+            builder.add(BufferCell.live(cfMeta.partitionColumns().iterator().next(),
                                         1L,
                                         ByteBuffer.allocate(0)));
             return BTreeRow.create(clustering, primaryKeyLivenessInfo, deletion, builder.build());

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -32,7 +32,6 @@
 import com.google.common.base.Objects;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import org.apache.commons.lang3.ArrayUtils;
 import org.apache.commons.lang3.builder.HashCodeBuilder;
@@ -305,7 +304,7 @@ private void rebuild()
     {
         this.comparator = new ClusteringComparator(extractTypes(clusteringColumns));
 
-        Map<ByteBuffer, ColumnDefinition> newColumnMetadata = Maps.newHashMapWithExpectedSize(partitionKeyColumns.size() + clusteringColumns.size() + partitionColumns.size());
+        Map<ByteBuffer, ColumnDefinition> newColumnMetadata = new HashMap<>();
         for (ColumnDefinition def : partitionKeyColumns)
             newColumnMetadata.put(def.name.bytes, def);
         for (ColumnDefinition def : clusteringColumns)
@@ -1261,7 +1260,7 @@ public Builder addStaticColumn(ColumnIdentifier name, AbstractType type)
 
         public Set<String> usedColumnNames()
         {
-            Set<String> usedNames = Sets.newHashSetWithExpectedSize(partitionKeys.size() + clusteringColumns.size() + staticColumns.size() + regularColumns.size());
+            Set<String> usedNames = new HashSet<>();
             for (Pair<ColumnIdentifier, AbstractType> p : partitionKeys)
                 usedNames.add(p.left.toString());
             for (Pair<ColumnIdentifier, AbstractType> p : clusteringColumns)

File: src/java/org/apache/cassandra/cql3/statements/BatchStatement.java
Patch:
@@ -22,7 +22,6 @@
 import java.util.concurrent.TimeUnit;
 
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Maps;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.slf4j.helpers.MessageFormatter;
@@ -555,7 +554,7 @@ public void addAll(CFMetaData table, PartitionColumns columns)
 
         public Map<UUID, PartitionColumns> build()
         {
-            Map<UUID, PartitionColumns> m = Maps.newHashMapWithExpectedSize(perTableBuilders.size());
+            Map<UUID, PartitionColumns> m = new HashMap<>();
             for (Map.Entry<UUID, PartitionColumns.Builder> p : perTableBuilders.entrySet())
                 m.put(p.getKey(), p.getValue().build());
             return m;

File: src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java
Patch:
@@ -22,7 +22,6 @@
 import com.google.common.base.Optional;
 import com.google.common.base.Strings;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Sets;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -174,7 +173,7 @@ private void validateTargetsForMultiColumnIndex(List<IndexTarget> targets)
         if (!properties.isCustom)
             throw new InvalidRequestException("Only CUSTOM indexes support multiple columns");
 
-        Set<ColumnIdentifier> columns = Sets.newHashSetWithExpectedSize(targets.size());
+        Set<ColumnIdentifier> columns = new HashSet<>();
         for (IndexTarget target : targets)
             if (!columns.add(target.column))
                 throw new InvalidRequestException("Duplicate column " + target.column + " in index target list");

File: src/java/org/apache/cassandra/cql3/statements/CreateViewStatement.java
Patch:
@@ -22,7 +22,6 @@
 import java.util.stream.Collectors;
 
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Sets;
 
 import org.apache.cassandra.auth.Permission;
 import org.apache.cassandra.config.CFMetaData;
@@ -149,7 +148,7 @@ public Event.SchemaChange announceMigration(boolean isLocalOnly) throws RequestV
                                                             baseName.getColumnFamily()));
         }
 
-        Set<ColumnIdentifier> included = Sets.newHashSetWithExpectedSize(selectClause.size());
+        Set<ColumnIdentifier> included = new HashSet<>();
         for (RawSelector selector : selectClause)
         {
             Selectable.Raw selectable = selector.selectable;

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -1279,7 +1279,7 @@ private static MerkleTrees createMerkleTrees(Iterable<SSTableReader> sstables, C
     {
         MerkleTrees tree = new MerkleTrees(cfs.getPartitioner());
         long allPartitions = 0;
-        Map<Range<Token>, Long> rangePartitionCounts = Maps.newHashMapWithExpectedSize(ranges.size());
+        Map<Range<Token>, Long> rangePartitionCounts = new HashMap<>();
         for (Range<Token> range : ranges)
         {
             long numPartitions = 0;

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -2221,6 +2221,6 @@ public static void setEncryptionContext(EncryptionContext ec)
 
     public static int searchConcurrencyFactor()
     {
-        return Integer.valueOf(System.getProperty("cassandra.search_concurrency_factor", "1"));
+        return Integer.parseInt(System.getProperty("cassandra.search_concurrency_factor", "1"));
     }
 }

File: src/java/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -59,7 +59,7 @@
  */
 public abstract class ReadCommand extends MonitorableImpl implements ReadQuery
 {
-    private static final int TEST_ITERATION_DELAY_MILLIS = Integer.valueOf(System.getProperty("cassandra.test.read_iteration_delay_ms", "0"));
+    private static final int TEST_ITERATION_DELAY_MILLIS = Integer.parseInt(System.getProperty("cassandra.test.read_iteration_delay_ms", "0"));
     protected static final Logger logger = LoggerFactory.getLogger(ReadCommand.class);
     public static final IVersionedSerializer<ReadCommand> serializer = new Serializer();
 

File: src/java/org/apache/cassandra/db/lifecycle/LogRecord.java
Patch:
@@ -123,9 +123,9 @@ public static LogRecord make(String line)
             Type type = Type.fromPrefix(matcher.group(1));
             return new LogRecord(type,
                                  matcher.group(2),
-                                 Long.valueOf(matcher.group(3)),
-                                 Integer.valueOf(matcher.group(4)),
-                                 Long.valueOf(matcher.group(5)),
+                                 Long.parseLong(matcher.group(3)),
+                                 Integer.parseInt(matcher.group(4)),
+                                 Long.parseLong(matcher.group(5)),
                                  line);
         }
         catch (IllegalArgumentException e)

File: src/java/org/apache/cassandra/db/monitoring/ApproximateTime.java
Patch:
@@ -36,7 +36,7 @@
 public class ApproximateTime
 {
     private static final Logger logger = LoggerFactory.getLogger(ApproximateTime.class);
-    private static final int CHECK_INTERVAL_MS = Math.max(5, Integer.valueOf(System.getProperty(Config.PROPERTY_PREFIX + "approximate_time_precision_ms", "10")));
+    private static final int CHECK_INTERVAL_MS = Math.max(5, Integer.parseInt(System.getProperty(Config.PROPERTY_PREFIX + "approximate_time_precision_ms", "10")));
 
     private static volatile long time = System.currentTimeMillis();
     static

File: src/java/org/apache/cassandra/db/monitoring/MonitoringTask.java
Patch:
@@ -51,13 +51,13 @@ public class MonitoringTask
     /**
      * Defines the interval for reporting any operations that have timed out.
      */
-    private static final int REPORT_INTERVAL_MS = Math.max(0, Integer.valueOf(System.getProperty(Config.PROPERTY_PREFIX + "monitoring_report_interval_ms", "5000")));
+    private static final int REPORT_INTERVAL_MS = Math.max(0, Integer.parseInt(System.getProperty(Config.PROPERTY_PREFIX + "monitoring_report_interval_ms", "5000")));
 
     /**
      * Defines the maximum number of unique timed out queries that will be reported in the logs.
      * Use a negative number to remove any limit.
      */
-    private static final int MAX_OPERATIONS = Integer.valueOf(System.getProperty(Config.PROPERTY_PREFIX + "monitoring_max_operations", "50"));
+    private static final int MAX_OPERATIONS = Integer.parseInt(System.getProperty(Config.PROPERTY_PREFIX + "monitoring_max_operations", "50"));
 
     @VisibleForTesting
     static MonitoringTask instance = make(REPORT_INTERVAL_MS, MAX_OPERATIONS);

File: src/java/org/apache/cassandra/index/sasi/utils/TypeUtil.java
Patch:
@@ -63,7 +63,7 @@ else if (validator instanceof LongType)
                         break;
 
                     default:
-                        upcastToken = Long.valueOf(UTF8Type.instance.getString(term));
+                        upcastToken = Long.parseLong(UTF8Type.instance.getString(term));
                 }
 
                 return LongType.instance.decompose(upcastToken);

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1895,7 +1895,7 @@ private void updateNetVersion(InetAddress endpoint, VersionedValue value)
     {
         try
         {
-            MessagingService.instance().setVersion(endpoint, Integer.valueOf(value.value));
+            MessagingService.instance().setVersion(endpoint, Integer.parseInt(value.value));
         }
         catch (NumberFormatException e)
         {

File: src/java/org/apache/cassandra/utils/progress/jmx/LegacyJMXProgressSupport.java
Patch:
@@ -102,6 +102,6 @@ else if (SESSION_SUCCESS_MATCHER.matcher(event.getMessage()).matches())
 
     protected static int getCmd(String tag)
     {
-        return Integer.valueOf(tag.split(":")[1]);
+        return Integer.parseInt(tag.split(":")[1]);
     }
 }

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -286,6 +286,9 @@ private CFMetaData(String keyspace,
         // A compact table should always have a clustering
         assert isCQLTable() || !clusteringColumns.isEmpty() : String.format("For table %s.%s, isDense=%b, isCompound=%b, clustering=%s", ksName, cfName, isDense, isCompound, clusteringColumns);
 
+        // All tables should have a partition key
+        assert !partitionKeyColumns.isEmpty() : String.format("Have no partition keys for table %s.%s", ksName, cfName);
+
         this.partitionKeyColumns = partitionKeyColumns;
         this.clusteringColumns = clusteringColumns;
         this.partitionColumns = partitionColumns;

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -286,6 +286,9 @@ private CFMetaData(String keyspace,
         // A compact table should always have a clustering
         assert isCQLTable() || !clusteringColumns.isEmpty() : String.format("For table %s.%s, isDense=%b, isCompound=%b, clustering=%s", ksName, cfName, isDense, isCompound, clusteringColumns);
 
+        // All tables should have a partition key
+        assert !partitionKeyColumns.isEmpty() : String.format("Have no partition keys for table %s.%s", ksName, cfName);
+
         this.partitionKeyColumns = partitionKeyColumns;
         this.clusteringColumns = clusteringColumns;
         this.partitionColumns = partitionColumns;

File: src/java/org/apache/cassandra/db/filter/DataLimits.java
Patch:
@@ -360,8 +360,7 @@ public CQLCounter(int nowInSec, boolean assumeLiveData)
             public void applyToPartition(DecoratedKey partitionKey, Row staticRow)
             {
                 rowInCurrentPartition = 0;
-                if (!staticRow.isEmpty() && (assumeLiveData || staticRow.hasLiveData(nowInSec)))
-                    hasLiveStaticRow = true;
+                hasLiveStaticRow = !staticRow.isEmpty() && (assumeLiveData || staticRow.hasLiveData(nowInSec));
             }
 
             @Override

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
Patch:
@@ -61,6 +61,7 @@ public enum CDCState {
         FORBIDDEN,
         CONTAINS
     }
+    Object cdcStateLock = new Object();
 
     private final static AtomicInteger nextId = new AtomicInteger(1);
     private static long replayLimitId;
@@ -614,7 +615,7 @@ public void setCDCState(CDCState newState)
             return;
 
         // Also synchronized in CDCSizeTracker.processNewSegment and .processDiscardedSegment
-        synchronized(this)
+        synchronized(cdcStateLock)
         {
             if (cdcState == CDCState.CONTAINS && newState != CDCState.CONTAINS)
                 throw new IllegalArgumentException("Cannot transition from CONTAINS to any other state.");

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegmentManagerCDC.java
Patch:
@@ -187,7 +187,7 @@ public void start()
         void processNewSegment(CommitLogSegment segment)
         {
             // See synchronization in CommitLogSegment.setCDCState
-            synchronized(segment)
+            synchronized(segment.cdcStateLock)
             {
                 segment.setCDCState(defaultSegmentSize() + totalCDCSizeOnDisk() > allowableCDCBytes()
                                     ? CDCState.FORBIDDEN
@@ -203,7 +203,7 @@ void processNewSegment(CommitLogSegment segment)
         void processDiscardedSegment(CommitLogSegment segment)
         {
             // See synchronization in CommitLogSegment.setCDCState
-            synchronized(segment)
+            synchronized(segment.cdcStateLock)
             {
                 // Add to flushed size before decrementing unflushed so we don't have a window of false generosity
                 if (segment.getCDCState() == CDCState.CONTAINS)

File: src/java/org/apache/cassandra/service/paxos/ProposeCallback.java
Patch:
@@ -59,7 +59,7 @@ public ProposeCallback(int totalTargets, int requiredTargets, boolean failFast,
 
     public void response(MessageIn<Boolean> msg)
     {
-        logger.debug("Propose response {} from {}", msg.payload, msg.from);
+        logger.trace("Propose response {} from {}", msg.payload, msg.from);
 
         if (msg.payload)
             accepts.incrementAndGet();

File: src/java/org/apache/cassandra/streaming/ConnectionHandler.java
Patch:
@@ -233,7 +233,7 @@ public boolean isClosed()
 
         protected void signalCloseDone()
         {
-            if (closeFuture == null)
+            if (!isClosed())
                 close();
 
             closeFuture.get().set(null);

File: src/java/org/apache/cassandra/streaming/StreamReceiveTask.java
Patch:
@@ -136,7 +136,7 @@ public long getTotalSize()
     public synchronized LifecycleTransaction getTransaction()
     {
         if (done)
-            throw new RuntimeException(String.format("Stream receive task {} of cf {} already finished.", session.planId(), cfId));
+            throw new RuntimeException(String.format("Stream receive task %s of cf %s already finished.", session.planId(), cfId));
         return txn;
     }
 

File: src/java/org/apache/cassandra/streaming/StreamReceiveTask.java
Patch:
@@ -18,8 +18,6 @@
 package org.apache.cassandra.streaming;
 
 import java.io.File;
-import java.io.IOError;
-import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;

File: test/unit/org/apache/cassandra/db/compaction/DateTieredCompactionStrategyTest.java
Patch:
@@ -368,5 +368,6 @@ public void testSTCSBigWindow()
         AbstractCompactionTask task = dtcs.getNextBackgroundTask(0);
         assertEquals(20, task.transaction.originals().size());
         task.transaction.abort();
+        cfs.truncateBlocking();
     }
 }

File: test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java
Patch:
@@ -103,7 +103,7 @@ public static void loadSchema() throws ConfigurationException
                                                                                SchemaLoader.fullTextSearchSASICFMD(KS_NAME, FTS_CF_NAME))));
     }
 
-    @After
+    @Before
     public void cleanUp()
     {
         Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME).truncateBlocking();
@@ -1093,8 +1093,8 @@ public void testInsertingIncorrectValuesIntoAgeIndex()
         Mutation rm = new Mutation(KS_NAME, decoratedKey(AsciiType.instance.decompose("key1")));
         update(rm, new ArrayList<Cell>()
         {{
-            add(buildCell(firstName, AsciiType.instance.decompose("pavel"), System.currentTimeMillis()));
             add(buildCell(age, LongType.instance.decompose(26L), System.currentTimeMillis()));
+            add(buildCell(firstName, AsciiType.instance.decompose("pavel"), System.currentTimeMillis()));
         }});
         rm.apply();
 

File: src/java/org/apache/cassandra/db/rows/BufferCell.java
Patch:
@@ -125,5 +125,4 @@ public long unsharedHeapSizeExcludingData()
     {
         return EMPTY_SIZE + ObjectSizes.sizeOnHeapExcludingData(value) + (path == null ? 0 : path.unsharedHeapSizeExcludingData());
     }
-
 }

File: src/java/org/apache/cassandra/db/rows/BufferCell.java
Patch:
@@ -125,5 +125,4 @@ public long unsharedHeapSizeExcludingData()
     {
         return EMPTY_SIZE + ObjectSizes.sizeOnHeapExcludingData(value) + (path == null ? 0 : path.unsharedHeapSizeExcludingData());
     }
-
 }

File: src/java/org/apache/cassandra/db/rows/Cell.java
Patch:
@@ -145,11 +145,11 @@ protected Cell(ColumnDefinition column)
 
     public interface Serializer
     {
-        public void serialize(Cell cell, DataOutputPlus out, LivenessInfo rowLiveness, SerializationHeader header) throws IOException;
+        public void serialize(Cell cell, ColumnDefinition column, DataOutputPlus out, LivenessInfo rowLiveness, SerializationHeader header) throws IOException;
 
         public Cell deserialize(DataInputPlus in, LivenessInfo rowLiveness, ColumnDefinition column, SerializationHeader header, SerializationHelper helper) throws IOException;
 
-        public long serializedSize(Cell cell, LivenessInfo rowLiveness, SerializationHeader header);
+        public long serializedSize(Cell cell, ColumnDefinition column, LivenessInfo rowLiveness, SerializationHeader header);
 
         // Returns if the skipped cell was an actual cell (i.e. it had its presence flag).
         public boolean skip(DataInputPlus in, ColumnDefinition column, SerializationHeader header) throws IOException;

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -1417,7 +1417,7 @@ public static void setCommitLogCompression(ParameterizedClass compressor)
     * (one segment in compression, one written to, one in reserve); delays in compression may cause the log to use
     * more, depending on how soon the sync policy stops all writing threads.
     */
-    public static int getCommitLogMaxCompressionBuffersPerPool()
+    public static int getCommitLogMaxCompressionBuffersInPool()
     {
         return conf.commitlog_max_compression_buffers_in_pool;
     }

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -109,6 +109,7 @@ private static CommitLog construct()
         segmentManager = DatabaseDescriptor.isCDCEnabled()
                          ? new CommitLogSegmentManagerCDC(this, DatabaseDescriptor.getCommitLogLocation())
                          : new CommitLogSegmentManagerStandard(this, DatabaseDescriptor.getCommitLogLocation());
+
         // register metrics
         metrics.attach(executor, segmentManager);
     }

File: src/java/org/apache/cassandra/net/OutboundTcpConnection.java
Patch:
@@ -301,8 +301,9 @@ private void writeConnected(QueuedMessage qm, boolean flush)
             if (flush)
                 out.flush();
         }
-        catch (Exception e)
+        catch (Throwable e)
         {
+            JVMStabilityInspector.inspectThrowable(e);
             disconnect();
             if (e instanceof IOException || e.getCause() instanceof IOException)
             {

File: test/unit/org/apache/cassandra/cql3/CQLTester.java
Patch:
@@ -64,6 +64,7 @@
 import org.apache.cassandra.transport.Server;
 import org.apache.cassandra.transport.messages.ResultMessage;
 import org.apache.cassandra.utils.ByteBufferUtil;
+import org.apache.cassandra.utils.FBUtilities;
 
 import static junit.framework.Assert.assertNotNull;
 
@@ -80,6 +81,7 @@ public abstract class CQLTester
     protected static final boolean REUSE_PREPARED = Boolean.valueOf(System.getProperty("cassandra.test.reuse_prepared", "true"));
     protected static final long ROW_CACHE_SIZE_IN_MB = Integer.valueOf(System.getProperty("cassandra.test.row_cache_size_in_mb", "0"));
     private static final AtomicInteger seqNumber = new AtomicInteger();
+    protected static final ByteBuffer TOO_BIG = ByteBuffer.allocate(FBUtilities.MAX_UNSIGNED_SHORT + 1024);
 
     private static org.apache.cassandra.transport.Server server;
     protected static final int nativePort;

File: src/java/org/apache/cassandra/net/OutboundTcpConnection.java
Patch:
@@ -301,8 +301,9 @@ private void writeConnected(QueuedMessage qm, boolean flush)
             if (flush)
                 out.flush();
         }
-        catch (Exception e)
+        catch (Throwable e)
         {
+            JVMStabilityInspector.inspectThrowable(e);
             disconnect();
             if (e instanceof IOException || e.getCause() instanceof IOException)
             {

File: test/unit/org/apache/cassandra/cql3/CQLTester.java
Patch:
@@ -64,6 +64,7 @@
 import org.apache.cassandra.transport.Server;
 import org.apache.cassandra.transport.messages.ResultMessage;
 import org.apache.cassandra.utils.ByteBufferUtil;
+import org.apache.cassandra.utils.FBUtilities;
 
 import static junit.framework.Assert.assertNotNull;
 
@@ -80,6 +81,7 @@ public abstract class CQLTester
     protected static final boolean REUSE_PREPARED = Boolean.valueOf(System.getProperty("cassandra.test.reuse_prepared", "true"));
     protected static final long ROW_CACHE_SIZE_IN_MB = Integer.valueOf(System.getProperty("cassandra.test.row_cache_size_in_mb", "0"));
     private static final AtomicInteger seqNumber = new AtomicInteger();
+    protected static final ByteBuffer TOO_BIG = ByteBuffer.allocate(FBUtilities.MAX_UNSIGNED_SHORT + 1024);
 
     private static org.apache.cassandra.transport.Server server;
     protected static final int nativePort;

File: src/java/org/apache/cassandra/net/OutboundTcpConnection.java
Patch:
@@ -292,8 +292,9 @@ private void writeConnected(QueuedMessage qm, boolean flush)
             if (flush)
                 out.flush();
         }
-        catch (Exception e)
+        catch (Throwable e)
         {
+            JVMStabilityInspector.inspectThrowable(e);
             disconnect();
             if (e instanceof IOException || e.getCause() instanceof IOException)
             {

File: test/unit/org/apache/cassandra/cql3/CQLTester.java
Patch:
@@ -81,6 +81,7 @@ public abstract class CQLTester
     protected static final boolean USE_PREPARED_VALUES = Boolean.valueOf(System.getProperty("cassandra.test.use_prepared", "true"));
     protected static final long ROW_CACHE_SIZE_IN_MB = Integer.valueOf(System.getProperty("cassandra.test.row_cache_size_in_mb", "0"));
     private static final AtomicInteger seqNumber = new AtomicInteger();
+    protected static final ByteBuffer TOO_BIG = ByteBuffer.allocate(1024 * 65);
 
     private static org.apache.cassandra.transport.Server server;
     protected static final int nativePort;

File: src/java/org/apache/cassandra/net/OutboundTcpConnection.java
Patch:
@@ -285,8 +285,9 @@ private void writeConnected(QueuedMessage qm, boolean flush)
             if (flush)
                 out.flush();
         }
-        catch (Exception e)
+        catch (Throwable e)
         {
+            JVMStabilityInspector.inspectThrowable(e);
             disconnect();
             if (e instanceof IOException)
             {

File: test/unit/org/apache/cassandra/cql3/CQLTester.java
Patch:
@@ -51,6 +51,7 @@
 import org.apache.cassandra.exceptions.*;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.serializers.TypeSerializer;
+import org.apache.cassandra.utils.FBUtilities;
 
 /**
  * Base class for CQL tests.
@@ -63,6 +64,7 @@ public abstract class CQLTester
     private static final boolean USE_PREPARED_VALUES = Boolean.valueOf(System.getProperty("cassandra.test.use_prepared", "true"));
     protected static final long ROW_CACHE_SIZE_IN_MB = Integer.valueOf(System.getProperty("cassandra.test.row_cache_size_in_mb", "0"));
     private static final AtomicInteger seqNumber = new AtomicInteger();
+    protected static final ByteBuffer TOO_BIG = ByteBuffer.allocate(FBUtilities.MAX_UNSIGNED_SHORT + 1024);
 
     static
     {

File: test/unit/org/apache/cassandra/io/compress/CompressorTest.java
Patch:
@@ -81,7 +81,7 @@ public void testArrayUncompress(byte[] data, int off, int len) throws IOExceptio
 
         // need byte[] representation which direct buffers don't have
         byte[] compressedBytes = new byte[compressed.capacity()];
-        ByteBufferUtil.arrayCopy(compressed, outOffset, compressedBytes, outOffset, compressed.capacity() - outOffset);
+        ByteBufferUtil.arrayCopy(compressed, outOffset, compressedBytes, outOffset, compressed.limit() - outOffset);
 
         final int decompressedLength = compressor.uncompress(compressedBytes, outOffset, compressed.remaining(), restored, restoreOffset);
 

File: test/unit/org/apache/cassandra/io/compress/CompressorTest.java
Patch:
@@ -81,7 +81,7 @@ public void testArrayUncompress(byte[] data, int off, int len) throws IOExceptio
 
         // need byte[] representation which direct buffers don't have
         byte[] compressedBytes = new byte[compressed.capacity()];
-        ByteBufferUtil.arrayCopy(compressed, outOffset, compressedBytes, outOffset, compressed.capacity() - outOffset);
+        ByteBufferUtil.arrayCopy(compressed, outOffset, compressedBytes, outOffset, compressed.limit() - outOffset);
 
         final int decompressedLength = compressor.uncompress(compressedBytes, outOffset, compressed.remaining(), restored, restoreOffset);
 

File: test/unit/org/apache/cassandra/io/compress/CompressorTest.java
Patch:
@@ -80,7 +80,7 @@ public void testArrayUncompress(byte[] data, int off, int len) throws IOExceptio
 
         // need byte[] representation which direct buffers don't have
         byte[] compressedBytes = new byte[compressed.capacity()];
-        ByteBufferUtil.arrayCopy(compressed, outOffset, compressedBytes, outOffset, compressed.capacity() - outOffset);
+        ByteBufferUtil.arrayCopy(compressed, outOffset, compressedBytes, outOffset, compressed.limit() - outOffset);
 
         final int decompressedLength = compressor.uncompress(compressedBytes, outOffset, compressed.remaining(), restored, restoreOffset);
 

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -593,7 +593,7 @@ public int compare(InetAddress endpoint1, InetAddress endpoint2)
             }
         }
 
-        if (conf.cdc_enabled != null)
+        if (conf.cdc_enabled == true)
         {
             logger.info("cdc_enabled is true. Starting casssandra node with Change-Data-Capture enabled.");
         }

File: src/java/org/apache/cassandra/db/filter/RowFilter.java
Patch:
@@ -1011,7 +1011,7 @@ public boolean isSatisfiedBy(CFMetaData metadata, DecoratedKey partitionKey, Row
      * registered before sending or receiving any messages containing expressions of that type.
      * Use of custom filtering expressions in a mixed version cluster should be handled with caution
      * as the order in which types are registered is significant: if continuity of use during upgrades
-     * is important, new types should registered last & obsoleted types should still be registered (
+     * is important, new types should registered last and obsoleted types should still be registered (
      * or dummy implementations registered in their place) to preserve consistent identifiers across
      * the cluster).
      *

File: src/java/org/apache/cassandra/db/rows/UnfilteredSerializer.java
Patch:
@@ -48,7 +48,7 @@
  *     where:
  *     <ul>
  *       <li>{@code <clustering>} is the row clustering as serialized by
- *           {@link Clustering.serializer} (note that static row are an
+ *           {@link org.apache.cassandra.db.Clustering.Serializer} (note that static row are an
  *           exception and don't have this). </li>
  *       <li>{@code <sizes>} are the sizes of the whole unfiltered on disk and
  *           of the previous unfiltered. This is only present for sstables and
@@ -60,7 +60,7 @@
  *           by the flags and if present, it conists of both the deletion
  *           timestamp and local deletion time.</li>
  *       <li>{@code <columns>} are the columns present in the row  encoded by
- *           {@link Columns.serializer#serializeSubset}. It is absent if the row
+ *           {@link org.apache.cassandra.db.Columns.Serializer#serializeSubset}. It is absent if the row
  *           contains all the columns of the {@code SerializationHeader} (which
  *           is then indicated by a flag). </li>
  *       <li>{@code <columns_data>} is the data for each of the column present
@@ -80,7 +80,7 @@
  *   </li>
  *   <li>
  *     {@code <marker>} is {@code <bound><deletion>} where {@code <bound>} is
- *     the marker bound as serialized by {@link ClusteringBoundOrBoundary.serializer}
+ *     the marker bound as serialized by {@link org.apache.cassandra.db.ClusteringBoundOrBoundary.Serializer}
  *     and {@code <deletion>} is the marker deletion time.
  *   </li>
  * </ul>

File: src/java/org/apache/cassandra/db/rows/WithOnlyQueriedData.java
Patch:
@@ -23,7 +23,7 @@
 
 /**
  * Function to skip cells (from an iterator) that are not part of those queried by the user
- * according to the provided {@code ColumnFilter}. See {@link UnfilteredRowIterators#withoutSkippedValues}
+ * according to the provided {@code ColumnFilter}. See {@link UnfilteredRowIterators#withOnlyQueriedData}
  * for more details.
  */
 public class WithOnlyQueriedData<I extends BaseRowIterator<?>> extends Transformation<I>

File: src/java/org/apache/cassandra/db/view/View.java
Patch:
@@ -81,9 +81,6 @@ public ViewDefinition getDefinition()
 
     /**
      * This updates the columns stored which are dependent on the base CFMetaData.
-     *
-     * @return true if the view contains only columns which are part of the base's primary key; false if there is at
-     *         least one column which is not.
      */
     public void updateDefinition(ViewDefinition definition)
     {

File: src/java/org/apache/cassandra/hadoop/cql3/CqlBulkOutputFormat.java
Patch:
@@ -45,10 +45,10 @@
  * As is the case with the {@link org.apache.cassandra.hadoop.cql3.CqlOutputFormat}, 
  * you need to set the prepared statement in your
  * Hadoop job Configuration. The {@link CqlConfigHelper} class, through its
- * {@link ConfigHelper#setOutputPreparedStatement} method, is provided to make this
+ * {@link org.apache.cassandra.hadoop.ConfigHelper#setOutputPreparedStatement} method, is provided to make this
  * simple.
  * you need to set the Keyspace. The {@link ConfigHelper} class, through its
- * {@link ConfigHelper#setOutputColumnFamily} method, is provided to make this
+ * {@link org.apache.cassandra.hadoop.ConfigHelper#setOutputColumnFamily} method, is provided to make this
  * simple.
  * </p>
  */

File: src/java/org/apache/cassandra/index/Index.java
Patch:
@@ -75,7 +75,7 @@
  * scheduling its execution can rest with SecondaryIndexManager. For instance, a task like reloading index metadata
  * following potential updates caused by modifications to the base table may be performed in a blocking way. In
  * contrast, adding a new index may require it to be built from existing SSTable data, a potentially expensive task
- * which should be performed asyncronously.
+ * which should be performed asynchronously.
  *
  * Index Selection:
  * There are two facets to index selection, write time and read time selection. The former is concerned with
@@ -108,7 +108,7 @@
  * whether any of them are supported by a registered Index. supportsExpression is used to filter out Indexes which
  * cannot support a given Expression. After filtering, the set of candidate indexes are ranked according to the result
  * of getEstimatedResultRows and the most selective (i.e. the one expected to return the smallest number of results) is
- * chosen. A Searcher instance is then obtained from the searcherFor method & used to perform the actual Index lookup.
+ * chosen. A Searcher instance is then obtained from the searcherFor method and used to perform the actual Index lookup.
  * Finally, Indexes can define a post processing step to be performed on the coordinator, after results (partitions from
  * the primary table) have been received from replicas and reconciled. This post processing is defined as a
  * java.util.functions.BiFunction<PartitionIterator, RowFilter, PartitionIterator>, that is a function which takes as

File: src/java/org/apache/cassandra/index/IndexNotAvailableException.java
Patch:
@@ -25,7 +25,7 @@ public final class IndexNotAvailableException extends RuntimeException
 {
     /**
      * Creates a new <code>IndexNotAvailableException</code> for the specified index.
-     * @param name the index name
+     * @param index the index
      */
     public IndexNotAvailableException(Index index)
     {

File: src/java/org/apache/cassandra/index/SecondaryIndexManager.java
Patch:
@@ -561,7 +561,7 @@ public void indexPartition(UnfilteredRowIterator partition, OpOrder.Group opGrou
      * Delete all data from all indexes for this partition.
      * For when cleanup rips a partition out entirely.
      *
-     * TODO : improve cleanup transaction to batch updates & perform them async
+     * TODO : improve cleanup transaction to batch updates and perform them async
      */
     public void deletePartition(UnfilteredRowIterator partition, int nowInSec)
     {

File: src/java/org/apache/cassandra/locator/TokenMetadata.java
Patch:
@@ -126,7 +126,7 @@ private TokenMetadata(BiMultiValMap<Token, InetAddress> tokenToEndpointMap, BiMa
     }
 
     /**
-     * To be used by tests only (via {@link StorageService.setPartitionerUnsafe}).
+     * To be used by tests only (via {@link org.apache.cassandra.service.StorageService#setPartitionerUnsafe}).
      */
     @VisibleForTesting
     public TokenMetadata cloneWithNewPartitioner(IPartitioner newPartitioner)

File: src/java/org/apache/cassandra/metrics/HintsServiceMetrics.java
Patch:
@@ -18,7 +18,7 @@
 package org.apache.cassandra.metrics;
 
 /**
- * Metrics for {@link HintsService}.
+ * Metrics for {@link org.apache.cassandra.hints.HintsService}.
  */
 public final class HintsServiceMetrics
 {

File: src/java/org/apache/cassandra/utils/concurrent/Ref.java
Patch:
@@ -68,13 +68,14 @@
  * This class' functionality is achieved by what may look at first glance like a complex web of references,
  * but boils down to:
  *
+ * {@code
  * Target --> selfRef --> [Ref.State] <--> Ref.GlobalState --> Tidy
  *                                             ^
  *                                             |
  * Ref ----------------------------------------
  *                                             |
  * Global -------------------------------------
- *
+ * }
  * So that, if Target is collected, Impl is collected and, hence, so is selfRef.
  *
  * Once ref or selfRef are collected, the paired Ref.State's release method is called, which if it had

File: test/unit/org/apache/cassandra/db/marshal/TimeTypeTest.java
Patch:
@@ -48,14 +48,14 @@ public class TimeTypeTest
 
         b1 = TimeSerializer.instance.serialize(0L);
         b2 = TimeSerializer.instance.serialize(10000000L);
-        assert TimeType.instance.compare(b1, b2) == -1 : "Failed < comparison on 0";
+        assert TimeType.instance.compare(b1, b2) < 0 : "Failed < comparison on 0";
 
         b1 = TimeSerializer.instance.serialize(0L);
         b2 = TimeSerializer.instance.serialize(TimeUnit.DAYS.toNanos(1));
-        assert TimeType.instance.compare(b1, b2) == -1 : "Failed < comparison against max range.";
+        assert TimeType.instance.compare(b1, b2) < 0 : "Failed < comparison against max range.";
 
         b1 = TimeSerializer.instance.serialize(TimeUnit.DAYS.toNanos(1));
         b2 = TimeSerializer.instance.serialize(0L);
-        assert TimeType.instance.compare(b1, b2) == 1 : "Failed > comparison against max range.";
+        assert TimeType.instance.compare(b1, b2) > 0 : "Failed > comparison against max range.";
     }
 }

File: src/java/org/apache/cassandra/db/commitlog/CommitLogReader.java
Patch:
@@ -315,7 +315,7 @@ private void readSection(CommitLogReadHandler handler,
             catch (EOFException eof)
             {
                 if (handler.shouldSkipSegmentOnError(new CommitLogReadException(
-                                                String.format("Unexpected end of segment", mutationStart, statusTracker.errorContext),
+                                                String.format("Unexpected end of segment at %d in %s", mutationStart, statusTracker.errorContext),
                                                 CommitLogReadErrorReason.EOF,
                                                 statusTracker.tolerateErrorsInSection)))
                 {

File: src/java/org/apache/cassandra/db/compaction/TimeWindowCompactionStrategy.java
Patch:
@@ -239,7 +239,7 @@ static Pair<HashMultimap<Long, SSTableReader>, Long> getBuckets(Iterable<SSTable
                 maxTimestamp = bounds.left;
         }
 
-        logger.trace("buckets {}, max timestamp", buckets, maxTimestamp);
+        logger.trace("buckets {}, max timestamp {}", buckets, maxTimestamp);
         return Pair.create(buckets, maxTimestamp);
     }
 

File: src/java/org/apache/cassandra/db/compaction/TimeWindowCompactionStrategyOptions.java
Patch:
@@ -114,12 +114,12 @@ public static Map<String, String> validateOptions(Map<String, String> options, M
             int sstableWindowSize = optionValue == null ? DEFAULT_COMPACTION_WINDOW_SIZE : Integer.parseInt(optionValue);
             if (sstableWindowSize < 1)
             {
-                throw new ConfigurationException(String.format("%s must be greater than 1", DEFAULT_COMPACTION_WINDOW_SIZE, sstableWindowSize));
+                throw new ConfigurationException(String.format("%d must be greater than 1 for %s", sstableWindowSize, COMPACTION_WINDOW_SIZE_KEY));
             }
         }
         catch (NumberFormatException e)
         {
-            throw new ConfigurationException(String.format("%s is not a parsable int (base10) for %s", optionValue, DEFAULT_COMPACTION_WINDOW_SIZE), e);
+            throw new ConfigurationException(String.format("%s is not a parsable int (base10) for %s", optionValue, COMPACTION_WINDOW_SIZE_KEY), e);
         }
 
         optionValue = options.get(EXPIRED_SSTABLE_CHECK_FREQUENCY_SECONDS_KEY);

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -802,7 +802,7 @@ public static Class<? extends AbstractCompactionStrategy> createCompactionStrate
         className = className.contains(".") ? className : "org.apache.cassandra.db.compaction." + className;
         Class<AbstractCompactionStrategy> strategyClass = FBUtilities.classForName(className, "compaction strategy");
         if (!AbstractCompactionStrategy.class.isAssignableFrom(strategyClass))
-            throw new ConfigurationException(String.format("Specified compaction strategy class (%s) is not derived from AbstractReplicationStrategy", className));
+            throw new ConfigurationException(String.format("Specified compaction strategy class (%s) is not derived from AbstractCompactionStrategy", className));
 
         return strategyClass;
     }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -580,7 +580,7 @@ public static synchronized ColumnFamilyStore createColumnFamilyStore(Keyspace ke
      */
     public static void scrubDataDirectories(CFMetaData metadata)
     {
-        Directories directories = new Directories(metadata);
+        Directories directories = new Directories(metadata, initialDirectories);
 
          // clear ephemeral snapshots that were not properly cleared last session (CASSANDRA-7357)
         clearEphemeralSnapshots(directories);

File: src/java/org/apache/cassandra/db/lifecycle/LogTransaction.java
Patch:
@@ -32,6 +32,7 @@
 
 import org.apache.cassandra.concurrent.ScheduledExecutors;
 import org.apache.cassandra.config.CFMetaData;
+import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.Directories;
 import org.apache.cassandra.db.SystemKeyspace;
 import org.apache.cassandra.db.compaction.OperationType;
@@ -385,7 +386,7 @@ protected void doPrepare() { }
      */
     static void removeUnfinishedLeftovers(CFMetaData metadata)
     {
-        removeUnfinishedLeftovers(new Directories(metadata).getCFDirectories());
+        removeUnfinishedLeftovers(new Directories(metadata, ColumnFamilyStore.getInitialDirectories()).getCFDirectories());
     }
 
     @VisibleForTesting

File: src/java/org/apache/cassandra/tools/StandaloneSSTableUtil.java
Patch:
@@ -20,6 +20,7 @@
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.Schema;
+import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.Directories;
 import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
 import org.apache.cassandra.utils.OutputHandler;
@@ -81,7 +82,7 @@ public static void main(String args[])
 
     private static void listFiles(Options options, CFMetaData metadata, OutputHandler handler) throws IOException
     {
-        Directories directories = new Directories(metadata);
+        Directories directories = new Directories(metadata, ColumnFamilyStore.getInitialDirectories());
 
         for (File dir : directories.getCFDirectories())
         {

File: src/java/org/apache/cassandra/db/compaction/CompactionTask.java
Patch:
@@ -173,7 +173,7 @@ public boolean apply(SSTableReader sstable)
                     collector.beginCompaction(ci);
                 long lastCheckObsoletion = start;
 
-                if (!controller.cfs.getCompactionStrategyManager().isActive)
+                if (!controller.cfs.getCompactionStrategyManager().isActive())
                     throw new CompactionInterruptedException(ci.getCompactionInfo());
 
                 try (CompactionAwareWriter writer = getCompactionAwareWriter(cfs, getDirectories(), transaction, actuallyCompact))

File: src/java/org/apache/cassandra/db/ClusteringPrefix.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.*;
 
 import org.apache.cassandra.cache.IMeasurableMemory;
-import org.apache.cassandra.config.CFMetaData;
+import org.apache.cassandra.config.*;
 import org.apache.cassandra.db.rows.*;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.io.util.DataInputPlus;
@@ -343,7 +343,7 @@ ByteBuffer[] deserializeValuesWithoutSize(DataInputPlus in, int size, int versio
                 {
                     values[offset] = isNull(header, offset)
                                 ? null
-                                : (isEmpty(header, offset) ? ByteBufferUtil.EMPTY_BYTE_BUFFER : types.get(offset).readValue(in));
+                                : (isEmpty(header, offset) ? ByteBufferUtil.EMPTY_BYTE_BUFFER : types.get(offset).readValue(in, DatabaseDescriptor.getMaxValueSize()));
                     offset++;
                 }
             }
@@ -479,7 +479,7 @@ private boolean deserializeOne() throws IOException
             int i = deserializedSize++;
             nextValues[i] = Serializer.isNull(nextHeader, i)
                           ? null
-                          : (Serializer.isEmpty(nextHeader, i) ? ByteBufferUtil.EMPTY_BYTE_BUFFER : serializationHeader.clusteringTypes().get(i).readValue(in));
+                          : (Serializer.isEmpty(nextHeader, i) ? ByteBufferUtil.EMPTY_BYTE_BUFFER : serializationHeader.clusteringTypes().get(i).readValue(in, DatabaseDescriptor.getMaxValueSize()));
             return true;
         }
 

File: src/java/org/apache/cassandra/db/SinglePartitionReadCommand.java
Patch:
@@ -1016,7 +1016,7 @@ private static class Deserializer extends SelectionDeserializer
         public ReadCommand deserialize(DataInputPlus in, int version, boolean isDigest, int digestVersion, boolean isForThrift, CFMetaData metadata, int nowInSec, ColumnFilter columnFilter, RowFilter rowFilter, DataLimits limits, Optional<IndexMetadata> index)
         throws IOException
         {
-            DecoratedKey key = metadata.decorateKey(metadata.getKeyValidator().readValue(in));
+            DecoratedKey key = metadata.decorateKey(metadata.getKeyValidator().readValue(in, DatabaseDescriptor.getMaxValueSize()));
             ClusteringIndexFilter filter = ClusteringIndexFilter.serializer.deserialize(in, version, metadata);
             return new SinglePartitionReadCommand(isDigest, digestVersion, isForThrift, metadata, nowInSec, columnFilter, rowFilter, limits, key, filter);
         }

File: src/java/org/apache/cassandra/db/rows/BufferCell.java
Patch:
@@ -20,8 +20,7 @@
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
-import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.config.ColumnDefinition;
+import org.apache.cassandra.config.*;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.context.CounterContext;
 import org.apache.cassandra.db.marshal.ByteType;
@@ -300,7 +299,7 @@ public Cell deserialize(DataInputPlus in, LivenessInfo rowLiveness, ColumnDefini
                 }
                 else
                 {
-                    value = header.getType(column).readValue(in);
+                    value = header.getType(column).readValue(in, DatabaseDescriptor.getMaxValueSize());
                     if (isCounter)
                         value = helper.maybeClearCounterValue(value);
                 }

File: src/java/org/apache/cassandra/cql3/statements/BatchStatement.java
Patch:
@@ -530,7 +530,7 @@ else if (!haveMultipleCFs)
 
             // Use the CFMetadata of the first statement for partition key bind indexes.  If the statements affect
             // multiple tables, we won't send partition key bind indexes.
-            Short[] partitionKeyBindIndexes = (haveMultipleCFs || batchStatement.statements.isEmpty())? null
+            short[] partitionKeyBindIndexes = (haveMultipleCFs || batchStatement.statements.isEmpty())? null
                                                               : boundNames.getPartitionKeyBindIndexes(batchStatement.statements.get(0).cfm);
 
             return new ParsedStatement.Prepared(batchStatement, boundNames, partitionKeyBindIndexes);

File: src/java/org/apache/cassandra/cql3/statements/ParsedStatement.java
Patch:
@@ -58,17 +58,17 @@ public static class Prepared
 
         public final CQLStatement statement;
         public final List<ColumnSpecification> boundNames;
-        public final Short[] partitionKeyBindIndexes;
+        public final short[] partitionKeyBindIndexes;
 
-        protected Prepared(CQLStatement statement, List<ColumnSpecification> boundNames, Short[] partitionKeyBindIndexes)
+        protected Prepared(CQLStatement statement, List<ColumnSpecification> boundNames, short[] partitionKeyBindIndexes)
         {
             this.statement = statement;
             this.boundNames = boundNames;
             this.partitionKeyBindIndexes = partitionKeyBindIndexes;
             this.rawCQLStatement = "";
         }
 
-        public Prepared(CQLStatement statement, VariableSpecifications names, Short[] partitionKeyBindIndexes)
+        public Prepared(CQLStatement statement, VariableSpecifications names, short[] partitionKeyBindIndexes)
         {
             this(statement, names.getSpecifications(), partitionKeyBindIndexes);
         }

File: test/unit/org/apache/cassandra/transport/SerDeserTest.java
Patch:
@@ -231,7 +231,7 @@ public void preparedMetadataSerializationTest()
         for (int i = 0; i < 3; i++)
             columnNames.add(new ColumnSpecification("ks", "cf", new ColumnIdentifier("col" + i, false), Int32Type.instance));
 
-        ResultSet.PreparedMetadata meta = new ResultSet.PreparedMetadata(columnNames, new Short[]{2, 1});
+        ResultSet.PreparedMetadata meta = new ResultSet.PreparedMetadata(columnNames, new short[]{2, 1});
         ByteBuf buf = Unpooled.buffer(meta.codec.encodedSize(meta, Server.VERSION_4));
         meta.codec.encode(meta, buf, Server.VERSION_4);
         ResultSet.PreparedMetadata decodedMeta = meta.codec.decode(buf, Server.VERSION_4);

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -85,7 +85,7 @@ public class Config
 
     public volatile Long truncate_request_timeout_in_ms = 60000L;
 
-    public Integer streaming_socket_timeout_in_ms = 3600000;
+    public Integer streaming_socket_timeout_in_ms = 86400000; //24 hours
 
     public boolean cross_node_timeout = false;
 

File: src/java/org/apache/cassandra/db/Directories.java
Patch:
@@ -346,7 +346,7 @@ public DataDirectory getWriteableLocation(long writeSize)
 
         if (candidates.isEmpty())
             if (tooBig)
-                return null;
+                throw new RuntimeException("Insufficient disk space to write " + writeSize + " bytes");
             else
                 throw new FSWriteError(new IOException("All configured data directories have been blacklisted as unwritable for erroring out"), "");
 

File: src/java/org/apache/cassandra/db/compaction/AbstractCompactionStrategy.java
Patch:
@@ -232,9 +232,6 @@ public long getMemtableReservedSize()
      */
     public void replaceFlushed(Memtable memtable, SSTableReader sstable)
     {
-        cfs.getTracker().replaceFlushed(memtable, sstable);
-        if (sstable != null)
-            CompactionManager.instance.submitBackground(cfs);
     }
 
     /**

File: src/java/org/apache/cassandra/db/compaction/Scrubber.java
Patch:
@@ -98,8 +98,6 @@ public Scrubber(ColumnFamilyStore cfs, LifecycleTransaction transaction, boolean
 
         // Calculate the expected compacted filesize
         this.destination = cfs.directories.getWriteableLocationAsFile(cfs.getExpectedCompactedFileSize(toScrub, OperationType.SCRUB));
-        if (destination == null)
-            throw new IOException("disk full");
 
         // If we run scrub offline, we should never purge tombstone, as we cannot know if other sstable have data that the tombstone deletes.
         this.controller = transaction.isOffline()

File: src/java/org/apache/cassandra/io/sstable/format/Version.java
Patch:
@@ -52,6 +52,8 @@ protected Version(SSTableFormat format, String version)
 
     public abstract boolean hasNewFileName();
 
+    public abstract boolean hasCommitLogLowerBound();
+
     public String getVersion()
     {
         return version;

File: src/java/org/apache/cassandra/io/sstable/format/big/BigTableWriter.java
Patch:
@@ -432,7 +432,7 @@ private static void writeMetadata(Descriptor desc, Map<MetadataType, MetadataCom
         File file = new File(desc.filenameFor(Component.STATS));
         try (SequentialWriter out = SequentialWriter.open(file);)
         {
-            desc.getMetadataSerializer().serialize(components, out.stream);
+            desc.getMetadataSerializer().serialize(components, desc.version, out.stream);
             out.setDescriptor(desc).finish();
         }
         catch (IOException e)

File: src/java/org/apache/cassandra/io/sstable/metadata/CompactionMetadata.java
Patch:
@@ -72,7 +72,7 @@ public int hashCode()
 
     public static class CompactionMetadataSerializer implements IMetadataComponentSerializer<CompactionMetadata>
     {
-        public int serializedSize(CompactionMetadata component) throws IOException
+        public int serializedSize(CompactionMetadata component, Version version) throws IOException
         {
             int size = 0;
             size += TypeSizes.NATIVE.sizeof(component.ancestors.size());
@@ -83,7 +83,7 @@ public int serializedSize(CompactionMetadata component) throws IOException
             return size;
         }
 
-        public void serialize(CompactionMetadata component, DataOutputPlus out) throws IOException
+        public void serialize(CompactionMetadata component, Version version, DataOutputPlus out) throws IOException
         {
             out.writeInt(component.ancestors.size());
             for (int g : component.ancestors)

File: src/java/org/apache/cassandra/io/sstable/metadata/IMetadataComponentSerializer.java
Patch:
@@ -35,7 +35,7 @@ public interface IMetadataComponentSerializer<T extends MetadataComponent>
      * @return serialized size of this component
      * @throws IOException
      */
-    int serializedSize(T component) throws IOException;
+    int serializedSize(T component, Version version) throws IOException;
 
     /**
      * Serialize metadata component to given output.
@@ -45,7 +45,7 @@ public interface IMetadataComponentSerializer<T extends MetadataComponent>
      * @param out  serialize destination
      * @throws IOException
      */
-    void serialize(T component, DataOutputPlus out) throws IOException;
+    void serialize(T component, Version version, DataOutputPlus out) throws IOException;
 
     /**
      * Deserialize metadata component from given input.

File: src/java/org/apache/cassandra/io/sstable/metadata/IMetadataSerializer.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.Map;
 
 import org.apache.cassandra.io.sstable.Descriptor;
+import org.apache.cassandra.io.sstable.format.Version;
 import org.apache.cassandra.io.util.DataOutputPlus;
 
 /**
@@ -37,7 +38,7 @@ public interface IMetadataSerializer
      * @param out
      * @throws IOException
      */
-    void serialize(Map<MetadataType, MetadataComponent> components, DataOutputPlus out) throws IOException;
+    void serialize(Map<MetadataType, MetadataComponent> components, Version version, DataOutputPlus out) throws IOException;
 
     /**
      * Deserialize specified metadata components from given descriptor.

File: src/java/org/apache/cassandra/io/sstable/metadata/ValidationMetadata.java
Patch:
@@ -71,12 +71,12 @@ public int hashCode()
 
     public static class ValidationMetadataSerializer implements IMetadataComponentSerializer<ValidationMetadata>
     {
-        public int serializedSize(ValidationMetadata component) throws IOException
+        public int serializedSize(ValidationMetadata component, Version version) throws IOException
         {
             return TypeSizes.NATIVE.sizeof(component.partitioner) + 8;
         }
 
-        public void serialize(ValidationMetadata component, DataOutputPlus out) throws IOException
+        public void serialize(ValidationMetadata component, Version version, DataOutputPlus out) throws IOException
         {
             out.writeUTF(component.partitioner);
             out.writeDouble(component.bloomFilterFPChance);

File: src/java/org/apache/cassandra/streaming/StreamReceiveTask.java
Patch:
@@ -122,14 +122,11 @@ public void run()
                     for (SSTableWriter writer : task.sstables)
                         writer.abort();
                     task.sstables.clear();
-                    task.session.taskCompleted(task);
                     return;
                 }
                 ColumnFamilyStore cfs = Keyspace.open(kscf.left).getColumnFamilyStore(kscf.right);
 
                 File lockfiledir = cfs.directories.getWriteableLocationAsFile(task.sstables.size() * 256L);
-                if (lockfiledir == null)
-                    throw new IOError(new IOException("All disks full"));
                 StreamLockfile lockfile = new StreamLockfile(lockfiledir, UUID.randomUUID());
                 lockfile.create(task.sstables);
                 List<SSTableReader> readers = new ArrayList<>();

File: src/java/org/apache/cassandra/tools/SSTableMetadataViewer.java
Patch:
@@ -70,7 +70,8 @@ public static void main(String[] args) throws IOException
                     out.printf("Estimated droppable tombstones: %s%n", stats.getEstimatedDroppableTombstoneRatio((int) (System.currentTimeMillis() / 1000)));
                     out.printf("SSTable Level: %d%n", stats.sstableLevel);
                     out.printf("Repaired at: %d%n", stats.repairedAt);
-                    out.println(stats.replayPosition);
+                    out.printf("Minimum replay position: %s\n", stats.commitLogLowerBound);
+                    out.printf("Maximum replay position: %s\n", stats.commitLogUpperBound);
                     out.println("Estimated tombstone drop times:");
                     for (Map.Entry<Double, Long> entry : stats.estimatedTombstoneDropTime.getAsMap().entrySet())
                     {

File: test/long/org/apache/cassandra/db/commitlog/CommitLogStressTest.java
Patch:
@@ -452,7 +452,7 @@ class Replayer extends CommitLogReplayer
         int cells = 0;
 
         @Override
-        void replayMutation(byte[] inputBuffer, int size, final long entryLocation, final CommitLogDescriptor desc)
+        void replayMutation(byte[] inputBuffer, int size, final int entryLocation, final CommitLogDescriptor desc)
         {
             if (desc.id < discardedPos.segment)
             {

File: test/unit/org/apache/cassandra/db/commitlog/CommitLogTestReplayer.java
Patch:
@@ -59,7 +59,7 @@ public CommitLogTestReplayer(CommitLog log, ReplayPosition discardedPos, Predica
     }
 
     @Override
-    void replayMutation(byte[] inputBuffer, int size, final long entryLocation, final CommitLogDescriptor desc)
+    void replayMutation(byte[] inputBuffer, int size, final int entryLocation, final CommitLogDescriptor desc)
     {
         FastByteArrayInputStream bufIn = new FastByteArrayInputStream(inputBuffer, 0, size);
         Mutation mutation;

File: test/unit/org/apache/cassandra/db/lifecycle/ViewTest.java
Patch:
@@ -208,6 +208,6 @@ static View fakeView(int memtableCount, int sstableCount, ColumnFamilyStore cfs)
         for (int i = 0 ; i < sstableCount ; i++)
             sstables.add(MockSchema.sstable(i, cfs));
         return new View(ImmutableList.copyOf(memtables), Collections.<Memtable>emptyList(), Helpers.identityMap(sstables),
-                        Collections.<SSTableReader>emptySet(), SSTableIntervalTree.build(sstables));
+                        Collections.<SSTableReader>emptySet(), Collections.<SSTableReader>emptySet(), SSTableIntervalTree.build(sstables));
     }
 }

File: test/unit/org/apache/cassandra/io/compress/CompressedRandomAccessReaderTest.java
Patch:
@@ -113,7 +113,7 @@ private void testResetAndTruncate(File f, boolean compressed, int junkSize) thro
         ChannelProxy channel = new ChannelProxy(f);
         try
         {
-            MetadataCollector sstableMetadataCollector = new MetadataCollector(new SimpleDenseCellNameType(BytesType.instance)).replayPosition(null);
+            MetadataCollector sstableMetadataCollector = new MetadataCollector(new SimpleDenseCellNameType(BytesType.instance));
             SequentialWriter writer = compressed
                 ? new CompressedSequentialWriter(f, filename + ".metadata", new CompressionParameters(SnappyCompressor.instance), sstableMetadataCollector)
                 : SequentialWriter.open(f);
@@ -166,7 +166,7 @@ public void testDataCorruptionDetection() throws IOException
         File metadata = new File(file.getPath() + ".meta");
         metadata.deleteOnExit();
 
-        MetadataCollector sstableMetadataCollector = new MetadataCollector(new SimpleDenseCellNameType(BytesType.instance)).replayPosition(null);
+        MetadataCollector sstableMetadataCollector = new MetadataCollector(new SimpleDenseCellNameType(BytesType.instance));
         try (SequentialWriter writer = new CompressedSequentialWriter(file, metadata.getPath(), new CompressionParameters(SnappyCompressor.instance), sstableMetadataCollector))
         {
             writer.write(CONTENT.getBytes());
@@ -251,7 +251,7 @@ public void testThrottledReadersAreNotCached() throws IOException
         File metadata = new File(file.getPath() + ".meta");
         metadata.deleteOnExit();
 
-        MetadataCollector sstableMetadataCollector = new MetadataCollector(new SimpleDenseCellNameType(BytesType.instance)).replayPosition(null);
+        MetadataCollector sstableMetadataCollector = new MetadataCollector(new SimpleDenseCellNameType(BytesType.instance));
         try (SequentialWriter writer = new CompressedSequentialWriter(file, metadata.getPath(), new CompressionParameters(SnappyCompressor.instance), sstableMetadataCollector))
         {
             writer.write(CONTENT.getBytes());

File: test/unit/org/apache/cassandra/io/compress/CompressedSequentialWriterTest.java
Patch:
@@ -85,7 +85,7 @@ private void testWrite(File f, int bytesToTest) throws IOException
 
         try
         {
-            MetadataCollector sstableMetadataCollector = new MetadataCollector(new SimpleDenseCellNameType(BytesType.instance)).replayPosition(null);
+            MetadataCollector sstableMetadataCollector = new MetadataCollector(new SimpleDenseCellNameType(BytesType.instance));
             byte[] dataPre = new byte[bytesToTest];
             byte[] rawPost = new byte[bytesToTest];
             try (CompressedSequentialWriter writer = new CompressedSequentialWriter(f, filename + ".metadata", new CompressionParameters(compressor), sstableMetadataCollector);)

File: test/unit/org/apache/cassandra/utils/IntervalTreeTest.java
Patch:
@@ -157,7 +157,7 @@ public void testSerialization() throws Exception
                 public String deserialize(DataInput in) throws IOException { return in.readUTF(); }
                 public long serializedSize(String v, TypeSizes s) { return v.length(); }
             },
-            (Constructor<Interval<Integer, String>>) (Object) Interval.class.getConstructor(Object.class, Object.class, Object.class)
+            (Constructor<Interval<Integer, String>>) (Constructor<?>) Interval.class.getConstructor(Object.class, Object.class, Object.class)
         );
 
         DataOutputBuffer out = new DataOutputBuffer();

File: src/java/org/apache/cassandra/cql3/functions/JavaBasedUDFunction.java
Patch:
@@ -343,12 +343,13 @@ protected URLConnection openConnection(URL u)
             // in case of an ITE, use the cause
             throw new InvalidRequestException(String.format("Could not compile function '%s' from Java source: %s", name, e.getCause()));
         }
-        catch (VirtualMachineError e)
+        catch (InvalidRequestException | VirtualMachineError e)
         {
             throw e;
         }
         catch (Throwable e)
         {
+            logger.error(String.format("Could not compile function '%s' from Java source:%n%s", name, javaSource), e);
             throw new InvalidRequestException(String.format("Could not compile function '%s' from Java source: %s", name, e));
         }
     }

File: src/java/org/apache/cassandra/cql3/statements/CreateTableStatement.java
Patch:
@@ -241,7 +241,7 @@ public ParsedStatement.Prepared prepare(Types udts) throws RequestValidationExce
             {
                 stmt.keyAliases.add(alias);
                 AbstractType<?> t = getTypeAndRemove(stmt.columns, alias);
-                if (t instanceof CounterColumnType)
+                if (t.asCQL3Type().getType() instanceof CounterColumnType)
                     throw new InvalidRequestException(String.format("counter type is not supported for PRIMARY KEY part %s", alias));
                 if (staticColumns.contains(alias))
                     throw new InvalidRequestException(String.format("Static column %s cannot be part of the PRIMARY KEY", alias));
@@ -255,7 +255,7 @@ public ParsedStatement.Prepared prepare(Types udts) throws RequestValidationExce
                 stmt.columnAliases.add(t);
 
                 AbstractType<?> type = getTypeAndRemove(stmt.columns, t);
-                if (type instanceof CounterColumnType)
+                if (type.asCQL3Type().getType() instanceof CounterColumnType)
                     throw new InvalidRequestException(String.format("counter type is not supported for PRIMARY KEY part %s", t));
                 if (staticColumns.contains(t))
                     throw new InvalidRequestException(String.format("Static column %s cannot be part of the PRIMARY KEY", t));

File: src/java/org/apache/cassandra/cql3/statements/CreateTableStatement.java
Patch:
@@ -268,7 +268,7 @@ else if (hasCounters && properties.getDefaultTimeToLive() > 0)
             {
                 stmt.keyAliases.add(alias.bytes);
                 AbstractType<?> t = getTypeAndRemove(stmt.columns, alias);
-                if (t instanceof CounterColumnType)
+                if (t.asCQL3Type().getType() instanceof CounterColumnType)
                     throw new InvalidRequestException(String.format("counter type is not supported for PRIMARY KEY part %s", alias));
                 if (staticColumns.contains(alias))
                     throw new InvalidRequestException(String.format("Static column %s cannot be part of the PRIMARY KEY", alias));
@@ -316,7 +316,7 @@ else if (hasCounters && properties.getDefaultTimeToLive() > 0)
 
                     stmt.columnAliases.add(alias.bytes);
                     AbstractType<?> at = getTypeAndRemove(stmt.columns, alias);
-                    if (at instanceof CounterColumnType)
+                    if (at.asCQL3Type().getType() instanceof CounterColumnType)
                         throw new InvalidRequestException(String.format("counter type is not supported for PRIMARY KEY part %s", stmt.columnAliases.get(0)));
                     stmt.comparator = new SimpleDenseCellNameType(at);
                 }
@@ -328,7 +328,7 @@ else if (hasCounters && properties.getDefaultTimeToLive() > 0)
                         stmt.columnAliases.add(t.bytes);
 
                         AbstractType<?> type = getTypeAndRemove(stmt.columns, t);
-                        if (type instanceof CounterColumnType)
+                        if (type.asCQL3Type().getType() instanceof CounterColumnType)
                             throw new InvalidRequestException(String.format("counter type is not supported for PRIMARY KEY part %s", t));
                         if (staticColumns.contains(t))
                             throw new InvalidRequestException(String.format("Static column %s cannot be part of the PRIMARY KEY", t));

File: src/java/org/apache/cassandra/auth/jmx/AuthenticationProxy.java
Patch:
@@ -76,7 +76,7 @@ public AuthenticationProxy(String loginConfigName)
      *
      * @param credentials optionally these credentials may be supplied by the JMX user.
      *                    Out of the box, the JDK's {@code}RMIServerImpl{@code} is capable
-     *                    of supplying a two element String[], containing username & password.
+     *                    of supplying a two element String[], containing username and password.
      *                    If present, these credentials will be made available to configured
      *                    {@code}LoginModule{@code}s via {@code}JMXCallbackHandler{@code}.
      *

File: src/java/org/apache/cassandra/concurrent/ExecutorLocal.java
Patch:
@@ -27,7 +27,7 @@ public interface ExecutorLocal<T>
     ExecutorLocal[] all = { Tracing.instance, ClientWarn.instance };
 
     /**
-     * This is called when scheduling the task, and also before calling {@link ExecutorLocal#set(T)} when running on a
+     * This is called when scheduling the task, and also before calling {@link #set(Object)} when running on a
      * executor thread.
      *
      * @return The thread-local value that we want to copy across executor boundaries; may be null if not set.

File: src/java/org/apache/cassandra/db/marshal/AbstractType.java
Patch:
@@ -336,7 +336,7 @@ public AbstractType<?> freeze()
      * Returns an AbstractType instance that is equivalent to this one, but with all nested UDTs explicitly frozen and
      * all collections in UDTs explicitly frozen.
      *
-     * This is only necessary for 2.x -> 3.x schema migrations, and can be removed in Cassandra 4.0.
+     * This is only necessary for {@code 2.x -> 3.x} schema migrations, and can be removed in Cassandra 4.0.
      *
      * See CASSANDRA-11609
      */

File: src/java/org/apache/cassandra/db/rows/RowDiffListener.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * Interface that allows to act on the result of merging multiple rows.
  *
- * More precisely, given N rows and the result of merging them, one can call {@link Rows#diff()}
+ * More precisely, given N rows and the result of merging them, one can call {@link Rows#diff(RowDiffListener, Row, Row...)}
  * with a {@code RowDiffListener} and that listener will be informed for each input row of the diff between
  * that input and merge row.
  */

File: src/java/org/apache/cassandra/db/view/ViewManager.java
Patch:
@@ -45,8 +45,8 @@
  * manager is initialized.
  *
  * The main purposes of the manager are to provide a single location for updates to be vetted to see whether they update
- * any views {@link ViewManager#updatesAffectView(Collection, boolean)}, provide locks to prevent multiple
- * updates from creating incoherent updates in the view {@link ViewManager#acquireLockFor(ByteBuffer)}, and
+ * any views {@link #updatesAffectView(Collection, boolean)}, provide locks to prevent multiple
+ * updates from creating incoherent updates in the view {@link #acquireLockFor(int)}, and
  * to affect change on the view.
  */
 public class ViewManager

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -711,7 +711,7 @@ public boolean isGossipOnlyMember(InetAddress endpoint)
     /**
      * Check if this node can safely be started and join the ring.
      * If the node is bootstrapping, examines gossip state for any previous status to decide whether
-     * it's safe to allow this node to start & bootstrap. If not bootstrapping, compares the host ID
+     * it's safe to allow this node to start and bootstrap. If not bootstrapping, compares the host ID
      * that the node itself has (obtained by reading from system.local or generated if not present)
      * with the host ID obtained from gossip for the endpoint address (if any). This latter case
      * prevents a non-bootstrapping, new node from being started with the same address of a

File: src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java
Patch:
@@ -1762,7 +1762,7 @@ public ISSTableScanner getScanner(Range<Token> range, RateLimiter limiter)
     /**
      * Direct I/O SSTableScanner over an iterator of bounds.
      *
-     * @param bounds the keys to cover
+     * @param rangeIterator the keys to cover
      * @return A Scanner for seeking over the rows of the SSTable.
      */
     public abstract ISSTableScanner getScanner(Iterator<AbstractBounds<PartitionPosition>> rangeIterator);

File: src/java/org/apache/cassandra/service/StorageServiceMBean.java
Patch:
@@ -194,19 +194,19 @@ public interface StorageServiceMBean extends NotificationEmitter
     public List<InetAddress> getNaturalEndpoints(String keyspaceName, ByteBuffer key);
 
     /**
-     * @deprecated use {@link #takeSnapshot(String tag, Map options, boolean keyspaces, String... entities)} instead.
+     * @deprecated use {@link #takeSnapshot(String tag, Map options, String... entities)} instead.
      */
     @Deprecated
     public void takeSnapshot(String tag, String... keyspaceNames) throws IOException;
 
     /**
-     * @deprecated use {@link #takeSnapshot(String tag, Map options, boolean keyspaces, String... entities)} instead.
+     * @deprecated use {@link #takeSnapshot(String tag, Map options, String... entities)} instead.
      */
     @Deprecated
     public void takeTableSnapshot(String keyspaceName, String tableName, String tag) throws IOException;
 
     /**
-     * @deprecated use {@link #takeSnapshot(String tag, Map options, boolean keyspaces, String... entities)} instead.
+     * @deprecated use {@link #takeSnapshot(String tag, Map options, String... entities)} instead.
      */
     @Deprecated
     public void takeMultipleTableSnapshot(String tag, String... tableList) throws IOException;

File: src/java/org/apache/cassandra/auth/Permission.java
Patch:
@@ -63,9 +63,7 @@ public enum Permission
     // UDF permissions
     EXECUTE;  // required to invoke any user defined function or aggregate
 
-    public static final Set<Permission> ALL_DATA =
-            ImmutableSet.copyOf(EnumSet.range(Permission.CREATE, Permission.EXECUTE));
     public static final Set<Permission> ALL =
-            ImmutableSet.copyOf(EnumSet.range(Permission.CREATE, Permission.EXECUTE));
+            Sets.immutableEnumSet(EnumSet.range(Permission.CREATE, Permission.EXECUTE));
     public static final Set<Permission> NONE = ImmutableSet.of();
 }

File: src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java
Patch:
@@ -406,7 +406,7 @@ private static void validateAlter(CFMetaData cfm, ColumnDefinition def, Abstract
     @Override
     public String toString()
     {
-        return String.format("AlterTableStatement(name=%s, type=%s, column=%s, validator=%s)",
+        return String.format("AlterTableStatement(name=%s, type=%s)",
                              cfName,
                              oType);
     }

File: src/java/org/apache/cassandra/cql3/functions/JavaBasedUDFunction.java
Patch:
@@ -294,7 +294,7 @@ protected URLConnection openConnection(URL u)
             }
 
             // Verify the UDF bytecode against use of probably dangerous code
-            Set<String> errors = udfByteCodeVerifier.verify(targetClassLoader.classData(targetClassName));
+            Set<String> errors = udfByteCodeVerifier.verify(targetClassName, targetClassLoader.classData(targetClassName));
             String validDeclare = "not allowed method declared: " + executeInternalName + '(';
             for (Iterator<String> i = errors.iterator(); i.hasNext();)
             {

File: src/java/org/apache/cassandra/db/SinglePartitionReadCommand.java
Patch:
@@ -279,11 +279,11 @@ public boolean selectsClustering(DecoratedKey key, Clustering clustering)
      * @param lastReturned the last row returned by the previous page. The newly created command
      * will only query row that comes after this (in query order). This can be {@code null} if this
      * is the first page.
-     * @param pageSize the size to use for the page to query.
+     * @param limits the limits to use for the page to query.
      *
      * @return the newly create command.
      */
-    public SinglePartitionReadCommand forPaging(Clustering lastReturned, int pageSize)
+    public SinglePartitionReadCommand forPaging(Clustering lastReturned, DataLimits limits)
     {
         // We shouldn't have set digest yet when reaching that point
         assert !isDigestQuery();
@@ -292,7 +292,7 @@ public SinglePartitionReadCommand forPaging(Clustering lastReturned, int pageSiz
                       nowInSec(),
                       columnFilter(),
                       rowFilter(),
-                      limits().forPaging(pageSize),
+                      limits,
                       partitionKey(),
                       lastReturned == null ? clusteringIndexFilter() : clusteringIndexFilter.forPaging(metadata().comparator, lastReturned, false));
     }

File: src/java/org/apache/cassandra/service/pager/MultiPartitionPager.java
Patch:
@@ -88,7 +88,7 @@ public PagingState state()
             return null;
 
         PagingState state = pagers[current].state();
-        return new PagingState(pagers[current].key(), state == null ? null : state.rowMark, remaining, Integer.MAX_VALUE);
+        return new PagingState(pagers[current].key(), state == null ? null : state.rowMark, remaining, pagers[current].remainingInPartition());
     }
 
     public boolean isExhausted()

File: src/java/org/apache/cassandra/cql3/restrictions/ClusteringColumnRestrictions.java
Patch:
@@ -113,7 +113,7 @@ public NavigableSet<Clustering> valuesAsClustering(QueryOptions options) throws
         return builder.build();
     }
 
-    public NavigableSet<Slice.Bound> boundsAsClustering(Bound bound, QueryOptions options) throws InvalidRequestException
+    public NavigableSet<ClusteringBound> boundsAsClustering(Bound bound, QueryOptions options) throws InvalidRequestException
     {
         MultiCBuilder builder = MultiCBuilder.create(comparator, hasIN() || hasMultiColumnSlice());
         int keyPosition = 0;

File: src/java/org/apache/cassandra/cql3/restrictions/StatementRestrictions.java
Patch:
@@ -721,7 +721,7 @@ public NavigableSet<Clustering> getClusteringColumns(QueryOptions options)
      * @param options the query options
      * @return the bounds (start or end) of the clustering columns
      */
-    public NavigableSet<Slice.Bound> getClusteringColumnsBounds(Bound b, QueryOptions options)
+    public NavigableSet<ClusteringBound> getClusteringColumnsBounds(Bound b, QueryOptions options)
     {
         return clusteringColumnsRestrictions.boundsAsClustering(b, options);
     }

File: src/java/org/apache/cassandra/db/MutableDeletionInfo.java
Patch:
@@ -290,8 +290,8 @@ public void add(RangeTombstoneMarker marker)
                 DeletionTime openDeletion = openMarker.openDeletionTime(reversed);
                 assert marker.closeDeletionTime(reversed).equals(openDeletion);
 
-                Slice.Bound open = openMarker.openBound(reversed);
-                Slice.Bound close = marker.closeBound(reversed);
+                ClusteringBound open = openMarker.openBound(reversed);
+                ClusteringBound close = marker.closeBound(reversed);
 
                 Slice slice = reversed ? Slice.make(close, open) : Slice.make(open, close);
                 deletion.add(new RangeTombstone(slice, openDeletion), comparator);

File: src/java/org/apache/cassandra/db/columniterator/AbstractSSTableIterator.java
Patch:
@@ -555,11 +555,11 @@ public IndexInfo index(int i) throws IOException
 
         // Finds the index of the first block containing the provided bound, starting at the provided index.
         // Will be -1 if the bound is before any block, and blocksCount() if it is after every block.
-        public int findBlockIndex(Slice.Bound bound, int fromIdx) throws IOException
+        public int findBlockIndex(ClusteringBound bound, int fromIdx) throws IOException
         {
-            if (bound == Slice.Bound.BOTTOM)
+            if (bound == ClusteringBound.BOTTOM)
                 return -1;
-            if (bound == Slice.Bound.TOP)
+            if (bound == ClusteringBound.TOP)
                 return blocksCount();
 
             return indexFor(bound, fromIdx);

File: src/java/org/apache/cassandra/db/columniterator/SSTableReversedIterator.java
Patch:
@@ -141,7 +141,7 @@ protected boolean stopReadingDisk() throws IOException
 
         // Reads the unfiltered from disk and load them into the reader buffer. It stops reading when either the partition
         // is fully read, or when stopReadingDisk() returns true.
-        protected void loadFromDisk(Slice.Bound start, Slice.Bound end, boolean includeFirst) throws IOException
+        protected void loadFromDisk(ClusteringBound start, ClusteringBound end, boolean includeFirst) throws IOException
         {
             buffer.reset();
 
@@ -163,7 +163,7 @@ protected void loadFromDisk(Slice.Bound start, Slice.Bound end, boolean includeF
             // If we have an open marker, it's either one from what we just skipped (if start != null), or it's from the previous index block.
             if (openMarker != null)
             {
-                RangeTombstone.Bound markerStart = start == null ? RangeTombstone.Bound.BOTTOM : RangeTombstone.Bound.fromSliceBound(start);
+                ClusteringBound markerStart = start == null ? ClusteringBound.BOTTOM : start;
                 buffer.add(new RangeTombstoneBoundMarker(markerStart, openMarker));
             }
 
@@ -186,7 +186,7 @@ protected void loadFromDisk(Slice.Bound start, Slice.Bound end, boolean includeF
             if (openMarker != null)
             {
                 // If we have no end and still an openMarker, this means we're indexed and the marker is closed in a following block.
-                RangeTombstone.Bound markerEnd = end == null ? RangeTombstone.Bound.TOP : RangeTombstone.Bound.fromSliceBound(end);
+                ClusteringBound markerEnd = end == null ? ClusteringBound.TOP : end;
                 buffer.add(new RangeTombstoneBoundMarker(markerEnd, getAndClearOpenMarker()));
             }
 

File: src/java/org/apache/cassandra/db/partitions/AbstractBTreePartition.java
Patch:
@@ -193,8 +193,8 @@ public UnfilteredRowIterator unfilteredIterator(Holder current, ColumnFilter sel
 
     private UnfilteredRowIterator sliceIterator(ColumnFilter selection, Slice slice, boolean reversed, Holder current, Row staticRow)
     {
-        Slice.Bound start = slice.start() == Slice.Bound.BOTTOM ? null : slice.start();
-        Slice.Bound end = slice.end() == Slice.Bound.TOP ? null : slice.end();
+        ClusteringBound start = slice.start() == ClusteringBound.BOTTOM ? null : slice.start();
+        ClusteringBound end = slice.end() == ClusteringBound.TOP ? null : slice.end();
         Iterator<Row> rowIter = BTree.slice(current.tree, metadata.comparator, start, true, end, true, desc(reversed));
         Iterator<RangeTombstone> deleteIter = current.deletionInfo.rangeIterator(slice, reversed);
 

File: src/java/org/apache/cassandra/db/rows/RowAndDeletionMergeIterator.java
Patch:
@@ -153,12 +153,12 @@ private RangeTombstone consumeOpenRange()
         return range;
     }
 
-    private Slice.Bound openBound(RangeTombstone range)
+    private ClusteringBound openBound(RangeTombstone range)
     {
         return range.deletedSlice().open(isReverseOrder());
     }
 
-    private Slice.Bound closeBound(RangeTombstone range)
+    private ClusteringBound closeBound(RangeTombstone range)
     {
         return range.deletedSlice().close(isReverseOrder());
     }

File: src/java/org/apache/cassandra/service/DataResolver.java
Patch:
@@ -167,7 +167,7 @@ private class MergeListener implements UnfilteredRowIterators.MergeListener
             private final Row.Builder[] currentRows = new Row.Builder[sources.length];
             private final RowDiffListener diffListener;
 
-            private final Slice.Bound[] markerOpen = new Slice.Bound[sources.length];
+            private final ClusteringBound[] markerOpen = new ClusteringBound[sources.length];
             private final DeletionTime[] markerTime = new DeletionTime[sources.length];
 
             public MergeListener(DecoratedKey partitionKey, PartitionColumns columns, boolean isReversed)
@@ -268,8 +268,8 @@ public void onMergedRangeTombstoneMarkers(RangeTombstoneMarker merged, RangeTomb
                     // Note that boundaries are both close and open, so it's not one or the other
                     if (merged.isClose(isReversed) && markerOpen[i] != null)
                     {
-                        Slice.Bound open = markerOpen[i];
-                        Slice.Bound close = merged.closeBound(isReversed);
+                        ClusteringBound open = markerOpen[i];
+                        ClusteringBound close = merged.closeBound(isReversed);
                         update(i).add(new RangeTombstone(Slice.make(isReversed ? close : open, isReversed ? open : close), markerTime[i]));
                     }
                     if (merged.isOpen(isReversed) && (marker == null || merged.openDeletionTime(isReversed).supersedes(marker.openDeletionTime(isReversed))))

File: test/unit/org/apache/cassandra/cql3/TombstonesWithIndexedSSTableTest.java
Patch:
@@ -108,7 +108,6 @@ public void testTombstoneBoundariesInIndex(String cacheKeys) throws Throwable
         assertRowCount(execute("SELECT DISTINCT s FROM %s WHERE k = ? ORDER BY t DESC", 0), 1);
     }
 
-    // Creates a random string
     public static String makeRandomString(int length)
     {
         Random random = new Random();

File: test/unit/org/apache/cassandra/db/RangeTombstoneTest.java
Patch:
@@ -207,8 +207,8 @@ public void rangeTombstoneFilteringTest() throws Exception
         assertEquals(1, rt.size());
 
         Slices.Builder sb = new Slices.Builder(cfs.getComparator());
-        sb.add(Slice.Bound.create(cfs.getComparator(), true, true, 1), Slice.Bound.create(cfs.getComparator(), false, true, 10));
-        sb.add(Slice.Bound.create(cfs.getComparator(), true, true, 16), Slice.Bound.create(cfs.getComparator(), false, true, 20));
+        sb.add(ClusteringBound.create(cfs.getComparator(), true, true, 1), ClusteringBound.create(cfs.getComparator(), false, true, 10));
+        sb.add(ClusteringBound.create(cfs.getComparator(), true, true, 16), ClusteringBound.create(cfs.getComparator(), false, true, 20));
 
         partition = Util.getOnlyPartitionUnfiltered(SinglePartitionReadCommand.create(cfs.metadata, FBUtilities.nowInSeconds(), Util.dk(key), sb.build()));
         rt = rangeTombstones(partition);

File: test/unit/org/apache/cassandra/db/SinglePartitionSliceCommandTest.java
Patch:
@@ -94,7 +94,7 @@ public void staticColumnsAreFiltered() throws IOException
 
         ColumnFilter columnFilter = ColumnFilter.selection(PartitionColumns.of(v));
         ByteBuffer zero = ByteBufferUtil.bytes(0);
-        Slices slices = Slices.with(cfm.comparator, Slice.make(Slice.Bound.inclusiveStartOf(zero), Slice.Bound.inclusiveEndOf(zero)));
+        Slices slices = Slices.with(cfm.comparator, Slice.make(ClusteringBound.inclusiveStartOf(zero), ClusteringBound.inclusiveEndOf(zero)));
         ClusteringIndexSliceFilter sliceFilter = new ClusteringIndexSliceFilter(slices, false);
         ReadCommand cmd = new SinglePartitionReadCommand(false, MessagingService.VERSION_30, true, cfm,
                                                           FBUtilities.nowInSeconds(),

File: test/unit/org/apache/cassandra/db/filter/SliceTest.java
Patch:
@@ -367,14 +367,14 @@ public void testSliceNormalization()
         assertSlicesNormalization(cc, slices(s(-1, 2), s(-1, 3), s(5, 9)), slices(s(-1, 3), s(5, 9)));
     }
 
-    private static Slice.Bound makeBound(ClusteringPrefix.Kind kind, Integer... components)
+    private static ClusteringBound makeBound(ClusteringPrefix.Kind kind, Integer... components)
     {
         ByteBuffer[] values = new ByteBuffer[components.length];
         for (int i = 0; i < components.length; i++)
         {
             values[i] = ByteBufferUtil.bytes(components[i]);
         }
-        return Slice.Bound.create(kind, values);
+        return ClusteringBound.create(kind, values);
     }
 
     private static List<ByteBuffer> columnNames(Integer ... components)

File: test/unit/org/apache/cassandra/db/partition/PartitionImplementationTest.java
Patch:
@@ -39,7 +39,6 @@
 import org.apache.cassandra.config.ColumnDefinition;
 import org.apache.cassandra.cql3.ColumnIdentifier;
 import org.apache.cassandra.db.*;
-import org.apache.cassandra.db.Slice.Bound;
 import org.apache.cassandra.db.filter.ColumnFilter;
 import org.apache.cassandra.db.marshal.AsciiType;
 import org.apache.cassandra.db.partitions.AbstractBTreePartition;
@@ -355,7 +354,7 @@ Slices makeSlices()
             Clustering start = clustering(pos);
             pos += sz;
             Clustering end = clustering(pos);
-            Slice slice = Slice.make(skip == 0 ? Bound.exclusiveStartOf(start) : Bound.inclusiveStartOf(start), Bound.inclusiveEndOf(end));
+            Slice slice = Slice.make(skip == 0 ? ClusteringBound.exclusiveStartOf(start) : ClusteringBound.inclusiveStartOf(start), ClusteringBound.inclusiveEndOf(end));
             builder.add(slice);
         }
         return builder.build();

File: src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java
Patch:
@@ -284,7 +284,7 @@ public boolean announceMigration(boolean isLocalOnly) throws RequestValidationEx
                 break;
         }
 
-        MigrationManager.announceColumnFamilyUpdate(cfm, false, isLocalOnly);
+        MigrationManager.announceColumnFamilyUpdate(cfm, isLocalOnly);
         return true;
     }
 

File: src/java/org/apache/cassandra/cql3/statements/AlterTypeStatement.java
Patch:
@@ -113,7 +113,7 @@ public boolean announceMigration(boolean isLocalOnly) throws InvalidRequestExcep
             for (ColumnDefinition def : copy.allColumns())
                 modified |= updateDefinition(copy, def, toUpdate.keyspace, toUpdate.name, updated);
             if (modified)
-                MigrationManager.announceColumnFamilyUpdate(copy, false, isLocalOnly);
+                MigrationManager.announceColumnFamilyUpdate(copy, isLocalOnly);
         }
 
         // Other user types potentially using the updated type

File: src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java
Patch:
@@ -191,7 +191,7 @@ else if (cfm.comparator.isCompound())
 
         cd.setIndexName(indexName);
         cfm.addDefaultIndexNames();
-        MigrationManager.announceColumnFamilyUpdate(cfm, false, isLocalOnly);
+        MigrationManager.announceColumnFamilyUpdate(cfm, isLocalOnly);
         return true;
     }
 

File: src/java/org/apache/cassandra/cql3/statements/CreateTriggerStatement.java
Patch:
@@ -78,7 +78,7 @@ public boolean announceMigration(boolean isLocalOnly) throws ConfigurationExcept
         {
             cfm.addTriggerDefinition(triggerDefinition);
             logger.info("Adding trigger with name {} and class {}", triggerName, triggerClass);
-            MigrationManager.announceColumnFamilyUpdate(cfm, false, isLocalOnly);
+            MigrationManager.announceColumnFamilyUpdate(cfm, isLocalOnly);
             return true;
         }
         return false;

File: src/java/org/apache/cassandra/cql3/statements/DropIndexStatement.java
Patch:
@@ -97,7 +97,7 @@ public boolean announceMigration(boolean isLocalOnly) throws InvalidRequestExcep
 
         CFMetaData updatedCfm = updateCFMetadata(cfm);
         indexedCF = updatedCfm.cfName;
-        MigrationManager.announceColumnFamilyUpdate(updatedCfm, false, isLocalOnly);
+        MigrationManager.announceColumnFamilyUpdate(updatedCfm, isLocalOnly);
         return true;
     }
 

File: src/java/org/apache/cassandra/cql3/statements/DropTriggerStatement.java
Patch:
@@ -63,7 +63,7 @@ public boolean announceMigration(boolean isLocalOnly) throws ConfigurationExcept
         if (cfm.removeTrigger(triggerName))
         {
             logger.info("Dropping trigger with name {}", triggerName);
-            MigrationManager.announceColumnFamilyUpdate(cfm, false, isLocalOnly);
+            MigrationManager.announceColumnFamilyUpdate(cfm, isLocalOnly);
             return true;
         }
         if (!ifExists)

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -1661,7 +1661,7 @@ public String system_update_column_family(CfDef cf_def)
             if (!oldCfm.getTriggers().equals(cfm.getTriggers()))
                 state().ensureIsSuper("Only superusers are allowed to add or remove triggers.");
 
-            MigrationManager.announceColumnFamilyUpdate(cfm, true);
+            MigrationManager.announceColumnFamilyUpdate(cfm);
             return Schema.instance.getVersion().toString();
         }
         catch (RequestValidationException e)

File: test/unit/org/apache/cassandra/triggers/TriggersSchemaTest.java
Patch:
@@ -103,7 +103,7 @@ public void addTriggerToCf() throws Exception
         CFMetaData cfm2 = Schema.instance.getCFMetaData(ksName, cfName).copy();
         TriggerDefinition td = TriggerDefinition.create(triggerName, triggerClass);
         cfm2.addTriggerDefinition(td);
-        MigrationManager.announceColumnFamilyUpdate(cfm2, false);
+        MigrationManager.announceColumnFamilyUpdate(cfm2);
 
         CFMetaData cfm3 = Schema.instance.getCFMetaData(ksName, cfName);
         assertFalse(cfm3.getTriggers().isEmpty());
@@ -126,7 +126,7 @@ public void removeTriggerFromCf() throws Exception
 
         CFMetaData cfm2 = Schema.instance.getCFMetaData(ksName, cfName).copy();
         cfm2.removeTrigger(triggerName);
-        MigrationManager.announceColumnFamilyUpdate(cfm2, false);
+        MigrationManager.announceColumnFamilyUpdate(cfm2);
 
         CFMetaData cfm3 = Schema.instance.getCFMetaData(ksName, cfName).copy();
         assertTrue(cfm3.getTriggers().isEmpty());

File: src/java/org/apache/cassandra/utils/Interval.java
Patch:
@@ -39,7 +39,7 @@ public static <C, D> Interval<C, D> create(C min, C max)
         return create(min, max, null);
     }
 
-    public static <C, D> Interval<C, D> git gitcreate(C min, C max, D data)
+    public static <C, D> Interval<C, D> create(C min, C max, D data)
     {
         return new Interval(min, max, data);
     }

File: src/java/org/apache/cassandra/tools/SSTableExport.java
Patch:
@@ -65,17 +65,17 @@ public class SSTableExport
     {
         Config.setClientMode(true);
 
-        Option optKey = new Option(KEY_OPTION, true, "Row key");
+        Option optKey = new Option(KEY_OPTION, true, "Partition key");
         // Number of times -k <key> can be passed on the command line.
         optKey.setArgs(500);
         options.addOption(optKey);
 
-        Option excludeKey = new Option(EXCLUDE_KEY_OPTION, true, "Excluded row key");
+        Option excludeKey = new Option(EXCLUDE_KEY_OPTION, true, "Excluded partition key");
         // Number of times -x <key> can be passed on the command line.
         excludeKey.setArgs(500);
         options.addOption(excludeKey);
 
-        Option optEnumerate = new Option(ENUMERATE_KEYS_OPTION, false, "enumerate keys only");
+        Option optEnumerate = new Option(ENUMERATE_KEYS_OPTION, false, "enumerate partition keys only");
         options.addOption(optEnumerate);
 
         Option debugOutput = new Option(DEBUG_OUTPUT_OPTION, false, "CQL row per line internal representation");

File: src/java/org/apache/cassandra/transport/DataType.java
Patch:
@@ -66,6 +66,7 @@ public enum DataType implements OptionCodec.Codecable<DataType>
     private final int id;
     private final int protocolVersion;
     private final AbstractType type;
+    private final Pair<DataType, Object> pair;
     private static final Map<AbstractType, DataType> dataTypeMap = new HashMap<AbstractType, DataType>();
     static
     {
@@ -81,6 +82,7 @@ public enum DataType implements OptionCodec.Codecable<DataType>
         this.id = id;
         this.type = type;
         this.protocolVersion = protocolVersion;
+        pair = Pair.create(this, null);
     }
 
     public int getId(int version)
@@ -261,7 +263,7 @@ else if (type instanceof SetType)
             // Fall back to CUSTOM if target doesn't know this data type
             if (version < dt.protocolVersion)
                 return Pair.<DataType, Object>create(CUSTOM, type.toString());
-            return Pair.create(dt, null);
+            return dt.pair;
         }
     }
 

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -218,7 +218,7 @@ public ReplayPosition add(Mutation mutation)
         long totalSize = size + ENTRY_OVERHEAD_SIZE;
         if (totalSize > MAX_MUTATION_SIZE)
         {
-            throw new IllegalArgumentException(String.format("Mutation of %s bytes is too large for the maxiumum size of %s",
+            throw new IllegalArgumentException(String.format("Mutation of %s bytes is too large for the maximum size of %s",
                                                              totalSize, MAX_MUTATION_SIZE));
         }
 

File: src/java/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -554,7 +554,7 @@ class WithoutPurgeableTombstones extends PurgeFunction
         {
             public WithoutPurgeableTombstones()
             {
-                super(isForThrift, cfs.gcBefore(nowInSec()), oldestUnrepairedTombstone(), cfs.getCompactionStrategyManager().onlyPurgeRepairedTombstones());
+                super(isForThrift, nowInSec(), cfs.gcBefore(nowInSec()), oldestUnrepairedTombstone(), cfs.getCompactionStrategyManager().onlyPurgeRepairedTombstones());
             }
 
             protected long getMaxPurgeableTimestamp()

File: src/java/org/apache/cassandra/db/compaction/CompactionIterator.java
Patch:
@@ -103,7 +103,7 @@ public CompactionIterator(OperationType type, List<ISSTableScanner> scanners, Co
                                              ? EmptyIterators.unfilteredPartition(controller.cfs.metadata, false)
                                              : UnfilteredPartitionIterators.merge(scanners, nowInSec, listener());
         boolean isForThrift = merged.isForThrift(); // to stop capture of iterator in Purger, which is confusing for debug
-        this.compacted = Transformation.apply(merged, new Purger(isForThrift, controller));
+        this.compacted = Transformation.apply(merged, new Purger(isForThrift, controller, nowInSec));
     }
 
     public boolean isForThrift()
@@ -264,9 +264,9 @@ private class Purger extends PurgeFunction
 
         private long compactedUnfiltered;
 
-        private Purger(boolean isForThrift, CompactionController controller)
+        private Purger(boolean isForThrift, CompactionController controller, int nowInSec)
         {
-            super(isForThrift, controller.gcBefore, controller.compactingRepaired() ? Integer.MIN_VALUE : Integer.MAX_VALUE, controller.cfs.getCompactionStrategyManager().onlyPurgeRepairedTombstones());
+            super(isForThrift, nowInSec, controller.gcBefore, controller.compactingRepaired() ? Integer.MIN_VALUE : Integer.MAX_VALUE, controller.cfs.getCompactionStrategyManager().onlyPurgeRepairedTombstones());
             this.controller = controller;
         }
 

File: src/java/org/apache/cassandra/db/rows/AbstractCell.java
Patch:
@@ -91,7 +91,7 @@ public Cell purge(DeletionPurger purger, int nowInSec)
                 // Note that as long as the expiring column and the tombstone put together live longer than GC grace seconds,
                 // we'll fulfil our responsibility to repair. See discussion at
                 // http://cassandra-user-incubator-apache-org.3065146.n2.nabble.com/repair-compaction-and-tombstone-rows-td7583481.html
-                return BufferCell.tombstone(column, timestamp(), localDeletionTime() - ttl());
+                return BufferCell.tombstone(column, timestamp(), localDeletionTime() - ttl(), path());
             }
         }
         return this;

File: src/java/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -554,7 +554,7 @@ class WithoutPurgeableTombstones extends PurgeFunction
         {
             public WithoutPurgeableTombstones()
             {
-                super(isForThrift, cfs.gcBefore(nowInSec()), oldestUnrepairedTombstone(), cfs.getCompactionStrategyManager().onlyPurgeRepairedTombstones());
+                super(isForThrift, nowInSec(), cfs.gcBefore(nowInSec()), oldestUnrepairedTombstone(), cfs.getCompactionStrategyManager().onlyPurgeRepairedTombstones());
             }
 
             protected long getMaxPurgeableTimestamp()

File: src/java/org/apache/cassandra/db/compaction/CompactionIterator.java
Patch:
@@ -103,7 +103,7 @@ public CompactionIterator(OperationType type, List<ISSTableScanner> scanners, Co
                                              ? EmptyIterators.unfilteredPartition(controller.cfs.metadata, false)
                                              : UnfilteredPartitionIterators.merge(scanners, nowInSec, listener());
         boolean isForThrift = merged.isForThrift(); // to stop capture of iterator in Purger, which is confusing for debug
-        this.compacted = Transformation.apply(merged, new Purger(isForThrift, controller));
+        this.compacted = Transformation.apply(merged, new Purger(isForThrift, controller, nowInSec));
     }
 
     public boolean isForThrift()
@@ -264,9 +264,9 @@ private class Purger extends PurgeFunction
 
         private long compactedUnfiltered;
 
-        private Purger(boolean isForThrift, CompactionController controller)
+        private Purger(boolean isForThrift, CompactionController controller, int nowInSec)
         {
-            super(isForThrift, controller.gcBefore, controller.compactingRepaired() ? Integer.MIN_VALUE : Integer.MAX_VALUE, controller.cfs.getCompactionStrategyManager().onlyPurgeRepairedTombstones());
+            super(isForThrift, nowInSec, controller.gcBefore, controller.compactingRepaired() ? Integer.MIN_VALUE : Integer.MAX_VALUE, controller.cfs.getCompactionStrategyManager().onlyPurgeRepairedTombstones());
             this.controller = controller;
         }
 

File: src/java/org/apache/cassandra/db/rows/AbstractCell.java
Patch:
@@ -91,7 +91,7 @@ public Cell purge(DeletionPurger purger, int nowInSec)
                 // Note that as long as the expiring column and the tombstone put together live longer than GC grace seconds,
                 // we'll fulfil our responsibility to repair. See discussion at
                 // http://cassandra-user-incubator-apache-org.3065146.n2.nabble.com/repair-compaction-and-tombstone-rows-td7583481.html
-                return BufferCell.tombstone(column, timestamp(), localDeletionTime() - ttl());
+                return BufferCell.tombstone(column, timestamp(), localDeletionTime() - ttl(), path());
             }
         }
         return this;

File: src/java/org/apache/cassandra/dht/Murmur3Partitioner.java
Patch:
@@ -278,7 +278,7 @@ public void validate(String token) throws ConfigurationException
         {
             try
             {
-                Long.valueOf(token);
+                fromString(token);
             }
             catch (NumberFormatException e)
             {

File: src/java/org/apache/cassandra/index/sasi/disk/Descriptor.java
Patch:
@@ -18,7 +18,7 @@
 package org.apache.cassandra.index.sasi.disk;
 
 /**
- * Object descriptor for SSTableAttachedSecondaryIndex files. Similar to, and based upon, the sstable descriptor.
+ * Object descriptor for SASIIndex files. Similar to, and based upon, the sstable descriptor.
  */
 public class Descriptor
 {

File: src/java/org/apache/cassandra/index/sasi/memory/TrieMemIndex.java
Patch:
@@ -228,6 +228,7 @@ public Iterable<ConcurrentSkipListSet<DecoratedKey>> search(Op operator, String
                 case SUFFIX:
                     return trie.getValuesForKeysEndingWith(value);
 
+                case PREFIX:
                 case CONTAINS:
                     return trie.getValuesForKeysContaining(value);
 

File: src/java/org/apache/cassandra/index/sasi/sa/IntegralSA.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.Comparator;
 import java.util.Iterator;
 
+import org.apache.cassandra.index.Index;
 import org.apache.cassandra.index.sasi.disk.OnDiskIndexBuilder;
 import org.apache.cassandra.index.sasi.disk.TokenTreeBuilder;
 import org.apache.cassandra.db.marshal.AbstractType;
@@ -72,13 +73,13 @@ public ByteBuffer maxTerm()
             return terms.get(terms.size() - 1).getTerm();
         }
 
-        protected Pair<ByteBuffer, TokenTreeBuilder> computeNext()
+        protected Pair<IndexedTerm, TokenTreeBuilder> computeNext()
         {
             if (!termIterator.hasNext())
                 return endOfData();
 
             Term<ByteBuffer> term = termIterator.next();
-            return Pair.create(term.getTerm(), term.getTokens().finish());
+            return Pair.create(new IndexedTerm(term.getTerm(), false), term.getTokens().finish());
         }
     }
 }

File: src/java/org/apache/cassandra/index/sasi/sa/TermIterator.java
Patch:
@@ -24,7 +24,7 @@
 
 import com.google.common.collect.AbstractIterator;
 
-public abstract class TermIterator extends AbstractIterator<Pair<ByteBuffer, TokenTreeBuilder>>
+public abstract class TermIterator extends AbstractIterator<Pair<IndexedTerm, TokenTreeBuilder>>
 {
     public abstract ByteBuffer minTerm();
     public abstract ByteBuffer maxTerm();

File: src/java/org/apache/cassandra/index/sasi/utils/CombinedTermIterator.java
Patch:
@@ -22,6 +22,7 @@
 import org.apache.cassandra.index.sasi.disk.Descriptor;
 import org.apache.cassandra.index.sasi.disk.OnDiskIndex;
 import org.apache.cassandra.index.sasi.disk.TokenTreeBuilder;
+import org.apache.cassandra.index.sasi.sa.IndexedTerm;
 import org.apache.cassandra.index.sasi.sa.TermIterator;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.utils.Pair;
@@ -72,7 +73,7 @@ public ByteBuffer maxTerm()
         return max;
     }
 
-    protected Pair<ByteBuffer, TokenTreeBuilder> computeNext()
+    protected Pair<IndexedTerm, TokenTreeBuilder> computeNext()
     {
         if (!union.hasNext())
         {
@@ -81,7 +82,7 @@ protected Pair<ByteBuffer, TokenTreeBuilder> computeNext()
         else
         {
             CombinedTerm term = union.next();
-            return Pair.create(term.getTerm(), term.getTokenTreeBuilder());
+            return Pair.create(new IndexedTerm(term.getTerm(), term.isPartial()), term.getTokenTreeBuilder());
         }
 
     }

File: src/java/org/apache/cassandra/service/pager/AbstractQueryPager.java
Patch:
@@ -359,6 +359,9 @@ private int discardTail(ColumnFamily cf, int toDiscard, ColumnFamily copy, Itera
         // paging and a deletion (pretty unlikely), so this is probably acceptable.
         int liveCount = columnCounter().countAll(cf).live();
 
+        if (liveCount == toDiscard)
+            return toDiscard;
+
         ColumnCounter counter = columnCounter();
         // Discard the last 'toDiscard' live (so stop adding as sound as we're past 'liveCount - toDiscard')
         while (iter.hasNext())

File: src/java/org/apache/cassandra/db/Directories.java
Patch:
@@ -310,7 +310,7 @@ public DataDirectory getWriteableLocation(long writeSize)
             if (tooBig)
                 return null;
             else
-                throw new IOError(new IOException("All configured data directories have been blacklisted as unwritable for erroring out"));
+                throw new FSWriteError(new IOException("All configured data directories have been blacklisted as unwritable for erroring out"), "");
 
         // shortcut for single data directory systems
         if (candidates.size() == 1)

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegmentManager.java
Patch:
@@ -35,6 +35,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 
+import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.*;
 import org.slf4j.Logger;
@@ -554,7 +555,8 @@ public void awaitTermination() throws InterruptedException
     /**
      * @return a read-only collection of the active commit log segments
      */
-    Collection<CommitLogSegment> getActiveSegments()
+    @VisibleForTesting
+    public Collection<CommitLogSegment> getActiveSegments()
     {
         return Collections.unmodifiableCollection(activeSegments);
     }

File: src/java/org/apache/cassandra/service/paxos/PrepareCallback.java
Patch:
@@ -58,7 +58,7 @@ public PrepareCallback(ByteBuffer key, CFMetaData metadata, int targets, Consist
     public synchronized void response(MessageIn<PrepareResponse> message)
     {
         PrepareResponse response = message.payload;
-        logger.debug("Prepare response {} from {}", response, message.from);
+        logger.trace("Prepare response {} from {}", response, message.from);
 
         // In case of clock skew, another node could be proposing with ballot that are quite a bit
         // older than our own. In that case, we record the more recent commit we've received to make

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -3184,8 +3184,8 @@ Collection<Range<Token>> getRangesForEndpoint(String keyspaceName, InetAddress e
     */
     public List<Range<Token>> getAllRanges(List<Token> sortedTokens)
     {
-        if (logger.isDebugEnabled())
-            logger.debug("computing ranges for {}", StringUtils.join(sortedTokens, ", "));
+        if (logger.isTraceEnabled())
+            logger.trace("computing ranges for {}", StringUtils.join(sortedTokens, ", "));
 
         if (sortedTokens.isEmpty())
             return Collections.emptyList();

File: src/java/org/apache/cassandra/serializers/UTF8Serializer.java
Patch:
@@ -71,11 +71,12 @@ else if ((b >> 5) == -2)
                         {
                             // validate first byte of 2-byte char, 0xc2-0xdf
                             if (b == (byte) 0xc0)
-                                // speical case: modified utf8 null is 0xc080.
+                                // special case: modified utf8 null is 0xc080.
                                 state = State.TWO_80;
                             else if ((b & 0x1e) == 0)
                                 return false;
-                            state = State.TWO;
+                            else
+                                state = State.TWO;
                         }
                         else if ((b >> 4) == -2)
                         {

File: test/unit/org/apache/cassandra/cql3/restrictions/PrimaryKeyRestrictionSetTest.java
Patch:
@@ -31,6 +31,7 @@
 import org.apache.cassandra.db.ColumnFamilyType;
 import org.apache.cassandra.db.composites.Composite;
 import org.apache.cassandra.db.composites.Composite.EOC;
+import org.apache.cassandra.db.composites.Composites;
 import org.apache.cassandra.db.composites.CompoundSparseCellNameType;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.Int32Type;
@@ -1682,7 +1683,7 @@ public void testBoundsAsCompositesWithSeveralMultiColumnRestrictions()
      */
     private static void assertEmptyComposite(Composite composite)
     {
-        assertTrue(composite.isEmpty());
+        assertEquals(Composites.EMPTY, composite);
     }
 
     /**

File: src/java/org/apache/cassandra/streaming/StreamSession.java
Patch:
@@ -609,6 +609,7 @@ public synchronized void complete()
         else
         {
             state(State.WAIT_COMPLETE);
+            handler.closeIncoming();
         }
     }
 
@@ -696,6 +697,7 @@ private boolean maybeCompleted()
                 handler.sendMessage(new CompleteMessage());
                 completeSent = true;
                 state(State.WAIT_COMPLETE);
+                handler.closeOutgoing();
             }
         }
         return completed;

File: src/java/org/apache/cassandra/service/pager/PagingState.java
Patch:
@@ -162,7 +162,7 @@ public final boolean equals(Object o)
     public String toString()
     {
         return String.format("PagingState(key=%s, cellname=%s, remaining=%d, remainingInPartition=%d",
-                             ByteBufferUtil.bytesToHex(partitionKey),
+                             partitionKey != null ? ByteBufferUtil.bytesToHex(partitionKey) : null,
                              rowMark,
                              remaining,
                              remainingInPartition);

File: src/java/org/apache/cassandra/db/rows/AbstractRow.java
Patch:
@@ -178,7 +178,7 @@ public boolean equals(Object other)
     @Override
     public int hashCode()
     {
-        int hash = Objects.hash(clustering(), columns(), primaryKeyLivenessInfo(), deletion());
+        int hash = Objects.hash(clustering(), primaryKeyLivenessInfo(), deletion());
         for (ColumnData cd : this)
             hash += 31 * cd.hashCode();
         return hash;

File: src/java/org/apache/cassandra/cql3/UpdateParameters.java
Patch:
@@ -116,7 +116,7 @@ public Clustering currentClustering()
 
     public void addPrimaryKeyLivenessInfo()
     {
-        builder.addPrimaryKeyLivenessInfo(LivenessInfo.create(metadata, timestamp, ttl, nowInSec));
+        builder.addPrimaryKeyLivenessInfo(LivenessInfo.create(timestamp, ttl, nowInSec));
     }
 
     public void addRowDeletion()
@@ -149,7 +149,7 @@ public void addCell(ColumnDefinition column, ByteBuffer value) throws InvalidReq
     public void addCell(ColumnDefinition column, CellPath path, ByteBuffer value) throws InvalidRequestException
     {
         Cell cell = ttl == LivenessInfo.NO_TTL
-                  ? BufferCell.live(metadata, column, timestamp, value, path)
+                  ? BufferCell.live(column, timestamp, value, path)
                   : BufferCell.expiring(column, timestamp, ttl, nowInSec, value, path);
         builder.addCell(cell);
     }
@@ -166,7 +166,7 @@ public void addCounter(ColumnDefinition column, long increment) throws InvalidRe
         // but that makes things a bit more complex as this means we need to be able to distinguish inside
         // PartitionUpdate between counter updates that has been processed by CounterMutation and those that
         // haven't.
-        builder.addCell(BufferCell.live(metadata, column, timestamp, CounterContext.instance().createLocal(increment)));
+        builder.addCell(BufferCell.live(column, timestamp, CounterContext.instance().createLocal(increment)));
     }
 
     public void setComplexDeletionTime(ColumnDefinition column)

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -188,7 +188,7 @@ public boolean isTimestampSet()
 
     public int getTimeToLive(QueryOptions options) throws InvalidRequestException
     {
-        return attrs.getTimeToLive(options);
+        return attrs.getTimeToLive(options, cfm.params.defaultTimeToLive);
     }
 
     public void checkAccess(ClientState state) throws InvalidRequestException, UnauthorizedException

File: src/java/org/apache/cassandra/db/LegacyLayout.java
Patch:
@@ -1167,7 +1167,7 @@ else if (!clustering.equals(cell.name.clustering))
             {
                 // It's the row marker
                 assert !cell.value.hasRemaining();
-                builder.addPrimaryKeyLivenessInfo(LivenessInfo.create(cell.timestamp, cell.ttl, cell.localDeletionTime));
+                builder.addPrimaryKeyLivenessInfo(LivenessInfo.withExpirationTime(cell.timestamp, cell.ttl, cell.localDeletionTime));
             }
             else
             {

File: src/java/org/apache/cassandra/db/RowUpdateBuilder.java
Patch:
@@ -85,7 +85,7 @@ private void startRow(Clustering clustering)
 
         // If a CQL table, add the "row marker"
         if (update.metadata().isCQLTable() && useRowMarker)
-            regularBuilder.addPrimaryKeyLivenessInfo(LivenessInfo.create(update.metadata(), timestamp, ttl, localDeletionTime));
+            regularBuilder.addPrimaryKeyLivenessInfo(LivenessInfo.create(timestamp, ttl, localDeletionTime));
     }
 
     private Row.Builder builder()
@@ -276,7 +276,7 @@ private Cell makeCell(ColumnDefinition c, ByteBuffer value, CellPath path)
     {
         return value == null
              ? BufferCell.tombstone(c, timestamp, localDeletionTime)
-             : (ttl == LivenessInfo.NO_TTL ? BufferCell.live(update.metadata(), c, timestamp, value, path) : BufferCell.expiring(c, timestamp, ttl, localDeletionTime, value, path));
+             : (ttl == LivenessInfo.NO_TTL ? BufferCell.live(c, timestamp, value, path) : BufferCell.expiring(c, timestamp, ttl, localDeletionTime, value, path));
     }
 
     public RowUpdateBuilder add(ColumnDefinition columnDefinition, Object value)

File: src/java/org/apache/cassandra/db/rows/UnfilteredSerializer.java
Patch:
@@ -420,7 +420,7 @@ public Row deserializeRowBody(DataInputPlus in,
                 long timestamp = header.readTimestamp(in);
                 int ttl = hasTTL ? header.readTTL(in) : LivenessInfo.NO_TTL;
                 int localDeletionTime = hasTTL ? header.readLocalDeletionTime(in) : LivenessInfo.NO_EXPIRATION_TIME;
-                rowLiveness = LivenessInfo.create(timestamp, ttl, localDeletionTime);
+                rowLiveness = LivenessInfo.withExpirationTime(timestamp, ttl, localDeletionTime);
             }
 
             builder.addPrimaryKeyLivenessInfo(rowLiveness);

File: src/java/org/apache/cassandra/db/view/View.java
Patch:
@@ -371,8 +371,7 @@ private PartitionUpdate createUpdatesForInserts(TemporalRow temporalRow)
             clustering.add(value);
         }
         regularBuilder.newRow(clustering.build());
-        regularBuilder.addPrimaryKeyLivenessInfo(LivenessInfo.create(viewCfm,
-                                                                     temporalRow.viewClusteringTimestamp(),
+        regularBuilder.addPrimaryKeyLivenessInfo(LivenessInfo.create(temporalRow.viewClusteringTimestamp(),
                                                                      temporalRow.viewClusteringTtl(),
                                                                      temporalRow.viewClusteringLocalDeletionTime()));
 

File: src/java/org/apache/cassandra/index/internal/CassandraIndex.java
Patch:
@@ -424,7 +424,7 @@ private void indexCell(Clustering clustering, Cell cell)
                 insert(key.getKey(),
                        clustering,
                        cell,
-                       LivenessInfo.create(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),
+                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),
                        opGroup);
             }
 
@@ -472,7 +472,7 @@ private LivenessInfo getPrimaryKeyIndexLiveness(Row row)
                         }
                     }
                 }
-                return LivenessInfo.create(baseCfs.metadata, timestamp, ttl, nowInSec);
+                return LivenessInfo.create(timestamp, ttl, nowInSec);
             }
         };
     }

File: src/java/org/apache/cassandra/thrift/ThriftValidation.java
Patch:
@@ -363,8 +363,8 @@ private static void validateTtl(Column column) throws org.apache.cassandra.excep
     {
         if (column.isSetTtl())
         {
-            if (column.ttl <= 0)
-                throw new org.apache.cassandra.exceptions.InvalidRequestException("ttl must be positive");
+            if (column.ttl < 0)
+                throw new org.apache.cassandra.exceptions.InvalidRequestException("ttl must be greater or equal to 0");
 
             if (column.ttl > Attributes.MAX_TTL)
                 throw new org.apache.cassandra.exceptions.InvalidRequestException(String.format("ttl is too large. requested (%d) maximum (%d)", column.ttl, Attributes.MAX_TTL));

File: test/unit/org/apache/cassandra/db/RowTest.java
Patch:
@@ -193,6 +193,6 @@ private void writeSimpleCellValue(Row.Builder builder,
                                       String value,
                                       long timestamp)
     {
-       builder.addCell(BufferCell.live(cfm, columnDefinition, timestamp, ((AbstractType) columnDefinition.cellValueType()).decompose(value)));
+       builder.addCell(BufferCell.live(columnDefinition, timestamp, ((AbstractType) columnDefinition.cellValueType()).decompose(value)));
     }
 }

File: test/unit/org/apache/cassandra/db/partition/PartitionImplementationTest.java
Patch:
@@ -104,7 +104,7 @@ Row makeRow(Clustering clustering, String colValue)
         ColumnDefinition defCol = cfm.getColumnDefinition(new ColumnIdentifier("col", true));
         Row.Builder row = BTreeRow.unsortedBuilder(TIMESTAMP);
         row.newRow(clustering);
-        row.addCell(BufferCell.live(cfm, defCol, TIMESTAMP, ByteBufferUtil.bytes(colValue)));
+        row.addCell(BufferCell.live(defCol, TIMESTAMP, ByteBufferUtil.bytes(colValue)));
         return row.build();
     }
 
@@ -113,7 +113,7 @@ Row makeStaticRow()
         ColumnDefinition defCol = cfm.getColumnDefinition(new ColumnIdentifier("static_col", true));
         Row.Builder row = BTreeRow.unsortedBuilder(TIMESTAMP);
         row.newRow(Clustering.STATIC_CLUSTERING);
-        row.addCell(BufferCell.live(cfm, defCol, TIMESTAMP, ByteBufferUtil.bytes("static value")));
+        row.addCell(BufferCell.live(defCol, TIMESTAMP, ByteBufferUtil.bytes("static value")));
         return row.build();
     }
 

File: test/unit/org/apache/cassandra/db/rows/DigestBackwardCompatibilityTest.java
Patch:
@@ -76,7 +76,6 @@ public void testCQLTable() throws Throwable
         createTable("CREATE TABLE %s (k text, t int, v1 text, v2 int, PRIMARY KEY (k, t))");
 
         String key = "someKey";
-        int N = 10;
 
         for (int i = 0; i < 10; i++)
             execute("INSERT INTO %s(k, t, v1, v2) VALUES (?, ?, ?, ?) USING TIMESTAMP ? AND TTL ?", key, i, "v" + i, i, 1L, 200);
@@ -103,7 +102,6 @@ public void testCompactTable() throws Throwable
         createTable("CREATE TABLE %s (k text, t int, v text, PRIMARY KEY (k, t)) WITH COMPACT STORAGE");
 
         String key = "someKey";
-        int N = 10;
 
         for (int i = 0; i < 10; i++)
             execute("INSERT INTO %s(k, t, v) VALUES (?, ?, ?) USING TIMESTAMP ? AND TTL ?", key, i, "v" + i, 1L, 200);
@@ -172,7 +170,7 @@ public void testCounterTable() throws Throwable
         CFMetaData metadata = getCurrentColumnFamilyStore().metadata;
         ColumnDefinition column = metadata.getColumnDefinition(ByteBufferUtil.bytes("c"));
         ByteBuffer value = CounterContext.instance().createGlobal(CounterId.fromInt(1), 1L, 42L);
-        Row row = BTreeRow.singleCellRow(Clustering.STATIC_CLUSTERING, BufferCell.live(metadata, column, 0L, value));
+        Row row = BTreeRow.singleCellRow(Clustering.STATIC_CLUSTERING, BufferCell.live(column, 0L, value));
 
         new Mutation(PartitionUpdate.singleRowUpdate(metadata, Util.dk(key), row)).applyUnsafe();
 

File: test/unit/org/apache/cassandra/db/rows/RowAndDeletionMergeIteratorTest.java
Patch:
@@ -380,12 +380,12 @@ private UnfilteredRowIterator createMergeIterator(Iterator<Row> rows,
 
     private void addRow(PartitionUpdate update, int col1, int a)
     {
-        update.add(BTreeRow.singleCellRow(update.metadata().comparator.make(col1), makeCell(cfm, defA, a, 0)));
+        update.add(BTreeRow.singleCellRow(update.metadata().comparator.make(col1), makeCell(defA, a, 0)));
     }
 
-    private Cell makeCell(CFMetaData cfm, ColumnDefinition columnDefinition, int value, long timestamp)
+    private Cell makeCell(ColumnDefinition columnDefinition, int value, long timestamp)
     {
-        return BufferCell.live(cfm, columnDefinition, timestamp, ((AbstractType)columnDefinition.cellValueType()).decompose(value));
+        return BufferCell.live(columnDefinition, timestamp, ((AbstractType)columnDefinition.cellValueType()).decompose(value));
     }
 
     private static RangeTombstone atLeast(int start, long tstamp, int delTime)

File: test/unit/org/apache/cassandra/db/rows/UnfilteredRowIteratorsMergeTest.java
Patch:
@@ -370,7 +370,7 @@ private static Clustering clusteringFor(int i)
     static Row emptyRowAt(int pos, Function<Integer, Integer> timeGenerator)
     {
         final Clustering clustering = clusteringFor(pos);
-        final LivenessInfo live = LivenessInfo.create(metadata, timeGenerator.apply(pos), nowInSec);
+        final LivenessInfo live = LivenessInfo.create(timeGenerator.apply(pos), nowInSec);
         return BTreeRow.noCellLiveRow(clustering, live);
     }
 

File: test/unit/org/apache/cassandra/index/internal/CustomCassandraIndex.java
Patch:
@@ -356,7 +356,7 @@ private void indexCell(Clustering clustering, Cell cell)
                 insert(key.getKey(),
                        clustering,
                        cell,
-                       LivenessInfo.create(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),
+                       LivenessInfo.withExpirationTime(cell.timestamp(), cell.ttl(), cell.localDeletionTime()),
                        opGroup);
             }
 
@@ -404,7 +404,7 @@ private LivenessInfo getPrimaryKeyIndexLiveness(Row row)
                         }
                     }
                 }
-                return LivenessInfo.create(baseCfs.metadata, timestamp, ttl, nowInSec);
+                return LivenessInfo.create(timestamp, ttl, nowInSec);
             }
         };
     }

File: test/unit/org/apache/cassandra/index/sasi/SASIIndexTest.java
Patch:
@@ -2201,14 +2201,14 @@ private static Row buildRow(Cell... cells)
     private static Cell buildCell(ByteBuffer name, ByteBuffer value, long timestamp)
     {
         CFMetaData cfm = Keyspace.open(KS_NAME).getColumnFamilyStore(CF_NAME).metadata;
-        return BufferCell.live(cfm, cfm.getColumnDefinition(name), timestamp, value);
+        return BufferCell.live(cfm.getColumnDefinition(name), timestamp, value);
     }
 
     private static Cell buildCell(CFMetaData cfm, ByteBuffer name, ByteBuffer value, long timestamp)
     {
         ColumnDefinition column = cfm.getColumnDefinition(name);
         assert column != null;
-        return BufferCell.live(cfm, column, timestamp, value);
+        return BufferCell.live(column, timestamp, value);
     }
 
     private static Expression buildExpression(ByteBuffer name, Operator op, ByteBuffer value)

File: test/unit/org/apache/cassandra/index/sasi/disk/PerSSTableIndexWriterTest.java
Patch:
@@ -88,7 +88,7 @@ public void testPartialIndexWrites() throws Exception
             ByteBuffer key = ByteBufferUtil.bytes(String.format(keyFormat, i));
             expectedKeys.put(cfs.metadata.partitioner.decorateKey(key),
                              BTreeRow.singleCellRow(Clustering.EMPTY,
-                                                    BufferCell.live(cfs.metadata, column, timestamp, Int32Type.instance.decompose(i))));
+                                                    BufferCell.live(column, timestamp, Int32Type.instance.decompose(i))));
         }
 
         indexWriter.begin();

File: test/unit/org/apache/cassandra/index/sasi/plan/OperationTest.java
Patch:
@@ -625,7 +625,7 @@ private static Row buildRow(Clustering clustering, Row.Deletion deletion, Cell..
 
     private static Cell buildCell(ColumnDefinition column, ByteBuffer value, long timestamp)
     {
-        return BufferCell.live(BACKEND.metadata, column, timestamp, value);
+        return BufferCell.live(column, timestamp, value);
     }
 
     private static Cell deletedCell(ColumnDefinition column, long timestamp, int nowInSeconds)

File: test/unit/org/apache/cassandra/service/DataResolverTest.java
Patch:
@@ -447,7 +447,7 @@ private static ByteBuffer bb(int b)
 
     private Cell mapCell(int k, int v, long ts)
     {
-        return BufferCell.live(cfm2, m, ts, bb(v), CellPath.create(bb(k)));
+        return BufferCell.live(m, ts, bb(v), CellPath.create(bb(k)));
     }
 
     @Test

File: test/unit/org/apache/cassandra/service/pager/PagingStateTest.java
Patch:
@@ -50,7 +50,7 @@ private PagingState makeSomePagingState(int protocolVersion)
 
         ColumnDefinition def = metadata.getColumnDefinition(new ColumnIdentifier("myCol", false));
         Clustering c = Clustering.make(ByteBufferUtil.bytes("c1"), ByteBufferUtil.bytes(42));
-        Row row = BTreeRow.singleCellRow(c, BufferCell.live(metadata, def, 0, ByteBufferUtil.EMPTY_BYTE_BUFFER));
+        Row row = BTreeRow.singleCellRow(c, BufferCell.live(def, 0, ByteBufferUtil.EMPTY_BYTE_BUFFER));
         PagingState.RowMark mark = PagingState.RowMark.create(metadata, row, protocolVersion);
         return new PagingState(pk, mark, 10, 0);
     }

File: test/unit/org/apache/cassandra/cql3/validation/entities/FrozenCollectionsTest.java
Patch:
@@ -27,6 +27,7 @@
 import org.junit.Test;
 
 import org.apache.cassandra.cql3.CQLTester;
+import org.apache.cassandra.cql3.restrictions.StatementRestrictions;
 import org.apache.cassandra.db.marshal.*;
 import org.apache.cassandra.dht.ByteOrderedPartitioner;
 import org.apache.cassandra.exceptions.ConfigurationException;
@@ -635,7 +636,7 @@ public void testSecondaryIndex() throws Throwable
         assertInvalidMessage("Cannot restrict clustering columns by a CONTAINS relation without a secondary index",
                              "SELECT * FROM %s WHERE b CONTAINS ? ALLOW FILTERING", 1);
 
-        assertInvalidMessage("No supported secondary index found for the non primary key columns restrictions",
+        assertInvalidMessage(StatementRestrictions.REQUIRES_ALLOW_FILTERING_MESSAGE,
                              "SELECT * FROM %s WHERE d CONTAINS KEY ?", 1);
 
         assertInvalidMessage("Cannot restrict clustering columns by a CONTAINS relation without a secondary index",

File: test/unit/org/apache/cassandra/cql3/validation/entities/SecondaryIndexTest.java
Patch:
@@ -31,6 +31,7 @@
 import org.apache.cassandra.cql3.CQLTester;
 import org.apache.cassandra.cql3.ColumnIdentifier;
 import org.apache.cassandra.cql3.QueryProcessor;
+import org.apache.cassandra.cql3.restrictions.StatementRestrictions;
 import org.apache.cassandra.cql3.statements.IndexTarget;
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.DeletionTime;
@@ -131,7 +132,7 @@ private void testCreateAndDropIndex(String indexName, boolean addKeyspaceOnDrop)
             execute("DROP INDEX " + indexName);
         }
 
-        assertInvalidMessage("No supported secondary index found for the non primary key columns restrictions",
+        assertInvalidMessage(StatementRestrictions.REQUIRES_ALLOW_FILTERING_MESSAGE,
                              "SELECT * FROM %s where b = ?", 1);
         dropIndex("DROP INDEX IF EXISTS " + indexName);
         assertInvalidMessage(String.format("Index '%s' could not be found",

File: test/unit/org/apache/cassandra/index/CustomIndexTest.java
Patch:
@@ -15,9 +15,9 @@
 import org.apache.cassandra.cql3.CQLTester;
 import org.apache.cassandra.cql3.ColumnIdentifier;
 import org.apache.cassandra.cql3.restrictions.IndexRestrictions;
+import org.apache.cassandra.cql3.restrictions.StatementRestrictions;
 import org.apache.cassandra.cql3.statements.IndexTarget;
 import org.apache.cassandra.cql3.statements.ModificationStatement;
-import org.apache.cassandra.cql3.statements.SelectStatement;
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.ReadCommand;
 import org.apache.cassandra.db.ReadOrderGroup;
@@ -347,7 +347,7 @@ public void testCustomIndexExpressionSyntax() throws Throwable
                                   "SELECT * FROM %s WHERE expr(custom_index, 'foo') AND expr(other_custom_index, 'bar')");
 
         assertInvalidThrowMessage(Server.CURRENT_VERSION,
-                                  SelectStatement.REQUIRES_ALLOW_FILTERING_MESSAGE,
+                                  StatementRestrictions.REQUIRES_ALLOW_FILTERING_MESSAGE,
                                   QueryValidationException.class,
                                   "SELECT * FROM %s WHERE expr(custom_index, 'foo') AND d=0");
         assertRows(execute("SELECT * FROM %s WHERE expr(custom_index, 'foo') AND d=0 ALLOW FILTERING"), row);

File: src/java/org/apache/cassandra/cql3/restrictions/AbstractRestriction.java
Patch:
@@ -93,8 +93,8 @@ protected static ByteBuffer validateIndexedValue(ColumnSpecification columnSpec,
                                                      ByteBuffer value)
                                                      throws InvalidRequestException
     {
-        checkNotNull(value, "Unsupported null value for indexed column %s", columnSpec.name);
-        checkBindValueSet(value, "Unsupported unset value for indexed column %s", columnSpec.name);
+        checkNotNull(value, "Unsupported null value for column %s", columnSpec.name);
+        checkBindValueSet(value, "Unsupported unset value for column %s", columnSpec.name);
         checkFalse(value.remaining() > 0xFFFF, "Index expression values may not be larger than 64K");
         return value;
     }

File: test/unit/org/apache/cassandra/cql3/validation/entities/FrozenCollectionsTest.java
Patch:
@@ -631,10 +631,10 @@ public void testSecondaryIndex() throws Throwable
         assertInvalidMessage("Cannot restrict clustering columns by a CONTAINS relation without a secondary index",
                              "SELECT * FROM %s WHERE b CONTAINS ? ALLOW FILTERING", 1);
 
-        assertInvalidMessage("No secondary indexes on the restricted columns support the provided operator",
+        assertInvalidMessage("Predicates on non-primary-key columns (d) are not yet supported for non secondary index queries",
                              "SELECT * FROM %s WHERE d CONTAINS KEY ?", 1);
 
-        assertInvalidMessage("No secondary indexes on the restricted columns support the provided operator",
+        assertInvalidMessage("Predicates on non-primary-key columns (d) are not yet supported for non secondary index queries",
                              "SELECT * FROM %s WHERE d CONTAINS KEY ? ALLOW FILTERING", 1);
 
         assertInvalidMessage("Cannot restrict clustering columns by a CONTAINS relation without a secondary index",

File: test/unit/org/apache/cassandra/cql3/validation/entities/SecondaryIndexTest.java
Patch:
@@ -109,7 +109,7 @@ private void testCreateAndDropIndex(String indexName, boolean addKeyspaceOnDrop)
             execute("DROP INDEX " + indexName);
         }
 
-        assertInvalidMessage("No secondary indexes on the restricted columns support the provided operators",
+        assertInvalidMessage("Predicates on non-primary-key columns (b) are not yet supported for non secondary index queries",
                              "SELECT * FROM %s where b = ?", 1);
         dropIndex("DROP INDEX IF EXISTS " + indexName);
         assertInvalidMessage("Index '" + removeQuotes(indexName.toLowerCase(Locale.US)) + "' could not be found", "DROP INDEX " + indexName);

File: test/unit/org/apache/cassandra/db/index/PerRowSecondaryIndexTest.java
Patch:
@@ -155,15 +155,15 @@ public void testRowDelete()
 
         assertTrue(Arrays.equals("k3".getBytes(), PerRowSecondaryIndexTest.TestIndex.LAST_INDEXED_KEY.array()));
     }
-    
+
     @Test
     public void testInvalidSearch()
     {
         Mutation rm;
         rm = new Mutation(KEYSPACE1, ByteBufferUtil.bytes("k4"));
         rm.add("Indexed1", Util.cellname("indexed"), ByteBufferUtil.bytes("foo"), 1);
         rm.apply();
-        
+
         // test we can search:
         UntypedResultSet result = QueryProcessor.executeInternal(String.format("SELECT * FROM \"%s\".\"Indexed1\" WHERE indexed = 'foo'", KEYSPACE1));
         assertEquals(1, result.size());

File: src/java/org/apache/cassandra/utils/NativeSSTableLoaderClient.java
Patch:
@@ -169,12 +169,12 @@ private static CFMetaData createTableMetadata(String keyspace,
                                                   Types types)
     {
         UUID id = row.getUUID("id");
-        Set<CFMetaData.Flag> flags = CFMetaData.flagsFromStrings(row.getSet("flags", String.class));
+        Set<CFMetaData.Flag> flags = isView ? Collections.emptySet() : CFMetaData.flagsFromStrings(row.getSet("flags", String.class));
 
         boolean isSuper = flags.contains(CFMetaData.Flag.SUPER);
         boolean isCounter = flags.contains(CFMetaData.Flag.COUNTER);
         boolean isDense = flags.contains(CFMetaData.Flag.DENSE);
-        boolean isCompound = flags.contains(CFMetaData.Flag.COMPOUND);
+        boolean isCompound = isView || flags.contains(CFMetaData.Flag.COMPOUND);
 
         String columnsQuery = String.format("SELECT * FROM %s.%s WHERE keyspace_name = ? AND table_name = ?",
                                             SchemaKeyspace.NAME,

File: src/java/org/apache/cassandra/db/ClusteringPrefix.java
Patch:
@@ -259,7 +259,7 @@ public void serialize(ClusteringPrefix clustering, DataOutputPlus out, int versi
             }
             else
             {
-                Slice.Bound.serializer.serialize((Slice.Bound)clustering, out, version, types);
+                RangeTombstone.Bound.serializer.serialize((RangeTombstone.Bound)clustering, out, version, types);
             }
         }
 
@@ -271,7 +271,7 @@ public ClusteringPrefix deserialize(DataInputPlus in, int version, List<Abstract
             if (kind == Kind.CLUSTERING)
                 return Clustering.serializer.deserialize(in, version, types);
             else
-                return Slice.Bound.serializer.deserializeValues(in, kind, version, types);
+                return RangeTombstone.Bound.serializer.deserializeValues(in, kind, version, types);
         }
 
         public long serializedSize(ClusteringPrefix clustering, int version, List<AbstractType<?>> types)
@@ -281,7 +281,7 @@ public long serializedSize(ClusteringPrefix clustering, int version, List<Abstra
             if (clustering.kind() == Kind.CLUSTERING)
                 return 1 + Clustering.serializer.serializedSize((Clustering)clustering, version, types);
             else
-                return Slice.Bound.serializer.serializedSize((Slice.Bound)clustering, version, types);
+                return RangeTombstone.Bound.serializer.serializedSize((RangeTombstone.Bound)clustering, version, types);
         }
 
         void serializeValuesWithoutSize(ClusteringPrefix clustering, DataOutputPlus out, int version, List<AbstractType<?>> types) throws IOException

File: test/unit/org/apache/cassandra/cql3/QueryWithIndexedSSTableTest.java
Patch:
@@ -43,7 +43,7 @@ public void queryIndexedSSTableTest() throws Throwable
 
         // We create a partition that is big enough that the underlying sstable will be indexed
         // For that, we use a large-ish number of row, and a value that isn't too small.
-        String text = makeRandomTest(VALUE_LENGTH);
+        String text = TombstonesWithIndexedSSTableTest.makeRandomString(VALUE_LENGTH);
         for (int i = 0; i < ROWS; i++)
             execute("INSERT INTO %s(k, t, v) VALUES (?, ?, ?)", 0, i, text + i);
 
@@ -72,7 +72,7 @@ public void queryIndexedSSTableTest() throws Throwable
     }
 
     // Creates a random string 
-    public static String makeRandomTest(int length)
+    public static String makeRandomSt(int length)
     {
         Random random = new Random();
         char[] chars = new char[26];

File: src/java/org/apache/cassandra/tools/BulkLoader.java
Patch:
@@ -528,6 +528,9 @@ public static LoaderOptions parseArgs(String cmdArgs[])
                 else
                 {
                     config = new Config();
+                    // unthrottle stream by default
+                    config.stream_throughput_outbound_megabits_per_sec = 0;
+                    config.inter_dc_stream_throughput_outbound_megabits_per_sec = 0;
                 }
                 opts.storagePort = config.storage_port;
                 opts.sslStoragePort = config.ssl_storage_port;

File: src/java/org/apache/cassandra/index/sasi/conf/view/View.java
Patch:
@@ -87,9 +87,9 @@ public View(ColumnIndex index,
             throw new IllegalStateException(String.format("mismatched sizes for intervals tree for keys vs terms: %d != %d", keyIntervalTree.intervalCount(), termTree.intervalCount()));
     }
 
-    public Set<SSTableIndex> match(final Set<SSTableReader> scope, Expression expression)
+    public Set<SSTableIndex> match(Expression expression)
     {
-        return Sets.filter(termTree.search(expression), index -> scope.contains(index.getSSTable()));
+        return termTree.search(expression);
     }
 
     public List<SSTableIndex> match(ByteBuffer minKey, ByteBuffer maxKey)

File: src/java/org/apache/cassandra/hints/CompressedChecksummedDataInput.java
Patch:
@@ -145,6 +145,8 @@ public Builder withPosition(long position)
         }
     }
 
+    // Closing the CompressedChecksummedDataInput will close the underlying channel.
+    @SuppressWarnings("resource")
     public static final CompressedChecksummedDataInput upgradeInput(ChecksummedDataInput input, ICompressor compressor)
     {
         long position = input.getPosition();

File: src/java/org/apache/cassandra/net/OutboundTcpConnectionPool.java
Patch:
@@ -122,6 +122,8 @@ public Socket newSocket() throws IOException
         return newSocket(endPoint());
     }
 
+    // Closing the socket will close the underlying channel.
+    @SuppressWarnings("resource")
     public static Socket newSocket(InetAddress endpoint) throws IOException
     {
         // zero means 'bind on any available port.'

File: src/java/org/apache/cassandra/net/OutboundTcpConnectionPool.java
Patch:
@@ -122,6 +122,8 @@ public Socket newSocket() throws IOException
         return newSocket(endPoint());
     }
 
+    // Closing the socket will close the underlying channel.
+    @SuppressWarnings("resource")
     public static Socket newSocket(InetAddress endpoint) throws IOException
     {
         // zero means 'bind on any available port.'

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -877,6 +877,9 @@ public boolean areAllNodesAtLeast30()
      */
     public int setVersion(InetAddress endpoint, int version)
     {
+        // We can't talk to someone from the future
+        version = Math.min(version, current_version);
+
         logger.trace("Setting version {} for {}", version, endpoint);
 
         if (version < VERSION_22)

File: src/java/org/apache/cassandra/cql3/Relation.java
Patch:
@@ -112,7 +112,8 @@ public final boolean isLIKE()
     {
         return relationType == Operator.LIKE_PREFIX
                 || relationType == Operator.LIKE_SUFFIX
-                || relationType == Operator.LIKE_CONTAINS;
+                || relationType == Operator.LIKE_CONTAINS
+                || relationType == Operator.LIKE_MATCHES;
     }
 
     /**
@@ -153,6 +154,7 @@ public final Restriction toRestriction(CFMetaData cfm,
             case LIKE_PREFIX:
             case LIKE_SUFFIX:
             case LIKE_CONTAINS:
+            case LIKE_MATCHES:
                 return newLikeRestriction(cfm, boundNames, relationType);
             default: throw invalidRequest("Unsupported \"!=\" relation: %s", this);
         }

File: src/java/org/apache/cassandra/db/filter/RowFilter.java
Patch:
@@ -604,6 +604,7 @@ public boolean isSatisfiedBy(CFMetaData metadata, DecoratedKey partitionKey, Row
                 case LIKE_PREFIX:
                 case LIKE_SUFFIX:
                 case LIKE_CONTAINS:
+                case LIKE_MATCHES:
                     {
                         assert !column.isComplex() : "Only CONTAINS and CONTAINS_KEY are supported for 'complex' types";
                         ByteBuffer foundValue = getValue(metadata, partitionKey, row);

File: src/java/org/apache/cassandra/index/sasi/conf/IndexMode.java
Patch:
@@ -179,6 +179,6 @@ else if (indexOptions.get(INDEX_ANALYZED_OPTION) != null)
 
     public boolean supports(Op operator)
     {
-        return !(isLiteral && operator == Op.RANGE) && mode.supports(operator);
+        return mode.supports(operator);
     }
 }

File: src/java/org/apache/cassandra/index/sasi/disk/OnDiskIndexBuilder.java
Patch:
@@ -50,8 +50,8 @@ public class OnDiskIndexBuilder
 
     public enum Mode
     {
-        PREFIX(EnumSet.of(Op.EQ, Op.PREFIX, Op.NOT_EQ, Op.RANGE)),
-        CONTAINS(EnumSet.of(Op.EQ, Op.CONTAINS, Op.SUFFIX, Op.NOT_EQ)),
+        PREFIX(EnumSet.of(Op.EQ, Op.MATCH, Op.PREFIX, Op.NOT_EQ, Op.RANGE)),
+        CONTAINS(EnumSet.of(Op.MATCH, Op.CONTAINS, Op.SUFFIX, Op.NOT_EQ)),
         SPARSE(EnumSet.of(Op.EQ, Op.NOT_EQ, Op.RANGE));
 
         Set<Op> supportedOps;

File: src/java/org/apache/cassandra/index/sasi/memory/TrieMemIndex.java
Patch:
@@ -182,6 +182,7 @@ public Iterable<ConcurrentSkipListSet<DecoratedKey>> search(Op operator, String
             switch (operator)
             {
                 case EQ:
+                case MATCH:
                     ConcurrentSkipListSet<DecoratedKey> keys = trie.getValueForExactKey(value);
                     return keys == null ? Collections.emptyList() : Collections.singletonList(keys);
 
@@ -219,6 +220,7 @@ public Iterable<ConcurrentSkipListSet<DecoratedKey>> search(Op operator, String
             switch (operator)
             {
                 case EQ:
+                case MATCH:
                     ConcurrentSkipListSet<DecoratedKey> keys = trie.getValueForExactKey(value);
                     return keys == null ? Collections.emptyList() : Collections.singletonList(keys);
 

File: test/unit/org/apache/cassandra/index/sasi/plan/OperationTest.java
Patch:
@@ -181,21 +181,21 @@ public void testAnalyze() throws Exception
 
         // comment = 'soft eng' and comment != 'likes do'
         ListMultimap<ColumnDefinition, Expression> e = Operation.analyzeGroup(controller, OperationType.OR,
-                                                    Arrays.asList(new SimpleExpression(comment, Operator.EQ, UTF8Type.instance.decompose("soft eng")),
+                                                    Arrays.asList(new SimpleExpression(comment, Operator.LIKE_MATCHES, UTF8Type.instance.decompose("soft eng")),
                                                                   new SimpleExpression(comment, Operator.NEQ, UTF8Type.instance.decompose("likes do"))));
 
         List<Expression> expectedExpressions = new ArrayList<Expression>(2)
         {{
                 add(new Expression("comment", UTF8Type.instance)
                 {{
-                        operation = Op.EQ;
+                        operation = Op.MATCH;
                         lower = new Bound(UTF8Type.instance.decompose("soft"), true);
                         upper = lower;
                 }});
 
                 add(new Expression("comment", UTF8Type.instance)
                 {{
-                        operation = Op.EQ;
+                        operation = Op.MATCH;
                         lower = new Bound(UTF8Type.instance.decompose("eng"), true);
                         upper = lower;
                 }});

File: src/java/org/apache/cassandra/cql3/restrictions/ForwardingPrimaryKeyRestrictions.java
Patch:
@@ -18,7 +18,6 @@
 package org.apache.cassandra.cql3.restrictions;
 
 import java.nio.ByteBuffer;
-import java.util.Collection;
 import java.util.List;
 
 import org.apache.cassandra.config.ColumnDefinition;
@@ -51,7 +50,7 @@ public Iterable<Function> getFunctions()
     }
 
     @Override
-    public Collection<ColumnDefinition> getColumnDefs()
+    public List<ColumnDefinition> getColumnDefs()
     {
         return getDelegate().getColumnDefs();
     }

File: src/java/org/apache/cassandra/cql3/restrictions/Restriction.java
Patch:
@@ -17,7 +17,6 @@
  */
 package org.apache.cassandra.cql3.restrictions;
 
-import java.util.Collection;
 import java.util.List;
 
 import org.apache.cassandra.config.ColumnDefinition;
@@ -60,7 +59,7 @@ public interface Restriction
      * Returns the column definitions in position order.
      * @return the column definitions in position order.
      */
-    public Collection<ColumnDefinition> getColumnDefs();
+    public List<ColumnDefinition> getColumnDefs();
 
     /**
      * Return an Iterable over all of the functions (both native and user-defined) used by any component

File: src/java/org/apache/cassandra/cql3/restrictions/RestrictionSet.java
Patch:
@@ -75,9 +75,9 @@ public final void addIndexExpressionTo(List<IndexExpression> expressions,
     }
 
     @Override
-    public final Set<ColumnDefinition> getColumnDefs()
+    public final List<ColumnDefinition> getColumnDefs()
     {
-        return restrictions.keySet();
+        return new ArrayList<>(restrictions.keySet());
     }
 
     @Override

File: src/java/org/apache/cassandra/cql3/restrictions/TokenRestriction.java
Patch:
@@ -18,7 +18,6 @@
 package org.apache.cassandra.cql3.restrictions;
 
 import java.nio.ByteBuffer;
-import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 
@@ -67,7 +66,7 @@ public  boolean isOnToken()
     }
 
     @Override
-    public Collection<ColumnDefinition> getColumnDefs()
+    public List<ColumnDefinition> getColumnDefs()
     {
         return columnDefs;
     }

File: src/java/org/apache/cassandra/db/lifecycle/LogFile.java
Patch:
@@ -127,7 +127,7 @@ static boolean isLogFile(File file)
 
     boolean verify()
     {
-        assert records.isEmpty();
+        records.clear();
         if (!replicas.readRecords(records))
         {
             logger.error("Failed to read records from {}", replicas);

File: test/unit/org/apache/cassandra/db/lifecycle/LogTransactionTest.java
Patch:
@@ -1079,7 +1079,8 @@ public void testGetTemporaryFilesThrowsIfCompletingAfterObsoletion() throws Thro
         }
         catch(RuntimeException e)
         {
-            //pass
+            //pass as long as the cause is not an assertion
+            assertFalse(e.getCause() instanceof AssertionError);
         }
 
         logs.finish();

File: src/java/org/apache/cassandra/dht/tokenallocator/TokenAllocation.java
Patch:
@@ -199,9 +199,9 @@ static StrategyAdapter getStrategy(final TokenMetadata tokenMetadata, final Netw
         final int replicas = rs.getReplicationFactor(dc);
 
         Topology topology = tokenMetadata.getTopology();
-        int racks = topology.getDatacenterRacks().get(dc).size();
+        int racks = topology.getDatacenterRacks().get(dc).asMap().size();
 
-        if (replicas >= racks)
+        if (racks >= replicas)
         {
             return new StrategyAdapter()
             {

File: src/java/org/apache/cassandra/dht/tokenallocator/TokenAllocation.java
Patch:
@@ -199,9 +199,9 @@ static StrategyAdapter getStrategy(final TokenMetadata tokenMetadata, final Netw
         final int replicas = rs.getReplicationFactor(dc);
 
         Topology topology = tokenMetadata.getTopology();
-        int racks = topology.getDatacenterRacks().get(dc).size();
+        int racks = topology.getDatacenterRacks().get(dc).asMap().size();
 
-        if (replicas >= racks)
+        if (racks >= replicas)
         {
             return new StrategyAdapter()
             {

File: src/java/org/apache/cassandra/cql3/functions/ScriptBasedUDFunction.java
Patch:
@@ -189,7 +189,7 @@ public ByteBuffer executeUserDefined(int protocolVersion, List<ByteBuffer> param
         if (result == null)
             return null;
 
-        Class<?> javaReturnType = UDHelper.asJavaClass(returnDataType);
+        Class<?> javaReturnType = UDHelper.asTypeToken(returnDataType).getRawType();
         Class<?> resultType = result.getClass();
         if (!javaReturnType.isAssignableFrom(resultType))
         {

File: src/java/org/apache/cassandra/db/Mutation.java
Patch:
@@ -218,7 +218,7 @@ public void apply(boolean durableWrites)
         }
         catch (ExecutionException e)
         {
-            Throwables.propagate(e.getCause());
+            throw Throwables.propagate(e.getCause());
         }
     }
 

File: src/java/org/apache/cassandra/db/commitlog/CommitLogReplayer.java
Patch:
@@ -611,7 +611,7 @@ public void runMayThrow()
                     }
                     catch (ExecutionException e)
                     {
-                        Throwables.propagate(e.getCause());
+                        throw Throwables.propagate(e.getCause());
                     }
 
                     keyspacesRecovered.add(keyspace);

File: src/java/org/apache/cassandra/service/paxos/PaxosState.java
Patch:
@@ -146,7 +146,7 @@ public static void commit(Commit proposal)
                 }
                 catch (ExecutionException e)
                 {
-                    Throwables.propagate(e.getCause());
+                    throw Throwables.propagate(e.getCause());
                 }
             }
             else

File: src/java/org/apache/cassandra/db/commitlog/CommitLogReplayer.java
Patch:
@@ -105,7 +105,7 @@ protected Future<Integer> initiateMutation(final Mutation mutation,
         {
             Runnable runnable = new WrappedRunnable()
             {
-                public void runMayThrow() throws IOException
+                public void runMayThrow() throws ExecutionException
                 {
                     if (Schema.instance.getKSMetaData(mutation.getKeyspaceName()) == null)
                         return;

File: src/java/org/apache/cassandra/db/ReadCommandVerbHandler.java
Patch:
@@ -44,7 +44,7 @@ public void doVerb(MessageIn<ReadCommand> message, int id)
         ReadResponse response;
         try (ReadOrderGroup opGroup = command.startOrderGroup(); UnfilteredPartitionIterator iterator = command.executeLocally(opGroup))
         {
-            response = command.createResponse(iterator, command.columnFilter());
+            response = command.createResponse(iterator);
         }
 
         MessageOut<ReadResponse> reply = new MessageOut<>(MessagingService.Verb.REQUEST_RESPONSE, response, serializer());

File: src/java/org/apache/cassandra/db/partitions/PartitionUpdate.java
Patch:
@@ -613,7 +613,7 @@ public void serialize(PartitionUpdate update, DataOutputPlus out, int version) t
 
                 if (version < MessagingService.VERSION_30)
                 {
-                    LegacyLayout.serializeAsLegacyPartition(iter, out, version);
+                    LegacyLayout.serializeAsLegacyPartition(null, iter, out, version);
                 }
                 else
                 {
@@ -699,7 +699,7 @@ public long serializedSize(PartitionUpdate update, int version)
             try (UnfilteredRowIterator iter = update.sliceableUnfilteredIterator())
             {
                 if (version < MessagingService.VERSION_30)
-                    return LegacyLayout.serializedSizeAsLegacyPartition(iter, version);
+                    return LegacyLayout.serializedSizeAsLegacyPartition(null, iter, version);
 
                 return CFMetaData.serializer.serializedSize(update.metadata(), version)
                      + UnfilteredRowIteratorSerializer.serializer.serializedSize(iter, null, version, update.rowCount());

File: src/java/org/apache/cassandra/repair/Validator.java
Patch:
@@ -211,7 +211,7 @@ private MerkleTree.RowHash rowHash(UnfilteredRowIterator partition)
         validated++;
         // MerkleTree uses XOR internally, so we want lots of output bits here
         CountingDigest digest = new CountingDigest(FBUtilities.newMessageDigest("SHA-256"));
-        UnfilteredRowIterators.digest(partition, digest, MessagingService.current_version);
+        UnfilteredRowIterators.digest(null, partition, digest, MessagingService.current_version);
         // only return new hash for merkle tree in case digest was updated - see CASSANDRA-8979
         return digest.count > 0
              ? new MerkleTree.RowHash(partition.partitionKey().getToken(), digest.digest(), digest.count)

File: src/java/org/apache/cassandra/service/DataResolver.java
Patch:
@@ -50,7 +50,7 @@ public DataResolver(Keyspace keyspace, ReadCommand command, ConsistencyLevel con
     public PartitionIterator getData()
     {
         ReadResponse response = responses.iterator().next().payload;
-        return UnfilteredPartitionIterators.filter(response.makeIterator(command.metadata(), command), command.nowInSec());
+        return UnfilteredPartitionIterators.filter(response.makeIterator(command), command.nowInSec());
     }
 
     public PartitionIterator resolve()
@@ -63,7 +63,7 @@ public PartitionIterator resolve()
         for (int i = 0; i < count; i++)
         {
             MessageIn<ReadResponse> msg = responses.get(i);
-            iters.add(msg.payload.makeIterator(command.metadata(), command));
+            iters.add(msg.payload.makeIterator(command));
             sources[i] = msg.from;
         }
 
@@ -385,7 +385,7 @@ private UnfilteredRowIterator doShortReadRetry(SinglePartitionReadCommand retryC
                 // We don't call handler.get() because we want to preserve tombstones since we're still in the middle of merging node results.
                 handler.awaitResults();
                 assert resolver.responses.size() == 1;
-                return UnfilteredPartitionIterators.getOnlyElement(resolver.responses.get(0).payload.makeIterator(command.metadata(), command), retryCommand);
+                return UnfilteredPartitionIterators.getOnlyElement(resolver.responses.get(0).payload.makeIterator(command), retryCommand);
             }
         }
     }

File: src/java/org/apache/cassandra/service/DigestResolver.java
Patch:
@@ -48,7 +48,7 @@ public void preprocess(MessageIn<ReadResponse> message)
     public PartitionIterator getData()
     {
         assert isDataPresent();
-        return UnfilteredPartitionIterators.filter(dataResponse.makeIterator(command.metadata(), command), command.nowInSec());
+        return UnfilteredPartitionIterators.filter(dataResponse.makeIterator(command), command.nowInSec());
     }
 
     /*
@@ -77,7 +77,7 @@ public PartitionIterator resolve() throws DigestMismatchException
         {
             ReadResponse response = message.payload;
 
-            ByteBuffer newDigest = response.digest(command.metadata(), command);
+            ByteBuffer newDigest = response.digest(command);
             if (digest == null)
                 digest = newDigest;
             else if (!digest.equals(newDigest))
@@ -88,7 +88,7 @@ else if (!digest.equals(newDigest))
         if (logger.isTraceEnabled())
             logger.trace("resolve: {} ms.", TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
 
-        return UnfilteredPartitionIterators.filter(dataResponse.makeIterator(command.metadata(), command), command.nowInSec());
+        return UnfilteredPartitionIterators.filter(dataResponse.makeIterator(command), command.nowInSec());
     }
 
     public boolean isDataPresent()

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -1779,7 +1779,7 @@ protected void runMayThrow()
             {
                 try (ReadOrderGroup orderGroup = command.startOrderGroup(); UnfilteredPartitionIterator iterator = command.executeLocally(orderGroup))
                 {
-                    handler.response(command.createResponse(iterator, command.columnFilter()));
+                    handler.response(command.createResponse(iterator));
                 }
                 MessagingService.instance().addLatency(FBUtilities.getBroadcastAddress(), TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
             }

File: test/unit/org/apache/cassandra/cache/CacheProviderTest.java
Patch:
@@ -103,8 +103,8 @@ private void assertDigests(IRowCacheEntry one, CachedBTreePartition two)
         {
             MessageDigest d1 = MessageDigest.getInstance("MD5");
             MessageDigest d2 = MessageDigest.getInstance("MD5");
-            UnfilteredRowIterators.digest(((CachedBTreePartition) one).unfilteredIterator(), d1, MessagingService.current_version);
-            UnfilteredRowIterators.digest(((CachedBTreePartition) two).unfilteredIterator(), d2, MessagingService.current_version);
+            UnfilteredRowIterators.digest(null, ((CachedBTreePartition) one).unfilteredIterator(), d1, MessagingService.current_version);
+            UnfilteredRowIterators.digest(null, ((CachedBTreePartition) two).unfilteredIterator(), d2, MessagingService.current_version);
             assertTrue(MessageDigest.isEqual(d1.digest(), d2.digest()));
         }
         catch (NoSuchAlgorithmException e)

File: test/unit/org/apache/cassandra/db/rows/DigestBackwardCompatibilityTest.java
Patch:
@@ -59,9 +59,10 @@ private ByteBuffer readAndDigest(String partitionKey)
          *   return ColumnFamily.digest(partition);
          */
 
-        ImmutableBTreePartition partition = Util.getOnlyPartitionUnfiltered(Util.cmd(getCurrentColumnFamilyStore(), partitionKey).build());
+        ReadCommand cmd = Util.cmd(getCurrentColumnFamilyStore(), partitionKey).build();
+        ImmutableBTreePartition partition = Util.getOnlyPartitionUnfiltered(cmd);
         MessageDigest digest = FBUtilities.threadLocalMD5Digest();
-        UnfilteredRowIterators.digest(partition.unfilteredIterator(), digest, MessagingService.VERSION_22);
+        UnfilteredRowIterators.digest(cmd, partition.unfilteredIterator(), digest, MessagingService.VERSION_22);
         return ByteBuffer.wrap(digest.digest());
     }
 

File: test/unit/org/apache/cassandra/service/DataResolverTest.java
Patch:
@@ -712,7 +712,7 @@ public MessageIn<ReadResponse> readResponseMessage(InetAddress from, UnfilteredP
     public MessageIn<ReadResponse> readResponseMessage(InetAddress from, UnfilteredPartitionIterator partitionIterator, ReadCommand cmd)
     {
         return MessageIn.create(from,
-                                ReadResponse.createRemoteDataResponse(partitionIterator, cmd.columnFilter()),
+                                ReadResponse.createRemoteDataResponse(partitionIterator, cmd),
                                 Collections.EMPTY_MAP,
                                 MessagingService.Verb.REQUEST_RESPONSE,
                                 MessagingService.current_version);

File: test/unit/org/apache/cassandra/index/sasi/plan/OperationTest.java
Patch:
@@ -512,7 +512,7 @@ public void testSatisfiedByWithClustering()
         ColumnDefinition height = getColumn(CLUSTERING_BACKEND, UTF8Type.instance.decompose("height"));
         ColumnDefinition score = getColumn(CLUSTERING_BACKEND, UTF8Type.instance.decompose("score"));
 
-        Unfiltered row = buildRow(new Clustering(UTF8Type.instance.fromString("US"), Int32Type.instance.decompose(27)),
+        Unfiltered row = buildRow(Clustering.make(UTF8Type.instance.fromString("US"), Int32Type.instance.decompose(27)),
                                   buildCell(height, Int32Type.instance.decompose(182), System.currentTimeMillis()),
                                   buildCell(score, DoubleType.instance.decompose(1.0d), System.currentTimeMillis()));
 

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1038,7 +1038,7 @@ else if (isSurveyMode)
 
     public boolean isJoined()
     {
-        return joined && !isSurveyMode;
+        return tokenMetadata.isMember(FBUtilities.getBroadcastAddress());
     }
 
     public void rebuild(String sourceDc)

File: src/java/org/apache/cassandra/index/internal/CassandraIndex.java
Patch:
@@ -816,6 +816,7 @@ static CassandraIndexFunctions getFunctions(IndexMetadata indexDef,
             case CLUSTERING:
                 return CassandraIndexFunctions.CLUSTERING_COLUMN_INDEX_FUNCTIONS;
             case REGULAR:
+            case STATIC:
                 return CassandraIndexFunctions.REGULAR_COLUMN_INDEX_FUNCTIONS;
             case PARTITION_KEY:
                 return CassandraIndexFunctions.PARTITION_KEY_INDEX_FUNCTIONS;

File: test/unit/org/apache/cassandra/cql3/validation/entities/SecondaryIndexTest.java
Patch:
@@ -749,9 +749,6 @@ public void testIndexesOnClusteringInvalid() throws Throwable
         assertInvalid("CREATE INDEX ON %s (a)");
         assertInvalid("CREATE INDEX ON %s (b)");
         assertInvalid("CREATE INDEX ON %s (c)");
-
-        createTable("CREATE TABLE %s (a int, b int, c int static , PRIMARY KEY (a, b))");
-        assertInvalid("CREATE INDEX ON %s (c)");
     }
 
     @Test

File: src/java/org/apache/cassandra/utils/NativeSSTableLoaderClient.java
Patch:
@@ -74,7 +74,7 @@ public void init(String keyspace)
 
             for (TokenRange tokenRange : tokenRanges)
             {
-                Set<Host> endpoints = metadata.getReplicas(keyspace, tokenRange);
+                Set<Host> endpoints = metadata.getReplicas(Metadata.quote(keyspace), tokenRange);
                 Range<Token> range = new Range<>(tokenFactory.fromString(tokenRange.getStart().getValue().toString()),
                                                  tokenFactory.fromString(tokenRange.getEnd().getValue().toString()));
                 for (Host endpoint : endpoints)

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -98,9 +98,11 @@
 import org.apache.cassandra.db.CounterMutationVerbHandler;
 import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.db.DefinitionsUpdateVerbHandler;
+import org.apache.cassandra.db.Directories;
 import org.apache.cassandra.db.Keyspace;
 import org.apache.cassandra.db.MigrationRequestVerbHandler;
 import org.apache.cassandra.db.MutationVerbHandler;
+import org.apache.cassandra.db.PartitionPosition;
 import org.apache.cassandra.db.RangeSliceVerbHandler;
 import org.apache.cassandra.db.ReadCommandVerbHandler;
 import org.apache.cassandra.db.ReadRepairVerbHandler;

File: src/java/org/apache/cassandra/db/composites/AbstractCType.java
Patch:
@@ -359,7 +359,8 @@ protected static ByteBuffer sliceBytes(ByteBuffer bb, int offs, int length)
     protected static void checkRemaining(ByteBuffer bb, int offs, int length)
     {
         if (offs + length > bb.limit())
-            throw new IllegalArgumentException("Not enough bytes");
+            throw new IllegalArgumentException(String.format("Not enough bytes. Offset: %d. Length: %d. Buffer size: %d",
+                                                             offs, length, bb.limit()));
     }
 
     private static class Serializer implements CType.Serializer

File: src/java/org/apache/cassandra/streaming/ConnectionHandler.java
Patch:
@@ -259,11 +259,11 @@ public void run()
                 {
                     // receive message
                     StreamMessage message = StreamMessage.deserialize(in, protocolVersion, session);
+                    logger.debug("[Stream #{}] Received {}", session.planId(), message);
                     // Might be null if there is an error during streaming (see FileMessage.deserialize). It's ok
                     // to ignore here since we'll have asked for a retry.
                     if (message != null)
                     {
-                        logger.debug("[Stream #{}] Received {}", session.planId(), message);
                         session.messageReceived(message);
                     }
                 }

File: test/unit/org/apache/cassandra/Util.java
Patch:
@@ -191,9 +191,11 @@ public static void createInitialRing(StorageService ss, IPartitioner partitioner
         for (int i = hostIdPool.size(); i < howMany; i++)
             hostIdPool.add(UUID.randomUUID());
 
+        boolean endpointTokenPrefilled = endpointTokens != null && !endpointTokens.isEmpty();
         for (int i=0; i<howMany; i++)
         {
-            endpointTokens.add(new BigIntegerToken(String.valueOf(10 * i)));
+            if(!endpointTokenPrefilled)
+                endpointTokens.add(new BigIntegerToken(String.valueOf(10 * i)));
             keyTokens.add(new BigIntegerToken(String.valueOf(10 * i + 5)));
             hostIds.add(hostIdPool.get(i));
         }

File: test/unit/org/apache/cassandra/Util.java
Patch:
@@ -273,9 +273,11 @@ public static void createInitialRing(StorageService ss, IPartitioner partitioner
         for (int i = hostIdPool.size(); i < howMany; i++)
             hostIdPool.add(UUID.randomUUID());
 
+        boolean endpointTokenPrefilled = endpointTokens != null && !endpointTokens.isEmpty();
         for (int i=0; i<howMany; i++)
         {
-            endpointTokens.add(new BigIntegerToken(String.valueOf(10 * i)));
+            if(!endpointTokenPrefilled)
+                endpointTokens.add(new BigIntegerToken(String.valueOf(10 * i)));
             keyTokens.add(new BigIntegerToken(String.valueOf(10 * i + 5)));
             hostIds.add(hostIdPool.get(i));
         }

File: test/unit/org/apache/cassandra/Util.java
Patch:
@@ -252,9 +252,11 @@ public static void createInitialRing(StorageService ss, IPartitioner partitioner
         for (int i = hostIdPool.size(); i < howMany; i++)
             hostIdPool.add(UUID.randomUUID());
 
+        boolean endpointTokenPrefilled = endpointTokens != null && !endpointTokens.isEmpty();
         for (int i=0; i<howMany; i++)
         {
-            endpointTokens.add(new BigIntegerToken(String.valueOf(10 * i)));
+            if(!endpointTokenPrefilled)
+                endpointTokens.add(new BigIntegerToken(String.valueOf(10 * i)));
             keyTokens.add(new BigIntegerToken(String.valueOf(10 * i + 5)));
             hostIds.add(hostIdPool.get(i));
         }

File: src/java/org/apache/cassandra/db/compaction/writers/CompactionAwareWriter.java
Patch:
@@ -46,7 +46,7 @@
  */
 public abstract class CompactionAwareWriter extends Transactional.AbstractTransactional implements Transactional
 {
-    protected static final Logger logger = LoggerFactory.getLogger(DefaultCompactionWriter.class);
+    protected static final Logger logger = LoggerFactory.getLogger(CompactionAwareWriter.class);
 
     protected final ColumnFamilyStore cfs;
     protected final Directories directories;

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -151,7 +151,7 @@ public class Config
     public Integer max_streaming_retries = 3;
 
     public volatile Integer stream_throughput_outbound_megabits_per_sec = 200;
-    public volatile Integer inter_dc_stream_throughput_outbound_megabits_per_sec = 0;
+    public volatile Integer inter_dc_stream_throughput_outbound_megabits_per_sec = 200;
 
     public String[] data_file_directories;
 

File: src/java/org/apache/cassandra/service/StorageServiceMBean.java
Patch:
@@ -476,6 +476,9 @@ public interface StorageServiceMBean extends NotificationEmitter
     public void setStreamThroughputMbPerSec(int value);
     public int getStreamThroughputMbPerSec();
 
+    public void setInterDCStreamThroughputMbPerSec(int value);
+    public int getInterDCStreamThroughputMbPerSec();
+
     public int getCompactionThroughputMbPerSec();
     public void setCompactionThroughputMbPerSec(int value);
 

File: src/java/org/apache/cassandra/db/rows/Row.java
Patch:
@@ -394,11 +394,11 @@ public interface Builder
         public Clustering clustering();
 
         /**
-         * Adds the liveness information for the partition key columns of this row.
+         * Adds the liveness information for the primary key columns of this row.
          *
          * This call is optional (skipping it is equivalent to calling {@code addPartitionKeyLivenessInfo(LivenessInfo.NONE)}).
          *
-         * @param info the liveness information for the partition key columns of the built row.
+         * @param info the liveness information for the primary key columns of the built row.
          */
         public void addPrimaryKeyLivenessInfo(LivenessInfo info);
 

File: src/java/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -488,7 +488,7 @@ class WithoutPurgeableTombstones extends PurgeFunction
         {
             public WithoutPurgeableTombstones()
             {
-                super(isForThrift, cfs.gcBefore(nowInSec()), oldestUnrepairedTombstone(), cfs.getCompactionStrategyManager().onlyPurgeRepairedTombstones());
+                super(isForThrift, nowInSec(), cfs.gcBefore(nowInSec()), oldestUnrepairedTombstone(), cfs.getCompactionStrategyManager().onlyPurgeRepairedTombstones());
             }
 
             protected long getMaxPurgeableTimestamp()

File: src/java/org/apache/cassandra/db/compaction/CompactionIterator.java
Patch:
@@ -103,7 +103,7 @@ public CompactionIterator(OperationType type, List<ISSTableScanner> scanners, Co
                                              ? EmptyIterators.unfilteredPartition(controller.cfs.metadata, false)
                                              : UnfilteredPartitionIterators.merge(scanners, nowInSec, listener());
         boolean isForThrift = merged.isForThrift(); // to stop capture of iterator in Purger, which is confusing for debug
-        this.compacted = Transformation.apply(merged, new Purger(isForThrift, controller));
+        this.compacted = Transformation.apply(merged, new Purger(isForThrift, controller, nowInSec));
     }
 
     public boolean isForThrift()
@@ -264,9 +264,9 @@ private class Purger extends PurgeFunction
 
         private long compactedUnfiltered;
 
-        private Purger(boolean isForThrift, CompactionController controller)
+        private Purger(boolean isForThrift, CompactionController controller, int nowInSec)
         {
-            super(isForThrift, controller.gcBefore, controller.compactingRepaired() ? Integer.MIN_VALUE : Integer.MAX_VALUE, controller.cfs.getCompactionStrategyManager().onlyPurgeRepairedTombstones());
+            super(isForThrift, nowInSec, controller.gcBefore, controller.compactingRepaired() ? Integer.MIN_VALUE : Integer.MAX_VALUE, controller.cfs.getCompactionStrategyManager().onlyPurgeRepairedTombstones());
             this.controller = controller;
         }
 

File: src/java/org/apache/cassandra/db/rows/BufferCell.java
Patch:
@@ -172,7 +172,7 @@ public Cell purge(DeletionPurger purger, int nowInSec)
                 // Note that as long as the expiring column and the tombstone put together live longer than GC grace seconds,
                 // we'll fulfil our responsibility to repair. See discussion at
                 // http://cassandra-user-incubator-apache-org.3065146.n2.nabble.com/repair-compaction-and-tombstone-rows-td7583481.html
-                return BufferCell.tombstone(column, timestamp, localDeletionTime - ttl);
+                return BufferCell.tombstone(column, timestamp, localDeletionTime - ttl, path);
             }
         }
         return this;

File: src/java/org/apache/cassandra/hints/HintVerbHandler.java
Patch:
@@ -67,7 +67,7 @@ public void doVerb(MessageIn<HintMessage> message, int id)
         }
         catch (MarshalException e)
         {
-            logger.warn("Failed to validate a hint for {} (table id {}) - skipped", hostId);
+            logger.warn("Failed to validate a hint for {} - skipped", hostId);
             reply(id, message.from);
             return;
         }

File: src/java/org/apache/cassandra/hints/LegacyHintsMigrator.java
Patch:
@@ -213,7 +213,7 @@ private static Mutation deserializeLegacyMutation(UntypedResultSet.Row row)
         }
         catch (IOException e)
         {
-            logger.error("Failed to migrate a hint for {} from legacy {}.{} table: {}",
+            logger.error("Failed to migrate a hint for {} from legacy {}.{} table",
                          row.getUUID("target_id"),
                          SystemKeyspace.NAME,
                          SystemKeyspace.LEGACY_HINTS,
@@ -222,7 +222,7 @@ private static Mutation deserializeLegacyMutation(UntypedResultSet.Row row)
         }
         catch (MarshalException e)
         {
-            logger.warn("Failed to validate a hint for {} (table id {}) from legacy {}.{} table - skipping: {})",
+            logger.warn("Failed to validate a hint for {} from legacy {}.{} table - skipping",
                         row.getUUID("target_id"),
                         SystemKeyspace.NAME,
                         SystemKeyspace.LEGACY_HINTS,

File: src/java/org/apache/cassandra/auth/CassandraRoleManager.java
Patch:
@@ -64,7 +64,7 @@
  * in CREATE/ALTER ROLE statements.
  *
  * Such a configuration could be implemented using a custom IRoleManager that
- * extends CassandraRoleManager and which includes Option.PASSWORD in the Set<Option>
+ * extends CassandraRoleManager and which includes Option.PASSWORD in the {@code Set<Option>}
  * returned from supportedOptions/alterableOptions. Any additional processing
  * of the password itself (such as storing it in an alternative location) would
  * be added in overridden createRole and alterRole implementations.

File: src/java/org/apache/cassandra/auth/IRoleManager.java
Patch:
@@ -170,7 +170,7 @@ void revokeRole(AuthenticatedUser performer, RoleResource role, RoleResource rev
 
     /**
      * Where an implementation supports OPTIONS in CREATE and ALTER operations
-     * this method should return the Map<String, String> representing the custom
+     * this method should return the {@code Map<String, String>} representing the custom
      * options associated with the role, as supplied to CREATE or ALTER.
      * It should never return null; if the implementation does not support
      * OPTIONS or if none were supplied then it should return an empty map.

File: src/java/org/apache/cassandra/auth/RoleOptions.java
Patch:
@@ -90,7 +90,7 @@ public Optional<String> getPassword()
     }
 
     /**
-     * Return a Map<String, String> representing custom options
+     * Return a {@code Map<String, String>} representing custom options
      * It is the responsiblity of IRoleManager implementations which support
      * IRoleManager.Option.OPTION to handle type checking and conversion of these
      * values, if present

File: src/java/org/apache/cassandra/auth/Roles.java
Patch:
@@ -28,7 +28,7 @@ public class Roles
     /**
      * Get all roles granted to the supplied Role, including both directly granted
      * and inherited roles.
-     * The returned roles may be cached if roles_validity_in_ms > 0
+     * The returned roles may be cached if {@code roles_validity_in_ms > 0}
      *
      * @param primaryRole the Role
      * @return set of all granted Roles for the primary Role

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -419,7 +419,7 @@ public static CFMetaData compile(String cql, String keyspace)
 
     /**
      * Generates deterministic UUID from keyspace/columnfamily name pair.
-     * This is used to generate the same UUID for C* version < 2.1
+     * This is used to generate the same UUID for {@code C* version < 2.1}
      *
      * Since 2.1, this is only used for system columnfamilies and tests.
      */

File: src/java/org/apache/cassandra/config/ViewDefinition.java
Patch:
@@ -129,8 +129,10 @@ public String toString()
     }
 
     /**
-     * Replace the column {@param from} with {@param to} in this materialized view definition's partition,
+     * Replace the column 'from' with 'to' in this materialized view definition's partition,
      * clustering, or included columns.
+     * @param from the existing column 
+     * @param to the new column 
      */
     public void renameColumn(ColumnIdentifier from, ColumnIdentifier to)
     {

File: src/java/org/apache/cassandra/cql3/QueryOptions.java
Patch:
@@ -152,7 +152,7 @@ public ImmutableList<ColumnSpecification> getColumnSpecifications()
         throw new UnsupportedOperationException();
     }
 
-    /**  The pageSize for this query. Will be <= 0 if not relevant for the query.  */
+    /**  The pageSize for this query. Will be {@code <= 0} if not relevant for the query.  */
     public int getPageSize()
     {
         return getSpecificOptions().pageSize;

File: src/java/org/apache/cassandra/cql3/SingleColumnRelation.java
Patch:
@@ -37,7 +37,7 @@
 
 /**
  * Relations encapsulate the relationship between an entity of some kind, and
- * a value (term). For example, <key> > "start" or "colname1" = "somevalue".
+ * a value (term). For example, {@code <key> > "start" or "colname1" = "somevalue"}.
  *
  */
 public final class SingleColumnRelation extends Relation

File: src/java/org/apache/cassandra/db/CompactTables.java
Patch:
@@ -56,6 +56,7 @@
  *
  * As far as thrift is concerned, one exception to this is super column families, which have a different layout. Namely, a super
  * column families is encoded with:
+ * {@code
  *   CREATE TABLE super (
  *      key [key_validation_class],
  *      super_column_name [comparator],
@@ -65,6 +66,7 @@
  *      "" map<[sub_comparator], [default_validation_class]>
  *      PRIMARY KEY (key, super_column_name)
  *   )
+ * }
  * In other words, every super column is encoded by a row. That row has one column for each defined "column_metadata", but it also
  * has a special map column (whose name is the empty string as this is guaranteed to never conflict with a user-defined
  * "column_metadata") which stores the super column "dynamic" sub-columns.

File: src/java/org/apache/cassandra/db/LegacyLayout.java
Patch:
@@ -1729,7 +1729,7 @@ public int compare(LegacyBound a, LegacyBound b)
 
     /**
      * Almost an entire copy of RangeTombstoneList from C* 2.1.  The main difference is that LegacyBoundComparator
-     * is used in place of Comparator<Composite> (because Composite doesn't exist any more).
+     * is used in place of {@code Comparator<Composite>} (because Composite doesn't exist any more).
      *
      * This class is needed to allow us to convert single-row deletions and complex deletions into range tombstones
      * and properly merge them into the normal set of range tombstones.

File: src/java/org/apache/cassandra/db/RangeTombstoneList.java
Patch:
@@ -38,7 +38,7 @@
  * A range tombstone has 4 elements: the start and end of the range covered,
  * and the deletion infos (markedAt timestamp and local deletion time). The
  * markedAt timestamp is what define the priority of 2 overlapping tombstones.
- * That is, given 2 tombstones [0, 10]@t1 and [5, 15]@t2, then if t2 > t1 (and
+ * That is, given 2 tombstones {@code [0, 10]@t1 and [5, 15]@t2, then if t2 > t1} (and
  * are the tombstones markedAt values), the 2nd tombstone take precedence over
  * the first one on [5, 10]. If such tombstones are added to a RangeTombstoneList,
  * the range tombstone list will store them as [[0, 5]@t1, [5, 15]@t2].

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -201,7 +201,7 @@ public void recover(String path) throws IOException
     }
 
     /**
-     * @return a ReplayPosition which, if >= one returned from add(), implies add() was started
+     * @return a ReplayPosition which, if {@code >= one} returned from add(), implies add() was started
      * (but not necessarily finished) prior to this call
      */
     public ReplayPosition getContext()

File: src/java/org/apache/cassandra/db/lifecycle/LogReplicaSet.java
Patch:
@@ -39,7 +39,8 @@
  * A set of log replicas. This class mostly iterates over replicas when writing or reading,
  * ensuring consistency among them and hiding replication details from LogFile.
  *
- * @see LogReplica, LogFile
+ * @see LogReplica
+ * @see LogFile
  */
 public class LogReplicaSet
 {

File: src/java/org/apache/cassandra/db/rows/UnfilteredRowIteratorSerializer.java
Patch:
@@ -36,6 +36,7 @@
  * The serialization is composed of a header, follows by the rows and range tombstones of the iterator serialized
  * until we read the end of the partition (see UnfilteredSerializer for details). The header itself
  * is:
+ * {@code
  *     <cfid><key><flags><s_header>[<partition_deletion>][<static_row>][<row_estimate>]
  * where:
  *     <cfid> is the table cfid.
@@ -54,6 +55,7 @@
  *     <static_row> is the static row for this partition as serialized by UnfilteredSerializer.
  *     <row_estimate> is the (potentially estimated) number of rows serialized. This is only used for
  *         the purpose of sizing on the receiving end and should not be relied upon too strongly.
+ * }
  *
  * Please note that the format described above is the on-wire format. On-disk, the format is basically the
  * same, but the header is written once per sstable, not once per-partition. Further, the actual row and

File: src/java/org/apache/cassandra/db/rows/UnfilteredSerializer.java
Patch:
@@ -29,6 +29,7 @@
 /**
  * Serialize/deserialize a single Unfiltered (both on-wire and on-disk).
  *
+ * {@code
  * The encoded format for an unfiltered is <flags>(<row>|<marker>) where:
  *
  *   <flags> is a byte (or two) whose bits are flags used by the rest of the serialization. Each
@@ -66,6 +67,7 @@
  *       and if it's expiring a delta-encoded int <ttl> (unless it's an expiring cell
  *       and the ttl and localDeletionTime are indicated by the flags to be the same
  *       than the row ones, in which case none of those appears).
+ * }
  */
 public class UnfilteredSerializer
 {

File: src/java/org/apache/cassandra/db/view/View.java
Patch:
@@ -191,7 +191,8 @@ public boolean updateDefinition(ViewDefinition definition)
      * If the update contains any range tombstones, there is a possibility that it will not touch a range that is
      * currently included in the view.
      *
-     * @return true if {@param partition} modifies a column included in the view
+     * @param partition the update partition
+     * @return true if partition modifies a column included in the view
      */
     public boolean updateAffectsView(AbstractBTreePartition partition)
     {

File: src/java/org/apache/cassandra/db/view/ViewUtils.java
Patch:
@@ -45,7 +45,7 @@ private ViewUtils()
      * nodes in the local datacenter when calculating cardinality.
      *
      * For example, if we have the following ring:
-     *   A, T1 -> B, T2 -> C, T3 -> A
+     *   {@code A, T1 -> B, T2 -> C, T3 -> A}
      *
      * For the token T1, at RF=1, A would be included, so A's cardinality for T1 is 1. For the token T1, at RF=2, B would
      * be included, so B's cardinality for token T1 is 2. For token T3, at RF = 2, A would be included, so A's cardinality

File: src/java/org/apache/cassandra/dht/ExcludingBounds.java
Patch:
@@ -23,7 +23,7 @@
 import org.apache.cassandra.utils.Pair;
 
 /**
- * AbstractBounds containing neither of its endpoints: (left, right).  Used by CQL key > X AND key < Y range scans.
+ * AbstractBounds containing neither of its endpoints: (left, right).  Used by {@code CQL key > X AND key < Y} range scans.
  */
 public class ExcludingBounds<T extends RingPosition<T>> extends AbstractBounds<T>
 {

File: src/java/org/apache/cassandra/dht/IncludingExcludingBounds.java
Patch:
@@ -23,7 +23,7 @@
 import org.apache.cassandra.utils.Pair;
 
 /**
- * AbstractBounds containing only its left endpoint: [left, right).  Used by CQL key >= X AND key < Y range scans.
+ * AbstractBounds containing only its left endpoint: [left, right).  Used by {@code CQL key >= X AND key < Y} range scans.
  */
 public class IncludingExcludingBounds<T extends RingPosition<T>> extends AbstractBounds<T>
 {

File: src/java/org/apache/cassandra/index/Index.java
Patch:
@@ -232,7 +232,7 @@ default IndexBuildingSupport getBuildTaskSupport()
      * false enables the index implementation (or some other component) to control if and when SSTable data is
      * incorporated into the index.
      *
-     * This is called by SecondaryIndexManager in buildIndexBlocking, buildAllIndexesBlocking & rebuildIndexesBlocking
+     * This is called by SecondaryIndexManager in buildIndexBlocking, buildAllIndexesBlocking and rebuildIndexesBlocking
      * where a return value of false causes the index to be exluded from the set of those which will process the
      * SSTable data.
      * @return if the index should be included in the set which processes SSTable data, false otherwise.
@@ -466,7 +466,7 @@ public interface Indexer
      * See CASSANDRA-8717 for further discussion.
      *
      * The function takes a PartitionIterator of the results from the replicas which has already been collated
-     * & reconciled, along with the command being executed. It returns another PartitionIterator containing the results
+     * and reconciled, along with the command being executed. It returns another PartitionIterator containing the results
      * of the transformation (which may be the same as the input if the transformation is a no-op).
      */
     public BiFunction<PartitionIterator, ReadCommand, PartitionIterator> postProcessorFor(ReadCommand command);

File: src/java/org/apache/cassandra/index/internal/CassandraIndexFunctions.java
Patch:
@@ -54,7 +54,7 @@ default AbstractType<?> getIndexedValueType(ColumnDefinition indexedColumn)
     /**
      * Add the clustering columns for a specific type of index table to the a CFMetaData.Builder (which is being
      * used to construct the index table's CFMetadata. In the default implementation, the clustering columns of the
-     * index table hold the partition key & clustering columns of the base table. This is overridden in several cases:
+     * index table hold the partition key and clustering columns of the base table. This is overridden in several cases:
      * * When the indexed value is itself a clustering column, in which case, we only need store the base table's
      *   *other* clustering values in the index - the indexed value being the index table's partition key
      * * When the indexed value is a collection value, in which case we also need to capture the cell path from the base

File: src/java/org/apache/cassandra/index/internal/composites/ClusteringColumnIndex.java
Patch:
@@ -36,12 +36,14 @@
  * has no impact) and v the cell value.
  *
  * Such a cell is always indexed by this index (or rather, it is indexed if
+ * {@code 
  * n >= columnDef.componentIndex, which will always be the case in practice)
  * and it will generate (makeIndexColumnName()) an index entry whose:
  *   - row key will be ck_i (getIndexedValue()) where i == columnDef.componentIndex.
  *   - cell name will
  *       rk ck_0 ... ck_{i-1} ck_{i+1} ck_n
  *     where rk is the row key of the initial cell and i == columnDef.componentIndex.
+ * }
  */
 public class ClusteringColumnIndex extends CassandraIndex
 {

File: src/java/org/apache/cassandra/index/transactions/CleanupTransaction.java
Patch:
@@ -26,7 +26,7 @@
  *
  * Notifies registered indexers of each partition being removed and
  *
- * Compaction & Cleanup are somewhat simpler than dealing with incoming writes,
+ * Compaction and Cleanup are somewhat simpler than dealing with incoming writes,
  * being only concerned with cleaning up stale index entries.
  *
  * When multiple versions of a row are compacted, the CleanupTransaction is

File: src/java/org/apache/cassandra/index/transactions/IndexTransaction.java
Patch:
@@ -26,7 +26,7 @@
  *   Used on the regular write path and when indexing newly acquired SSTables from streaming or sideloading. This type
  *   of transaction may include both row inserts and updates to rows previously existing in the base Memtable. Instances
  *   are scoped to a single partition update and are obtained from the factory method
- *   @{code SecondaryIndexManager#newUpdateTransaction}
+ *   {@code SecondaryIndexManager#newUpdateTransaction}
  *
  * * {@code CompactionTransaction}
  *   Used during compaction when stale entries which have been superceded are cleaned up from the index. As rows in a

File: src/java/org/apache/cassandra/index/transactions/UpdateTransaction.java
Patch:
@@ -53,7 +53,7 @@
  * onInserted(row)*              -- called for each Row not already present in the Memtable
  * onUpdated(existing, updated)* -- called for any Row in the update for where a version was already present
  *                                  in the Memtable. It's important to note here that existing is the previous
- *                                  row from the Memtable & updated is the final version replacing it. It is
+ *                                  row from the Memtable and updated is the final version replacing it. It is
  *                                  *not* the incoming row, but the result of merging the incoming and existing
  *                                  rows.
  * commit()                      -- finally, finish is called when the new Partition is swapped into the Memtable

File: src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java
Patch:
@@ -1253,7 +1253,7 @@ private void validate()
 
     /**
      * Gets the position in the index file to start scanning to find the given key (at most indexInterval keys away,
-     * modulo downsampling of the index summary). Always returns a value >= 0
+     * modulo downsampling of the index summary). Always returns a {@code value >= 0}
      */
     public long getIndexScanPosition(PartitionPosition key)
     {

File: src/java/org/apache/cassandra/io/sstable/metadata/MetadataSerializer.java
Patch:
@@ -37,7 +37,7 @@
 import org.apache.cassandra.utils.FBUtilities;
 
 /**
- * Metadata serializer for SSTables version >= 'k'.
+ * Metadata serializer for SSTables {@code version >= 'k'}.
  *
  * <pre>
  * File format := | number of components (4 bytes) | toc | component1 | component2 | ... |

File: src/java/org/apache/cassandra/service/StorageServiceMBean.java
Patch:
@@ -384,7 +384,7 @@ public interface StorageServiceMBean extends NotificationEmitter
      * If classQualifer is not empty but level is empty/null, it will set the level to null for the defined classQualifer<br>
      * If level cannot be parsed, then the level will be defaulted to DEBUG<br>
      * <br>
-     * The logback configuration should have < jmxConfigurator /> set
+     * The logback configuration should have {@code < jmxConfigurator />} set
      * 
      * @param classQualifier The logger's classQualifer
      * @param level The log level
@@ -423,7 +423,7 @@ public interface StorageServiceMBean extends NotificationEmitter
 
     /**
      * given a list of tokens (representing the nodes in the cluster), returns
-     *   a mapping from "token -> %age of cluster owned by that token"
+     *   a mapping from {@code "token -> %age of cluster owned by that token"}
      */
     public Map<InetAddress, Float> getOwnership();
 

File: src/java/org/apache/cassandra/utils/FastByteOperations.java
Patch:
@@ -333,7 +333,7 @@ public static int compareTo(Object buffer1, long offset1, int length1, ByteBuffe
          * @param memoryOffset2 Where to start comparing in the right buffer (pure memory address if buffer1 is null, or relative otherwise)
          * @param length1 How much to compare from the left buffer
          * @param length2 How much to compare from the right buffer
-         * @return 0 if equal, < 0 if left is less than right, etc.
+         * @return 0 if equal, {@code < 0} if left is less than right, etc.
          */
         @Inline
         public static int compareTo(Object buffer1, long memoryOffset1, int length1,

File: src/java/org/apache/cassandra/utils/SearchIterator.java
Patch:
@@ -26,7 +26,7 @@ public interface SearchIterator<K, V>
      * if this or any key greater has already been returned by the iterator, the method may
      * choose to return null, the correct or incorrect output, or fail an assertion.
      *
-     * it is permitted to search past the end of the iterator, i.e. !hasNext() => next(?) == null
+     * it is permitted to search past the end of the iterator, i.e. {@code !hasNext() => next(?) == null}
      *
      * @param key to search for
      * @return value associated with key, if present in direction of travel

File: src/java/org/apache/cassandra/utils/UUIDGen.java
Patch:
@@ -203,7 +203,7 @@ private static long fromUnixTimestamp(long timestamp, long nanos)
      * of a type 1 UUID (a time-based UUID).
      *
      * To specify a 100-nanoseconds precision timestamp, one should provide a milliseconds timestamp and
-     * a number 0 <= n < 10000 such that n*100 is the number of nanoseconds within that millisecond.
+     * a number {@code 0 <= n < 10000} such that n*100 is the number of nanoseconds within that millisecond.
      *
      * <p><i><b>Warning:</b> This method is not guaranteed to return unique UUIDs; Multiple
      * invocations using identical timestamps will result in identical UUIDs.</i></p>

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -644,15 +644,14 @@ public void forceUserDefinedCleanup(String dataFiles)
                 return;
             }
 
-            if(sstable == null)
+            if (sstable == null)
             {
                 logger.warn("Will not clean {}, it is not an active sstable", entry.getValue());
             }
             else
             {
-                LifecycleTransaction txn = cfs.getTracker().tryModify(sstable, OperationType.CLEANUP);
                 CleanupStrategy cleanupStrategy = CleanupStrategy.get(cfs, ranges, FBUtilities.nowInSeconds());
-                try
+                try (LifecycleTransaction txn = cfs.getTracker().tryModify(sstable, OperationType.CLEANUP))
                 {
                     doCleanupOne(cfs, txn, cleanupStrategy, ranges, hasIndexes);
                 }

File: src/java/org/apache/cassandra/db/partitions/CachedPartition.java
Patch:
@@ -45,7 +45,7 @@ public interface CachedPartition extends Partition, IRowCacheEntry
     /**
      * The number of rows that were live at the time the partition was cached.
      *
-     * See {@link ColumnFamilyStore#isFilterFullyCoveredBy} to see why we need this.
+     * See {@link org.apache.cassandra.db.ColumnFamilyStore#isFilterFullyCoveredBy} to see why we need this.
      *
      * @return the number of rows in this partition that were live at the time the
      * partition was cached (this can be different from the number of live rows now
@@ -58,7 +58,7 @@ public interface CachedPartition extends Partition, IRowCacheEntry
      * non-deleted cell.
      *
      * Note that this is generally not a very meaningful number, but this is used by
-     * {@link DataLimits#hasEnoughLiveData} as an optimization.
+     * {@link org.apache.cassandra.db.filter.DataLimits#hasEnoughLiveData} as an optimization.
      *
      * @return the number of row that have at least one non-expiring non-deleted cell.
      */
@@ -86,7 +86,7 @@ public interface CachedPartition extends Partition, IRowCacheEntry
      * The number of cells in this cached partition that are neither tombstone nor expiring.
      *
      * Note that this is generally not a very meaningful number, but this is used by
-     * {@link DataLimits#hasEnoughLiveData} as an optimization.
+     * {@link org.apache.cassandra.db.filter.DataLimits#hasEnoughLiveData} as an optimization.
      *
      * @return the number of cells that are neither tombstones nor expiring.
      */

File: src/java/org/apache/cassandra/db/rows/LazilyInitializedUnfilteredRowIterator.java
Patch:
@@ -27,7 +27,7 @@
  *
  * This is used during partition range queries when we know the partition key but want
  * to defer the initialization of the rest of the UnfilteredRowIterator until we need those informations.
- * See {@link BigTableScanner#KeyScanningIterator} for instance.
+ * See {@link org.apache.cassandra.io.sstable.format.big.BigTableScanner#KeyScanningIterator} for instance.
  */
 public abstract class LazilyInitializedUnfilteredRowIterator extends AbstractIterator<Unfiltered> implements UnfilteredRowIterator
 {

File: src/java/org/apache/cassandra/db/rows/RangeTombstoneMarker.java
Patch:
@@ -27,7 +27,8 @@
 /**
  * A marker for a range tombstone bound.
  * <p>
- * There is 2 types of markers: bounds (see {@link RangeTombstoneBound}) and boundaries (see {@link RangeTombstoneBoundary}).
+ * There is 2 types of markers: bounds (see {@link RangeTombstoneBoundMarker}) and boundaries (see {@link RangeTombstoneBoundaryMarker}).
+ * </p>
  */
 public interface RangeTombstoneMarker extends Unfiltered
 {

File: src/java/org/apache/cassandra/db/rows/Unfiltered.java
Patch:
@@ -49,7 +49,7 @@ public enum Kind { ROW, RANGE_TOMBSTONE_MARKER };
      * Validate the data of this atom.
      *
      * @param metadata the metadata for the table this atom is part of.
-     * @throws MarshalException if some of the data in this atom is
+     * @throws org.apache.cassandra.serializers.MarshalException if some of the data in this atom is
      * invalid (some value is invalid for its column type, or some field
      * is nonsensical).
      */

File: src/java/org/apache/cassandra/index/Index.java
Patch:
@@ -491,7 +491,7 @@ public interface Indexer
     public interface Searcher
     {
         /**
-         * @param orderGroup the collection of OpOrder.Groups which the ReadCommand is being performed under.
+         * @param executionController the collection of OpOrder.Groups which the ReadCommand is being performed under.
          * @return partitions from the base table matching the criteria of the search.
          */
         public UnfilteredPartitionIterator search(ReadExecutionController executionController);

File: src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java
Patch:
@@ -1664,7 +1664,6 @@ public void setCrcCheckChance(double crcCheckChance)
      * When calling this function, the caller must ensure that the SSTableReader is not referenced anywhere
      * except for threads holding a reference.
      *
-     * @return true if the this is the first time the file was marked obsolete.  Calling this
      * multiple times is usually buggy (see exceptions in Tracker.unmarkCompacting and removeOldSSTablesSize).
      */
     public void markObsolete(Runnable tidier)

File: src/java/org/apache/cassandra/io/util/RandomAccessReader.java
Patch:
@@ -308,10 +308,10 @@ public void seek(long newPosition)
      * represented by zero or more characters followed by {@code '\n'}, {@code
      * '\r'}, {@code "\r\n"} or the end of file marker. The string does not
      * include the line terminating sequence.
-     * <p/>
+     * <p>
      * Blocks until a line terminating sequence has been read, the end of the
      * file is reached or an exception is thrown.
-     *
+     * </p>
      * @return the contents of the line or {@code null} if no characters have
      * been read before the end of the file has been reached.
      * @throws IOException if this file is closed or another I/O error occurs.

File: src/java/org/apache/cassandra/repair/Validator.java
Patch:
@@ -128,7 +128,7 @@ public void prepare(ColumnFamilyStore cfs, MerkleTrees tree)
      * Called (in order) for every row present in the CF.
      * Hashes the row, and adds it to the tree being built.
      *
-     * @param row Row to add hash
+     * @param partition Partition to add hash
      */
     public void add(UnfilteredRowIterator partition)
     {

File: src/java/org/apache/cassandra/schema/Indexes.java
Patch:
@@ -95,7 +95,7 @@ public boolean has(String name)
     /**
      * Get the index with the specified id
      *
-     * @param name a UUID which identifies an index
+     * @param id a UUID which identifies an index
      * @return an empty {@link Optional} if no index with the specified id is found; a non-empty optional of
      *         {@link IndexMetadata} otherwise
      */
@@ -107,7 +107,7 @@ public Optional<IndexMetadata> get(UUID id)
 
     /**
      * Answer true if contains an index with the specified id.
-     * @param name a UUID which identifies an index.
+     * @param id a UUID which identifies an index.
      * @return true if an index with the specified id is found; false otherwise
      */
     public boolean has(UUID id)

File: src/java/org/apache/cassandra/service/StorageServiceMBean.java
Patch:
@@ -515,7 +515,7 @@ public interface StorageServiceMBean extends NotificationEmitter
      * Load new SSTables to the given keyspace/table
      *
      * @param ksName The parent keyspace name
-     * @param cfName The ColumnFamily name where SSTables belong
+     * @param tableName The ColumnFamily name where SSTables belong
      */
     public void loadNewSSTables(String ksName, String tableName);
 

File: src/java/org/apache/cassandra/thrift/CustomTThreadPoolServer.java
Patch:
@@ -56,8 +56,8 @@
  * Slightly modified version of the Apache Thrift TThreadPoolServer.
  * <p>
  * This allows passing an executor so you have more control over the actual
- * behaviour of the tasks being run.
- * <p/>
+ * behavior of the tasks being run.
+ * </p>
  * Newer version of Thrift should make this obsolete.
  */
 public class CustomTThreadPoolServer extends TServer

File: src/java/org/apache/cassandra/utils/ByteBufferUtil.java
Patch:
@@ -383,7 +383,6 @@ public static int serializedSizeWithShortLength(ByteBuffer buffer)
 
     /**
      * @param in data input
-     * @return null
      * @throws IOException if an I/O error occurs.
      */
     public static void skipShortLength(DataInputPlus in) throws IOException

File: src/java/org/apache/cassandra/streaming/StreamSession.java
Patch:
@@ -617,6 +617,7 @@ public synchronized void complete()
      */
     public synchronized void sessionFailed()
     {
+        logger.error("[Stream #{}] Remote peer {} failed stream session.", planId(), peer.getHostAddress());
         closeSession(State.FAILED);
     }
 
@@ -665,11 +666,13 @@ public void onDead(InetAddress endpoint, EndpointState state) {}
 
     public void onRemove(InetAddress endpoint)
     {
+        logger.error("[Stream #{}] Session failed because remote peer {} has left.", planId(), peer.getHostAddress());
         closeSession(State.FAILED);
     }
 
     public void onRestart(InetAddress endpoint, EndpointState epState)
     {
+        logger.error("[Stream #{}] Session failed because remote peer {} was restarted.", planId(), peer.getHostAddress());
         closeSession(State.FAILED);
     }
 

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegmentManager.java
Patch:
@@ -383,7 +383,8 @@ public CommitLogSegment call()
     void recycleSegment(final File file)
     {
         if (isCapExceeded()
-            || CommitLogDescriptor.fromFileName(file.getName()).getMessagingVersion() != MessagingService.current_version)
+            || CommitLogDescriptor.fromFileName(file.getName()).getMessagingVersion() != MessagingService.current_version
+            || !DatabaseDescriptor.getCommitLogSegmentRecyclingEnabled())
         {
             // (don't decrease managed size, since this was never a "live" segment)
             logger.debug("(Unopened) segment {} is no longer needed and will be deleted now", file);

File: src/java/org/apache/cassandra/gms/FailureDetector.java
Patch:
@@ -246,7 +246,7 @@ public boolean isAlive(InetAddress ep)
         // it's worth being defensive here so minor bugs don't cause disproportionate
         // badness.  (See CASSANDRA-1463 for an example).
         if (epState == null)
-            logger.error("unknown endpoint {}", ep);
+            logger.error("Unknown endpoint: " + ep, new IllegalArgumentException(""));
         return epState != null && epState.isAlive();
     }
 

File: src/java/org/apache/cassandra/utils/NativeSSTableLoaderClient.java
Patch:
@@ -75,7 +75,7 @@ public void init(String keyspace)
 
             for (TokenRange tokenRange : tokenRanges)
             {
-                Set<Host> endpoints = metadata.getReplicas(keyspace, tokenRange);
+                Set<Host> endpoints = metadata.getReplicas(Metadata.quote(keyspace), tokenRange);
                 Range<Token> range = new Range<>(tokenFactory.fromString(tokenRange.getStart().getValue().toString()),
                                                  tokenFactory.fromString(tokenRange.getEnd().getValue().toString()));
                 for (Host endpoint : endpoints)

File: tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java
Patch:
@@ -95,7 +95,7 @@ public void connect(ProtocolOptions.Compression compression) throws Exception
                                                 .addContactPoint(host)
                                                 .withPort(port)
                                                 .withPoolingOptions(poolingOpts)
-                                                .withProtocolVersion(ProtocolVersion.V2)
+                                                .withProtocolVersion(ProtocolVersion.NEWEST_SUPPORTED)
                                                 .withoutMetrics(); // The driver uses metrics 3 with conflict with our version
         if (whitelist != null)
             clusterBuilder.withLoadBalancingPolicy(whitelist);

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -723,7 +723,7 @@ public static void mutateMV(ByteBuffer dataKey, Collection<Mutation> mutations,
                         //if there are no paired endpoints there are probably range movements going on,
                         //so we write to the local batchlog to replay later
                         if (pendingEndpoints.isEmpty())
-                            logger.warn("Received base materialized view mutation for key %s that does not belong " +
+                            logger.warn("Received base materialized view mutation for key {} that does not belong " +
                                         "to this node. There is probably a range movement happening (move or decommission)," +
                                         "but this node hasn't updated its ring metadata yet. Adding mutation to " +
                                         "local batchlog to be replayed later.",

File: test/unit/org/apache/cassandra/cql3/CQLTester.java
Patch:
@@ -732,9 +732,9 @@ protected void assertRowsNet(int protocolVersion, ResultSet result, Object[]...
                                                                                                 .getCodecRegistry()
                                                                                                 .codecFor(type);
                 ByteBuffer expectedByteValue = codec.serialize(expected[j], ProtocolVersion.fromInt(protocolVersion));
-                int expectedBytes = expectedByteValue.remaining();
+                int expectedBytes = expectedByteValue == null ? -1 : expectedByteValue.remaining();
                 ByteBuffer actualValue = actual.getBytesUnsafe(meta.getName(j));
-                int actualBytes = actualValue.remaining();
+                int actualBytes = actualValue == null ? -1 : actualValue.remaining();
                 if (!Objects.equal(expectedByteValue, actualValue))
                     Assert.fail(String.format("Invalid value for row %d column %d (%s of type %s), " +
                                               "expected <%s> (%d bytes) but got <%s> (%d bytes) " +

File: test/unit/org/apache/cassandra/cql3/ViewTest.java
Patch:
@@ -935,7 +935,7 @@ public void testDeleteSingleColumnInViewClustering() throws Throwable
         createView("mv1", "CREATE MATERIALIZED VIEW %s AS SELECT * FROM %%s WHERE a IS NOT NULL AND b IS NOT NULL AND d IS NOT NULL PRIMARY KEY (a, d, b)");
 
         updateView("INSERT INTO %s (a, b, c, d) VALUES (?, ?, ?, ?)", 0, 0, 0, 0);
-        ResultSet mvRows = executeNet(protocolVersion, "SELECT a, d, b, cFROM mv1");
+        ResultSet mvRows = executeNet(protocolVersion, "SELECT a, d, b, c FROM mv1");
         assertRowsNet(protocolVersion, mvRows, row(0, 0, 0, 0));
 
         updateView("DELETE c FROM %s WHERE a = ? AND b = ?", 0, 0);

File: src/java/org/apache/cassandra/service/AbstractReadExecutor.java
Patch:
@@ -93,7 +93,6 @@ protected void makeDigestRequests(Iterable<InetAddress> endpoints)
 
     private void makeRequests(ReadCommand readCommand, Iterable<InetAddress> endpoints)
     {
-        MessageOut<ReadCommand> message = null;
         boolean hasLocalEndpoint = false;
 
         for (InetAddress endpoint : endpoints)
@@ -107,8 +106,7 @@ private void makeRequests(ReadCommand readCommand, Iterable<InetAddress> endpoin
             if (traceState != null)
                 traceState.trace("reading {} from {}", readCommand.isDigestQuery() ? "digest" : "data", endpoint);
             logger.trace("reading {} from {}", readCommand.isDigestQuery() ? "digest" : "data", endpoint);
-            if (message == null)
-                message = readCommand.createMessage(MessagingService.instance().getVersion(endpoint));
+            MessageOut<ReadCommand> message = readCommand.createMessage(MessagingService.instance().getVersion(endpoint));
             MessagingService.instance().sendRRWithFailure(message, endpoint, handler);
         }
 

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1683,7 +1683,9 @@ assert isRowCacheEnabled()
             {
                 metric.rowCacheHit.inc();
                 Tracing.trace("Row cache hit");
-                return filterColumnFamily(cachedCf, filter);
+                ColumnFamily result = filterColumnFamily(cachedCf, filter);
+                metric.updateSSTableIterated(0);
+                return result;
             }
 
             metric.rowCacheHitOutOfRange.inc();

File: src/java/org/apache/cassandra/utils/SearchIterator.java
Patch:
@@ -23,7 +23,8 @@ public interface SearchIterator<K, V>
 
     /**
      * Searches "forwards" (in direction of travel) in the iterator for the required key;
-     * if this or any key greater has already been returned by the iterator, null will be returned.
+     * if this or any key greater has already been returned by the iterator, the method may
+     * choose to return null, the correct or incorrect output, or fail an assertion.
      *
      * it is permitted to search past the end of the iterator, i.e. !hasNext() => next(?) == null
      *

File: src/java/org/apache/cassandra/streaming/StreamReceiveTask.java
Patch:
@@ -209,9 +209,9 @@ public void run()
                                                  cfs.keyspace.getName(), cfs.getTableName());
                             }
                         }
-                        task.session.taskCompleted(task);
                     }
                 }
+                task.session.taskCompleted(task);
             }
             catch (Throwable t)
             {

File: src/java/org/apache/cassandra/streaming/StreamReader.java
Patch:
@@ -116,9 +116,7 @@ public SSTableMultiWriter read(ReadableByteChannel channel) throws IOException
         {
             if (writer != null)
             {
-                Throwable e2 = writer.abort(null);
-                // add abort error to original and continue so we can drain unread stream
-                e.addSuppressed(e2);
+                writer.abort(e);
             }
             drain(dis, in.getBytesRead());
             if (e instanceof IOException)

File: src/java/org/apache/cassandra/streaming/compress/CompressedStreamReader.java
Patch:
@@ -104,9 +104,7 @@ public SSTableMultiWriter read(ReadableByteChannel channel) throws IOException
         {
             if (writer != null)
             {
-                Throwable e2 = writer.abort(null);
-                // add abort error to original and continue so we can drain unread stream
-                e.addSuppressed(e2);
+                writer.abort(e);
             }
             drain(cis, in.getBytesRead());
             if (e instanceof IOException)

File: src/java/org/apache/cassandra/io/compress/CompressedSequentialWriter.java
Patch:
@@ -156,7 +156,7 @@ public CompressionMetadata open(long overrideLength)
     public FileMark mark()
     {
         if (!buffer.hasRemaining())
-            doFlush();
+            doFlush(0);
         return new CompressedFileWriterMark(chunkOffset, current(), buffer.position(), chunkCount + 1);
     }
 

File: src/java/org/apache/cassandra/io/util/DataOutputBufferFixed.java
Patch:
@@ -47,7 +47,7 @@ public DataOutputBufferFixed(ByteBuffer buffer)
     }
 
     @Override
-    protected void doFlush() throws IOException
+    protected void doFlush(int count) throws IOException
     {
         throw new BufferOverflowException();
     }

File: src/java/org/apache/cassandra/io/util/SequentialWriter.java
Patch:
@@ -196,12 +196,12 @@ protected void syncDataOnlyInternal()
      */
     protected void syncInternal()
     {
-        doFlush();
+        doFlush(0);
         syncDataOnlyInternal();
     }
 
     @Override
-    protected void doFlush()
+    protected void doFlush(int count)
     {
         flushData();
 

File: src/java/org/apache/cassandra/io/util/DataOutputBufferFixed.java
Patch:
@@ -47,7 +47,7 @@ public DataOutputBufferFixed(ByteBuffer buffer)
     }
 
     @Override
-    protected void doFlush() throws IOException
+    protected void doFlush(int count) throws IOException
     {
         throw new BufferOverflowException();
     }

File: tools/stress/src/org/apache/cassandra/stress/StressProfile.java
Patch:
@@ -126,7 +126,7 @@ private void init(StressYaml yaml) throws RequestValidationException
             }
             catch (RuntimeException e)
             {
-                throw new IllegalArgumentException("There was a problem parsing the table cql: " + e.getCause().getMessage());
+                throw new IllegalArgumentException("There was a problem parsing the table cql: " + e.getMessage());
             }
         }
         else

File: src/java/org/apache/cassandra/cache/AutoSavingCache.java
Patch:
@@ -318,6 +318,7 @@ public CompactionInfo getCompactionInfo()
             return info.forProgress(keysWritten, Math.max(keysWritten, keysEstimate));
         }
 
+        @SuppressWarnings("resource")
         public void saveCache()
         {
             logger.trace("Deleting old {} files.", cacheType);

File: src/java/org/apache/cassandra/db/commitlog/CommitLogReplayer.java
Patch:
@@ -197,7 +197,7 @@ else if (end < offset || end > reader.length())
         }
         return end;
     }
-    
+
     abstract static class ReplayFilter
     {
         public abstract Iterable<ColumnFamily> filter(Mutation mutation);
@@ -273,6 +273,7 @@ public boolean includes(CFMetaData metadata)
         }
     }
 
+    @SuppressWarnings("resource")
     public void recover(File file, boolean tolerateTruncation) throws IOException
     {
         CommitLogDescriptor desc = CommitLogDescriptor.fromFileName(file.getName());

File: src/java/org/apache/cassandra/hadoop/AbstractColumnFamilyInputFormat.java
Patch:
@@ -117,9 +117,9 @@ else if (jobKeyRange.start_token != null)
             }
         }
 
-        try (Cluster cluster = CqlConfigHelper.getInputCluster(ConfigHelper.getInputInitialAddress(conf).split(","), conf))
+        try (Cluster cluster = CqlConfigHelper.getInputCluster(ConfigHelper.getInputInitialAddress(conf).split(","), conf);
+             Session session = cluster.connect())
         {
-            Session session = cluster.connect();
             Metadata metadata = session.getCluster().getMetadata();
 
             for (TokenRange range : masterRangeNodes.keySet())

File: src/java/org/apache/cassandra/hadoop/pig/CqlNativeStorage.java
Patch:
@@ -690,7 +690,7 @@ public void setStoreLocation(String location, Job job) throws IOException
             else
                 throw new IOException("bulk_insert_statement is missing in input url parameter");
             if (bulkTableAlias != null)
-                CqlBulkOutputFormat.setTableAlias(conf, bulkTableAlias, column_family); 
+                CqlBulkOutputFormat.setTableAlias(conf, bulkTableAlias, column_family);
             CqlBulkOutputFormat.setDeleteSourceOnSuccess(conf, bulkDeleteSourceOnSuccess);
             if (bulkOutputLocation != null)
                 conf.set(CqlBulkRecordWriter.OUTPUT_LOCATION, bulkOutputLocation);
@@ -724,9 +724,9 @@ protected void initSchema(String signature) throws IOException
         // Only get the schema if we haven't already gotten it
         if (!properties.containsKey(signature))
         {
-            try (Cluster cluster = CqlConfigHelper.getInputCluster(ConfigHelper.getInputInitialAddress(conf), conf))
+            try (Cluster cluster = CqlConfigHelper.getInputCluster(ConfigHelper.getInputInitialAddress(conf), conf);
+                 Session client = cluster.connect())
             {
-                Session client = cluster.connect();
                 client.execute("USE " + keyspace);
 
                 // compose the CfDef for the columfamily

File: src/java/org/apache/cassandra/io/util/SegmentedFile.java
Patch:
@@ -179,6 +179,7 @@ public SegmentedFile complete(String path)
             return complete(path, -1L);
         }
 
+        @SuppressWarnings("resource")
         public SegmentedFile complete(String path, long overrideLength)
         {
             ChannelProxy channelCopy = getChannel(path);

File: src/java/org/apache/cassandra/net/IncomingTcpConnection.java
Patch:
@@ -108,7 +108,7 @@ public void run()
             close();
         }
     }
-    
+
     @Override
     public void close()
     {
@@ -164,6 +164,7 @@ private void receiveMessages() throws IOException
         }
         else
         {
+            @SuppressWarnings("resource")
             ReadableByteChannel channel = socket.getChannel();
             in = new NIODataInputStream(channel != null ? channel : Channels.newChannel(socket.getInputStream()), BUFFER_SIZE);
         }

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -370,6 +370,7 @@ public void shutdownBlocking() throws InterruptedException
      */
     public void resetUnsafe()
     {
+        sync(true);
         allocator.resetUnsafe();
     }
 

File: src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java
Patch:
@@ -182,6 +182,9 @@ public boolean announceMigration(boolean isLocalOnly) throws RequestValidationEx
                         }
                         break;
                     case CLUSTERING_COLUMN:
+                        if (!cfm.isCQL3Table())
+                            throw new InvalidRequestException(String.format("Cannot alter clustering column %s in a non-CQL3 table", columnName));
+
                         AbstractType<?> oldType = cfm.comparator.subtype(def.position());
                         // Note that CFMetaData.validateCompatibility already validate the change we're about to do. However, the error message it
                         // sends is a bit cryptic for a CQL3 user, so validating here for a sake of returning a better error message

File: test/unit/org/apache/cassandra/cql3/validation/operations/AggregationTest.java
Patch:
@@ -1371,7 +1371,7 @@ public void testFunctionWithFrozenSetType() throws Throwable
                                              "INITCOND null");
 
         assertRows(execute("SELECT initcond FROM system_schema.aggregates WHERE keyspace_name=? AND aggregate_name=?", KEYSPACE, shortFunctionName(aggregation)),
-                   row(null));
+                   row((Object) null));
 
         assertRows(execute("SELECT " + aggregation + "(b) FROM %s"),
                    row(set(7, 8, 9)));

File: src/java/org/apache/cassandra/cql3/functions/FunctionResolver.java
Patch:
@@ -126,9 +126,11 @@ public static Function get(String keyspace,
             }
         }
 
-        if (compatibles == null || compatibles.isEmpty())
+        if (compatibles == null)
+        {
             throw new InvalidRequestException(String.format("Invalid call to function %s, none of its type signatures match (known type signatures: %s)",
                                                             name, format(candidates)));
+        }
 
         if (compatibles.size() > 1)
             throw new InvalidRequestException(String.format("Ambiguous call to function %s (can be matched by following signatures: %s): use type casts to disambiguate",

File: src/java/org/apache/cassandra/db/SystemKeyspace.java
Patch:
@@ -450,6 +450,7 @@ private static Functions functions()
                         .add(TimeFcts.all())
                         .add(BytesConversionFcts.all())
                         .add(AggregateFcts.all())
+                        .add(CastFcts.all())
                         .build();
     }
 

File: test/unit/org/apache/cassandra/cql3/validation/operations/AggregationTest.java
Patch:
@@ -96,6 +96,7 @@ public void testFunctions() throws Throwable
         assertRows(execute("SELECT COUNT(b), count(c), count(e), count(f) FROM %s LIMIT 2"), row(4L, 3L, 3L, 3L));
         assertRows(execute("SELECT COUNT(b), count(c), count(e), count(f) FROM %s WHERE a = 1 LIMIT 2"),
                    row(4L, 3L, 3L, 3L));
+        assertRows(execute("SELECT AVG(CAST(b AS double)) FROM %s"), row(11.0/4));
     }
 
     @Test
@@ -1371,7 +1372,7 @@ public void testFunctionWithFrozenSetType() throws Throwable
                                              "INITCOND null");
 
         assertRows(execute("SELECT initcond FROM system_schema.aggregates WHERE keyspace_name=? AND aggregate_name=?", KEYSPACE, shortFunctionName(aggregation)),
-                   row(null));
+                   row((Object) null));
 
         assertRows(execute("SELECT " + aggregation + "(b) FROM %s"),
                    row(set(7, 8, 9)));

File: test/unit/org/apache/cassandra/db/HintedHandOffTest.java
Patch:
@@ -35,6 +35,7 @@
 import org.apache.cassandra.db.marshal.Int32Type;
 import org.apache.cassandra.db.marshal.UUIDType;
 import org.apache.cassandra.utils.ByteBufferUtil;
+import org.apache.cassandra.utils.Pair;
 
 import static org.junit.Assert.assertEquals;
 import static org.apache.cassandra.cql3.QueryProcessor.executeInternal;
@@ -65,7 +66,7 @@ public void testCompactionOfHintsCF() throws Exception
         HintedHandOffManager.instance.hintFor(rm,
                                               System.currentTimeMillis(),
                                               HintedHandOffManager.calculateHintTTL(rm),
-                                              UUID.randomUUID())
+                                              Pair.create(InetAddress.getByName("127.0.0.1"), UUID.randomUUID()))
                                      .apply();
 
         // flush data to disk
@@ -106,7 +107,7 @@ public void testTruncateHints() throws Exception
         HintedHandOffManager.instance.hintFor(rm,
                                               System.currentTimeMillis(),
                                               HintedHandOffManager.calculateHintTTL(rm),
-                                              UUID.randomUUID())
+                                              Pair.create(InetAddress.getByName("127.0.0.1"), UUID.randomUUID()))
                                      .apply();
 
         assert getNoOfHints() == 1;

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -887,7 +887,8 @@ EndpointState getStateForVersionBiggerThan(InetAddress forEndpoint, int version)
                     states.put(key, value);
                 }
             }
-            reqdEndpointState.addApplicationStates(states);
+            if (reqdEndpointState != null)
+                reqdEndpointState.addApplicationStates(states);
         }
         return reqdEndpointState;
     }

File: src/java/org/apache/cassandra/db/marshal/SimpleDateType.java
Patch:
@@ -69,7 +69,7 @@ public boolean isCompatibleWith(AbstractType<?> previous)
     @Override
     public boolean isValueCompatibleWithInternal(AbstractType<?> otherType)
     {
-        return this == otherType || otherType == IntegerType.instance;
+        return this == otherType || otherType == Int32Type.instance;
     }
 
     public Term fromJSONObject(Object parsed) throws MarshalException

File: test/unit/org/apache/cassandra/locator/EC2SnitchTest.java
Patch:
@@ -24,6 +24,7 @@
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.UnknownHostException;
+import java.util.EnumMap;
 import java.util.Map;
 
 import org.junit.AfterClass;
@@ -79,9 +80,10 @@ public void testRac() throws IOException, ConfigurationException
         InetAddress nonlocal = InetAddress.getByName("127.0.0.7");
 
         Gossiper.instance.addSavedEndpoint(nonlocal);
-        Map<ApplicationState,VersionedValue> stateMap = Gossiper.instance.getEndpointStateForEndpoint(nonlocal).getApplicationStateMap();
+        Map<ApplicationState, VersionedValue> stateMap = new EnumMap<>(ApplicationState.class);
         stateMap.put(ApplicationState.DC, StorageService.instance.valueFactory.datacenter("us-west"));
         stateMap.put(ApplicationState.RACK, StorageService.instance.valueFactory.datacenter("1a"));
+        Gossiper.instance.getEndpointStateForEndpoint(nonlocal).addApplicationStates(stateMap);
 
         assertEquals("us-west", snitch.getDatacenter(nonlocal));
         assertEquals("1a", snitch.getRack(nonlocal));

File: src/java/org/apache/cassandra/hadoop/AbstractColumnFamilyInputFormat.java
Patch:
@@ -215,7 +215,7 @@ public List<InputSplit> call() throws Exception
                                     partitioner.preservesOrder() ?
                                             subrange.getStart().toString().substring(2) : subrange.getStart().toString(),
                                     partitioner.preservesOrder() ?
-                                            subrange.getEnd().toString().substring(2) : subrange.getStart().toString(),
+                                            subrange.getEnd().toString().substring(2) : subrange.getEnd().toString(),
                                     subSplits.get(subSplit),
                                     endpoints);
 

File: test/unit/org/apache/cassandra/io/sstable/CQLSSTableWriterTest.java
Patch:
@@ -158,7 +158,7 @@ public void testForbidCounterUpdates() throws Exception
         String insert = String.format("UPDATE cql_keyspace.counter1 SET my_counter = my_counter - ? WHERE my_id = ?");
         CQLSSTableWriter.builder().inDirectory(dataDir)
                         .forTable(schema)
-                        .withPartitioner(StorageService.instance.getPartitioner())
+                        .withPartitioner(Murmur3Partitioner.instance)
                         .using(insert).build();
     }
 

File: src/java/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -922,8 +922,10 @@ static PartitionRangeReadCommand maybeConvertNamesToSlice(PartitionRangeReadComm
         static ColumnFilter getColumnSelectionForSlice(boolean selectsStatics, int compositesToGroup, CFMetaData metadata)
         {
             // A value of -2 indicates this is a DISTINCT query that doesn't select static columns, only partition keys.
+            // In that case, we'll basically be querying the first row of the partition, but we must make sure we include
+            // all columns so we get at least one cell if there is a live row as it would confuse pre-3.0 nodes otherwise.
             if (compositesToGroup == -2)
-                return ColumnFilter.selection(PartitionColumns.NONE);
+                return ColumnFilter.all(metadata);
 
             // if a slice query from a pre-3.0 node doesn't cover statics, we shouldn't select them at all
             PartitionColumns columns = selectsStatics

File: src/java/org/apache/cassandra/cql3/statements/DropTypeStatement.java
Patch:
@@ -85,7 +85,7 @@ public void validate(ClientState state) throws RequestValidationException
 
         for (UserType ut : ksm.types)
             if (!ut.name.equals(name.getUserTypeName()) && isUsedBy(ut))
-                throw new InvalidRequestException(String.format("Cannot drop user type %s as it is still used by user type %s", name, ut.asCQL3Type()));
+                throw new InvalidRequestException(String.format("Cannot drop user type %s as it is still used by user type %s", name, ut.getNameAsString()));
 
         for (CFMetaData cfm : ksm.tablesAndViews())
             for (ColumnDefinition def : cfm.allColumns())

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -667,7 +667,7 @@ public static void mutateMV(ByteBuffer dataKey, Collection<Mutation> mutations,
             // if we haven't joined the ring, write everything to batchlog because paired replicas may be stale
             final UUID batchUUID = UUIDGen.getTimeUUID();
 
-            if (!Gossiper.instance.isEnabled())
+            if (StorageService.instance.isStarting() || StorageService.instance.isJoining() || StorageService.instance.isMoving())
             {
                 BatchlogManager.store(Batch.createLocal(batchUUID, FBUtilities.timestampMicros(),
                                                         mutations),

File: src/java/org/apache/cassandra/utils/NativeSSTableLoaderClient.java
Patch:
@@ -23,6 +23,7 @@
 import com.datastax.driver.core.*;
 
 import org.apache.cassandra.config.ColumnDefinition;
+import org.apache.cassandra.config.ColumnDefinition.ClusteringOrder;
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.cql3.ColumnIdentifier;
 import org.apache.cassandra.db.marshal.*;

File: src/java/org/apache/cassandra/schema/Types.java
Patch:
@@ -237,7 +237,7 @@ public Types build()
             return Types.builder().add(types).build();
         }
 
-        void add(String name, List<String> fieldNames, List<String> fieldTypes)
+        public void add(String name, List<String> fieldNames, List<String> fieldTypes)
         {
             List<CQL3Type.Raw> rawFieldTypes =
                 fieldTypes.stream()

File: src/java/org/apache/cassandra/schema/CQLTypeParser.java
Patch:
@@ -52,7 +52,7 @@ public static AbstractType<?> parse(String keyspace, String unparsed, Types user
         if (udt != null)
             return udt;
 
-        return parseRaw(unparsed).prepare(keyspace, userTypes).getType();
+        return parseRaw(unparsed).prepareInternal(keyspace, userTypes).getType();
     }
 
     static CQL3Type.Raw parseRaw(String type)

File: src/java/org/apache/cassandra/schema/Types.java
Patch:
@@ -274,7 +274,7 @@ UserType prepare(String keyspace, Types types)
 
                 List<AbstractType<?>> preparedFieldTypes =
                     fieldTypes.stream()
-                              .map(t -> t.prepare(keyspace, types).getType())
+                              .map(t -> t.prepareInternal(keyspace, types).getType())
                               .collect(toList());
 
                 return new UserType(keyspace, bytes(name), preparedFieldNames, preparedFieldTypes);

File: src/java/org/apache/cassandra/cql3/ColumnIdentifier.java
Patch:
@@ -328,7 +328,7 @@ public String toCQLString()
         }
     }
 
-    private static String maybeQuote(String text)
+    static String maybeQuote(String text)
     {
         if (UNQUOTED_IDENTIFIER.matcher(text).matches())
             return text;

File: src/java/org/apache/cassandra/db/DefinitionsUpdateVerbHandler.java
Patch:
@@ -24,6 +24,7 @@
 
 import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.concurrent.StageManager;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.net.IVerbHandler;
 import org.apache.cassandra.net.MessageIn;
 import org.apache.cassandra.schema.SchemaKeyspace;
@@ -45,7 +46,7 @@ public void doVerb(final MessageIn<Collection<Mutation>> message, int id)
 
         StageManager.getStage(Stage.MIGRATION).submit(new WrappedRunnable()
         {
-            public void runMayThrow() throws Exception
+            public void runMayThrow() throws ConfigurationException
             {
                 SchemaKeyspace.mergeSchemaAndAnnounceVersion(message.payload);
             }

File: src/java/org/apache/cassandra/db/Keyspace.java
Patch:
@@ -377,7 +377,6 @@ public void initCf(UUID cfId, String cfName, boolean loadSSTables)
             // re-initializing an existing CF.  This will happen if you cleared the schema
             // on this node and it's getting repopulated from the rest of the cluster.
             assert cfs.name.equals(cfName);
-            cfs.metadata.reload();
             cfs.reload();
         }
     }

File: test/unit/org/apache/cassandra/cql3/validation/entities/TupleTypeTest.java
Patch:
@@ -110,7 +110,7 @@ public void testTupleFromString() throws Throwable
             row(0, 4, tuple(null, "1"))
         );
 
-        assertInvalidMessage("Invalid tuple literal: too many elements. Type tuple<int, text> expects 2 but got 3",
+        assertInvalidMessage("Invalid tuple literal: too many elements. Type frozen<tuple<int, text>> expects 2 but got 3",
                              "INSERT INTO %s(k, t) VALUES (1,'1:2:3')");
     }
 
@@ -121,7 +121,7 @@ public void testInvalidQueries() throws Throwable
 
         assertInvalidSyntax("INSERT INTO %s (k, t) VALUES (0, ())");
 
-        assertInvalidMessage("Invalid tuple literal for t: too many elements. Type tuple<int, text, double> expects 3 but got 4",
+        assertInvalidMessage("Invalid tuple literal for t: too many elements. Type frozen<tuple<int, text, double>> expects 3 but got 4",
                              "INSERT INTO %s (k, t) VALUES (0, (2, 'foo', 3.1, 'bar'))");
     }
 

File: test/unit/org/apache/cassandra/cql3/validation/entities/UFTest.java
Patch:
@@ -797,7 +797,7 @@ public void testFunctionInSystemKS() throws Throwable
     @Test
     public void testFunctionNonExistingKeyspace() throws Throwable
     {
-        assertInvalidMessage("to non existing keyspace",
+        assertInvalidMessage("Keyspace this_ks_does_not_exist doesn't exist",
                              "CREATE OR REPLACE FUNCTION this_ks_does_not_exist.jnft(val double) " +
                              "RETURNS NULL ON NULL INPUT " +
                              "RETURNS double " +
@@ -810,7 +810,7 @@ public void testFunctionAfterOnDropKeyspace() throws Throwable
     {
         dropPerTestKeyspace();
 
-        assertInvalidMessage("to non existing keyspace",
+        assertInvalidMessage("Keyspace " + KEYSPACE_PER_TEST + " doesn't exist",
                              "CREATE OR REPLACE FUNCTION " + KEYSPACE_PER_TEST + ".jnft(val double) " +
                              "RETURNS NULL ON NULL INPUT " +
                              "RETURNS double " +

File: src/java/org/apache/cassandra/utils/memory/MemoryUtil.java
Patch:
@@ -98,7 +98,7 @@ public static byte getByte(long address)
 
     public static int getShort(long address)
     {
-        return UNALIGNED ? unsafe.getShort(address) : getShortByByte(address);
+        return UNALIGNED ? unsafe.getShort(address) & 0xffff : getShortByByte(address);
     }
 
     public static int getInt(long address)

File: src/java/org/apache/cassandra/cql3/statements/CQL3CasRequest.java
Patch:
@@ -133,7 +133,7 @@ private PartitionColumns columnsToRead()
         return conditionColumns;
     }
 
-    public SinglePartitionReadCommand<?> readCommand(int nowInSec)
+    public SinglePartitionReadCommand readCommand(int nowInSec)
     {
         assert !conditions.isEmpty();
         Slices.Builder builder = new Slices.Builder(cfm.comparator, conditions.size());

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -345,7 +345,7 @@ private Map<DecoratedKey, Partition> readRequiredLists(Collection<ByteBuffer> pa
             throw new InvalidRequestException(String.format("Write operation require a read but consistency %s is not supported on reads", cl));
         }
 
-        List<SinglePartitionReadCommand<?>> commands = new ArrayList<>(partitionKeys.size());
+        List<SinglePartitionReadCommand> commands = new ArrayList<>(partitionKeys.size());
         int nowInSec = FBUtilities.nowInSeconds();
         for (ByteBuffer key : partitionKeys)
             commands.add(SinglePartitionReadCommand.create(cfm,
@@ -573,7 +573,7 @@ static RowIterator casInternal(CQL3CasRequest request, QueryState state)
     {
         UUID ballot = UUIDGen.getTimeUUIDFromMicros(state.getTimestamp());
 
-        SinglePartitionReadCommand<?> readCommand = request.readCommand(FBUtilities.nowInSeconds());
+        SinglePartitionReadCommand readCommand = request.readCommand(FBUtilities.nowInSeconds());
         FilteredPartition current;
         try (ReadOrderGroup orderGroup = readCommand.startOrderGroup(); PartitionIterator iter = readCommand.executeInternal(orderGroup))
         {

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -440,7 +440,7 @@ private ReadQuery getSliceCommands(QueryOptions options, DataLimits limit, int n
 
         // Note that we use the total limit for every key, which is potentially inefficient.
         // However, IN + LIMIT is not a very sensible choice.
-        List<SinglePartitionReadCommand<?>> commands = new ArrayList<>(keys.size());
+        List<SinglePartitionReadCommand> commands = new ArrayList<>(keys.size());
         for (ByteBuffer key : keys)
         {
             QueryProcessor.validateKey(key);

File: src/java/org/apache/cassandra/db/AbstractReadCommandBuilder.java
Patch:
@@ -255,7 +255,7 @@ protected ClusteringIndexFilter makeFilter()
         @Override
         public ReadCommand build()
         {
-            return SinglePartitionSliceCommand.create(cfs.metadata, nowInSeconds, makeColumnFilter(), filter, makeLimits(), partitionKey, makeFilter());
+            return SinglePartitionReadCommand.create(cfs.metadata, nowInSeconds, makeColumnFilter(), filter, makeLimits(), partitionKey, makeFilter());
         }
     }
 

File: src/java/org/apache/cassandra/db/partitions/PartitionIterators.java
Patch:
@@ -33,7 +33,7 @@ public abstract class PartitionIterators
     private PartitionIterators() {}
 
     @SuppressWarnings("resource") // The created resources are returned right away
-    public static RowIterator getOnlyElement(final PartitionIterator iter, SinglePartitionReadCommand<?> command)
+    public static RowIterator getOnlyElement(final PartitionIterator iter, SinglePartitionReadCommand command)
     {
         // If the query has no results, we'll get an empty iterator, but we still
         // want a RowIterator out of this method, so we return an empty one.

File: src/java/org/apache/cassandra/db/partitions/UnfilteredPartitionIterators.java
Patch:
@@ -51,7 +51,7 @@ public interface MergeListener
     }
 
     @SuppressWarnings("resource") // The created resources are returned right away
-    public static UnfilteredRowIterator getOnlyElement(final UnfilteredPartitionIterator iter, SinglePartitionReadCommand<?> command)
+    public static UnfilteredRowIterator getOnlyElement(final UnfilteredPartitionIterator iter, SinglePartitionReadCommand command)
     {
         // If the query has no results, we'll get an empty iterator, but we still
         // want a RowIterator out of this method, so we return an empty one.

File: src/java/org/apache/cassandra/schema/LegacySchemaMigrator.java
Patch:
@@ -709,7 +709,7 @@ private static long readTypeTimestamp(String keyspaceName, String typeName)
         Slices slices = Slices.with(comparator, Slice.make(comparator, typeName));
         int nowInSec = FBUtilities.nowInSeconds();
         DecoratedKey key = store.metadata.decorateKey(AsciiType.instance.fromString(keyspaceName));
-        SinglePartitionReadCommand command = SinglePartitionSliceCommand.create(store.metadata, nowInSec, key, slices);
+        SinglePartitionReadCommand command = SinglePartitionReadCommand.create(store.metadata, nowInSec, key, slices);
 
         try (OpOrder.Group op = store.readOrdering.start();
              RowIterator partition = UnfilteredRowIterators.filter(command.queryMemtableAndDisk(store, op), nowInSec))

File: src/java/org/apache/cassandra/schema/SchemaKeyspace.java
Patch:
@@ -457,8 +457,8 @@ private static <T> T readSchemaPartitionForTableAndApply(String schemaTableName,
         Slices slices = Slices.with(comparator, Slice.make(comparator, tableName));
         int nowInSec = FBUtilities.nowInSeconds();
         try (OpOrder.Group op = store.readOrdering.start();
-             RowIterator partition =  UnfilteredRowIterators.filter(SinglePartitionSliceCommand.create(store.metadata, nowInSec, getSchemaKSKey(keyspaceName), slices)
-                                                                                               .queryMemtableAndDisk(store, op), nowInSec))
+             RowIterator partition =  UnfilteredRowIterators.filter(SinglePartitionReadCommand.create(store.metadata, nowInSec, getSchemaKSKey(keyspaceName), slices)
+                                                                                              .queryMemtableAndDisk(store, op), nowInSec))
         {
             return fct.apply(partition);
         }

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -1541,7 +1541,7 @@ private static PartitionIterator readRegular(SinglePartitionReadCommand.Group gr
      * 4. If the digests (if any) match the data return the data
      * 5. else carry out read repair by getting data from all the nodes.
      */
-    private static PartitionIterator fetchRows(List<SinglePartitionReadCommand<?>> commands, ConsistencyLevel consistencyLevel)
+    private static PartitionIterator fetchRows(List<SinglePartitionReadCommand> commands, ConsistencyLevel consistencyLevel)
     throws UnavailableException, ReadFailureException, ReadTimeoutException
     {
         int cmdCount = commands.size();
@@ -1575,14 +1575,14 @@ private static PartitionIterator fetchRows(List<SinglePartitionReadCommand<?>> c
 
     private static class SinglePartitionReadLifecycle
     {
-        private final SinglePartitionReadCommand<?> command;
+        private final SinglePartitionReadCommand command;
         private final AbstractReadExecutor executor;
         private final ConsistencyLevel consistency;
 
         private PartitionIterator result;
         private ReadCallback repairHandler;
 
-        SinglePartitionReadLifecycle(SinglePartitionReadCommand<?> command, ConsistencyLevel consistency)
+        SinglePartitionReadLifecycle(SinglePartitionReadCommand command, ConsistencyLevel consistency)
         {
             this.command = command;
             this.executor = AbstractReadExecutor.getReadExecutor(command, consistency);

File: src/java/org/apache/cassandra/service/pager/SinglePartitionPager.java
Patch:
@@ -35,11 +35,11 @@ public class SinglePartitionPager extends AbstractQueryPager
 {
     private static final Logger logger = LoggerFactory.getLogger(SinglePartitionPager.class);
 
-    private final SinglePartitionReadCommand<?> command;
+    private final SinglePartitionReadCommand command;
 
     private volatile PagingState.RowMark lastReturned;
 
-    public SinglePartitionPager(SinglePartitionReadCommand<?> command, PagingState state, int protocolVersion)
+    public SinglePartitionPager(SinglePartitionReadCommand command, PagingState state, int protocolVersion)
     {
         super(command, protocolVersion);
         this.command = command;

File: test/unit/org/apache/cassandra/db/RangeTombstoneTest.java
Patch:
@@ -210,7 +210,7 @@ public void rangeTombstoneFilteringTest() throws Exception
         sb.add(Slice.Bound.create(cfs.getComparator(), true, true, 1), Slice.Bound.create(cfs.getComparator(), false, true, 10));
         sb.add(Slice.Bound.create(cfs.getComparator(), true, true, 16), Slice.Bound.create(cfs.getComparator(), false, true, 20));
 
-        partition = Util.getOnlyPartitionUnfiltered(SinglePartitionSliceCommand.create(cfs.metadata, FBUtilities.nowInSeconds(), Util.dk(key), sb.build()));
+        partition = Util.getOnlyPartitionUnfiltered(SinglePartitionReadCommand.create(cfs.metadata, FBUtilities.nowInSeconds(), Util.dk(key), sb.build()));
         rt = rangeTombstones(partition);
         assertEquals(2, rt.size());
     }

File: src/java/org/apache/cassandra/db/partitions/PartitionUpdate.java
Patch:
@@ -334,6 +334,7 @@ public void updateAllTimestamp(long newTimestamp)
     public int operationCount()
     {
         return rowCount()
+             + (staticRow().isEmpty() ? 0 : 1)
              + deletionInfo.rangeCount()
              + (deletionInfo.getPartitionDeletion().isLive() ? 0 : 1);
     }

File: test/unit/org/apache/cassandra/security/CipherFactoryTest.java
Patch:
@@ -19,7 +19,7 @@ public class CipherFactoryTest
     // http://www.gutenberg.org/files/4300/4300-h/4300-h.htm
     static final String ULYSSEUS = "Stately, plump Buck Mulligan came from the stairhead, bearing a bowl of lather on which a mirror and a razor lay crossed. " +
                                    "A yellow dressinggown, ungirdled, was sustained gently behind him on the mild morning air. He held the bowl aloft and intoned: " +
-                                   "—Introibo ad altare Dei.";
+                                   "-Introibo ad altare Dei.";
     TransparentDataEncryptionOptions encryptionOptions;
     CipherFactory cipherFactory;
     SecureRandom secureRandom;

File: src/java/org/apache/cassandra/db/lifecycle/LogAwareFileLister.java
Patch:
@@ -98,15 +98,14 @@ static List<File> list(DirectoryStream<Path> stream) throws IOException
      */
     void classifyFiles(File txnFile)
     {
-        LogFile txn = LogFile.make(txnFile, -1);
+        LogFile txn = LogFile.make(txnFile);
         readTxnLog(txn);
         classifyFiles(txn);
         files.put(txnFile, FileType.TXN_LOG);
     }
 
     void readTxnLog(LogFile txn)
     {
-        txn.readRecords();
         if (!txn.verify() && onTxnErr == OnTxnErr.THROW)
             throw new LogTransaction.CorruptTransactionLogException("Some records failed verification. See earlier in log for details.", txn);
     }

File: src/java/org/apache/cassandra/db/lifecycle/Tracker.java
Patch:
@@ -224,7 +224,7 @@ public Throwable dropSSTables(Throwable accumulate)
      */
     public Throwable dropSSTables(final Predicate<SSTableReader> remove, OperationType operationType, Throwable accumulate)
     {
-        try (LogTransaction txnLogs = new LogTransaction(operationType, cfstore.metadata, this))
+        try (LogTransaction txnLogs = new LogTransaction(operationType, this))
         {
             Pair<View, View> result = apply(view -> {
                 Set<SSTableReader> toremove = copyOf(filter(view.sstables, and(remove, notIn(view.compacting))));
@@ -247,7 +247,7 @@ public Throwable dropSSTables(final Predicate<SSTableReader> remove, OperationTy
                     accumulate = updateSizeTracking(removed, emptySet(), accumulate);
                     accumulate = release(selfRefs(removed), accumulate);
                     // notifySSTablesChanged -> LeveledManifest.promote doesn't like a no-op "promotion"
-                    accumulate = notifySSTablesChanged(removed, Collections.<SSTableReader>emptySet(), txnLogs.getType(), accumulate);
+                    accumulate = notifySSTablesChanged(removed, Collections.<SSTableReader>emptySet(), txnLogs.type(), accumulate);
                 }
             }
             catch (Throwable t)

File: src/java/org/apache/cassandra/io/sstable/SSTableTxnWriter.java
Patch:
@@ -96,7 +96,7 @@ public Collection<SSTableReader> finish(boolean openResult)
     @SuppressWarnings("resource") // log and writer closed during postCleanup
     public static SSTableTxnWriter create(ColumnFamilyStore cfs, Descriptor descriptor, long keyCount, long repairedAt, int sstableLevel, SerializationHeader header)
     {
-        LifecycleTransaction txn = LifecycleTransaction.offline(OperationType.WRITE, descriptor.directory);
+        LifecycleTransaction txn = LifecycleTransaction.offline(OperationType.WRITE);
         SSTableMultiWriter writer = cfs.createSSTableMultiWriter(descriptor, keyCount, repairedAt, sstableLevel, header, txn);
         return new SSTableTxnWriter(txn, writer);
     }
@@ -105,7 +105,7 @@ public static SSTableTxnWriter create(ColumnFamilyStore cfs, Descriptor descript
     public static SSTableTxnWriter create(CFMetaData cfm, Descriptor descriptor, long keyCount, long repairedAt, int sstableLevel, SerializationHeader header)
     {
         // if the column family store does not exist, we create a new default SSTableMultiWriter to use:
-        LifecycleTransaction txn = LifecycleTransaction.offline(OperationType.WRITE, descriptor.directory);
+        LifecycleTransaction txn = LifecycleTransaction.offline(OperationType.WRITE);
         MetadataCollector collector = new MetadataCollector(cfm.comparator).sstableLevel(sstableLevel);
         SSTableMultiWriter writer = SimpleSSTableMultiWriter.create(descriptor, keyCount, repairedAt, cfm, collector, header, txn);
         return new SSTableTxnWriter(txn, writer);

File: src/java/org/apache/cassandra/streaming/StreamReceiveTask.java
Patch:
@@ -72,7 +72,7 @@ public StreamReceiveTask(StreamSession session, UUID cfId, int totalFiles, long
         this.totalSize = totalSize;
         // this is an "offline" transaction, as we currently manually expose the sstables once done;
         // this should be revisited at a later date, so that LifecycleTransaction manages all sstable state changes
-        this.txn = LifecycleTransaction.offline(OperationType.STREAM, Schema.instance.getCFMetaData(cfId));
+        this.txn = LifecycleTransaction.offline(OperationType.STREAM);
         this.sstables = new ArrayList<>(totalFiles);
     }
 

File: test/unit/org/apache/cassandra/db/ScrubTest.java
Patch:
@@ -326,7 +326,7 @@ public void testScrubOutOfOrder() throws Exception
             String filename = cfs.getSSTablePath(tempDataDir);
             Descriptor desc = Descriptor.fromFilename(filename);
 
-            LifecycleTransaction txn = LifecycleTransaction.offline(OperationType.WRITE, desc.directory);
+            LifecycleTransaction txn = LifecycleTransaction.offline(OperationType.WRITE);
             try (SSTableTxnWriter writer = new SSTableTxnWriter(txn, createTestWriter(desc, (long) keys.size(), cfs.metadata, txn)))
             {
 

File: test/unit/org/apache/cassandra/db/lifecycle/HelpersTest.java
Patch:
@@ -159,7 +159,7 @@ public void testSetupDeletionNotification()
     public void testMarkObsolete()
     {
         ColumnFamilyStore cfs = MockSchema.newCFS();
-        LogTransaction txnLogs = new LogTransaction(OperationType.UNKNOWN, cfs.metadata);
+        LogTransaction txnLogs = new LogTransaction(OperationType.UNKNOWN);
         Iterable<SSTableReader> readers = Lists.newArrayList(MockSchema.sstable(1, cfs), MockSchema.sstable(2, cfs));
 
         List<LogTransaction.Obsoletion> obsoletions = new ArrayList<>();

File: test/unit/org/apache/cassandra/io/sstable/SSTableRewriterTest.java
Patch:
@@ -246,7 +246,7 @@ public void testFileRemoval() throws InterruptedException
         truncate(cfs);
 
         File dir = cfs.getDirectories().getDirectoryForNewSSTables();
-        LifecycleTransaction txn = LifecycleTransaction.offline(OperationType.WRITE, cfs.metadata);
+        LifecycleTransaction txn = LifecycleTransaction.offline(OperationType.WRITE);
         try (SSTableWriter writer = getWriter(cfs, dir, txn))
         {
             for (int i = 0; i < 10000; i++)

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -1571,7 +1571,7 @@ private static float estimateResultRowsPerRange(AbstractRangeCommand command, Ke
                 {
                     // use our own mean column count as our estimate for how many matching rows each node will have
                     SecondaryIndex highestSelectivityIndex = searcher.highestSelectivityIndex(command.rowFilter);
-                    resultRowsPerRange = Math.min(resultRowsPerRange, highestSelectivityIndex.estimateResultRows());
+                    resultRowsPerRange = highestSelectivityIndex == null ? resultRowsPerRange : Math.min(resultRowsPerRange, highestSelectivityIndex.estimateResultRows());
                 }
             }
         }

File: src/java/org/apache/cassandra/io/sstable/format/big/BigTableWriter.java
Patch:
@@ -101,8 +101,8 @@ public void resetAndTruncate()
     private long beforeAppend(DecoratedKey decoratedKey)
     {
         assert decoratedKey != null : "Keys must not be null"; // empty keys ARE allowed b/c of indexed column values
-        //if (lastWrittenKey != null && lastWrittenKey.compareTo(decoratedKey) >= 0)
-        //    throw new RuntimeException("Last written key " + lastWrittenKey + " >= current key " + decoratedKey + " writing into " + getFilename());
+        if (lastWrittenKey != null && lastWrittenKey.compareTo(decoratedKey) >= 0)
+            throw new RuntimeException("Last written key " + lastWrittenKey + " >= current key " + decoratedKey + " writing into " + getFilename());
         return (lastWrittenKey == null) ? 0 : dataFile.position();
     }
 

File: src/java/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -1060,7 +1060,7 @@ public ReadCommand deserialize(DataInputPlus in, int version) throws IOException
             // is what 3.0 does.
             DataRange dataRange = new DataRange(keyRange, filter);
             Slices slices = filter.requestedSlices();
-            if (startBound != LegacyLayout.LegacyBound.BOTTOM && !startBound.bound.equals(slices.get(0).start()))
+            if (!isDistinct && startBound != LegacyLayout.LegacyBound.BOTTOM && !startBound.bound.equals(slices.get(0).start()))
             {
                 // pre-3.0 nodes normally expect pages to include the last cell from the previous page, but they handle it
                 // missing without any problems, so we can safely always set "inclusive" to false in the data range

File: src/java/org/apache/cassandra/cql3/UntypedResultSet.java
Patch:
@@ -76,7 +76,7 @@ public Row one()
         {
             if (cqlRows.rows.size() != 1)
                 throw new IllegalStateException("One row required, " + cqlRows.rows.size() + " found");
-            return new Row(cqlRows.metadata.names, cqlRows.rows.get(0));
+            return new Row(cqlRows.metadata.requestNames(), cqlRows.rows.get(0));
         }
 
         public Iterator<Row> iterator()
@@ -89,7 +89,7 @@ protected Row computeNext()
                 {
                     if (!iter.hasNext())
                         return endOfData();
-                    return new Row(cqlRows.metadata.names, iter.next());
+                    return new Row(cqlRows.metadata.requestNames(), iter.next());
                 }
             };
         }
@@ -154,7 +154,7 @@ private FromPager(SelectStatement select, QueryPager pager, int pageSize)
             this.select = select;
             this.pager = pager;
             this.pageSize = pageSize;
-            this.metadata = select.getResultMetadata().names;
+            this.metadata = select.getResultMetadata().requestNames();
         }
 
         public int size()

File: test/unit/org/apache/cassandra/cql3/CQLTester.java
Patch:
@@ -416,8 +416,7 @@ protected void assertRows(UntypedResultSet result, Object[]... rows)
             for (int j = 0; j < meta.size(); j++)
             {
                 ColumnSpecification column = meta.get(j);
-                Object expectedValue = expected[j];
-                ByteBuffer expectedByteValue = makeByteBuffer(expected[j], (AbstractType)column.type);
+                ByteBuffer expectedByteValue = makeByteBuffer(expected[j], column.type);
                 ByteBuffer actualValue = actual.getBytes(column.name.toString());
 
                 if (!Objects.equal(expectedByteValue, actualValue))

File: src/java/org/apache/cassandra/db/lifecycle/LogFile.java
Patch:
@@ -43,7 +43,8 @@ final class LogFile
     static LogFile make(File logFile, int folderDescriptor)
     {
         Matcher matcher = LogFile.FILE_REGEX.matcher(logFile.getName());
-        assert matcher.matches() && matcher.groupCount() == 3;
+        boolean matched = matcher.matches();
+        assert matched && matcher.groupCount() == 3;
 
         // For now we don't need this but it is there in case we need to change
         // file format later on, the version is the sstable version as defined in BigFormat

File: src/java/org/apache/cassandra/db/rows/BTreeRow.java
Patch:
@@ -464,7 +464,7 @@ private int getSimpleIdxAndIncrement()
 
         private int getComplexIdx()
         {
-            return reversed ? data.length - simpleIdx - 1 : simpleIdx;
+            return reversed ? data.length - complexIdx - 1 : complexIdx;
         }
 
         private int getComplexIdxAndIncrement()

File: src/java/org/apache/cassandra/io/util/MmappedSegmentedFile.java
Patch:
@@ -269,7 +269,7 @@ else if (boundaries[fixedCount] == 0)
             private static long[] ensureCapacity(long[] boundaries, int fixedCount)
             {
                 if (fixedCount + 1 >= boundaries.length)
-                    return Arrays.copyOf(boundaries, boundaries.length * 2);
+                    return Arrays.copyOf(boundaries, Math.max(fixedCount + 2, boundaries.length * 2));
                 return boundaries;
             }
 

File: src/java/org/apache/cassandra/thrift/ThriftConversion.java
Patch:
@@ -611,7 +611,7 @@ public static ColumnDef toThrift(CFMetaData cfMetaData, ColumnDefinition column)
                                                                   s -> !IndexTarget.TARGET_OPTION_NAME.equals(s));
             cd.setIndex_options(filteredOptions.isEmpty()
                                 ? null
-                                : Maps.newHashMap(matchedIndex.options));
+                                : Maps.newHashMap(filteredOptions));
         }
 
         return cd;

File: src/java/org/apache/cassandra/cql3/functions/TimeFcts.java
Patch:
@@ -67,7 +67,7 @@ public ByteBuffer execute(int protocolVersion, List<ByteBuffer> parameters)
             if (bb == null)
                 return null;
 
-            return ByteBuffer.wrap(UUIDGen.decompose(UUIDGen.minTimeUUID(TimestampType.instance.compose(bb).getTime())));
+            return UUIDGen.toByteBuffer(UUIDGen.minTimeUUID(TimestampType.instance.compose(bb).getTime()));
         }
     };
 
@@ -79,7 +79,7 @@ public ByteBuffer execute(int protocolVersion, List<ByteBuffer> parameters)
             if (bb == null)
                 return null;
 
-            return ByteBuffer.wrap(UUIDGen.decompose(UUIDGen.maxTimeUUID(TimestampType.instance.compose(bb).getTime())));
+            return UUIDGen.toByteBuffer(UUIDGen.maxTimeUUID(TimestampType.instance.compose(bb).getTime()));
         }
     };
 

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -178,11 +178,11 @@ public void checkAccess(ClientState state) throws InvalidRequestException, Unaut
         {
             CFMetaData baseTable = View.findBaseTable(keyspace(), columnFamily());
             if (baseTable != null)
-                state.hasColumnFamilyAccess(keyspace(), baseTable.cfName, Permission.SELECT);
+                state.hasColumnFamilyAccess(baseTable, Permission.SELECT);
         }
         else
         {
-            state.hasColumnFamilyAccess(keyspace(), columnFamily(), Permission.SELECT);
+            state.hasColumnFamilyAccess(cfm, Permission.SELECT);
         }
 
         for (Function function : getFunctions())

File: src/java/org/apache/cassandra/db/marshal/CompositeType.java
Patch:
@@ -391,7 +391,9 @@ public static ByteBuffer build(boolean isStatic, ByteBuffer... buffers)
         for (ByteBuffer bb : buffers)
         {
             ByteBufferUtil.writeShortLength(out, bb.remaining());
-            out.put(bb.duplicate());
+            int toCopy = bb.remaining();
+            ByteBufferUtil.arrayCopy(bb, bb.position(), out, out.position(), toCopy);
+            out.position(out.position() + toCopy);
             out.put((byte) 0);
         }
         out.flip();

File: src/java/org/apache/cassandra/db/marshal/UUIDType.java
Patch:
@@ -140,7 +140,7 @@ static ByteBuffer parse(String source)
         {
             try
             {
-                return ByteBuffer.wrap(UUIDGen.decompose(UUID.fromString(source)));
+                return UUIDGen.toByteBuffer(UUID.fromString(source));
             }
             catch (IllegalArgumentException e)
             {

File: src/java/org/apache/cassandra/serializers/UUIDSerializer.java
Patch:
@@ -34,7 +34,7 @@ public UUID deserialize(ByteBuffer bytes)
 
     public ByteBuffer serialize(UUID value)
     {
-        return value == null ? ByteBufferUtil.EMPTY_BYTE_BUFFER : ByteBuffer.wrap(UUIDGen.decompose(value));
+        return value == null ? ByteBufferUtil.EMPTY_BYTE_BUFFER : UUIDGen.toByteBuffer(value);
     }
 
     public void validate(ByteBuffer bytes) throws MarshalException

File: src/java/org/apache/cassandra/io/sstable/AbstractSSTableSimpleWriter.java
Patch:
@@ -200,4 +200,6 @@ boolean shouldStartNewRow() throws IOException
     protected abstract void writeRow(DecoratedKey key, ColumnFamily columnFamily) throws IOException;
 
     protected abstract ColumnFamily getColumnFamily() throws IOException;
+
+    public abstract Descriptor getCurrentDescriptor();
 }

File: src/java/org/apache/cassandra/io/util/SegmentedFile.java
Patch:
@@ -23,6 +23,7 @@
 import java.io.IOException;
 import java.nio.MappedByteBuffer;
 import java.util.Iterator;
+import java.util.List;
 import java.util.NoSuchElementException;
 
 import com.google.common.util.concurrent.RateLimiter;

File: src/java/org/apache/cassandra/net/OutboundTcpConnection.java
Patch:
@@ -518,6 +518,8 @@ private void expireMessages()
         while (iter.hasNext())
         {
             QueuedMessage qm = iter.next();
+            if (!qm.droppable)
+                continue;
             if (qm.timestampNanos >= System.nanoTime() - qm.message.getTimeout())
                 return;
             iter.remove();

File: src/java/org/apache/cassandra/tools/NodeProbe.java
Patch:
@@ -502,7 +502,7 @@ public String getLocalHostId()
 
     public Map<String, String> getHostIdMap()
     {
-        return ssProxy.getHostIdMap();
+        return ssProxy.getEndpointToHostId();
     }
 
     public String getLoadString()
@@ -807,7 +807,7 @@ public StorageProxyMBean getSpProxy()
 
     public String getEndpoint()
     {
-        Map<String, String> hostIdToEndpoint = ssProxy.getHostIdMap();
+        Map<String, String> hostIdToEndpoint = ssProxy.getHostIdToEndpoint();
         return hostIdToEndpoint.get(ssProxy.getLocalHostId());
     }
 

File: src/java/org/apache/cassandra/db/rows/UnfilteredRowIterators.java
Patch:
@@ -99,8 +99,8 @@ public static UnfilteredRowIterator emptyIterator(final CFMetaData cfm, final De
      */
     public static UnfilteredRowIterator noRowsIterator(final CFMetaData cfm, final DecoratedKey partitionKey, final Row staticRow, final DeletionTime partitionDeletion, final boolean isReverseOrder)
     {
-        PartitionColumns columns = staticRow == null ? PartitionColumns.NONE
-                                                     : new PartitionColumns(Columns.from(staticRow.columns()), Columns.NONE);
+        PartitionColumns columns = staticRow == Rows.EMPTY_STATIC_ROW ? PartitionColumns.NONE
+                                                                      : new PartitionColumns(Columns.from(staticRow.columns()), Columns.NONE);
         return new UnfilteredRowIterator()
         {
             public CFMetaData metadata()

File: src/java/org/apache/cassandra/auth/CassandraAuthorizer.java
Patch:
@@ -439,7 +439,7 @@ public boolean apply(String s)
         {
             logger.info("Unable to complete conversion of legacy permissions data (perhaps not enough nodes are upgraded yet). " +
                         "Conversion should not be considered complete");
-            logger.debug("Conversion error", e);
+            logger.trace("Conversion error", e);
         }
     }
 

File: src/java/org/apache/cassandra/auth/CassandraRoleManager.java
Patch:
@@ -376,7 +376,7 @@ public void run()
                 // will be finished by then.
                 if (!MessagingService.instance().areAllNodesAtLeast22())
                 {
-                    logger.debug("Not all nodes are upgraded to a version that supports Roles yet, rescheduling setup task");
+                    logger.trace("Not all nodes are upgraded to a version that supports Roles yet, rescheduling setup task");
                     scheduleSetupTask(setupTask);
                     return;
                 }
@@ -442,7 +442,7 @@ private void convertLegacyData() throws Exception
         {
             logger.info("Unable to complete conversion of legacy auth data (perhaps not enough nodes are upgraded yet). " +
                         "Conversion should not be considered complete");
-            logger.debug("Conversion error", e);
+            logger.trace("Conversion error", e);
             throw e;
         }
     }

File: src/java/org/apache/cassandra/auth/PasswordAuthenticator.java
Patch:
@@ -86,7 +86,7 @@ private AuthenticatedUser authenticate(String username, String password) throws
         }
         catch (RequestExecutionException e)
         {
-            logger.debug("Error performing internal authentication", e);
+            logger.trace("Error performing internal authentication", e);
             throw new AuthenticationException(e.toString());
         }
     }
@@ -196,7 +196,7 @@ public AuthenticatedUser getAuthenticatedUser() throws AuthenticationException
          */
         private void decodeCredentials(byte[] bytes) throws AuthenticationException
         {
-            logger.debug("Decoding credentials from client token");
+            logger.trace("Decoding credentials from client token");
             byte[] user = null;
             byte[] pass = null;
             int end = bytes.length;

File: src/java/org/apache/cassandra/auth/PermissionsCache.java
Patch:
@@ -137,7 +137,7 @@ public ListenableFuture<Set<Permission>> reload(final Pair<AuthenticatedUser, IR
                                            }
                                            catch (Exception e)
                                            {
-                                               logger.debug("Error performing async refresh of user permissions", e);
+                                               logger.trace("Error performing async refresh of user permissions", e);
                                                throw e;
                                            }
                                        }

File: src/java/org/apache/cassandra/auth/RolesCache.java
Patch:
@@ -135,7 +135,7 @@ public Set<RoleResource> call() throws Exception
                                     return roleManager.getRoles(primaryRole, true);
                                 } catch (Exception e)
                                 {
-                                    logger.debug("Error performing async refresh of user roles", e);
+                                    logger.trace("Error performing async refresh of user roles", e);
                                     throw e;
                                 }
                             }

File: src/java/org/apache/cassandra/cache/SerializingCache.java
Patch:
@@ -92,7 +92,7 @@ private V deserialize(RefCountedMemory mem)
         }
         catch (IOException e)
         {
-            logger.debug("Cannot fetch in memory data, we will fallback to read from disk ", e);
+            logger.trace("Cannot fetch in memory data, we will fallback to read from disk ", e);
             return null;
         }
     }

File: src/java/org/apache/cassandra/client/RingCache.java
Patch:
@@ -93,7 +93,7 @@ public void refreshEndpointMap()
         }
         catch (TException e)
         {
-            logger.debug("Error contacting seed list {} {}", ConfigHelper.getOutputInitialAddress(conf), e.getMessage());
+            logger.trace("Error contacting seed list {} {}", ConfigHelper.getOutputInitialAddress(conf), e.getMessage());
         }
     }
 

File: src/java/org/apache/cassandra/concurrent/DebuggableScheduledThreadPoolExecutor.java
Patch:
@@ -54,7 +54,7 @@ public void rejectedExecution(Runnable task, ThreadPoolExecutor executor)
                 if (task instanceof Future)
                     ((Future) task).cancel(false);
 
-                logger.debug("ScheduledThreadPoolExecutor has shut down as part of C* shutdown");
+                logger.trace("ScheduledThreadPoolExecutor has shut down as part of C* shutdown");
             }
             else
             {

File: src/java/org/apache/cassandra/concurrent/DebuggableThreadPoolExecutor.java
Patch:
@@ -266,7 +266,7 @@ public static Throwable extractThrowable(Runnable runnable)
             }
             catch (CancellationException e)
             {
-                logger.debug("Task cancelled", e);
+                logger.trace("Task cancelled", e);
             }
             catch (ExecutionException e)
             {

File: src/java/org/apache/cassandra/cql3/QueryProcessor.java
Patch:
@@ -618,20 +618,20 @@ public void onCreateAggregate(String ksName, String aggregateName, List<Abstract
 
         public void onUpdateColumnFamily(String ksName, String cfName, boolean columnsDidChange)
         {
-            logger.debug("Column definitions for {}.{} changed, invalidating related prepared statements", ksName, cfName);
+            logger.trace("Column definitions for {}.{} changed, invalidating related prepared statements", ksName, cfName);
             if (columnsDidChange)
                 removeInvalidPreparedStatements(ksName, cfName);
         }
 
         public void onDropKeyspace(String ksName)
         {
-            logger.debug("Keyspace {} was dropped, invalidating related prepared statements", ksName);
+            logger.trace("Keyspace {} was dropped, invalidating related prepared statements", ksName);
             removeInvalidPreparedStatements(ksName, null);
         }
 
         public void onDropColumnFamily(String ksName, String cfName)
         {
-            logger.debug("Table {}.{} was dropped, invalidating related prepared statements", ksName, cfName);
+            logger.trace("Table {}.{} was dropped, invalidating related prepared statements", ksName, cfName);
             removeInvalidPreparedStatements(ksName, cfName);
         }
 

File: src/java/org/apache/cassandra/cql3/functions/JavaSourceUDFFactory.java
Patch:
@@ -170,7 +170,7 @@ static UDFunction buildUDF(FunctionName name,
 
         String javaSource = javaSourceBuilder.toString();
 
-        logger.debug("Compiling Java source UDF '{}' as class '{}' using source:\n{}", name, targetClassName, javaSource);
+        logger.trace("Compiling Java source UDF '{}' as class '{}' using source:\n{}", name, targetClassName, javaSource);
 
         try
         {
@@ -303,7 +303,7 @@ private static String generateArguments(Class<?>[] paramTypes, List<ColumnIdenti
             if (i > 0)
                 code.append(",\n");
 
-            if (logger.isDebugEnabled())
+            if (logger.isTraceEnabled())
                 code.append("                /* parameter '").append(argNames.get(i)).append("' */\n");
 
             code

File: src/java/org/apache/cassandra/cql3/functions/ScriptBasedUDF.java
Patch:
@@ -143,7 +143,7 @@ else if (javaReturnType == BigDecimal.class)
         }
         catch (RuntimeException | ScriptException e)
         {
-            logger.debug("Execution of UDF '{}' failed", name, e);
+            logger.trace("Execution of UDF '{}' failed", name, e);
             throw FunctionExecutionException.create(this, e);
         }
     }

File: src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java
Patch:
@@ -164,7 +164,7 @@ public boolean announceMigration(boolean isLocalOnly) throws RequestValidationEx
     {
         CFMetaData cfm = Schema.instance.getCFMetaData(keyspace(), columnFamily()).copy();
         IndexTarget target = rawTarget.prepare(cfm);
-        logger.debug("Updating column {} definition for index {}", target.column, indexName);
+        logger.trace("Updating column {} definition for index {}", target.column, indexName);
         ColumnDefinition cd = cfm.getColumnDefinition(target.column);
 
         if (cd.getIndexType() != null && ifNotExists)

File: src/java/org/apache/cassandra/db/ConsistencyLevel.java
Patch:
@@ -260,7 +260,7 @@ public void assureSufficientLiveNodes(Keyspace keyspace, Iterable<InetAddress> l
                 int localLive = countLocalEndpoints(liveEndpoints);
                 if (localLive < blockFor)
                 {
-                    if (logger.isDebugEnabled())
+                    if (logger.isTraceEnabled())
                     {
                         StringBuilder builder = new StringBuilder("Local replicas [");
                         for (InetAddress endpoint : liveEndpoints)
@@ -269,7 +269,7 @@ public void assureSufficientLiveNodes(Keyspace keyspace, Iterable<InetAddress> l
                                 builder.append(endpoint).append(",");
                         }
                         builder.append("] are insufficient to satisfy LOCAL_QUORUM requirement of ").append(blockFor).append(" live nodes in '").append(DatabaseDescriptor.getLocalDataCenter()).append("'");
-                        logger.debug(builder.toString());
+                        logger.trace(builder.toString());
                     }
                     throw new UnavailableException(this, blockFor, localLive);
                 }
@@ -291,7 +291,7 @@ public void assureSufficientLiveNodes(Keyspace keyspace, Iterable<InetAddress> l
                 int live = Iterables.size(liveEndpoints);
                 if (live < blockFor)
                 {
-                    logger.debug("Live nodes {} do not satisfy ConsistencyLevel ({} required)", Iterables.toString(liveEndpoints), blockFor);
+                    logger.trace("Live nodes {} do not satisfy ConsistencyLevel ({} required)", Iterables.toString(liveEndpoints), blockFor);
                     throw new UnavailableException(this, blockFor, live);
                 }
                 break;

File: src/java/org/apache/cassandra/db/CounterMutationVerbHandler.java
Patch:
@@ -35,7 +35,7 @@ public class CounterMutationVerbHandler implements IVerbHandler<CounterMutation>
     public void doVerb(final MessageIn<CounterMutation> message, final int id)
     {
         final CounterMutation cm = message.payload;
-        logger.debug("Applying forwarded {}", cm);
+        logger.trace("Applying forwarded {}", cm);
 
         String localDataCenter = DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getBroadcastAddress());
         // We should not wait for the result of the write in this thread,

File: src/java/org/apache/cassandra/db/DefinitionsUpdateVerbHandler.java
Patch:
@@ -41,7 +41,7 @@ public class DefinitionsUpdateVerbHandler implements IVerbHandler<Collection<Mut
 
     public void doVerb(final MessageIn<Collection<Mutation>> message, int id)
     {
-        logger.debug("Received schema mutation push from {}", message.from);
+        logger.trace("Received schema mutation push from {}", message.from);
 
         StageManager.getStage(Stage.MIGRATION).submit(new WrappedRunnable()
         {

File: src/java/org/apache/cassandra/db/Keyspace.java
Patch:
@@ -266,7 +266,7 @@ private Keyspace(String keyspaceName, boolean loadSSTables)
         this.metric = new KeyspaceMetrics(this);
         for (CFMetaData cfm : new ArrayList<>(metadata.cfMetaData().values()))
         {
-            logger.debug("Initializing {}.{}", getName(), cfm.cfName);
+            logger.trace("Initializing {}.{}", getName(), cfm.cfName);
             initCf(cfm.cfId, cfm.cfName, loadSSTables);
         }
     }
@@ -420,8 +420,8 @@ public AbstractReplicationStrategy getReplicationStrategy()
      */
     public static void indexRow(DecoratedKey key, ColumnFamilyStore cfs, Set<String> idxNames)
     {
-        if (logger.isDebugEnabled())
-            logger.debug("Indexing row {} ", cfs.metadata.getKeyValidator().getString(key.getKey()));
+        if (logger.isTraceEnabled())
+            logger.trace("Indexing row {} ", cfs.metadata.getKeyValidator().getString(key.getKey()));
 
         try (OpOrder.Group opGroup = cfs.keyspace.writeOrder.start())
         {

File: src/java/org/apache/cassandra/db/MigrationRequestVerbHandler.java
Patch:
@@ -39,7 +39,7 @@ public class MigrationRequestVerbHandler implements IVerbHandler
 
     public void doVerb(MessageIn message, int id)
     {
-        logger.debug("Received migration request from {}.", message.from);
+        logger.trace("Received migration request from {}.", message.from);
         MessageOut<Collection<Mutation>> response = new MessageOut<>(MessagingService.Verb.INTERNAL_RESPONSE,
                                                                      LegacySchemaTables.convertSchemaToMutations(),
                                                                      MigrationManager.MigrationsSerializer.instance);

File: src/java/org/apache/cassandra/db/SchemaCheckVerbHandler.java
Patch:
@@ -35,7 +35,7 @@ public class SchemaCheckVerbHandler implements IVerbHandler
 
     public void doVerb(MessageIn message, int id)
     {
-        logger.debug("Received schema check request.");
+        logger.trace("Received schema check request.");
         MessageOut<UUID> response = new MessageOut<UUID>(MessagingService.Verb.INTERNAL_RESPONSE, Schema.instance.getVersion(), UUIDSerializer.serializer);
         MessagingService.instance().sendReply(response, id, message.from);
     }

File: src/java/org/apache/cassandra/db/SizeEstimatesRecorder.java
Patch:
@@ -57,11 +57,11 @@ public void run()
     {
         if (StorageService.instance.isStarting())
         {
-            logger.debug("Node has not yet joined; not recording size estimates");
+            logger.trace("Node has not yet joined; not recording size estimates");
             return;
         }
 
-        logger.debug("Recording size estimates");
+        logger.trace("Recording size estimates");
 
         // find primary token ranges for the local node.
         Collection<Token> localTokens = StorageService.instance.getLocalTokens();
@@ -74,7 +74,7 @@ public void run()
                 long start = System.nanoTime();
                 recordSizeEstimates(table, localRanges);
                 long passed = System.nanoTime() - start;
-                logger.debug("Spent {} milliseconds on estimating {}.{} size",
+                logger.trace("Spent {} milliseconds on estimating {}.{} size",
                              TimeUnit.NANOSECONDS.toMillis(passed),
                              table.metadata.ksName,
                              table.metadata.cfName);

File: src/java/org/apache/cassandra/db/SliceFromReadCommand.java
Patch:
@@ -65,7 +65,7 @@ public Row getRow(Keyspace keyspace)
         // reads in order to guarantee that the static columns are fetched.  See CASSANDRA-8502 for more details.
         if (filter.reversed && filter.hasStaticSlice(cfm))
         {
-            logger.debug("Splitting reversed slice with static columns into two reads");
+            logger.trace("Splitting reversed slice with static columns into two reads");
             Pair<SliceQueryFilter, SliceQueryFilter> newFilters = filter.splitOutStaticSlice(cfm);
 
             Row normalResults =  keyspace.getRow(new QueryFilter(dk, cfName, newFilters.right, timestamp));

File: src/java/org/apache/cassandra/db/SystemKeyspace.java
Patch:
@@ -1110,7 +1110,7 @@ private static String getPreviousVersionString()
             {
                 if (dataDirectory.getName().equals("Versions") && dataDirectory.listFiles().length > 0)
                 {
-                    logger.debug("Found unreadable versions info in pre 1.2 system.Versions table");
+                    logger.trace("Found unreadable versions info in pre 1.2 system.Versions table");
                     return UNREADABLE_VERSION.toString();
                 }
             }

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -303,7 +303,7 @@ public ReplayPosition add(Mutation mutation)
      */
     public void discardCompletedSegments(final UUID cfId, final ReplayPosition context)
     {
-        logger.debug("discard completed log segments for {}, table {}", context, cfId);
+        logger.trace("discard completed log segments for {}, table {}", context, cfId);
 
         // Go thru the active segment files, which are ordered oldest to newest, marking the
         // flushed CF as clean, until we reach the segment file containing the ReplayPosition passed
@@ -316,12 +316,12 @@ public void discardCompletedSegments(final UUID cfId, final ReplayPosition conte
 
             if (segment.isUnused())
             {
-                logger.debug("Commit log segment {} is unused", segment);
+                logger.trace("Commit log segment {} is unused", segment);
                 allocator.recycleSegment(segment);
             }
             else
             {
-                logger.debug("Not safe to delete{} commit log segment {}; dirty is {}",
+                logger.trace("Not safe to delete{} commit log segment {}; dirty is {}",
                         (iter.hasNext() ? "" : " active"), segment, segment.dirtyString());
             }
 

File: src/java/org/apache/cassandra/db/commitlog/CommitLogArchiver.java
Patch:
@@ -83,7 +83,7 @@ public static CommitLogArchiver construct()
         {
             if (stream == null)
             {
-                logger.debug("No commitlog_archiving properties found; archive + pitr will be disabled");
+                logger.trace("No commitlog_archiving properties found; archive + pitr will be disabled");
                 return disabled();
             }
             else
@@ -237,7 +237,7 @@ else if (fromHeader != null)
                 File toFile = new File(DatabaseDescriptor.getCommitLogLocation(), descriptor.fileName());
                 if (toFile.exists())
                 {
-                    logger.debug("Skipping restore of archive {} as the segment already exists in the restore location {}",
+                    logger.trace("Skipping restore of archive {} as the segment already exists in the restore location {}",
                                  fromFile.getPath(), toFile.getPath());
                     continue;
                 }

File: src/java/org/apache/cassandra/db/compaction/CompactionController.java
Patch:
@@ -110,7 +110,7 @@ public Set<SSTableReader> getFullyExpiredSSTables()
      */
     public static Set<SSTableReader> getFullyExpiredSSTables(ColumnFamilyStore cfStore, Iterable<SSTableReader> compacting, Iterable<SSTableReader> overlapping, int gcBefore)
     {
-        logger.debug("Checking droppable sstables in {}", cfStore);
+        logger.trace("Checking droppable sstables in {}", cfStore);
 
         if (compacting == null)
             return Collections.<SSTableReader>emptySet();
@@ -150,7 +150,7 @@ public static Set<SSTableReader> getFullyExpiredSSTables(ColumnFamilyStore cfSto
             }
             else
             {
-               logger.debug("Dropping expired SSTable {} (maxLocalDeletionTime={}, gcBefore={})",
+               logger.trace("Dropping expired SSTable {} (maxLocalDeletionTime={}, gcBefore={})",
                         candidate, candidate.getSSTableMetadata().maxLocalDeletionTime, gcBefore);
             }
         }

File: src/java/org/apache/cassandra/db/compaction/LeveledCompactionStrategy.java
Patch:
@@ -71,7 +71,7 @@ public LeveledCompactionStrategy(ColumnFamilyStore cfs, Map<String, String> opti
         maxSSTableSizeInMB = configuredMaxSSTableSize;
 
         manifest = new LeveledManifest(cfs, this.maxSSTableSizeInMB, localOptions);
-        logger.debug("Created {}", manifest);
+        logger.trace("Created {}", manifest);
     }
 
     public int getLevelSize(int i)
@@ -101,7 +101,7 @@ public synchronized AbstractCompactionTask getNextBackgroundTask(int gcBefore)
                 SSTableReader sstable = findDroppableSSTable(gcBefore);
                 if (sstable == null)
                 {
-                    logger.debug("No compaction necessary for {}", this);
+                    logger.trace("No compaction necessary for {}", this);
                     return null;
                 }
                 candidate = new LeveledManifest.CompactionCandidate(Collections.singleton(sstable),

File: src/java/org/apache/cassandra/db/compaction/SizeTieredCompactionStrategy.java
Patch:
@@ -82,7 +82,7 @@ private List<SSTableReader> getNextBackgroundSSTables(final int gcBefore)
         Iterable<SSTableReader> candidates = filterSuspectSSTables(Sets.intersection(cfs.getUncompactingSSTables(), sstables));
 
         List<List<SSTableReader>> buckets = getBuckets(createSSTableAndLengthPairs(candidates), sizeTieredOptions.bucketHigh, sizeTieredOptions.bucketLow, sizeTieredOptions.minSSTableSize);
-        logger.debug("Compaction buckets are {}", buckets);
+        logger.trace("Compaction buckets are {}", buckets);
         updateEstimatedCompactionsByTasks(buckets);
         List<SSTableReader> mostInteresting = mostInterestingBucket(buckets, minThreshold, maxThreshold);
         if (!mostInteresting.isEmpty())
@@ -210,7 +210,7 @@ public AbstractCompactionTask getUserDefinedTask(Collection<SSTableReader> sstab
         LifecycleTransaction transaction = cfs.getTracker().tryModify(sstables, OperationType.COMPACTION);
         if (transaction == null)
         {
-            logger.debug("Unable to mark {} for compaction; probably a background compaction got to it first.  You can disable background compactions temporarily if this is a problem", sstables);
+            logger.trace("Unable to mark {} for compaction; probably a background compaction got to it first.  You can disable background compactions temporarily if this is a problem", sstables);
             return null;
         }
 

File: src/java/org/apache/cassandra/db/compaction/WrappingCompactionStrategy.java
Patch:
@@ -63,7 +63,7 @@ public WrappingCompactionStrategy(ColumnFamilyStore cfs)
         super(cfs, cfs.metadata.compactionStrategyOptions);
         reloadCompactionStrategy(cfs.metadata);
         cfs.getTracker().subscribe(this);
-        logger.debug("{} subscribed to the data tracker.", this);
+        logger.trace("{} subscribed to the data tracker.", this);
     }
 
     @Override

File: src/java/org/apache/cassandra/db/compaction/writers/DefaultCompactionWriter.java
Patch:
@@ -45,7 +45,7 @@ public class DefaultCompactionWriter extends CompactionAwareWriter
     public DefaultCompactionWriter(ColumnFamilyStore cfs, LifecycleTransaction txn, Set<SSTableReader> nonExpiredSSTables, boolean offline, OperationType compactionType)
     {
         super(cfs, txn, nonExpiredSSTables, offline);
-        logger.debug("Expected bloom filter size : {}", estimatedTotalKeys);
+        logger.trace("Expected bloom filter size : {}", estimatedTotalKeys);
         long expectedWriteSize = cfs.getExpectedCompactedFileSize(nonExpiredSSTables, compactionType);
         File sstableDirectory = cfs.directories.getLocationForDisk(getWriteDirectory(expectedWriteSize));
         @SuppressWarnings("resource")

File: src/java/org/apache/cassandra/db/compaction/writers/SplittingSizeTieredCompactionWriter.java
Patch:
@@ -93,7 +93,7 @@ public SplittingSizeTieredCompactionWriter(ColumnFamilyStore cfs, LifecycleTrans
                                                                             new MetadataCollector(allSSTables, cfs.metadata.comparator, 0));
 
         sstableWriter.switchWriter(writer);
-        logger.debug("Ratios={}, expectedKeys = {}, totalSize = {}, currentPartitionsToWrite = {}, currentBytesToWrite = {}", ratios, estimatedTotalKeys, totalSize, currentPartitionsToWrite, currentBytesToWrite);
+        logger.trace("Ratios={}, expectedKeys = {}, totalSize = {}, currentPartitionsToWrite = {}, currentBytesToWrite = {}", ratios, estimatedTotalKeys, totalSize, currentPartitionsToWrite, currentBytesToWrite);
     }
 
     @Override
@@ -114,7 +114,7 @@ public boolean append(AbstractCompactedRow row)
                                                                                 cfs.partitioner,
                                                                                 new MetadataCollector(allSSTables, cfs.metadata.comparator, 0));
             sstableWriter.switchWriter(writer);
-            logger.debug("Switching writer, currentPartitionsToWrite = {}", currentPartitionsToWrite);
+            logger.trace("Switching writer, currentPartitionsToWrite = {}", currentPartitionsToWrite);
         }
         return rie != null;
     }

File: src/java/org/apache/cassandra/db/filter/ExtendedFilter.java
Patch:
@@ -261,7 +261,7 @@ private boolean needsExtraQuery(ByteBuffer rowKey, ColumnFamily data)
             {
                 if (data.getColumn(data.getComparator().cellFromByteBuffer(expr.column)) == null)
                 {
-                    logger.debug("adding extraFilter to cover additional expressions");
+                    logger.trace("adding extraFilter to cover additional expressions");
                     return true;
                 }
             }

File: src/java/org/apache/cassandra/db/index/composites/CompositesIndex.java
Patch:
@@ -142,8 +142,8 @@ public void delete(IndexedEntry entry, OpOrder.Group opGroup)
         ColumnFamily cfi = ArrayBackedSortedColumns.factory.create(indexCfs.metadata);
         cfi.addTombstone(entry.indexEntry, localDeletionTime, entry.timestamp);
         indexCfs.apply(entry.indexValue, cfi, SecondaryIndexManager.nullUpdater, opGroup, null);
-        if (logger.isDebugEnabled())
-            logger.debug("removed index entry for cleaned-up value {}:{}", entry.indexValue, cfi);
+        if (logger.isTraceEnabled())
+            logger.trace("removed index entry for cleaned-up value {}:{}", entry.indexValue, cfi);
     }
 
     protected AbstractType<?> getExpressionComparator()

File: src/java/org/apache/cassandra/db/index/composites/CompositesSearcher.java
Patch:
@@ -98,8 +98,8 @@ private ColumnFamilyStore.AbstractScanIterator getIndexedIterator(final OpOrder.
         assert index.getIndexCfs() != null;
         final DecoratedKey indexKey = index.getIndexKeyFor(primary.value);
 
-        if (logger.isDebugEnabled())
-            logger.debug("Most-selective indexed predicate is {}", index.expressionString(primary));
+        if (logger.isTraceEnabled())
+            logger.trace("Most-selective indexed predicate is {}", index.expressionString(primary));
 
         /*
          * XXX: If the range requested is a token range, we'll have to start at the beginning (and stop at the end) of
@@ -240,7 +240,7 @@ else if (!currentKey.equals(dk))
                             }
                             else
                             {
-                                logger.debug("Skipping entry {} before assigned scan range", dk.getToken());
+                                logger.trace("Skipping entry {} before assigned scan range", dk.getToken());
                                 continue;
                             }
                         }

File: src/java/org/apache/cassandra/db/index/keys/KeysSearcher.java
Patch:
@@ -73,8 +73,8 @@ private ColumnFamilyStore.AbstractScanIterator getIndexedIterator(final OpOrder.
         assert index.getIndexCfs() != null;
         final DecoratedKey indexKey = index.getIndexKeyFor(primary.value);
 
-        if (logger.isDebugEnabled())
-            logger.debug("Most-selective indexed predicate is {}",
+        if (logger.isTraceEnabled())
+            logger.trace("Most-selective indexed predicate is {}",
                          ((AbstractSimplePerColumnSecondaryIndex) index).expressionString(primary));
 
         /*

File: src/java/org/apache/cassandra/dht/BootStrapper.java
Patch:
@@ -65,7 +65,7 @@ public BootStrapper(InetAddress address, Collection<Token> tokens, TokenMetadata
 
     public ListenableFuture<StreamState> bootstrap(StreamStateStore stateStore, boolean useStrictConsistency)
     {
-        logger.debug("Beginning bootstrap process");
+        logger.trace("Beginning bootstrap process");
 
         RangeStreamer streamer = new RangeStreamer(tokenMetadata,
                                                    tokens,
@@ -159,7 +159,7 @@ public static Collection<Token> getBootstrapTokens(final TokenMetadata metadata)
         // if user specified tokens, use those
         if (initialTokens.size() > 0)
         {
-            logger.debug("tokens manually specified as {}",  initialTokens);
+            logger.trace("tokens manually specified as {}",  initialTokens);
             List<Token> tokens = new ArrayList<>(initialTokens.size());
             for (String tokenString : initialTokens)
             {

File: src/java/org/apache/cassandra/hadoop/AbstractColumnFamilyInputFormat.java
Patch:
@@ -81,7 +81,7 @@ public List<InputSplit> getSplits(JobContext context) throws IOException
         keyspace = ConfigHelper.getInputKeyspace(conf);
         cfName = ConfigHelper.getInputColumnFamily(conf);
         partitioner = ConfigHelper.getInputPartitioner(conf);
-        logger.debug("partitioner is {}", partitioner);
+        logger.trace("partitioner is {}", partitioner);
 
         // canonical ranges and nodes holding replicas
         Map<TokenRange, Set<Host>> masterRangeNodes = getRangeMap(conf, keyspace);
@@ -219,7 +219,7 @@ public List<InputSplit> call() throws Exception
                                     subSplits.get(subSplit),
                                     endpoints);
 
-                    logger.debug("adding {}", split);
+                    logger.trace("adding {}", split);
                     splits.add(split);
                 }
             }

File: src/java/org/apache/cassandra/hadoop/ColumnFamilyInputFormat.java
Patch:
@@ -63,7 +63,7 @@ public class ColumnFamilyInputFormat extends AbstractColumnFamilyInputFormat<Byt
     @SuppressWarnings("resource")
     public static Cassandra.Client createAuthenticatedClient(String location, int port, Configuration conf) throws Exception
     {
-        logger.debug("Creating authenticated client for CF input format");
+        logger.trace("Creating authenticated client for CF input format");
         TTransport transport;
         try
         {
@@ -86,7 +86,7 @@ public static Cassandra.Client createAuthenticatedClient(String location, int po
             AuthenticationRequest authRequest = new AuthenticationRequest(creds);
             client.login(authRequest);
         }
-        logger.debug("Authenticated client for CF input format created successfully");
+        logger.trace("Authenticated client for CF input format created successfully");
         return client;
     }
 

File: src/java/org/apache/cassandra/hadoop/ColumnFamilyOutputFormat.java
Patch:
@@ -117,7 +117,7 @@ public void checkOutputSpecs(org.apache.hadoop.fs.FileSystem filesystem, org.apa
     @SuppressWarnings("resource")
     public static Cassandra.Client createAuthenticatedClient(String host, int port, Configuration conf) throws Exception
     {
-        logger.debug("Creating authenticated client for CF output format");
+        logger.trace("Creating authenticated client for CF output format");
         TTransport transport = ConfigHelper.getClientTransportFactory(conf).openTransport(host, port);
         TProtocol binaryProtocol = new TBinaryProtocol(transport, true, true);
         Cassandra.Client client = new Cassandra.Client(binaryProtocol);
@@ -127,7 +127,7 @@ public static Cassandra.Client createAuthenticatedClient(String host, int port,
         if ((user != null) && (password != null))
             login(user, password, client);
 
-        logger.debug("Authenticated client for CF output format created successfully");
+        logger.trace("Authenticated client for CF output format created successfully");
         return client;
     }
 

File: src/java/org/apache/cassandra/hadoop/cql3/CqlRecordReader.java
Patch:
@@ -156,10 +156,10 @@ public void initialize(InputSplit split, TaskAttemptContext context) throws IOEx
 
         if (StringUtils.isEmpty(cqlQuery))
             cqlQuery = buildQuery();
-        logger.debug("cqlQuery {}", cqlQuery);
+        logger.trace("cqlQuery {}", cqlQuery);
 
         rowIterator = new RowIterator();
-        logger.debug("created {}", rowIterator);
+        logger.trace("created {}", rowIterator);
     }
 
     public void close()
@@ -194,7 +194,7 @@ public boolean nextKeyValue() throws IOException
     {
         if (!rowIterator.hasNext())
         {
-            logger.debug("Finished scanning {} rows (estimate was: {})", rowIterator.totalRead, totalRowCount);
+            logger.trace("Finished scanning {} rows (estimate was: {})", rowIterator.totalRead, totalRowCount);
             return false;
         }
 

File: src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java
Patch:
@@ -1028,7 +1028,7 @@ protected List<ColumnDef> getColumnMeta(Cassandra.Client client, boolean cassand
                 ColumnDef cDef = new ColumnDef();
                 String columnName = def.name.toString();
                 String type = def.type.toString();
-                logger.debug("name: {}, type: {} ", columnName, type);
+                logger.trace("name: {}, type: {} ", columnName, type);
                 cDef.name = ByteBufferUtil.bytes(columnName);
                 cDef.validation_class = type;
                 columnDefs.add(cDef);

File: src/java/org/apache/cassandra/hadoop/pig/CqlNativeStorage.java
Patch:
@@ -626,7 +626,7 @@ public void setLocation(String location, Job job) throws IOException
 
         if (wc != null)
         {
-            logger.debug("where clause: {}", wc);
+            logger.trace("where clause: {}", wc);
             CqlConfigHelper.setInputWhereClauses(conf, wc);
         }
         if (System.getenv(StorageHelper.PIG_INPUT_SPLIT_SIZE) != null)

File: src/java/org/apache/cassandra/io/sstable/SSTable.java
Patch:
@@ -115,7 +115,7 @@ public static boolean delete(Descriptor desc, Set<Component> components)
         }
         FileUtils.delete(desc.filenameFor(Component.SUMMARY));
 
-        logger.debug("Deleted {}", desc);
+        logger.trace("Deleted {}", desc);
         return true;
     }
 

File: src/java/org/apache/cassandra/io/util/MmappedSegmentedFile.java
Patch:
@@ -124,7 +124,7 @@ public void tidy()
                         continue;
                     FileUtils.clean(segment.right);
                 }
-                logger.debug("All segments have been unmapped successfully");
+                logger.trace("All segments have been unmapped successfully");
             }
             catch (Exception e)
             {

File: src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
Patch:
@@ -84,7 +84,7 @@ public ArrayList<InetAddress> getCachedEndpoints(Token t)
             {
                 if (lastVersion > lastInvalidatedVersion)
                 {
-                    logger.debug("clearing cached endpoints");
+                    logger.trace("clearing cached endpoints");
                     cachedEndpoints.clear();
                     lastInvalidatedVersion = lastVersion;
                 }

File: src/java/org/apache/cassandra/locator/NetworkTopologyStrategy.java
Patch:
@@ -71,7 +71,7 @@ public NetworkTopologyStrategy(String keyspaceName, TokenMetadata tokenMetadata,
         }
 
         datacenters = Collections.unmodifiableMap(newDatacenters);
-        logger.debug("Configured datacenter replicas are {}", FBUtilities.toString(datacenters));
+        logger.trace("Configured datacenter replicas are {}", FBUtilities.toString(datacenters));
     }
 
     /**

File: src/java/org/apache/cassandra/locator/PropertyFileSnitch.java
Patch:
@@ -99,7 +99,7 @@ private String[] getRawEndpointInfo(InetAddress endpoint)
         String[] value = endpointMap.get(endpoint);
         if (value == null)
         {
-            logger.debug("Could not find end point information for {}, will use default", endpoint);
+            logger.trace("Could not find end point information for {}, will use default", endpoint);
             return defaultDCRack;
         }
         return value;
@@ -182,12 +182,12 @@ public void reloadConfiguration(boolean isUpdate) throws ConfigurationException
             throw new ConfigurationException(String.format("Snitch definitions at %s do not define a location for this node's broadcast address %s, nor does it provides a default",
                                                            SNITCH_PROPERTIES_FILENAME, FBUtilities.getBroadcastAddress()));
 
-        if (logger.isDebugEnabled())
+        if (logger.isTraceEnabled())
         {
             StringBuilder sb = new StringBuilder();
             for (Map.Entry<InetAddress, String[]> entry : reloadedMap.entrySet())
                 sb.append(entry.getKey()).append(":").append(Arrays.toString(entry.getValue())).append(", ");
-            logger.debug("Loaded network topology from property file: {}", StringUtils.removeEnd(sb.toString(), ", "));
+            logger.trace("Loaded network topology from property file: {}", StringUtils.removeEnd(sb.toString(), ", "));
         }
 
         endpointMap = reloadedMap;

File: src/java/org/apache/cassandra/locator/ReconnectableSnitchHelper.java
Patch:
@@ -63,7 +63,7 @@ private void reconnect(InetAddress publicAddress, InetAddress localAddress)
                 && !MessagingService.instance().getConnectionPool(publicAddress).endPoint().equals(localAddress))
         {
             MessagingService.instance().getConnectionPool(publicAddress).reset(localAddress);
-            logger.debug(String.format("Intiated reconnect to an Internal IP %s for the %s", localAddress, publicAddress));
+            logger.trace(String.format("Intiated reconnect to an Internal IP %s for the %s", localAddress, publicAddress));
         }
     }
     

File: src/java/org/apache/cassandra/net/IncomingStreamingConnection.java
Patch:
@@ -70,7 +70,7 @@ public void run()
         }
         catch (IOException e)
         {
-            logger.debug("IOException reading from socket; closing", e);
+            logger.trace("IOException reading from socket; closing", e);
             close();
         }
     }
@@ -87,7 +87,7 @@ public void close()
         }
         catch (IOException e)
         {
-            logger.debug("Error closing socket", e);
+            logger.trace("Error closing socket", e);
         }
         finally
         {

File: src/java/org/apache/cassandra/net/MessageDeliveryTask.java
Patch:
@@ -57,7 +57,7 @@ public void run()
         IVerbHandler verbHandler = MessagingService.instance().getVerbHandler(verb);
         if (verbHandler == null)
         {
-            logger.debug("Unknown verb {}", verb);
+            logger.trace("Unknown verb {}", verb);
             return;
         }
 

File: src/java/org/apache/cassandra/net/ResponseVerbHandler.java
Patch:
@@ -35,7 +35,7 @@ public void doVerb(MessageIn message, int id)
         if (callbackInfo == null)
         {
             String msg = "Callback already removed for {} (from {})";
-            logger.debug(msg, id, message.from);
+            logger.trace(msg, id, message.from);
             Tracing.trace(msg, id, message.from);
             return;
         }

File: src/java/org/apache/cassandra/schema/LegacySchemaTables.java
Patch:
@@ -1357,7 +1357,7 @@ private static UDFunction createFunctionFromFunctionRow(UntypedResultSet.Row row
                 udf.body().equals(body) &&
                 udf.isCalledOnNullInput() == calledOnNullInput)
             {
-                logger.debug("Skipping duplicate compilation of already existing UDF {}", name);
+                logger.trace("Skipping duplicate compilation of already existing UDF {}", name);
                 return udf;
             }
         }

File: src/java/org/apache/cassandra/service/FileCacheService.java
Patch:
@@ -147,8 +147,8 @@ private CacheBucket getCacheFor(CacheKey key)
     public void put(CacheKey cacheKey, RandomAccessReader instance)
     {
         int memoryUsed = memoryUsage.get();
-        if (logger.isDebugEnabled())
-            logger.debug("Estimated memory usage is {} compared to actual usage {}", memoryUsed, sizeInBytes());
+        if (logger.isTraceEnabled())
+            logger.trace("Estimated memory usage is {} compared to actual usage {}", memoryUsed, sizeInBytes());
 
         CacheBucket bucket = cache.getIfPresent(cacheKey);
         if (memoryUsed >= MEMORY_USAGE_THRESHOLD || bucket == null)

File: src/java/org/apache/cassandra/service/GCInspector.java
Patch:
@@ -282,8 +282,8 @@ public void handleNotification(final Notification notification, final Object han
                 logger.warn(st);
             else if (duration > MIN_LOG_DURATION)
                 logger.info(st);
-            else if (logger.isDebugEnabled())
-                logger.debug(st);
+            else if (logger.isTraceEnabled())
+                logger.trace(st);
 
             if (duration > STAT_THRESHOLD)
                 StatusLogger.log();

File: src/java/org/apache/cassandra/service/LoadBroadcaster.java
Patch:
@@ -87,8 +87,8 @@ public void startBroadcasting()
         {
             public void run()
             {
-                if (logger.isDebugEnabled())
-                    logger.debug("Disseminating load info ...");
+                if (logger.isTraceEnabled())
+                    logger.trace("Disseminating load info ...");
                 Gossiper.instance.addLocalApplicationState(ApplicationState.LOAD,
                                                            StorageService.instance.valueFactory.load(StorageMetrics.load.getCount()));
             }

File: src/java/org/apache/cassandra/thrift/CustomTThreadPoolServer.java
Patch:
@@ -126,7 +126,7 @@ public void serve()
             catch (RejectedExecutionException e)
             {
                 // worker thread decremented activeClients but hadn't finished exiting
-                logger.debug("Dropping client connection because our limit of {} has been reached", args.maxWorkerThreads);
+                logger.trace("Dropping client connection because our limit of {} has been reached", args.maxWorkerThreads);
                 continue;
             }
 
@@ -211,7 +211,7 @@ public void run()
             {
                 // Assume the client died and continue silently
                 // Log at debug to allow debugging of "frame too large" errors (see CASSANDRA-3142).
-                logger.debug("Thrift transport error occurred during processing of message.", ttx);
+                logger.trace("Thrift transport error occurred during processing of message.", ttx);
             }
             catch (TException tx)
             {

File: src/java/org/apache/cassandra/thrift/ThriftValidation.java
Patch:
@@ -451,8 +451,8 @@ public static void validateColumnData(CFMetaData metadata, ByteBuffer key, ByteB
         }
         catch (MarshalException me)
         {
-            if (logger.isDebugEnabled())
-                logger.debug("rejecting invalid value {}", ByteBufferUtil.bytesToHex(summarize(column.value)));
+            if (logger.isTraceEnabled())
+                logger.trace("rejecting invalid value {}", ByteBufferUtil.bytesToHex(summarize(column.value)));
 
             throw new org.apache.cassandra.exceptions.InvalidRequestException(String.format("(%s) [%s][%s][%s] failed validation",
                                                                       me.getMessage(),

File: src/java/org/apache/cassandra/tracing/Tracing.java
Patch:
@@ -152,7 +152,7 @@ public void stopSession()
         TraceState state = this.state.get();
         if (state == null) // inline isTracing to avoid implicit two calls to state.get()
         {
-            logger.debug("request complete");
+            logger.trace("request complete");
         }
         else
         {

File: src/java/org/apache/cassandra/transport/Message.java
Patch:
@@ -503,7 +503,7 @@ public void channelRead0(ChannelHandlerContext ctx, Request request)
 
                 QueryState qstate = connection.validateNewMessage(request.type, connection.getVersion(), request.getStreamId());
 
-                logger.debug("Received: {}, v={}", request, connection.getVersion());
+                logger.trace("Received: {}, v={}", request, connection.getVersion());
                 response = request.execute(qstate);
                 response.setStreamId(request.getStreamId());
                 response.setWarnings(ClientWarn.getWarnings());
@@ -522,7 +522,7 @@ public void channelRead0(ChannelHandlerContext ctx, Request request)
                 ClientWarn.resetWarnings();
             }
 
-            logger.debug("Responding: {}, v={}", response, connection.getVersion());
+            logger.trace("Responding: {}, v={}", response, connection.getVersion());
             flush(new FlushItem(ctx, response, request.getSourceFrame()));
         }
 
@@ -597,7 +597,7 @@ public boolean apply(Throwable exception)
                 if (ioExceptionsAtDebugLevel.contains(exception.getMessage()))
                 {
                     // Likely unclean client disconnects
-                    logger.debug(message, exception);
+                    logger.trace(message, exception);
                 }
                 else
                 {

File: src/java/org/apache/cassandra/triggers/CustomClassLoader.java
Patch:
@@ -112,7 +112,7 @@ public synchronized Class<?> loadClassInternal(String name) throws ClassNotFound
         }
         catch (ClassNotFoundException ex)
         {
-            logger.debug("Class not found using parent class loader,", ex);
+            logger.trace("Class not found using parent class loader,", ex);
             // Don't throw the exception here, try triggers directory.
         }
         Class<?> clazz = this.findClass(name);

File: src/java/org/apache/cassandra/utils/CLibrary.java
Patch:
@@ -70,7 +70,7 @@ public final class CLibrary
         catch (UnsatisfiedLinkError e)
         {
             logger.warn("JNA link failure, one or more native method will be unavailable.");
-            logger.debug("JNA link failure details: {}", e.getMessage());
+            logger.trace("JNA link failure details: {}", e.getMessage());
         }
         catch (NoSuchMethodError e)
         {

File: src/java/org/apache/cassandra/utils/EstimatedHistogram.java
Patch:
@@ -234,7 +234,7 @@ public boolean isOverflowed()
     }
 
     /**
-     * log.debug() every record in the histogram
+     * log.trace() every record in the histogram
      *
      * @param log
      */
@@ -265,7 +265,7 @@ public void log(Logger log)
             // calculation, and accept the unnecessary whitespace prefixes that will occasionally occur
             if (i == 0 && count == 0)
                 continue;
-            log.debug(String.format(formatstr, names[i], count));
+            log.trace(String.format(formatstr, names[i], count));
         }
     }
 

File: src/java/org/apache/cassandra/utils/Mx4jTool.java
Patch:
@@ -42,7 +42,7 @@ public static boolean maybeLoad()
     {
         try
         {
-            logger.debug("Will try to load mx4j now, if it's in the classpath");
+            logger.trace("Will try to load mx4j now, if it's in the classpath");
             MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
             ObjectName processorName = new ObjectName("Server:name=XSLTProcessor");
 
@@ -65,7 +65,7 @@ public static boolean maybeLoad()
         }
         catch (ClassNotFoundException e)
         {
-            logger.debug("Will not load MX4J, mx4j-tools.jar is not in the classpath");
+            logger.trace("Will not load MX4J, mx4j-tools.jar is not in the classpath");
         }
         catch(Exception e)
         {

File: src/java/org/apache/cassandra/utils/OutputHandler.java
Patch:
@@ -44,7 +44,7 @@ public void output(String msg)
 
         public void debug(String msg)
         {
-            logger.debug(msg);
+            logger.trace(msg);
         }
 
         public void warn(String msg)

File: src/java/org/apache/cassandra/utils/TopKSampler.java
Patch:
@@ -110,7 +110,7 @@ public void run()
                                 hll.offerHashed(hash);
                             } catch (Exception e)
                             {
-                                logger.debug("Failure to offer sample", e);
+                                logger.trace("Failure to offer sample", e);
                             }
                         }
                     }

File: src/java/org/apache/cassandra/db/filter/DataLimits.java
Patch:
@@ -303,7 +303,10 @@ public void endOfPartition()
                 // rows in the partition. However, if we only have the static row, it will be returned as one row
                 // so count it.
                 if (hasLiveStaticRow && rowInCurrentPartition == 0)
+                {
                     ++rowCounted;
+                    ++rowInCurrentPartition;
+                }
             }
 
             public int counted()

File: src/java/org/apache/cassandra/service/pager/MultiPartitionPager.java
Patch:
@@ -169,13 +169,13 @@ protected RowIterator computeNext()
         {
             while (result == null || !result.hasNext())
             {
+                if (result != null)
+                    result.close();
+
                 // This sets us on the first non-exhausted pager
                 if (isExhausted())
                     return endOfData();
 
-                if (result != null)
-                    result.close();
-
                 int toQuery = pageSize - counter.counted();
                 result = consistency == null
                        ? pagers[current].fetchPageInternal(toQuery, orderGroup)

File: src/java/org/apache/cassandra/utils/btree/BTreeSearchIterator.java
Patch:
@@ -102,9 +102,8 @@ public V next(K target)
             return null;
 
         int state = this.state;
-        int index = seekTo(target, forwards, (state & (ON_ITEM | BEFORE_FIRST)) != 0);
-        boolean found = index >= 0;
-        if (!found) index = -1 -index;
+        boolean found = seekTo(target, forwards, (state & (ON_ITEM | BEFORE_FIRST)) != 0);
+        int index = cur.globalIndex();
 
         V next = null;
         if (state == BEFORE_FIRST && compareToFirst(index) < 0)

File: src/java/org/apache/cassandra/io/compress/CompressedSequentialWriter.java
Patch:
@@ -263,7 +263,7 @@ protected class TransactionalProxy extends SequentialWriter.TransactionalProxy
         @Override
         protected Throwable doCommit(Throwable accumulate)
         {
-            return metadataWriter.commit(accumulate);
+            return super.doCommit(metadataWriter.commit(accumulate));
         }
 
         @Override
@@ -278,7 +278,6 @@ protected void doPrepare()
             syncInternal();
             if (descriptor != null)
                 crcMetadata.writeFullChecksum(descriptor);
-            releaseFileHandle();
             sstableMetadataCollector.addCompressionRatio(compressedSize, uncompressedSize);
             metadataWriter.finalizeLength(current(), chunkCount).prepareToCommit();
         }

File: src/java/org/apache/cassandra/io/compress/CompressionMetadata.java
Patch:
@@ -410,7 +410,7 @@ public void resetAndTruncate(int chunkIndex)
             count = chunkIndex;
         }
 
-        protected Throwable doPreCleanup(Throwable failed)
+        protected Throwable doPostCleanup(Throwable failed)
         {
             return offsets.close(failed);
         }
@@ -422,7 +422,7 @@ protected Throwable doCommit(Throwable accumulate)
 
         protected Throwable doAbort(Throwable accumulate)
         {
-            return FileUtils.deleteWithConfirm(filePath, false, accumulate);
+            return accumulate;
         }
     }
 

File: src/java/org/apache/cassandra/io/sstable/SSTableTxnWriter.java
Patch:
@@ -69,13 +69,13 @@ protected Throwable doCommit(Throwable accumulate)
 
     protected Throwable doAbort(Throwable accumulate)
     {
-        return writer.abort(txn.abort(accumulate));
+        return txn.abort(writer.abort(accumulate));
     }
 
     protected void doPrepare()
     {
-        txn.prepareToCommit();
         writer.prepareToCommit();
+        txn.prepareToCommit();
     }
 
     public Collection<SSTableReader> finish(boolean openResult)

File: src/java/org/apache/cassandra/utils/concurrent/Transactional.java
Patch:
@@ -88,7 +88,8 @@ public enum State
         // Transactional objects will perform cleanup in the commit() or abort() calls
 
         /**
-         * perform an exception-safe pre-abort cleanup; this will still be run *after* commit
+         * perform an exception-safe pre-abort/commit cleanup;
+         * this will be run after prepareToCommit (so before commit), and before abort
          */
         protected Throwable doPreCleanup(Throwable accumulate){ return accumulate; }
 
@@ -113,7 +114,6 @@ public final Throwable commit(Throwable accumulate)
             if (state != State.READY_TO_COMMIT)
                 throw new IllegalStateException("Cannot commit unless READY_TO_COMMIT; state is " + state);
             accumulate = doCommit(accumulate);
-            accumulate = doPreCleanup(accumulate);
             accumulate = doPostCleanup(accumulate);
             state = State.COMMITTED;
             return accumulate;
@@ -171,6 +171,7 @@ public final void prepareToCommit()
                 throw new IllegalStateException("Cannot prepare to commit unless IN_PROGRESS; state is " + state);
 
             doPrepare();
+            maybeFail(doPreCleanup(null));
             state = State.READY_TO_COMMIT;
         }
 

File: test/unit/org/apache/cassandra/io/compress/CompressedSequentialWriterTest.java
Patch:
@@ -222,7 +222,6 @@ protected void assertPrepared() throws Exception
         protected void assertAborted() throws Exception
         {
             super.assertAborted();
-            Assert.assertFalse(offsetsFile.exists());
         }
 
         void cleanup()

File: test/unit/org/apache/cassandra/io/util/ChecksummedSequentialWriterTest.java
Patch:
@@ -85,7 +85,6 @@ protected void assertPrepared() throws Exception
         protected void assertAborted() throws Exception
         {
             super.assertAborted();
-            Assert.assertFalse(crcFile.exists());
         }
     }
 

File: test/unit/org/apache/cassandra/io/util/SequentialWriterTest.java
Patch:
@@ -102,7 +102,6 @@ protected void assertPrepared() throws Exception
         protected void assertAborted() throws Exception
         {
             Assert.assertFalse(writer.isOpen());
-            Assert.assertFalse(file.exists());
         }
 
         protected void assertCommitted() throws Exception

File: src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java
Patch:
@@ -78,6 +78,9 @@ public void validate(ClientState state) throws RequestValidationException
         if (cfm.isCounter())
             throw new InvalidRequestException("Secondary indexes are not supported on counter tables");
 
+        if (cfm.isView())
+            throw new InvalidRequestException("Secondary indexes are not supported on materialized views");
+
         if (cfm.isCompactTable() && !cfm.isStaticCompactTable())
             throw new InvalidRequestException("Secondary indexes are not supported on COMPACT STORAGE tables that have clustering columns");
 

File: src/java/org/apache/cassandra/cql3/statements/DropTableStatement.java
Patch:
@@ -63,7 +63,7 @@ public boolean announceMigration(boolean isLocalOnly) throws ConfigurationExcept
         try
         {
             KeyspaceMetadata ksm = Schema.instance.getKSMetaData(keyspace());
-            CFMetaData cfm = ksm.tables.getNullable(columnFamily());
+            CFMetaData cfm = ksm.getTableOrViewNullable(columnFamily());
             if (cfm != null)
             {
                 if (cfm.isView())

File: src/java/org/apache/cassandra/cql3/statements/BatchStatement.java
Patch:
@@ -510,7 +510,7 @@ else if (!haveMultipleCFs)
 
             // Use the CFMetadata of the first statement for partition key bind indexes.  If the statements affect
             // multiple tables, we won't send partition key bind indexes.
-            Short[] partitionKeyBindIndexes = haveMultipleCFs ? null
+            Short[] partitionKeyBindIndexes = (haveMultipleCFs || batchStatement.statements.isEmpty())? null
                                                               : boundNames.getPartitionKeyBindIndexes(batchStatement.statements.get(0).cfm);
 
             return new ParsedStatement.Prepared(batchStatement, boundNames, partitionKeyBindIndexes);

File: src/java/org/apache/cassandra/db/view/MaterializedViewManager.java
Patch:
@@ -59,7 +59,7 @@
 public class MaterializedViewManager
 {
     private static final Striped<Lock> LOCKS = Striped.lazyWeakLock(DatabaseDescriptor.getConcurrentWriters() * 1024);
-    private static final boolean disableCoordinatorBatchlog = Boolean.getBoolean("cassandra.mv_disable_coordinator_batchlog");
+    private static final boolean enableCoordinatorBatchlog = Boolean.getBoolean("cassandra.mv_enable_coordinator_batchlog");
 
     private final ConcurrentNavigableMap<String, MaterializedView> viewsByName;
 
@@ -196,7 +196,7 @@ public static Lock acquireLockFor(ByteBuffer key)
 
     public static boolean updatesAffectView(Collection<? extends IMutation> mutations, boolean coordinatorBatchlog)
     {
-        if (coordinatorBatchlog && disableCoordinatorBatchlog)
+        if (coordinatorBatchlog && !enableCoordinatorBatchlog)
             return false;
 
         for (IMutation mutation : mutations)

File: src/java/org/apache/cassandra/locator/PropertyFileSnitch.java
Patch:
@@ -69,6 +69,7 @@ public PropertyFileSnitch() throws ConfigurationException
                 protected void runMayThrow() throws ConfigurationException
                 {
                     reloadConfiguration();
+                    StorageService.instance.updateTopology();
                 }
             };
             ResourceWatcher.watch(SNITCH_PROPERTIES_FILENAME, runnable, 60 * 1000);

File: src/java/org/apache/cassandra/locator/YamlFileNetworkTopologySnitch.java
Patch:
@@ -120,6 +120,7 @@ public YamlFileNetworkTopologySnitch() throws ConfigurationException
                 protected void runMayThrow() throws ConfigurationException
                 {
                     loadTopologyConfiguration();
+                    StorageService.instance.updateTopology();
                 }
             };
             ResourceWatcher.watch(topologyConfigFilename, runnable,

File: src/java/org/apache/cassandra/db/RowIndexEntry.java
Patch:
@@ -150,7 +150,8 @@ public void serialize(RowIndexEntry<IndexHelper.IndexInfo> rie, DataOutputPlus o
                     int i = 0;
                     for (IndexHelper.IndexInfo info : rie.columnsIndex())
                     {
-                        offsets[i++] = i == 0 ? 0 : (int)(out.getFilePointer() - start);
+                        offsets[i] = i == 0 ? 0 : (int)(out.getFilePointer() - start);
+                        i++;
                         idxSerializer.serialize(info, out);
                     }
                 }

File: test/unit/org/apache/cassandra/db/rows/RowBuilder.java
Patch:
@@ -36,7 +36,7 @@ public class RowBuilder implements Row.Builder
     public List<Cell> cells = new LinkedList<>();
     public Clustering clustering = null;
     public LivenessInfo livenessInfo = null;
-    public DeletionTime deletionTime = null;
+    public Row.Deletion deletionTime = null;
     public List<Pair<ColumnDefinition, DeletionTime>> complexDeletions = new LinkedList<>();
 
     public void addCell(Cell cell)
@@ -66,13 +66,12 @@ public void addPrimaryKeyLivenessInfo(LivenessInfo info)
         livenessInfo = info;
     }
 
-    public void addRowDeletion(DeletionTime deletion)
+    public void addRowDeletion(Row.Deletion deletion)
     {
         assert deletionTime == null;
         deletionTime = deletion;
     }
 
-
     public void addComplexDeletion(ColumnDefinition column, DeletionTime complexDeletion)
     {
         complexDeletions.add(Pair.create(column, complexDeletion));

File: src/java/org/apache/cassandra/utils/concurrent/Ref.java
Patch:
@@ -317,7 +317,7 @@ public String toString()
     private static final Set<GlobalState> globallyExtant = Collections.newSetFromMap(new ConcurrentHashMap<>());
     static final ReferenceQueue<Object> referenceQueue = new ReferenceQueue<>();
     private static final ExecutorService EXEC = Executors.newFixedThreadPool(1, new NamedThreadFactory("Reference-Reaper"));
-    private static final ScheduledExecutorService STRONG_LEAK_DETECTOR = !DEBUG_ENABLED ? null : Executors.newScheduledThreadPool(0, new NamedThreadFactory("Strong-Reference-Leak-Detector"));
+    private static final ScheduledExecutorService STRONG_LEAK_DETECTOR = !DEBUG_ENABLED ? null : Executors.newScheduledThreadPool(1, new NamedThreadFactory("Strong-Reference-Leak-Detector"));
     static
     {
         EXEC.execute(new ReferenceReaper());

File: src/java/org/apache/cassandra/cql3/QueryProcessor.java
Patch:
@@ -616,20 +616,20 @@ public void onUpdateColumnFamily(String ksName, String cfName, boolean columnsDi
         {
             if (columnsDidChange)
             {
-                logger.info("Column definitions for {}.{} changed, invalidating related prepared statements", ksName, cfName);
+                logger.debug("Column definitions for {}.{} changed, invalidating related prepared statements", ksName, cfName);
                 removeInvalidPreparedStatements(ksName, cfName);
             }
         }
 
         public void onDropKeyspace(String ksName)
         {
-            logger.info("Keyspace {} was dropped, invalidating related prepared statements", ksName);
+            logger.debug("Keyspace {} was dropped, invalidating related prepared statements", ksName);
             removeInvalidPreparedStatements(ksName, null);
         }
 
         public void onDropColumnFamily(String ksName, String cfName)
         {
-            logger.info("Table {}.{} was dropped, invalidating related prepared statements", ksName, cfName);
+            logger.debug("Table {}.{} was dropped, invalidating related prepared statements", ksName, cfName);
             removeInvalidPreparedStatements(ksName, cfName);
         }
 	}

File: src/java/org/apache/cassandra/cql3/UpdateParameters.java
Patch:
@@ -153,7 +153,7 @@ public void addRowDeletion()
         if (metadata.isCompactTable() && builder.clustering() != Clustering.STATIC_CLUSTERING)
             addTombstone(metadata.compactValueColumn());
         else
-            builder.addRowDeletion(deletionTime);
+            builder.addRowDeletion(Row.Deletion.regular(deletionTime));
     }
 
     public void addTombstone(ColumnDefinition column) throws InvalidRequestException

File: src/java/org/apache/cassandra/db/ClusteringPrefix.java
Patch:
@@ -416,9 +416,9 @@ public Deserializer(ClusteringComparator comparator, DataInputPlus in, Serializa
             this.serializationHeader = header;
         }
 
-        public void prepare(int flags) throws IOException
+        public void prepare(int flags, int extendedFlags) throws IOException
         {
-            assert !UnfilteredSerializer.isStatic(flags) : "Flags = " + flags;
+            assert !UnfilteredSerializer.isStatic(extendedFlags) : "Flags = " + flags;
             this.nextIsRow = UnfilteredSerializer.kind(flags) == Unfiltered.Kind.ROW;
             this.nextKind = nextIsRow ? Kind.CLUSTERING : ClusteringPrefix.Kind.values()[in.readByte()];
             this.nextSize = nextIsRow ? comparator.size() : in.readUnsignedShort();

File: src/java/org/apache/cassandra/db/LegacyLayout.java
Patch:
@@ -682,7 +682,7 @@ private static Pair<LegacyRangeTombstoneList, Iterator<LegacyCell>> fromRow(fina
             LegacyBound start = new LegacyLayout.LegacyBound(startBound, false, null);
             LegacyBound end = new LegacyLayout.LegacyBound(endBound, false, null);
 
-            deletions.add(start, end, row.deletion().markedForDeleteAt(), row.deletion().localDeletionTime());
+            deletions.add(start, end, row.deletion().time().markedForDeleteAt(), row.deletion().time().localDeletionTime());
         }
 
         for (ColumnData cd : row)
@@ -1155,7 +1155,7 @@ public boolean addRangeTombstone(LegacyRangeTombstone tombstone)
 
                 clustering = tombstone.start.getAsClustering(metadata);
                 builder.newRow(clustering);
-                builder.addRowDeletion(tombstone.deletionTime);
+                builder.addRowDeletion(Row.Deletion.regular(tombstone.deletionTime));
                 rowDeletion = tombstone;
                 return true;
             }

File: src/java/org/apache/cassandra/db/RowUpdateBuilder.java
Patch:
@@ -194,7 +194,7 @@ private static void deleteRow(PartitionUpdate update, long timestamp, int localD
             builder.newRow(Clustering.STATIC_CLUSTERING);
         else
             builder.newRow(clusteringValues.length == 0 ? Clustering.EMPTY : update.metadata().comparator.make(clusteringValues));
-        builder.addRowDeletion(new DeletionTime(timestamp, localDeletionTime));
+        builder.addRowDeletion(Row.Deletion.regular(new DeletionTime(timestamp, localDeletionTime)));
 
         update.add(builder.build());
     }

File: src/java/org/apache/cassandra/db/partitions/AbstractBTreePartition.java
Patch:
@@ -160,7 +160,7 @@ public Row next(Clustering clustering)
                     activeDeletion = rt.deletionTime();
 
                 if (row == null)
-                    return activeDeletion.isLive() ? null : BTreeRow.emptyDeletedRow(clustering, activeDeletion);
+                    return activeDeletion.isLive() ? null : BTreeRow.emptyDeletedRow(clustering, Row.Deletion.regular(activeDeletion));
 
                 return row.filter(columns, activeDeletion, true, metadata);
             }

File: src/java/org/apache/cassandra/db/rows/AbstractRow.java
Patch:
@@ -78,7 +78,7 @@ public void validateData(CFMetaData metadata)
         }
 
         primaryKeyLivenessInfo().validate();
-        if (deletion().localDeletionTime() < 0)
+        if (deletion().time().localDeletionTime() < 0)
             throw new MarshalException("A local deletion time should not be negative");
 
         for (ColumnData cd : this)

File: src/java/org/apache/cassandra/db/rows/RowDiffListener.java
Patch:
@@ -50,7 +50,7 @@ public interface RowDiffListener
      * but the merged result doesn't (i.e. the deletion has been shadowed).
      * @param original the deletion of input {@code i}. May be {@code null} if input {@code i} had no deletion but the merged row has.
      */
-    public void onDeletion(int i, Clustering clustering, DeletionTime merged, DeletionTime original);
+    public void onDeletion(int i, Clustering clustering, Row.Deletion merged, Row.Deletion original);
 
     /**
      * Called for every (non-live) complex deletion of any complex column present in either the merged row of input {@code i}.

File: src/java/org/apache/cassandra/db/view/TemporalRow.java
Patch:
@@ -256,7 +256,7 @@ public void addToRow(TemporalRow row, ColumnIdentifier column, CellPath path)
         this.nowInSec = nowInSec;
 
         LivenessInfo liveness = row.primaryKeyLivenessInfo();
-        this.viewClusteringLocalDeletionTime = minValueIfSet(viewClusteringLocalDeletionTime, row.deletion().localDeletionTime(), NO_DELETION_TIME);
+        this.viewClusteringLocalDeletionTime = minValueIfSet(viewClusteringLocalDeletionTime, row.deletion().time().localDeletionTime(), NO_DELETION_TIME);
         this.viewClusteringTimestamp = minValueIfSet(viewClusteringTimestamp, liveness.timestamp(), NO_TIMESTAMP);
         this.viewClusteringTtl = minValueIfSet(viewClusteringTtl, liveness.ttl(), NO_TTL);
 
@@ -402,7 +402,7 @@ public DeletionTime deletionTime(AbstractBTreePartition partition)
             return clusterTombstone.deletionTime();
 
         Row row = partition.getRow(baseClustering);
-        return row == null || row.deletion().isLive() ? DeletionTime.LIVE : row.deletion();
+        return row == null || row.deletion().isLive() ? DeletionTime.LIVE : row.deletion().time();
     }
 
     public Collection<org.apache.cassandra.db.rows.Cell> values(ColumnDefinition definition, Resolver resolver)

File: src/java/org/apache/cassandra/index/SecondaryIndexManager.java
Patch:
@@ -742,7 +742,7 @@ public void onPrimaryKeyLivenessInfo(int i, Clustering clustering, LivenessInfo
                         toInsert.addPrimaryKeyLivenessInfo(merged);
                 }
 
-                public void onDeletion(int i, Clustering clustering, DeletionTime merged, DeletionTime original)
+                public void onDeletion(int i, Clustering clustering, Row.Deletion merged, Row.Deletion original)
                 {
                 }
 
@@ -834,7 +834,7 @@ public void onPrimaryKeyLivenessInfo(int i, Clustering clustering, LivenessInfo
                 {
                 }
 
-                public void onDeletion(int i, Clustering clustering, DeletionTime merged, DeletionTime original)
+                public void onDeletion(int i, Clustering clustering, Row.Deletion merged, Row.Deletion original)
                 {
                 }
 

File: src/java/org/apache/cassandra/index/internal/CassandraIndex.java
Patch:
@@ -411,13 +411,13 @@ private void removeCell(Clustering clustering, Cell cell)
 
             private void indexPrimaryKey(final Clustering clustering,
                                          final LivenessInfo liveness,
-                                         final DeletionTime deletion)
+                                         final Row.Deletion deletion)
             {
                 if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)
                     insert(key.getKey(), clustering, null, liveness, opGroup);
 
                 if (!deletion.isLive())
-                    delete(key.getKey(), clustering, deletion, opGroup);
+                    delete(key.getKey(), clustering, deletion.time(), opGroup);
             }
 
             private LivenessInfo getPrimaryKeyIndexLiveness(Row row)
@@ -516,7 +516,7 @@ private void doDelete(DecoratedKey indexKey,
                           DeletionTime deletion,
                           OpOrder.Group opGroup)
     {
-        Row row = BTreeRow.emptyDeletedRow(indexClustering, deletion);
+        Row row = BTreeRow.emptyDeletedRow(indexClustering, Row.Deletion.regular(deletion));
         PartitionUpdate upd = partitionUpdate(indexKey, row);
         indexCfs.apply(upd, UpdateTransaction.NO_OP, opGroup, null);
         logger.debug("Removed index entry for value {}", indexKey);

File: src/java/org/apache/cassandra/service/DataResolver.java
Patch:
@@ -180,7 +180,7 @@ public void onPrimaryKeyLivenessInfo(int i, Clustering clustering, LivenessInfo
                             currentRow(i, clustering).addPrimaryKeyLivenessInfo(merged);
                     }
 
-                    public void onDeletion(int i, Clustering clustering, DeletionTime merged, DeletionTime original)
+                    public void onDeletion(int i, Clustering clustering, Row.Deletion merged, Row.Deletion original)
                     {
                         if (merged != null && !merged.equals(original))
                             currentRow(i, clustering).addRowDeletion(merged);

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -1343,7 +1343,7 @@ private void internal_remove(ByteBuffer key, ColumnPath column_path, long timest
         }
         else if (column_path.super_column != null && column_path.column == null)
         {
-            Row row = BTreeRow.emptyDeletedRow(new Clustering(column_path.super_column), new DeletionTime(timestamp, nowInSec));
+            Row row = BTreeRow.emptyDeletedRow(new Clustering(column_path.super_column), Row.Deletion.regular(new DeletionTime(timestamp, nowInSec)));
             update = PartitionUpdate.singleRowUpdate(metadata, dk, row);
         }
         else

File: test/unit/org/apache/cassandra/cql3/CQLTester.java
Patch:
@@ -753,12 +753,12 @@ public static void assertRows(UntypedResultSet result, Object[]... rows)
             Object[] expected = rows[i];
             UntypedResultSet.Row actual = iter.next();
 
-            Assert.assertEquals(String.format("Invalid number of (expected) values provided for row %d", i), expected.length, meta.size());
+            Assert.assertEquals(String.format("Invalid number of (expected) values provided for row %d", i), expected == null ? 1 : expected.length, meta.size());
 
             for (int j = 0; j < meta.size(); j++)
             {
                 ColumnSpecification column = meta.get(j);
-                ByteBuffer expectedByteValue = makeByteBuffer(expected[j], column.type);
+                ByteBuffer expectedByteValue = makeByteBuffer(expected == null ? null : expected[j], column.type);
                 ByteBuffer actualValue = actual.getBytes(column.name.toString());
 
                 if (!Objects.equal(expectedByteValue, actualValue))

File: test/unit/org/apache/cassandra/db/rows/UnfilteredRowIteratorsMergeTest.java
Patch:
@@ -337,8 +337,8 @@ DeletionTime deletionFor(Clusterable pointer, List<Unfiltered> list, DeletionTim
         else
         {
             Row row = (Row) list.get(index);
-            if (row.deletion() != null && row.deletion().supersedes(def))
-                def = row.deletion();
+            if (row.deletion().supersedes(def))
+                def = row.deletion().time();
         }
 
         if (index >= list.size())

File: test/unit/org/apache/cassandra/index/internal/CustomCassandraIndex.java
Patch:
@@ -395,13 +395,13 @@ private void removeCell(Clustering clustering, Cell cell)
 
             private void indexPrimaryKey(final Clustering clustering,
                                          final LivenessInfo liveness,
-                                         final DeletionTime deletion)
+                                         final Row.Deletion deletion)
             {
                 if (liveness.timestamp() != LivenessInfo.NO_TIMESTAMP)
                     insert(key.getKey(), clustering, null, liveness, opGroup);
 
                 if (!deletion.isLive())
-                    delete(key.getKey(), clustering, deletion, opGroup);
+                    delete(key.getKey(), clustering, deletion.time(), opGroup);
             }
 
             private LivenessInfo getPrimaryKeyIndexLiveness(Row row)
@@ -500,7 +500,7 @@ private void doDelete(DecoratedKey indexKey,
                           DeletionTime deletion,
                           OpOrder.Group opGroup)
     {
-        Row row = BTreeRow.emptyDeletedRow(indexClustering, deletion);
+        Row row = BTreeRow.emptyDeletedRow(indexClustering, Row.Deletion.regular(deletion));
         PartitionUpdate upd = partitionUpdate(indexKey, row);
         indexCfs.apply(upd, UpdateTransaction.NO_OP, opGroup, null);
         logger.debug("Removed index entry for value {}", indexKey);

File: src/java/org/apache/cassandra/db/lifecycle/LogTransaction.java
Patch:
@@ -401,7 +401,8 @@ static void removeUnfinishedLeftovers(CFMetaData metadata)
                     if (data.verify())
                     {
                         Throwable failure = data.removeUnfinishedLeftovers(null);
-                        logger.error("Failed to remove unfinished transaction leftovers for log {}", log, failure);
+                        if (failure != null)
+                            logger.error("Failed to remove unfinished transaction leftovers for log {}", log, failure);
                     }
                     else
                     {

File: src/java/org/apache/cassandra/hints/ChecksummedDataInput.java
Patch:
@@ -137,7 +137,7 @@ public void reBuffer()
 
     private void updateCrc()
     {
-        if (crcPosition == buffer.position() | crcUpdateDisabled)
+        if (crcPosition == buffer.position() || crcUpdateDisabled)
             return;
 
         assert crcPosition >= 0 && crcPosition < buffer.position();

File: src/java/org/apache/cassandra/utils/memory/BufferPool.java
Patch:
@@ -44,7 +44,7 @@
  */
 public class BufferPool
 {
-    /** The size of a page aligned buffer, 64kbit */
+    /** The size of a page aligned buffer, 64KiB */
     static final int CHUNK_SIZE = 64 << 10;
 
     @VisibleForTesting

File: test/unit/org/apache/cassandra/db/compaction/AntiCompactionTest.java
Patch:
@@ -148,7 +148,7 @@ public void shouldSkipAntiCompactionForNonIntersectingRange() throws Interrupted
         ColumnFamilyStore store = prepareColumnFamilyStore();
         Collection<SSTableReader> sstables = store.getUnrepairedSSTables();
         assertEquals(store.getSSTables().size(), sstables.size());
-        Range<Token> range = new Range<Token>(new BytesToken("-10".getBytes()), new BytesToken("-1".getBytes()));
+        Range<Token> range = new Range<Token>(new BytesToken("-1".getBytes()), new BytesToken("-10".getBytes()));
         List<Range<Token>> ranges = Arrays.asList(range);
 
         Refs<SSTableReader> refs = Refs.tryRef(sstables);

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -280,8 +280,7 @@ public Object call() throws Exception
                 }));
             }
 
-            for (Future<Object> f : futures)
-                f.get();
+            FBUtilities.waitOnFutures(futures);
         }
         finally
         {

File: src/java/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -863,7 +863,7 @@ static ColumnFilter getColumnSelectionForSlice(ClusteringIndexSliceFilter filter
             PartitionColumns columns = filter.selects(Clustering.STATIC_CLUSTERING)
                                      ? metadata.partitionColumns()
                                      : metadata.partitionColumns().withoutStatics();
-            return new ColumnFilter.Builder(metadata).addAll(columns).build();
+            return ColumnFilter.selectionBuilder().addAll(columns).build();
         }
     }
 
@@ -1208,7 +1208,7 @@ static Pair<ColumnFilter, ClusteringIndexNamesFilter> deserializeNamesSelectionA
             // fully specified.  We need to handle those cases differently in 3.0.
             NavigableSet<Clustering> clusterings = new TreeSet<>(metadata.comparator);
 
-            ColumnFilter.Builder selectionBuilder = new ColumnFilter.Builder(metadata);
+            ColumnFilter.Builder selectionBuilder = ColumnFilter.selectionBuilder();
             for (int i = 0; i < numCellNames; i++)
             {
                 ByteBuffer buffer = ByteBufferUtil.readWithShortLength(in);
@@ -1287,7 +1287,7 @@ private SinglePartitionSliceCommand deserializeSliceCommand(DataInputPlus in, bo
             PartitionColumns columns = selectsStatics
                                      ? metadata.partitionColumns()
                                      : metadata.partitionColumns().withoutStatics();
-            ColumnFilter columnFilter = new ColumnFilter.Builder(metadata).addAll(columns).build();
+            ColumnFilter columnFilter = ColumnFilter.selectionBuilder().addAll(columns).build();
 
             boolean isDistinct = compositesToGroup == -2 || (count == 1 && selectsStatics);
             DataLimits limits;

File: src/java/org/apache/cassandra/db/Slices.java
Patch:
@@ -876,7 +876,8 @@ public boolean intersects(List<ByteBuffer> minClusteringValues, List<ByteBuffer>
 
         public UnfilteredRowIterator makeSliceIterator(SliceableUnfilteredRowIterator iter)
         {
-            return UnfilteredRowIterators.emptyIterator(iter.metadata(), iter.partitionKey(), iter.isReverseOrder());
+            return UnfilteredRowIterators.noRowsIterator(iter.metadata(), iter.partitionKey(), iter.staticRow(),
+                                                         iter.partitionLevelDeletion(), iter.isReverseOrder());
         }
 
         public Iterator<Slice> iterator()

File: src/java/org/apache/cassandra/db/filter/ColumnFilter.java
Patch:
@@ -246,7 +246,7 @@ public static class Builder
         private PartitionColumns.Builder selection;
         private List<ColumnSubselection> subSelections;
 
-        public Builder(CFMetaData metadata)
+        private Builder(CFMetaData metadata)
         {
             this.metadata = metadata;
         }

File: src/java/org/apache/cassandra/db/partitions/FilteredPartition.java
Patch:
@@ -29,7 +29,7 @@ public class FilteredPartition extends ImmutableBTreePartition
 {
     public FilteredPartition(RowIterator rows)
     {
-        super(rows.metadata(), rows.partitionKey(), rows.columns(), build(rows, DeletionInfo.LIVE, false, 16));
+        super(rows.metadata(), rows.partitionKey(), build(rows, DeletionInfo.LIVE, false, 16));
     }
 
     /**
@@ -60,7 +60,7 @@ public boolean isReverseOrder()
 
             public PartitionColumns columns()
             {
-                return columns;
+                return FilteredPartition.this.columns();
             }
 
             public DecoratedKey partitionKey()

File: src/java/org/apache/cassandra/db/partitions/FilteredPartition.java
Patch:
@@ -29,7 +29,7 @@ public class FilteredPartition extends ImmutableBTreePartition
 {
     public FilteredPartition(RowIterator rows)
     {
-        super(rows.metadata(), rows.partitionKey(), rows.columns(), build(rows, DeletionInfo.LIVE, false, 16));
+        super(rows.metadata(), rows.partitionKey(), build(rows, DeletionInfo.LIVE, false, 16));
     }
 
     /**
@@ -60,7 +60,7 @@ public boolean isReverseOrder()
 
             public PartitionColumns columns()
             {
-                return columns;
+                return FilteredPartition.this.columns();
             }
 
             public DecoratedKey partitionKey()

File: src/java/org/apache/cassandra/db/SinglePartitionNamesCommand.java
Patch:
@@ -192,7 +192,7 @@ private ImmutableBTreePartition add(UnfilteredRowIterator iter, ImmutableBTreePa
         if (result == null)
             return ImmutableBTreePartition.create(iter, maxRows);
 
-        try (UnfilteredRowIterator merged = UnfilteredRowIterators.merge(Arrays.asList(iter, result.unfilteredIterator(columnFilter(), Slices.ALL, false)), nowInSec()))
+        try (UnfilteredRowIterator merged = UnfilteredRowIterators.merge(Arrays.asList(iter, result.unfilteredIterator(columnFilter(), Slices.ALL, clusteringIndexFilter().isReversed())), nowInSec()))
         {
             return ImmutableBTreePartition.create(merged, maxRows);
         }

File: src/java/org/apache/cassandra/db/columniterator/SSTableIterator.java
Patch:
@@ -265,9 +265,7 @@ && metadata().comparator.compare(slice.end(), indexState.currentIndex().firstNam
         protected Unfiltered computeNext() throws IOException
         {
             // Our previous read might have made us cross an index block boundary. If so, update our informations.
-            int currentBlockIdx = indexState.currentBlockIdx();
-            if (indexState.isPastCurrentBlock() && currentBlockIdx + 1 < indexState.blocksCount())
-                indexState.setToBlock(currentBlockIdx + 1);
+            indexState.updateBlock();
 
             // Return the next unfiltered unless we've reached the end, or we're beyond our slice
             // end (note that unless we're on the last block for the slice, there is no point

File: src/java/org/apache/cassandra/io/sstable/IndexHelper.java
Patch:
@@ -152,7 +152,7 @@ public Serializer(CFMetaData metadata, Version version)
 
             public void serialize(IndexInfo info, DataOutputPlus out, SerializationHeader header) throws IOException
             {
-                ISerializer<ClusteringPrefix> clusteringSerializer = metadata.serializers().clusteringPrefixSerializer(version, header);
+                ISerializer<ClusteringPrefix> clusteringSerializer = metadata.serializers().indexEntryClusteringPrefixSerializer(version, header);
                 clusteringSerializer.serialize(info.firstName, out);
                 clusteringSerializer.serialize(info.lastName, out);
                 out.writeLong(info.offset);
@@ -168,7 +168,7 @@ public void serialize(IndexInfo info, DataOutputPlus out, SerializationHeader he
 
             public IndexInfo deserialize(DataInputPlus in, SerializationHeader header) throws IOException
             {
-                ISerializer<ClusteringPrefix> clusteringSerializer = metadata.serializers().clusteringPrefixSerializer(version, header);
+                ISerializer<ClusteringPrefix> clusteringSerializer = metadata.serializers().indexEntryClusteringPrefixSerializer(version, header);
 
                 ClusteringPrefix firstName = clusteringSerializer.deserialize(in);
                 ClusteringPrefix lastName = clusteringSerializer.deserialize(in);
@@ -183,7 +183,7 @@ public IndexInfo deserialize(DataInputPlus in, SerializationHeader header) throw
 
             public long serializedSize(IndexInfo info, SerializationHeader header)
             {
-                ISerializer<ClusteringPrefix> clusteringSerializer = metadata.serializers().clusteringPrefixSerializer(version, header);
+                ISerializer<ClusteringPrefix> clusteringSerializer = metadata.serializers().indexEntryClusteringPrefixSerializer(version, header);
                 long size = clusteringSerializer.serializedSize(info.firstName)
                           + clusteringSerializer.serializedSize(info.lastName)
                           + TypeSizes.sizeof(info.offset)

File: src/java/org/apache/cassandra/net/MessageDeliveryTask.java
Patch:
@@ -78,7 +78,7 @@ public void run()
             Gossiper.instance.setLastProcessedMessageAt(constructionTime);
     }
 
-    EnumSet<MessagingService.Verb> GOSSIP_VERBS = EnumSet.of(MessagingService.Verb.GOSSIP_DIGEST_ACK,
+    private static final EnumSet<MessagingService.Verb> GOSSIP_VERBS = EnumSet.of(MessagingService.Verb.GOSSIP_DIGEST_ACK,
                                                              MessagingService.Verb.GOSSIP_DIGEST_ACK2,
                                                              MessagingService.Verb.GOSSIP_DIGEST_SYN);
 }

File: src/java/org/apache/cassandra/db/SerializationHeader.java
Patch:
@@ -104,7 +104,6 @@ public static SerializationHeader make(CFMetaData metadata, Collection<SSTableRe
             stats.updateTimestamp(sstable.getMinTimestamp());
             stats.updateLocalDeletionTime(sstable.getMinLocalDeletionTime());
             stats.updateTTL(sstable.getMinTTL());
-            stats.updateColumnSetPerRow(sstable.getTotalColumnsSet(), sstable.getTotalRows());
             if (sstable.header == null)
                 columns.addAll(metadata.partitionColumns());
             else

File: src/java/org/apache/cassandra/db/rows/UnfilteredSerializer.java
Patch:
@@ -147,7 +147,7 @@ private void writeComplexColumn(ComplexColumnData data, boolean hasComplexDeleti
     throws IOException
     {
         if (hasComplexDeletion)
-            header.writeDeletionTime(data == null ? DeletionTime.LIVE : data.complexDeletion(), out);
+            header.writeDeletionTime(data.complexDeletion(), out);
 
         out.writeUnsignedVInt(data.cellsCount());
         for (Cell cell : data)
@@ -222,7 +222,7 @@ private long sizeOfComplexColumn(ComplexColumnData data, boolean hasComplexDelet
         long size = 0;
 
         if (hasComplexDeletion)
-            size += header.deletionTimeSerializedSize(data == null ? DeletionTime.LIVE : data.complexDeletion());
+            size += header.deletionTimeSerializedSize(data.complexDeletion());
 
         size += TypeSizes.sizeofUnsignedVInt(data.cellsCount());
         for (Cell cell : data)

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -293,7 +293,10 @@ private void rebuild()
         for (ColumnDefinition def : partitionKeyColumns)
             this.columnMetadata.put(def.name.bytes, def);
         for (ColumnDefinition def : clusteringColumns)
+        {
             this.columnMetadata.put(def.name.bytes, def);
+            def.type.checkComparable();
+        }
         for (ColumnDefinition def : partitionColumns)
             this.columnMetadata.put(def.name.bytes, def);
 

File: src/java/org/apache/cassandra/db/marshal/BooleanType.java
Patch:
@@ -35,14 +35,14 @@ public class BooleanType extends AbstractType<Boolean>
 
     public static final BooleanType instance = new BooleanType();
 
-    BooleanType() {} // singleton
+    BooleanType() {super(ComparisonType.CUSTOM);} // singleton
 
     public boolean isEmptyValueMeaningless()
     {
         return true;
     }
 
-    public int compare(ByteBuffer o1, ByteBuffer o2)
+    public int compareCustom(ByteBuffer o1, ByteBuffer o2)
     {
         if (!o1.hasRemaining() || !o2.hasRemaining())
             return o1.hasRemaining() ? 1 : o2.hasRemaining() ? -1 : 0;

File: src/java/org/apache/cassandra/db/marshal/ByteType.java
Patch:
@@ -33,9 +33,10 @@ public class ByteType extends AbstractType<Byte>
 
     ByteType()
     {
+        super(ComparisonType.CUSTOM);
     } // singleton
 
-    public int compare(ByteBuffer o1, ByteBuffer o2)
+    public int compareCustom(ByteBuffer o1, ByteBuffer o2)
     {
         return o1.get(o1.position()) - o2.get(o2.position());
     }

File: src/java/org/apache/cassandra/db/marshal/CollectionType.java
Patch:
@@ -83,8 +83,9 @@ public ColumnSpecification makeCollectionReceiver(ColumnSpecification collection
 
     public final Kind kind;
 
-    protected CollectionType(Kind kind)
+    protected CollectionType(ComparisonType comparisonType, Kind kind)
     {
+        super(comparisonType);
         this.kind = kind;
     }
 

File: src/java/org/apache/cassandra/db/marshal/ColumnToCollectionType.java
Patch:
@@ -61,10 +61,11 @@ public static synchronized ColumnToCollectionType getInstance(Map<ByteBuffer, Co
 
     private ColumnToCollectionType(Map<ByteBuffer, CollectionType> defined)
     {
+        super(ComparisonType.CUSTOM);
         this.defined = ImmutableMap.copyOf(defined);
     }
 
-    public int compare(ByteBuffer o1, ByteBuffer o2)
+    public int compareCustom(ByteBuffer o1, ByteBuffer o2)
     {
         throw new UnsupportedOperationException("ColumnToCollectionType should only be used in composite types, never alone");
     }

File: src/java/org/apache/cassandra/db/marshal/DecimalType.java
Patch:
@@ -32,14 +32,14 @@ public class DecimalType extends AbstractType<BigDecimal>
 {
     public static final DecimalType instance = new DecimalType();
 
-    DecimalType() {} // singleton
+    DecimalType() {super(ComparisonType.CUSTOM);} // singleton
 
     public boolean isEmptyValueMeaningless()
     {
         return true;
     }
 
-    public int compare(ByteBuffer o1, ByteBuffer o2)
+    public int compareCustom(ByteBuffer o1, ByteBuffer o2)
     {
         if (!o1.hasRemaining() || !o2.hasRemaining())
             return o1.hasRemaining() ? 1 : o2.hasRemaining() ? -1 : 0;

File: src/java/org/apache/cassandra/db/marshal/DoubleType.java
Patch:
@@ -31,14 +31,14 @@ public class DoubleType extends AbstractType<Double>
 {
     public static final DoubleType instance = new DoubleType();
 
-    DoubleType() {} // singleton
+    DoubleType() {super(ComparisonType.CUSTOM);} // singleton
 
     public boolean isEmptyValueMeaningless()
     {
         return true;
     }
 
-    public int compare(ByteBuffer o1, ByteBuffer o2)
+    public int compareCustom(ByteBuffer o1, ByteBuffer o2)
     {
         if (!o1.hasRemaining() || !o2.hasRemaining())
             return o1.hasRemaining() ? 1 : o2.hasRemaining() ? -1 : 0;

File: src/java/org/apache/cassandra/db/marshal/EmptyType.java
Patch:
@@ -34,9 +34,9 @@ public class EmptyType extends AbstractType<Void>
 {
     public static final EmptyType instance = new EmptyType();
 
-    private EmptyType() {} // singleton
+    private EmptyType() {super(ComparisonType.CUSTOM);} // singleton
 
-    public int compare(ByteBuffer o1, ByteBuffer o2)
+    public int compareCustom(ByteBuffer o1, ByteBuffer o2)
     {
         return 0;
     }

File: src/java/org/apache/cassandra/db/marshal/FloatType.java
Patch:
@@ -32,14 +32,14 @@ public class FloatType extends AbstractType<Float>
 {
     public static final FloatType instance = new FloatType();
 
-    FloatType() {} // singleton
+    FloatType() {super(ComparisonType.CUSTOM);} // singleton
 
     public boolean isEmptyValueMeaningless()
     {
         return true;
     }
 
-    public int compare(ByteBuffer o1, ByteBuffer o2)
+    public int compareCustom(ByteBuffer o1, ByteBuffer o2)
     {
         if (!o1.hasRemaining() || !o2.hasRemaining())
             return o1.hasRemaining() ? 1 : o2.hasRemaining() ? -1 : 0;

File: src/java/org/apache/cassandra/db/marshal/Int32Type.java
Patch:
@@ -33,14 +33,15 @@ public class Int32Type extends AbstractType<Integer>
 
     Int32Type()
     {
+        super(ComparisonType.CUSTOM);
     } // singleton
 
     public boolean isEmptyValueMeaningless()
     {
         return true;
     }
 
-    public int compare(ByteBuffer o1, ByteBuffer o2)
+    public int compareCustom(ByteBuffer o1, ByteBuffer o2)
     {
         if (!o1.hasRemaining() || !o2.hasRemaining())
             return o1.hasRemaining() ? 1 : o2.hasRemaining() ? -1 : 0;

File: src/java/org/apache/cassandra/db/marshal/IntegerType.java
Patch:
@@ -58,14 +58,14 @@ private static int findMostSignificantByte(ByteBuffer bytes)
         return i;
     }
 
-    IntegerType() {/* singleton */}
+    IntegerType() {super(ComparisonType.CUSTOM);}/* singleton */
 
     public boolean isEmptyValueMeaningless()
     {
         return true;
     }
 
-    public int compare(ByteBuffer lhs, ByteBuffer rhs)
+    public int compareCustom(ByteBuffer lhs, ByteBuffer rhs)
     {
         return IntegerType.compareIntegers(lhs, rhs);
     }

File: src/java/org/apache/cassandra/db/marshal/LexicalUUIDType.java
Patch:
@@ -34,14 +34,15 @@ public class LexicalUUIDType extends AbstractType<UUID>
 
     LexicalUUIDType()
     {
+        super(ComparisonType.CUSTOM);
     } // singleton
 
     public boolean isEmptyValueMeaningless()
     {
         return true;
     }
 
-    public int compare(ByteBuffer o1, ByteBuffer o2)
+    public int compareCustom(ByteBuffer o1, ByteBuffer o2)
     {
         if (!o1.hasRemaining() || !o2.hasRemaining())
             return o1.hasRemaining() ? 1 : o2.hasRemaining() ? -1 : 0;

File: src/java/org/apache/cassandra/db/marshal/ListType.java
Patch:
@@ -68,7 +68,7 @@ public static synchronized <T> ListType<T> getInstance(AbstractType<T> elements,
 
     private ListType(AbstractType<T> elements, boolean isMultiCell)
     {
-        super(Kind.LIST);
+        super(ComparisonType.CUSTOM, Kind.LIST);
         this.elements = elements;
         this.serializer = ListSerializer.getInstance(elements.getSerializer());
         this.isMultiCell = isMultiCell;
@@ -124,7 +124,7 @@ public boolean isValueCompatibleWithFrozen(CollectionType<?> previous)
     }
 
     @Override
-    public int compare(ByteBuffer o1, ByteBuffer o2)
+    public int compareCustom(ByteBuffer o1, ByteBuffer o2)
     {
         return compareListOrSet(elements, o1, o2);
     }

File: src/java/org/apache/cassandra/db/marshal/LongType.java
Patch:
@@ -31,14 +31,14 @@ public class LongType extends AbstractType<Long>
 {
     public static final LongType instance = new LongType();
 
-    LongType() {} // singleton
+    LongType() {super(ComparisonType.CUSTOM);} // singleton
 
     public boolean isEmptyValueMeaningless()
     {
         return true;
     }
 
-    public int compare(ByteBuffer o1, ByteBuffer o2)
+    public int compareCustom(ByteBuffer o1, ByteBuffer o2)
     {
         return compareLongs(o1, o2);
     }

File: src/java/org/apache/cassandra/db/marshal/PartitionerDefinedOrder.java
Patch:
@@ -37,6 +37,7 @@ public class PartitionerDefinedOrder extends AbstractType<ByteBuffer>
 
     public PartitionerDefinedOrder(IPartitioner partitioner)
     {
+        super(ComparisonType.CUSTOM);
         this.partitioner = partitioner;
     }
 
@@ -86,7 +87,7 @@ public String toJSONString(ByteBuffer buffer, int protocolVersion)
         throw new UnsupportedOperationException();
     }
 
-    public int compare(ByteBuffer o1, ByteBuffer o2)
+    public int compareCustom(ByteBuffer o1, ByteBuffer o2)
     {
         // o1 and o2 can be empty so we need to use PartitionPosition, not DecoratedKey
         return PartitionPosition.ForKey.get(o1, partitioner).compareTo(PartitionPosition.ForKey.get(o2, partitioner));

File: src/java/org/apache/cassandra/db/marshal/ReversedType.java
Patch:
@@ -57,6 +57,7 @@ public static synchronized <T> ReversedType<T> getInstance(AbstractType<T> baseT
 
     private ReversedType(AbstractType<T> baseType)
     {
+        super(ComparisonType.CUSTOM);
         this.baseType = baseType;
     }
 
@@ -65,7 +66,7 @@ public boolean isEmptyValueMeaningless()
         return baseType.isEmptyValueMeaningless();
     }
 
-    public int compare(ByteBuffer o1, ByteBuffer o2)
+    public int compareCustom(ByteBuffer o1, ByteBuffer o2)
     {
         // An empty byte buffer is always smaller
         if (o1.remaining() == 0)

File: src/java/org/apache/cassandra/db/marshal/ShortType.java
Patch:
@@ -33,9 +33,10 @@ public class ShortType extends AbstractType<Short>
 
     ShortType()
     {
+        super(ComparisonType.CUSTOM);
     } // singleton
 
-    public int compare(ByteBuffer o1, ByteBuffer o2)
+    public int compareCustom(ByteBuffer o1, ByteBuffer o2)
     {
         int diff = o1.get(o1.position()) - o2.get(o2.position());
         if (diff != 0)

File: src/java/org/apache/cassandra/db/marshal/TimeUUIDType.java
Patch:
@@ -33,14 +33,15 @@ public class TimeUUIDType extends AbstractType<UUID>
 
     TimeUUIDType()
     {
+        super(ComparisonType.CUSTOM);
     } // singleton
 
     public boolean isEmptyValueMeaningless()
     {
         return true;
     }
 
-    public int compare(ByteBuffer b1, ByteBuffer b2)
+    public int compareCustom(ByteBuffer b1, ByteBuffer b2)
     {
         // Compare for length
         int s1 = b1.position(), s2 = b2.position();

File: src/java/org/apache/cassandra/db/marshal/TimestampType.java
Patch:
@@ -43,14 +43,14 @@ public class TimestampType extends AbstractType<Date>
 
     public static final TimestampType instance = new TimestampType();
 
-    private TimestampType() {} // singleton
+    private TimestampType() {super(ComparisonType.CUSTOM);} // singleton
 
     public boolean isEmptyValueMeaningless()
     {
         return true;
     }
 
-    public int compare(ByteBuffer o1, ByteBuffer o2)
+    public int compareCustom(ByteBuffer o1, ByteBuffer o2)
     {
         return LongType.compareLongs(o1, o2);
     }

File: src/java/org/apache/cassandra/db/marshal/TupleType.java
Patch:
@@ -41,6 +41,7 @@ public class TupleType extends AbstractType<ByteBuffer>
 
     public TupleType(List<AbstractType<?>> types)
     {
+        super(ComparisonType.CUSTOM);
         for (int i = 0; i < types.size(); i++)
             types.set(i, types.get(i).freeze());
         this.types = types;
@@ -69,7 +70,7 @@ public List<AbstractType<?>> allTypes()
         return types;
     }
 
-    public int compare(ByteBuffer o1, ByteBuffer o2)
+    public int compareCustom(ByteBuffer o1, ByteBuffer o2)
     {
         if (!o1.hasRemaining() || !o2.hasRemaining())
             return o1.hasRemaining() ? 1 : o2.hasRemaining() ? -1 : 0;

File: src/java/org/apache/cassandra/db/marshal/UUIDType.java
Patch:
@@ -48,14 +48,15 @@ public class UUIDType extends AbstractType<UUID>
 
     UUIDType()
     {
+        super(ComparisonType.CUSTOM);
     }
 
     public boolean isEmptyValueMeaningless()
     {
         return true;
     }
 
-    public int compare(ByteBuffer b1, ByteBuffer b2)
+    public int compareCustom(ByteBuffer b1, ByteBuffer b2)
     {
         // Compare for length
         int s1 = b1.position(), s2 = b2.position();

File: src/java/org/apache/cassandra/cql3/UpdateParameters.java
Patch:
@@ -149,7 +149,7 @@ public void addRowDeletion()
         // For compact tables, at the exclusion of the static row (of static compact tables), each row ever has a single column,
         // the "compact" one. As such, deleting the row or deleting that single cell is equivalent. We favor the later however
         // because that makes it easier when translating back to the old format layout (for thrift and pre-3.0 backward
-        // compatibility) as we don't have to special case for the row deletion. This is also in line with what we use to do pre-3.0.
+        // compatibility) as we don't have to special case for the row deletion. This is also in line with what we used to do pre-3.0.
         if (metadata.isCompactTable() && builder.clustering() != Clustering.STATIC_CLUSTERING)
             addTombstone(metadata.compactValueColumn());
         else

File: src/java/org/apache/cassandra/db/view/MaterializedViewManager.java
Patch:
@@ -59,7 +59,7 @@
 public class MaterializedViewManager
 {
     private static final Striped<Lock> LOCKS = Striped.lazyWeakLock(DatabaseDescriptor.getConcurrentWriters() * 1024);
-    private static final boolean disableCoordinatorBatchlog = Boolean.getBoolean("cassandra.mv_disble_coordinator_batchlog");
+    private static final boolean disableCoordinatorBatchlog = Boolean.getBoolean("cassandra.mv_disable_coordinator_batchlog");
 
     private final ConcurrentNavigableMap<String, MaterializedView> viewsByName;
 

File: src/java/org/apache/cassandra/db/view/MaterializedViewBuilder.java
Patch:
@@ -183,7 +183,8 @@ public Iterable<SSTableReader> apply(View view)
                 }
             }
 
-            SystemKeyspace.finishMaterializedViewBuildStatus(ksname, viewName);
+            if (!isStopped)
+                SystemKeyspace.finishMaterializedViewBuildStatus(ksname, viewName);
 
         }
         catch (Exception e)

File: src/java/org/apache/cassandra/db/commitlog/AbstractCommitLogService.java
Patch:
@@ -186,7 +186,7 @@ public void shutdown()
     /**
      * FOR TESTING ONLY
      */
-    public void startUnsafe()
+    public void restartUnsafe()
     {
         while (haveWork.availablePermits() < 1)
             haveWork.release();

File: test/unit/org/apache/cassandra/SchemaLoader.java
Patch:
@@ -463,7 +463,7 @@ public static void cleanupAndLeaveDirs() throws IOException
         mkdirs();
         cleanup();
         mkdirs();
-        CommitLog.instance.startUnsafe();
+        CommitLog.instance.restartUnsafe();
     }
 
     public static void cleanup()

File: test/unit/org/apache/cassandra/db/commitlog/CommitLogUpgradeTest.java
Patch:
@@ -157,7 +157,7 @@ public void testRestore(String location) throws IOException, InterruptedExceptio
         }
 
         Hasher hasher = new Hasher();
-        CommitLogTestReplayer replayer = new CommitLogTestReplayer(hasher);
+        CommitLogTestReplayer replayer = new CommitLogTestReplayer(CommitLog.instance, hasher);
         File[] files = new File(location).listFiles(new FilenameFilter()
         {
             @Override

File: test/unit/org/apache/cassandra/db/ColumnsTest.java
Patch:
@@ -124,7 +124,7 @@ public void testSerializeHugeSubset() throws IOException
     }
 
     @Test
-    public void testContainsColumnsWithLargeNumberOfColumns()
+    public void testContainsAllWithLargeNumberOfColumns()
     {
         List<String> names = new ArrayList<>();
         for (int i = 0; i < 50; i++)
@@ -140,7 +140,7 @@ public void testContainsColumnsWithLargeNumberOfColumns()
 
         Columns subset = Columns.from(new HashSet<>(defs));
 
-        org.junit.Assert.assertTrue(columns.contains(subset));
+        Assert.assertTrue(columns.containsAll(subset));
     }
 
     private void testSerializeSubset(ColumnsCheck input) throws IOException

File: src/java/org/apache/cassandra/db/Columns.java
Patch:
@@ -263,7 +263,7 @@ public Columns mergeTo(Columns other)
      */
     public boolean contains(Columns other)
     {
-        if (other.columns.length > columns.length)
+        if (other.columnCount() > columnCount())
             return false;
 
         BTreeSearchIterator<ColumnDefinition, ColumnDefinition> iter = BTree.slice(columns, Comparator.naturalOrder(), BTree.Dir.ASC);

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1038,7 +1038,7 @@ private void doAuthSetup()
         // Also, the addKeyspace above can be racy if multiple nodes are started
         // concurrently - see CASSANDRA-9201
         for (CFMetaData table : AuthKeyspace.metadata().tables)
-            if (Schema.instance.getCFMetaData(table.ksName, table.cfName) == null)
+            if (Schema.instance.getCF(table.cfId) == null)
                 maybeAddTable(table);
 
         DatabaseDescriptor.getRoleManager().setup();

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -85,7 +85,7 @@ public class Config
 
     public volatile Long truncate_request_timeout_in_ms = 60000L;
 
-    public Integer streaming_socket_timeout_in_ms = 0;
+    public Integer streaming_socket_timeout_in_ms = 3600000;
 
     public boolean cross_node_timeout = false;
 

File: src/java/org/apache/cassandra/index/SecondaryIndexManager.java
Patch:
@@ -341,7 +341,7 @@ public void flushIndexesBlocking(Set<Index> indexes)
             indexes.forEach(index ->
                 index.getBackingTable()
                      .map(cfs -> wait.add(cfs.forceFlush()))
-                     .orElse(nonCfsIndexes.add(index)));
+                     .orElseGet(() -> nonCfsIndexes.add(index)));
         }
         executeAllBlocking(nonCfsIndexes.stream(), Index::getBlockingFlushTask);
         FBUtilities.waitOnFutures(wait);

File: src/java/org/apache/cassandra/utils/NanoTimeToCurrentTimeMillis.java
Patch:
@@ -46,7 +46,7 @@ public class NanoTimeToCurrentTimeMillis
      * There is also the issue of how scalable nanoTime() and currentTimeMillis() are which is a moving target.
      *
      * These timestamps don't order with System.currentTimeMillis() because currentTimeMillis() can tick over
-     * before this one does. I have seen it behind by as much as 2 milliseconds.
+     * before this one does. I have seen it behind by as much as 2ms on Linux and 25ms on Windows.
      */
     public static final long convert(long nanoTime)
     {

File: src/java/org/apache/cassandra/tools/nodetool/TpStats.java
Patch:
@@ -31,11 +31,11 @@ public class TpStats extends NodeToolCmd
     @Override
     public void execute(NodeProbe probe)
     {
-        System.out.printf("%-25s%10s%10s%15s%10s%18s%n", "Pool Name", "Active", "Pending", "Completed", "Blocked", "All time blocked");
+        System.out.printf("%-30s%10s%10s%15s%10s%18s%n", "Pool Name", "Active", "Pending", "Completed", "Blocked", "All time blocked");
 
         for (Stage stage : Stage.jmxEnabledStages())
         {
-            System.out.printf("%-25s%10s%10s%15s%10s%18s%n",
+            System.out.printf("%-30s%10s%10s%15s%10s%18s%n",
                               stage.getJmxName(),
                               probe.getThreadPoolMetric(stage, "ActiveTasks"),
                               probe.getThreadPoolMetric(stage, "PendingTasks"),

File: src/java/org/apache/cassandra/net/OutboundTcpConnection.java
Patch:
@@ -293,7 +293,7 @@ private void writeConnected(QueuedMessage qm, boolean flush)
         catch (Exception e)
         {
             disconnect();
-            if (e instanceof IOException)
+            if (e instanceof IOException || e.getCause() instanceof IOException)
             {
                 if (logger.isDebugEnabled())
                     logger.debug("error writing to {}", poolReference.endPoint(), e);

File: test/unit/org/apache/cassandra/cql3/validation/entities/TypeTest.java
Patch:
@@ -41,11 +41,11 @@ public void testDateCompatibility() throws Throwable
         createTable("CREATE TABLE %s (a int, b timestamp, c bigint, d varint, PRIMARY KEY (a, b, c, d))");
 
         execute("INSERT INTO %s (a, b, c, d) VALUES (0, toUnixTimestamp(now()), toTimestamp(now()), toTimestamp(now()))");
-        UntypedResultSet results = execute("SELECT * FROM %s WHERE a=0 AND b < toUnixTimestamp(now())");
+        UntypedResultSet results = execute("SELECT * FROM %s WHERE a=0 AND b <= toUnixTimestamp(now())");
         assertEquals(1, results.size());
 
         execute("INSERT INTO %s (a, b, c, d) VALUES (1, unixTimestampOf(now()), dateOf(now()), dateOf(now()))");
-        results = execute("SELECT * FROM %s WHERE a=1 AND b < toUnixTimestamp(now())");
+        results = execute("SELECT * FROM %s WHERE a=1 AND b <= toUnixTimestamp(now())");
         assertEquals(1, results.size());
     }
 

File: src/java/org/apache/cassandra/cql3/functions/ScriptBasedUDFunction.java
Patch:
@@ -70,8 +70,10 @@ final class ScriptBasedUDFunction extends UDFunction
     "jdk.nashorn.internal.runtime.linker",
     // following required by Java Driver
     "java.math",
+    "java.nio",
     "java.text",
     "com.google.common.base",
+    "com.google.common.collect",
     "com.google.common.reflect",
     // following required by UDF
     "com.datastax.driver.core",

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -1527,7 +1527,7 @@ public static int getHintsFlushPeriodInMS()
 
     public static long getMaxHintsFileSize()
     {
-        return conf.max_hints_file_size_in_mb * 1024 * 1024;
+        return conf.max_hints_file_size_in_mb * 1024L * 1024L;
     }
 
     public static boolean isIncrementalBackupsEnabled()

File: src/java/org/apache/cassandra/hints/LegacyHintsMigrator.java
Patch:
@@ -71,7 +71,7 @@ private static int calculatePageSize(ColumnFamilyStore legacyHintsTable)
         int meanCellCount = legacyHintsTable.getMeanColumns();
         double meanPartitionSize = legacyHintsTable.getMeanPartitionSize();
 
-        if (meanCellCount != 0 || meanPartitionSize != 0)
+        if (meanCellCount != 0 && meanPartitionSize != 0)
         {
             int avgHintSize = (int) meanPartitionSize / meanCellCount;
             size = Math.max(2, Math.min(size, (512 << 10) / avgHintSize));

File: src/java/org/apache/cassandra/db/lifecycle/TransactionLog.java
Patch:
@@ -228,7 +228,7 @@ private String format()
 
         public byte[] getBytes()
         {
-            return record.getBytes();
+            return record.getBytes(FileUtils.CHARSET);
         }
 
         public boolean verify(String parentFolder, boolean lastRecordIsCorrupt)
@@ -360,7 +360,7 @@ private Record readRecord(String line, boolean isLast)
                 return Record.make(line, isLast);
             }
 
-            byte[] bytes = matcher.group(1).getBytes();
+            byte[] bytes = matcher.group(1).getBytes(FileUtils.CHARSET);
             checksum.update(bytes, 0, bytes.length);
 
             if (checksum.getValue() != Long.valueOf(matcher.group(2)))

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -193,7 +193,9 @@ public int recover(File... clogs) throws IOException
      */
     public void recover(String path) throws IOException
     {
-        recover(new File(path));
+        CommitLogReplayer recovery = CommitLogReplayer.construct(this);
+        recovery.recover(new File(path), false);
+        recovery.blockForWrites();
     }
 
     /**

File: test/unit/org/apache/cassandra/db/commitlog/CommitLogFailurePolicyTest.java
Patch:
@@ -17,7 +17,7 @@
 * under the License.
 */
 
-package org.apache.cassandra.db;
+package org.apache.cassandra.db.commitlog;
 
 import org.junit.Assert;
 import org.junit.BeforeClass;

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -189,7 +189,9 @@ public int recover(File... clogs) throws IOException
      */
     public void recover(String path) throws IOException
     {
-        recover(new File(path));
+        CommitLogReplayer recovery = CommitLogReplayer.create();
+        recovery.recover(new File(path), false);
+        recovery.blockForWrites();
     }
 
     /**

File: test/unit/org/apache/cassandra/db/commitlog/CommitLogFailurePolicyTest.java
Patch:
@@ -17,7 +17,7 @@
 * under the License.
 */
 
-package org.apache.cassandra.db;
+package org.apache.cassandra.db.commitlog;
 
 import org.junit.Assert;
 import org.junit.BeforeClass;
@@ -39,7 +39,6 @@ public class CommitLogFailurePolicyTest
     public static void defineSchema() throws ConfigurationException
     {
         SchemaLoader.prepareServer();
-        System.setProperty("cassandra.commitlog.stop_on_errors", "true");
     }
 
     @Test

File: src/java/org/apache/cassandra/schema/SchemaKeyspace.java
Patch:
@@ -1434,13 +1434,13 @@ private static IndexMetadata createIndexMetadataFromIndexesRow(CFMetaData cfm, U
 
         Set<String> targetColumnNames = row.getSet("target_columns", UTF8Type.instance);
         assert targetType == IndexMetadata.TargetType.COLUMN : "Per row indexes with dynamic target columns are not supported yet";
-        assert targetColumnNames.size() == 1 : "Secondary indexes targetting multiple columns are not supported yet";
 
         Set<ColumnIdentifier> targetColumns = new HashSet<>();
         // if it's not a CQL table, we can't assume that the column name is utf8, so
         // in that case we have to do a linear scan of the cfm's columns to get the matching one
         if (targetColumnNames != null)
         {
+            assert targetColumnNames.size() == 1 : "Secondary indexes targetting multiple columns are not supported yet";
             targetColumnNames.forEach(targetColumnName -> {
                 if (cfm.isCQLTable())
                     targetColumns.add(ColumnIdentifier.getInterned(targetColumnName, true));

File: test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
Patch:
@@ -530,6 +530,8 @@ public void testScrubDataDirectories() throws Throwable
         String tmpDataFileName = ssTable.descriptor.tmpFilenameFor(Component.DATA);
         new File(dataFileName).renameTo(new File(tmpDataFileName));
 
+        ssTable.selfRef().release();
+
         ColumnFamilyStore.scrubDataDirectories(cfs.metadata);
 
         List<File> ssTableFiles = new Directories(cfs.metadata).sstableLister(Directories.OnTxnErr.THROW).listFiles();

File: test/unit/org/apache/cassandra/cql3/validation/operations/AggregationTest.java
Patch:
@@ -1465,7 +1465,7 @@ public void testFunctionWithFrozenUDFType() throws Throwable
         execute("INSERT INTO %s (a, b) VALUES (?, {f : ?})", 3, 7);
 
         String fState = createFunction(KEYSPACE,
-                                       "tuple<int, int>",
+                                       myType + ',' + myType,
                                        "CREATE FUNCTION %s (state " + myType + ", values " + myType + ") " +
                                        "CALLED ON NULL INPUT " +
                                        "RETURNS " + myType + " " +
@@ -1535,7 +1535,7 @@ public void testEmptyValues() throws Throwable
                                       "INITCOND ''");
 
         String fRNON = createFunction(KEYSPACE,
-                                      "text",
+                                      "text, text",
                                       "CREATE FUNCTION %s(a text, b text) " +
                                       "RETURNS NULL ON NULL INPUT " +
                                       "RETURNS text " +
@@ -1551,7 +1551,7 @@ public void testEmptyValues() throws Throwable
                                       "AS 'return \"fin\" + a;'");
 
         String aRNON = createAggregate(KEYSPACE,
-                                      "int",
+                                      "text",
                                       "CREATE AGGREGATE %s(text) " +
                                       "SFUNC " + shortFunctionName(fRNON) + ' ' +
                                       "STYPE text " +

File: src/java/org/apache/cassandra/db/Clustering.java
Patch:
@@ -134,6 +134,7 @@ public static class Serializer
         public void serialize(Clustering clustering, DataOutputPlus out, int version, List<AbstractType<?>> types) throws IOException
         {
             assert clustering != STATIC_CLUSTERING : "We should never serialize a static clustering";
+            assert clustering.size() == types.size() : "Invalid clustering for the table: " + clustering;
             ClusteringPrefix.serializer.serializeValuesWithoutSize(clustering, out, version, types);
         }
 

File: src/java/org/apache/cassandra/db/filter/ColumnSubselection.java
Patch:
@@ -180,8 +180,9 @@ public void serialize(ColumnSubselection subSel, DataOutputPlus out, int version
                     Element eltSelection = (Element)subSel;
                     column.cellPathSerializer().serialize(eltSelection.element, out);
                     break;
+                default:
+                    throw new AssertionError();
             }
-            throw new AssertionError();
         }
 
         public ColumnSubselection deserialize(DataInputPlus in, int version, CFMetaData metadata) throws IOException

File: src/java/org/apache/cassandra/db/marshal/CollectionType.java
Patch:
@@ -127,7 +127,7 @@ public boolean isCollection()
     public void validateCellValue(ByteBuffer cellValue) throws MarshalException
     {
         if (isMultiCell())
-            valueComparator().validate(cellValue);
+            valueComparator().validateCellValue(cellValue);
         else
             super.validateCellValue(cellValue);
     }

File: src/java/org/apache/cassandra/cql3/restrictions/PrimaryKeyRestrictionSet.java
Patch:
@@ -98,7 +98,7 @@ private PrimaryKeyRestrictionSet(PrimaryKeyRestrictionSet primaryKeyRestrictions
             this.slice = true;
         else if (restriction.isContains() || primaryKeyRestrictions.isContains())
             this.contains = true;
-        else if (restriction.isIN())
+        else if (restriction.isIN() || primaryKeyRestrictions.isIN())
             this.in = true;
         else
             this.eq = true;

File: src/java/org/apache/cassandra/cql3/statements/CreateTableStatement.java
Patch:
@@ -221,7 +221,7 @@ public ParsedStatement.Prepared prepare() throws RequestValidationException
         {
             // Column family name
             if (!columnFamily().matches("\\w+"))
-                throw new InvalidRequestException(String.format("\"%s\" is not a valid table name (must be alphanumeric character only: [0-9A-Za-z]+)", columnFamily()));
+                throw new InvalidRequestException(String.format("\"%s\" is not a valid table name (must be alphanumeric character or underscore only: [a-zA-Z_0-9]+)", columnFamily()));
             if (columnFamily().length() > Schema.NAME_LENGTH)
                 throw new InvalidRequestException(String.format("Table names shouldn't be more than %s characters long (got \"%s\")", Schema.NAME_LENGTH, columnFamily()));
 

File: src/java/org/apache/cassandra/db/commitlog/AbstractCommitLogService.java
Patch:
@@ -192,7 +192,7 @@ public void shutdown()
     /**
      * FOR TESTING ONLY
      */
-    public void startUnsafe()
+    public void restartUnsafe()
     {
         while (haveWork.availablePermits() < 1)
             haveWork.release();

File: src/java/org/apache/cassandra/db/commitlog/CommitLogDescriptor.java
Patch:
@@ -40,7 +40,6 @@
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.io.FSReadError;
 import org.apache.cassandra.net.MessagingService;
-import org.apache.cassandra.utils.FBUtilities;
 import org.json.simple.JSONValue;
 
 import static org.apache.cassandra.utils.FBUtilities.updateChecksumInt;

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
Patch:
@@ -49,7 +49,6 @@
 import org.apache.cassandra.io.FSWriteError;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.utils.CLibrary;
-import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.concurrent.OpOrder;
 import org.apache.cassandra.utils.concurrent.WaitQueue;
 

File: test/unit/org/apache/cassandra/SchemaLoader.java
Patch:
@@ -464,7 +464,7 @@ public static void cleanupAndLeaveDirs() throws IOException
         mkdirs();
         cleanup();
         mkdirs();
-        CommitLog.instance.startUnsafe();
+        CommitLog.instance.restartUnsafe();
     }
 
     public static void cleanup()

File: test/unit/org/apache/cassandra/cql3/CQLTester.java
Patch:
@@ -173,7 +173,7 @@ public static void cleanupAndLeaveDirs() throws IOException
         mkdirs();
         cleanup();
         mkdirs();
-        CommitLog.instance.startUnsafe();
+        CommitLog.instance.restartUnsafe();
     }
 
     public static void cleanup()

File: test/unit/org/apache/cassandra/db/CommitLogTest.java
Patch:
@@ -408,7 +408,7 @@ public void testCommitLogFailureBeforeInitialization_mustKillJVM() throws Except
             DatabaseDescriptor.setCommitFailurePolicy(Config.CommitFailurePolicy.ignore);
 
             //now let's create a commit log segment manager and wait for it to fail
-            new CommitLogSegmentManager(CommitLog.instance);
+            new CommitLogSegmentManager(CommitLog.instance).start();
 
             //busy wait since commitlogsegmentmanager spawns another thread
             int retries = 0;
@@ -447,7 +447,7 @@ public void testCommitLogFailureAfterInitialization_mustRespectFailurePolicy() t
             DatabaseDescriptor.setCommitFailurePolicy(Config.CommitFailurePolicy.ignore);
 
             //now let's create a commit log segment manager and wait for it to fail
-            new CommitLogSegmentManager(CommitLog.instance);
+            new CommitLogSegmentManager(CommitLog.instance).start();
 
             //wait commit log segment manager thread to execute
             Thread.sleep(50);

File: src/java/org/apache/cassandra/metrics/EstimatedHistogramReservoir.java
Patch:
@@ -33,9 +33,10 @@ public class EstimatedHistogramReservoir implements Reservoir
 {
     EstimatedHistogram histogram;
 
+    // Default to >4 hours of in nanoseconds of buckets
     public EstimatedHistogramReservoir()
     {
-        this(128);
+        this(164);
     }
 
     public EstimatedHistogramReservoir(int numBuckets)

File: src/java/org/apache/cassandra/db/commitlog/CommitLogArchiver.java
Patch:
@@ -124,9 +124,6 @@ protected void runMayThrow() throws IOException
             {
                 segment.waitForFinalSync();
                 String command = archiveCommand.replace("%name", segment.getName());
-                // We need to swap out / with the os-specific separator in the event someone provided an incorrect value
-                if (FBUtilities.isWindows())
-                    archiveCommand.replace('/', File.separatorChar);
                 command = command.replace("%path", segment.getPath());
                 exec(command);
             }

File: src/java/org/apache/cassandra/db/commitlog/CommitLogArchiver.java
Patch:
@@ -124,6 +124,9 @@ protected void runMayThrow() throws IOException
             {
                 segment.waitForFinalSync();
                 String command = archiveCommand.replace("%name", segment.getName());
+                // We need to swap out / with the os-specific separator in the event someone provided an incorrect value
+                if (FBUtilities.isWindows())
+                    archiveCommand.replace('/', File.separatorChar);
                 command = command.replace("%path", segment.getPath());
                 exec(command);
             }

File: src/java/org/apache/cassandra/utils/MerkleTrees.java
Patch:
@@ -125,6 +125,7 @@ public MerkleTree addMerkleTree(int maxsize, byte hashdepth, Range<Token> range)
      * @param t
      * @return
      */
+    @VisibleForTesting
     public MerkleTree.TreeRange get(Token t)
     {
         return getMerkleTree(t).get(t);
@@ -167,6 +168,7 @@ public boolean split(Token t)
      * 
      * @param t
      */
+    @VisibleForTesting
     public void invalidate(Token t)
     {
         getMerkleTree(t).invalidate(t);
@@ -215,7 +217,7 @@ private MerkleTree getMerkleTree(Token t)
                 return merkleTrees.get(range);
         }
 
-        return null;
+        throw new AssertionError("Expected tree for token " + t);
     }
 
     private void addTrees(Collection<MerkleTree> trees)

File: test/unit/org/apache/cassandra/repair/LocalSyncTaskTest.java
Patch:
@@ -20,9 +20,7 @@
 
 import java.net.InetAddress;
 import java.util.Arrays;
-import java.util.HashMap;
 import java.util.HashSet;
-import java.util.Map;
 import java.util.Set;
 import java.util.UUID;
 

File: src/java/org/apache/cassandra/db/lifecycle/TransactionLogs.java
Patch:
@@ -479,7 +479,7 @@ private static void delete(File file)
         }
         catch (NoSuchFileException e)
         {
-            logger.warn("Unable to delete {} as it does not exist", file);
+            logger.error("Unable to delete {} as it does not exist", file);
         }
         catch (IOException e)
         {

File: src/java/org/apache/cassandra/cql3/restrictions/StatementRestrictions.java
Patch:
@@ -513,8 +513,10 @@ public boolean areRequestedBoundsInclusive(Bound bound)
      */
     public boolean isColumnRange()
     {
+        // For static compact tables we need to ignore the fake clustering column.
+        int numberOfClusteringColumns = cfm.isStaticCompactTable() ? 0 : cfm.clusteringColumns().size();
         // it is a range query if it has at least one the column alias for which no relation is defined or is not EQ.
-        return clusteringColumnsRestrictions.size() < cfm.clusteringColumns().size()
+        return clusteringColumnsRestrictions.size() < numberOfClusteringColumns
             || (!clusteringColumnsRestrictions.isEQ() && !clusteringColumnsRestrictions.isIN());
     }
 

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -51,6 +51,7 @@
 import org.apache.cassandra.io.util.DataOutputPlus;
 import org.apache.cassandra.schema.*;
 import org.apache.cassandra.utils.*;
+import org.apache.cassandra.utils.AbstractIterator;
 import org.github.jamm.Unmetered;
 
 /**

File: src/java/org/apache/cassandra/cql3/UntypedResultSet.java
Patch:
@@ -22,7 +22,7 @@
 import java.nio.ByteBuffer;
 import java.util.*;
 
-import com.google.common.collect.AbstractIterator;
+import org.apache.cassandra.utils.AbstractIterator;
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.ColumnDefinition;

File: src/java/org/apache/cassandra/db/LegacyLayout.java
Patch:
@@ -23,7 +23,7 @@
 import java.nio.ByteBuffer;
 import java.util.*;
 
-import com.google.common.collect.AbstractIterator;
+import org.apache.cassandra.utils.AbstractIterator;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.Lists;
 import com.google.common.collect.PeekingIterator;

File: src/java/org/apache/cassandra/db/RangeTombstoneList.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.Arrays;
 import java.util.Iterator;
 
-import com.google.common.collect.AbstractIterator;
+import org.apache.cassandra.utils.AbstractIterator;
 import com.google.common.collect.Iterators;
 
 import org.slf4j.Logger;

File: src/java/org/apache/cassandra/db/partitions/PartitionIterators.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.*;
 import java.security.MessageDigest;
 
-import com.google.common.collect.AbstractIterator;
+import org.apache.cassandra.utils.AbstractIterator;
 
 import org.apache.cassandra.db.SinglePartitionReadCommand;
 import org.apache.cassandra.db.rows.*;

File: src/java/org/apache/cassandra/db/rows/AbstractUnfilteredRowIterator.java
Patch:
@@ -17,7 +17,7 @@
  */
 package org.apache.cassandra.db.rows;
 
-import com.google.common.collect.AbstractIterator;
+import org.apache.cassandra.utils.AbstractIterator;
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.db.*;

File: src/java/org/apache/cassandra/db/rows/BTreeBackedRow.java
Patch:
@@ -22,7 +22,6 @@
 import java.util.function.Predicate;
 
 import com.google.common.base.Function;
-import com.google.common.collect.AbstractIterator;
 import com.google.common.collect.Iterators;
 
 import org.apache.cassandra.config.CFMetaData;
@@ -31,6 +30,7 @@
 import org.apache.cassandra.db.filter.ColumnFilter;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.partitions.PartitionUpdate;
+import org.apache.cassandra.utils.AbstractIterator;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.ObjectSizes;
 import org.apache.cassandra.utils.btree.BTree;

File: src/java/org/apache/cassandra/db/rows/LazilyInitializedUnfilteredRowIterator.java
Patch:
@@ -17,7 +17,7 @@
  */
 package org.apache.cassandra.db.rows;
 
-import com.google.common.collect.AbstractIterator;
+import org.apache.cassandra.utils.AbstractIterator;
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.db.*;

File: src/java/org/apache/cassandra/hadoop/cql3/CqlRecordReader.java
Patch:
@@ -27,7 +27,7 @@
 import com.google.common.base.Function;
 import com.google.common.base.Joiner;
 import com.google.common.base.Splitter;
-import com.google.common.collect.AbstractIterator;
+import org.apache.cassandra.utils.AbstractIterator;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
 import org.apache.commons.lang3.StringUtils;

File: src/java/org/apache/cassandra/io/sstable/KeyIterator.java
Patch:
@@ -21,7 +21,7 @@
 import java.io.File;
 import java.io.IOException;
 
-import com.google.common.collect.AbstractIterator;
+import org.apache.cassandra.utils.AbstractIterator;
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.db.DecoratedKey;

File: src/java/org/apache/cassandra/io/sstable/SSTableIdentityIterator.java
Patch:
@@ -19,7 +19,7 @@
 
 import java.io.*;
 
-import com.google.common.collect.AbstractIterator;
+import org.apache.cassandra.utils.AbstractIterator;
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.db.*;

File: src/java/org/apache/cassandra/io/sstable/SSTableSimpleIterator.java
Patch:
@@ -21,7 +21,7 @@
 import java.io.IOError;
 import java.util.Iterator;
 
-import com.google.common.collect.AbstractIterator;
+import org.apache.cassandra.utils.AbstractIterator;
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.ColumnDefinition;

File: src/java/org/apache/cassandra/io/sstable/format/big/BigTableScanner.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.*;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import com.google.common.collect.AbstractIterator;
+import org.apache.cassandra.utils.AbstractIterator;
 import com.google.common.collect.Iterators;
 import com.google.common.util.concurrent.RateLimiter;
 

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -67,6 +67,7 @@
 import org.apache.cassandra.tracing.Tracing;
 import org.apache.cassandra.triggers.TriggerExecutor;
 import org.apache.cassandra.utils.*;
+import org.apache.cassandra.utils.AbstractIterator;
 
 public class StorageProxy implements StorageProxyMBean
 {

File: src/java/org/apache/cassandra/service/pager/MultiPartitionPager.java
Patch:
@@ -19,7 +19,7 @@
 
 import java.util.List;
 
-import com.google.common.collect.AbstractIterator;
+import org.apache.cassandra.utils.AbstractIterator;
 
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.rows.*;

File: src/java/org/apache/cassandra/thrift/ThriftResultsMerger.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 
-import com.google.common.collect.AbstractIterator;
+import org.apache.cassandra.utils.AbstractIterator;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.PeekingIterator;
 

File: src/java/org/apache/cassandra/utils/FBUtilities.java
Patch:
@@ -29,7 +29,7 @@
 import java.util.zip.Checksum;
 
 import com.google.common.base.Joiner;
-import com.google.common.collect.AbstractIterator;
+import org.apache.cassandra.utils.AbstractIterator;
 import org.apache.commons.lang3.StringUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: src/java/org/apache/cassandra/utils/IntervalTree.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.*;
 
 import com.google.common.base.Joiner;
-import com.google.common.collect.AbstractIterator;
+import org.apache.cassandra.utils.AbstractIterator;
 import com.google.common.collect.Iterators;
 
 import org.slf4j.Logger;

File: src/java/org/apache/cassandra/utils/MergeIterator.java
Patch:
@@ -20,7 +20,7 @@
 import java.io.Closeable;
 import java.util.*;
 
-import com.google.common.collect.AbstractIterator;
+import org.apache.cassandra.utils.AbstractIterator;
 
 /** Merges sorted input iterators which individually contain unique items. */
 public abstract class MergeIterator<In,Out> extends AbstractIterator<Out> implements IMergeIterator<In, Out>

File: src/java/org/apache/cassandra/utils/MerkleTree.java
Patch:
@@ -23,7 +23,6 @@
 import java.util.*;
 
 import com.google.common.base.Preconditions;
-import com.google.common.collect.AbstractIterator;
 import com.google.common.collect.PeekingIterator;
 
 import org.apache.cassandra.db.TypeSizes;

File: test/unit/org/apache/cassandra/utils/MergeIteratorComparisonTest.java
Patch:
@@ -23,7 +23,7 @@
 
 import com.google.common.base.Function;
 import com.google.common.base.Objects;
-import com.google.common.collect.AbstractIterator;
+import org.apache.cassandra.utils.AbstractIterator;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.Lists;

File: test/unit/org/apache/cassandra/utils/MergeIteratorTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.Arrays;
 import java.util.Iterator;
 
-import com.google.common.collect.AbstractIterator;
+import org.apache.cassandra.utils.AbstractIterator;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.Ordering;
 import org.junit.Before;

File: test/unit/org/apache/cassandra/utils/MerkleTreeTest.java
Patch:
@@ -21,7 +21,7 @@
 import java.math.BigInteger;
 import java.util.*;
 
-import com.google.common.collect.AbstractIterator;
+import org.apache.cassandra.utils.AbstractIterator;
 
 import org.junit.Before;
 import org.junit.Test;

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -920,7 +920,7 @@ private void logDroppedMessages()
     {
         List<String> logs = getDroppedMessagesLogs();
         for (String log : logs)
-            logger.error(log);
+            logger.info(log);
 
         if (logs.size() > 0)
             StatusLogger.log();

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -2029,7 +2029,7 @@ public void truncate(String cfname) throws InvalidRequestException, UnavailableE
         {
             String keyspace = cState.getKeyspace();
             cState.hasColumnFamilyAccess(keyspace, cfname, Permission.MODIFY);
-            CFMetaData metadata = ThriftValidation.validateColumnFamily(keyspace, cfname, true);
+            CFMetaData metadata = ThriftValidation.validateColumnFamily(keyspace, cfname, false);
             if (metadata.isMaterializedView())
                 throw new org.apache.cassandra.exceptions.InvalidRequestException("Cannot truncate Materialized Views");
 

File: src/java/org/apache/cassandra/db/rows/Cell.java
Patch:
@@ -41,7 +41,7 @@ public abstract class Cell extends ColumnData
     public static final int NO_TTL = 0;
     public static final int NO_DELETION_TIME = Integer.MAX_VALUE;
 
-    public final Comparator<Cell> comparator = (c1, c2) ->
+    public final static Comparator<Cell> comparator = (c1, c2) ->
     {
         int cmp = c1.column().compareTo(c2.column());
         if (cmp != 0)

File: src/java/org/apache/cassandra/db/rows/Row.java
Patch:
@@ -465,7 +465,7 @@ protected ColumnData getReduced()
                         cellReducer.setActiveDeletion(activeDeletion);
                     }
 
-                    Iterator<Cell> cells = MergeIterator.get(complexCells, ColumnData.comparator, cellReducer);
+                    Iterator<Cell> cells = MergeIterator.get(complexCells, Cell.comparator, cellReducer);
                     while (cells.hasNext())
                     {
                         Cell merged = cells.next();

File: src/java/org/apache/cassandra/db/compaction/AbstractCompactionStrategy.java
Patch:
@@ -180,7 +180,7 @@ public void shutdown()
 
     public AbstractCompactionTask getCompactionTask(LifecycleTransaction txn, final int gcBefore, long maxSSTableBytes)
     {
-        return new CompactionTask(cfs, txn, gcBefore, false);
+        return new CompactionTask(cfs, txn, gcBefore);
     }
 
     /**

File: src/java/org/apache/cassandra/db/compaction/DateTieredCompactionStrategy.java
Patch:
@@ -71,7 +71,7 @@ public synchronized AbstractCompactionTask getNextBackgroundTask(int gcBefore)
 
             LifecycleTransaction modifier = cfs.getTracker().tryModify(latestBucket, OperationType.COMPACTION);
             if (modifier != null)
-                return new CompactionTask(cfs, modifier, gcBefore, false);
+                return new CompactionTask(cfs, modifier, gcBefore);
         }
     }
 
@@ -372,7 +372,7 @@ public synchronized Collection<AbstractCompactionTask> getMaximalTask(int gcBefo
         if (modifier == null)
             return null;
 
-        return Arrays.<AbstractCompactionTask>asList(new CompactionTask(cfs, modifier, gcBefore, false));
+        return Arrays.<AbstractCompactionTask>asList(new CompactionTask(cfs, modifier, gcBefore));
     }
 
     @Override
@@ -388,7 +388,7 @@ public synchronized AbstractCompactionTask getUserDefinedTask(Collection<SSTable
             return null;
         }
 
-        return new CompactionTask(cfs, modifier, gcBefore, false).setUserDefined(true);
+        return new CompactionTask(cfs, modifier, gcBefore).setUserDefined(true);
     }
 
     public int getEstimatedRemainingTasks()

File: src/java/org/apache/cassandra/db/compaction/LeveledCompactionTask.java
Patch:
@@ -34,7 +34,7 @@ public class LeveledCompactionTask extends CompactionTask
 
     public LeveledCompactionTask(ColumnFamilyStore cfs, LifecycleTransaction txn, int level, int gcBefore, long maxSSTableBytes, boolean majorCompaction)
     {
-        super(cfs, txn, gcBefore, false);
+        super(cfs, txn, gcBefore);
         this.level = level;
         this.maxSSTableBytes = maxSSTableBytes;
         this.majorCompaction = majorCompaction;
@@ -46,8 +46,8 @@ public CompactionAwareWriter getCompactionAwareWriter(ColumnFamilyStore cfs,
                                                           Set<SSTableReader> nonExpiredSSTables)
     {
         if (majorCompaction)
-            return new MajorLeveledCompactionWriter(cfs, txn, nonExpiredSSTables, maxSSTableBytes, false);
-        return new MaxSSTableSizeWriter(cfs, txn, nonExpiredSSTables, maxSSTableBytes, getLevel(), false);
+            return new MajorLeveledCompactionWriter(cfs, txn, nonExpiredSSTables, maxSSTableBytes, false, false);
+        return new MaxSSTableSizeWriter(cfs, txn, nonExpiredSSTables, maxSSTableBytes, getLevel(), false, false);
     }
 
     @Override

File: src/java/org/apache/cassandra/db/compaction/SSTableSplitter.java
Patch:
@@ -60,7 +60,7 @@ public static class SplittingCompactionTask extends CompactionTask
 
         public SplittingCompactionTask(ColumnFamilyStore cfs, LifecycleTransaction transaction, int sstableSizeInMB)
         {
-            super(cfs, transaction, CompactionManager.NO_GC, true);
+            super(cfs, transaction, CompactionManager.NO_GC, true, false);
             this.sstableSizeInMB = sstableSizeInMB;
 
             if (sstableSizeInMB <= 0)
@@ -78,7 +78,7 @@ public CompactionAwareWriter getCompactionAwareWriter(ColumnFamilyStore cfs,
                                                               LifecycleTransaction txn,
                                                               Set<SSTableReader> nonExpiredSSTables)
         {
-            return new MaxSSTableSizeWriter(cfs, txn, nonExpiredSSTables, sstableSizeInMB * 1024L * 1024L, 0, true);
+            return new MaxSSTableSizeWriter(cfs, txn, nonExpiredSSTables, sstableSizeInMB * 1024L * 1024L, 0, true, false);
         }
 
         @Override

File: src/java/org/apache/cassandra/db/compaction/writers/SplittingSizeTieredCompactionWriter.java
Patch:
@@ -59,7 +59,7 @@ public SplittingSizeTieredCompactionWriter(ColumnFamilyStore cfs, LifecycleTrans
     @SuppressWarnings("resource")
     public SplittingSizeTieredCompactionWriter(ColumnFamilyStore cfs, LifecycleTransaction txn, Set<SSTableReader> nonExpiredSSTables, long smallestSSTable)
     {
-        super(cfs, txn, nonExpiredSSTables, false);
+        super(cfs, txn, nonExpiredSSTables, false, false);
         this.allSSTables = txn.originals();
         totalSize = cfs.getExpectedCompactedFileSize(nonExpiredSSTables, txn.opType());
         double[] potentialRatios = new double[20];

File: src/java/org/apache/cassandra/db/lifecycle/TransactionLogs.java
Patch:
@@ -592,7 +592,7 @@ public void run()
                 return;
             }
 
-            if (tracker != null && !wasNew)
+            if (tracker != null && tracker.cfstore != null && !wasNew)
                 tracker.cfstore.metric.totalDiskSpaceUsed.dec(sizeOnDisk);
 
             // release the referent to the parent so that the all transaction files can be released

File: src/java/org/apache/cassandra/io/sstable/SSTableTxnWriter.java
Patch:
@@ -60,18 +60,18 @@ public long getFilePointer()
 
     protected Throwable doCommit(Throwable accumulate)
     {
-        return txn.commit(writer.commit(accumulate));
+        return writer.commit(txn.commit(accumulate));
     }
 
     protected Throwable doAbort(Throwable accumulate)
     {
-        return txn.abort(writer.abort(accumulate));
+        return writer.abort(txn.abort(accumulate));
     }
 
     protected void doPrepare()
     {
-        writer.prepareToCommit();
         txn.prepareToCommit();
+        writer.prepareToCommit();
     }
 
     public SSTableReader finish(boolean openResult)

File: test/long/org/apache/cassandra/db/compaction/LongCompactionsTest.java
Patch:
@@ -127,7 +127,7 @@ protected void testCompaction(int sstableCount, int partitionsPerSSTable, int ro
         try (LifecycleTransaction txn = store.getTracker().tryModify(sstables, OperationType.COMPACTION))
         {
             assert txn != null : "Cannot markCompacting all sstables";
-            new CompactionTask(store, txn, gcBefore, false).execute(null);
+            new CompactionTask(store, txn, gcBefore).execute(null);
         }
         System.out.println(String.format("%s: sstables=%d rowsper=%d colsper=%d: %d ms",
                                          this.getClass().getName(),

File: test/unit/org/apache/cassandra/db/compaction/CompactionAwareWriterTest.java
Patch:
@@ -78,7 +78,7 @@ public void testDefaultCompactionWriter() throws Throwable
         populate(rowCount);
         LifecycleTransaction txn = cfs.getTracker().tryModify(cfs.getLiveSSTables(), OperationType.COMPACTION);
         long beforeSize = txn.originals().iterator().next().onDiskLength();
-        CompactionAwareWriter writer = new DefaultCompactionWriter(cfs, txn, txn.originals(), false);
+        CompactionAwareWriter writer = new DefaultCompactionWriter(cfs, txn, txn.originals());
         int rows = compact(cfs, txn, writer);
         assertEquals(1, cfs.getLiveSSTables().size());
         assertEquals(rowCount, rows);
@@ -97,7 +97,7 @@ public void testMaxSSTableSizeWriter() throws Throwable
         LifecycleTransaction txn = cfs.getTracker().tryModify(cfs.getLiveSSTables(), OperationType.COMPACTION);
         long beforeSize = txn.originals().iterator().next().onDiskLength();
         int sstableSize = (int)beforeSize/10;
-        CompactionAwareWriter writer = new MaxSSTableSizeWriter(cfs, txn, txn.originals(), sstableSize, 0, false);
+        CompactionAwareWriter writer = new MaxSSTableSizeWriter(cfs, txn, txn.originals(), sstableSize, 0);
         int rows = compact(cfs, txn, writer);
         assertEquals(10, cfs.getLiveSSTables().size());
         assertEquals(rowCount, rows);
@@ -150,7 +150,7 @@ public void testMajorLeveledCompactionWriter() throws Throwable
         LifecycleTransaction txn = cfs.getTracker().tryModify(cfs.getLiveSSTables(), OperationType.COMPACTION);
         long beforeSize = txn.originals().iterator().next().onDiskLength();
         int sstableSize = (int)beforeSize/targetSSTableCount;
-        CompactionAwareWriter writer = new MajorLeveledCompactionWriter(cfs, txn, txn.originals(), sstableSize, false);
+        CompactionAwareWriter writer = new MajorLeveledCompactionWriter(cfs, txn, txn.originals(), sstableSize);
         int rows = compact(cfs, txn, writer);
         assertEquals(targetSSTableCount, cfs.getLiveSSTables().size());
         int [] levelCounts = new int[5];

File: test/unit/org/apache/cassandra/io/sstable/SSTableRewriterTest.java
Patch:
@@ -670,8 +670,6 @@ public void testSSTableSplit() throws InterruptedException
             splitter.split();
 
             assertFileCounts(s.descriptor.directory.list());
-
-            s.selfRef().release();
             TransactionLogs.waitForDeletions();
 
             for (File f : s.descriptor.directory.listFiles())

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -992,7 +992,6 @@ public static long getTimeout(MessagingService.Verb verb)
             case PAXOS_PREPARE:
             case PAXOS_PROPOSE:
             case BATCHLOG_MUTATION:
-            case MATERIALIZED_VIEW_MUTATION:
                 return getWriteRpcTimeout();
             case COUNTER_MUTATION:
                 return getCounterWriteRpcTimeout();

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -294,7 +294,6 @@ public StorageService()
         /* register the verb handlers */
         MessagingService.instance().registerVerbHandlers(MessagingService.Verb.MUTATION, new MutationVerbHandler());
         MessagingService.instance().registerVerbHandlers(MessagingService.Verb.BATCHLOG_MUTATION, new MutationVerbHandler());
-        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.MATERIALIZED_VIEW_MUTATION, new MutationVerbHandler());
         MessagingService.instance().registerVerbHandlers(MessagingService.Verb.READ_REPAIR, new ReadRepairVerbHandler());
         MessagingService.instance().registerVerbHandlers(MessagingService.Verb.READ, new ReadCommandVerbHandler());
         MessagingService.instance().registerVerbHandlers(MessagingService.Verb.RANGE_SLICE, new ReadCommandVerbHandler());

File: src/java/org/apache/cassandra/security/CipherFactory.java
Patch:
@@ -109,7 +109,7 @@ public Cipher getEncryptor(String transformation, String keyAlias) throws IOExce
 
     public Cipher getDecryptor(String transformation, String keyAlias, byte[] iv) throws IOException
     {
-        assert iv != null && iv.length > 0 : "trying to decrypt, but the initialization vector is empty";
+        assert iv != null || iv.length > 0 : "trying to decrypt, but the initialization vector is empty";
         return buildCipher(transformation, keyAlias, iv, Cipher.DECRYPT_MODE);
     }
 

File: src/java/org/apache/cassandra/security/CipherFactory.java
Patch:
@@ -109,7 +109,7 @@ public Cipher getEncryptor(String transformation, String keyAlias) throws IOExce
 
     public Cipher getDecryptor(String transformation, String keyAlias, byte[] iv) throws IOException
     {
-        assert iv != null || iv.length > 0 : "trying to decrypt, but the initialization vector is empty";
+        assert iv != null && iv.length > 0 : "trying to decrypt, but the initialization vector is empty";
         return buildCipher(transformation, keyAlias, iv, Cipher.DECRYPT_MODE);
     }
 

File: src/java/org/apache/cassandra/security/CipherFactory.java
Patch:
@@ -109,7 +109,7 @@ public Cipher getEncryptor(String transformation, String keyAlias) throws IOExce
 
     public Cipher getDecryptor(String transformation, String keyAlias, byte[] iv) throws IOException
     {
-        assert iv != null || iv.length > 0 : "trying to decrypt, but the initialization vector is empty";
+        assert iv != null && iv.length > 0 : "trying to decrypt, but the initialization vector is empty";
         return buildCipher(transformation, keyAlias, iv, Cipher.DECRYPT_MODE);
     }
 

File: src/java/org/apache/cassandra/db/lifecycle/LifecycleTransaction.java
Patch:
@@ -350,7 +350,7 @@ public void update(SSTableReader reader, boolean original)
         staged.update.add(reader);
         identities.add(reader.instanceId);
         if (!isOffline())
-            reader.setupKeyCache();
+            reader.setupOnline();
     }
 
     /**

File: src/java/org/apache/cassandra/db/lifecycle/Tracker.java
Patch:
@@ -177,7 +177,7 @@ Throwable updateSizeTracking(Iterable<SSTableReader> oldSSTables, Iterable<SSTab
     public void addInitialSSTables(Iterable<SSTableReader> sstables)
     {
         if (!isDummy())
-            setupKeycache(sstables);
+            setupOnline(sstables);
         apply(updateLiveSet(emptySet(), sstables));
         maybeFail(updateSizeTracking(emptySet(), sstables, null));
         // no notifications or backup necessary
@@ -341,7 +341,7 @@ public void replaceFlushed(Memtable memtable, SSTableReader sstable)
             return;
         }
 
-        sstable.setupKeyCache();
+        sstable.setupOnline();
         // back up before creating a new Snapshot (which makes the new one eligible for compaction)
         maybeIncrementallyBackup(sstable);
 

File: src/java/org/apache/cassandra/io/sstable/SSTableRewriter.java
Patch:
@@ -222,7 +222,7 @@ private void moveStarts(SSTableReader newReader, DecoratedKey lowerbound)
 
         final List<DecoratedKey> invalidateKeys = new ArrayList<>();
         invalidateKeys.addAll(cachedKeys.keySet());
-        newReader.setupKeyCache();
+        newReader.setupOnline();
         for (Map.Entry<DecoratedKey, RowIndexEntry> cacheKey : cachedKeys.entrySet())
             newReader.cacheKey(cacheKey.getKey(), cacheKey.getValue());
 

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -266,6 +266,7 @@ public class Config
     public int windows_timer_interval = 0;
 
     public boolean enable_user_defined_functions = false;
+    public boolean enable_scripted_user_defined_functions = false;
     /**
      * Optionally disable asynchronous UDF execution.
      * Disabling asynchronous UDF execution also implicitly disables the security-manager!

File: src/java/org/apache/cassandra/cql3/statements/CreateFunctionStatement.java
Patch:
@@ -131,8 +131,7 @@ public void checkAccess(ClientState state) throws UnauthorizedException, Invalid
 
     public void validate(ClientState state) throws InvalidRequestException
     {
-        if (!DatabaseDescriptor.enableUserDefinedFunctions())
-            throw new InvalidRequestException("User-defined-functions are disabled in cassandra.yaml - set enable_user_defined_functions=true to enable if you are aware of the security risks");
+        UDFunction.assertUdfsEnabled(language);
 
         if (ifNotExists && orReplace)
             throw new InvalidRequestException("Cannot use both 'OR REPLACE' and 'IF NOT EXISTS' directives");

File: test/unit/org/apache/cassandra/db/compaction/CompactionsCQLTest.java
Patch:
@@ -30,7 +30,7 @@ public class CompactionsCQLTest extends CQLTester
     public void testTriggerMinorCompaction() throws Throwable
     {
         createTable("CREATE TABLE %s (id text PRIMARY KEY);");
-        assertTrue(Keyspace.open(KEYSPACE).getColumnFamilyStore(currentTable()).getCompactionStrategy().isEnabled());
+        assertTrue(Keyspace.open(KEYSPACE).getColumnFamilyStore(currentTable()).getCompactionStrategyManager().isEnabled());
         execute("insert into %s (id) values ('1')");
         flush();
         execute("insert into %s (id) values ('1')");

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -1766,7 +1766,7 @@ public Map<String, String> describe_token_map() throws InvalidRequestException
 
     public String describe_partitioner() throws TException
     {
-        return StorageService.instance.getTokenMetadata().getClass().getName();
+        return StorageService.instance.getPartitionerName();
     }
 
     public String describe_snitch() throws TException

File: src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java
Patch:
@@ -1251,7 +1251,6 @@ private void validate()
     {
         if (this.first.compareTo(this.last) > 0)
         {
-            selfRef().release();
             throw new IllegalStateException(String.format("SSTable first key %s > last key %s", this.first, this.last));
         }
     }

File: src/java/org/apache/cassandra/tools/StandaloneScrubber.java
Patch:
@@ -121,7 +121,7 @@ public static void main(String args[])
                     try (LifecycleTransaction txn = LifecycleTransaction.offline(OperationType.SCRUB, sstable))
                     {
                         txn.obsoleteOriginals(); // make sure originals are deleted and avoid NPE if index is missing, CASSANDRA-9591
-                        try (Scrubber scrubber = new Scrubber(cfs, txn, options.skipCorrupted, handler, true, !options.noValidate, false))
+                        try (Scrubber scrubber = new Scrubber(cfs, txn, options.skipCorrupted, handler, true, !options.noValidate))
                         {
                             scrubber.scrub();
                         }

File: src/java/org/apache/cassandra/utils/btree/TreeCursor.java
Patch:
@@ -141,8 +141,8 @@ int seekTo(K key, boolean forwards, boolean skipOne)
             if (bound == null)
                 break; // we're all that's left
 
-            int cmpbound = comparator.compare(key, bound.bound(forwards));
-            if (forwards ? cmpbound < 0 : cmpbound > 0)
+            int cmpbound = comparator.compare(bound.bound(forwards), key); // order of provision matters for asymmetric comparators
+            if (forwards ? cmpbound > 0 : cmpbound < 0)
                 break; //  already in correct sub-tree
 
             // bound is on-or-before target, so ascend to that bound and continue looking upwards

File: src/java/org/apache/cassandra/schema/SchemaKeyspace.java
Patch:
@@ -701,8 +701,7 @@ public static Mutation makeDropKeyspaceMutation(KeyspaceMetadata keyspace, long
         Mutation mutation = new Mutation(NAME, getSchemaKSDecoratedKey(keyspace.name));
         for (CFMetaData schemaTable : All)
             mutation.add(PartitionUpdate.fullPartitionDelete(schemaTable, mutation.key(), timestamp, nowInSec));
-        mutation.add(PartitionUpdate.fullPartitionDelete(SystemKeyspace.BuiltMaterializedViews, mutation.key(), timestamp, nowInSec));
-        mutation.add(PartitionUpdate.fullPartitionDelete(SystemKeyspace.MaterializedViewsBuildsInProgress, mutation.key(), timestamp, nowInSec));
+
         return mutation;
     }
 

File: src/java/org/apache/cassandra/schema/SchemaKeyspace.java
Patch:
@@ -1340,7 +1340,7 @@ private static MaterializedViewDefinition createMaterializedViewFromMaterialized
         String name = row.getString("view_name");
         List<String> partitionColumnNames = row.getList("target_columns", UTF8Type.instance);
 
-        String cfName = row.getString("columnfamily_name");
+        String cfName = row.getString("table_name");
         List<String> clusteringColumnNames = row.getList("clustering_columns", UTF8Type.instance);
 
         List<ColumnIdentifier> partitionColumns = new ArrayList<>();

File: src/java/org/apache/cassandra/schema/SchemaKeyspace.java
Patch:
@@ -1340,7 +1340,7 @@ private static MaterializedViewDefinition createMaterializedViewFromMaterialized
         String name = row.getString("view_name");
         List<String> partitionColumnNames = row.getList("target_columns", UTF8Type.instance);
 
-        String cfName = row.getString("table_name");
+        String cfName = row.getString("columnfamily_name");
         List<String> clusteringColumnNames = row.getList("clustering_columns", UTF8Type.instance);
 
         List<ColumnIdentifier> partitionColumns = new ArrayList<>();

File: src/java/org/apache/cassandra/schema/SchemaKeyspace.java
Patch:
@@ -1340,7 +1340,7 @@ private static MaterializedViewDefinition createMaterializedViewFromMaterialized
         String name = row.getString("view_name");
         List<String> partitionColumnNames = row.getList("target_columns", UTF8Type.instance);
 
-        String cfName = row.getString("columnfamily_name");
+        String cfName = row.getString("table_name");
         List<String> clusteringColumnNames = row.getList("clustering_columns", UTF8Type.instance);
 
         List<ColumnIdentifier> partitionColumns = new ArrayList<>();

File: test/unit/org/apache/cassandra/db/commitlog/CommitLogUpgradeTestMaker.java
Patch:
@@ -239,7 +239,7 @@ public void run()
                 {
                     int sz = randomSize ? tlr.nextInt(cellSize) : cellSize;
                     ByteBuffer bytes = randomBytes(sz, tlr);
-                    builder.newRow("name" + ii).add("val", bytes);
+                    builder.newRow(CommitLogUpgradeTest.CELLNAME + ii).add("val", bytes);
                     hash = hash(hash, bytes);
                     ++cells;
                     dataSize += sz;

File: src/java/org/apache/cassandra/io/util/NIODataInputStream.java
Patch:
@@ -23,6 +23,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
 import java.nio.channels.ReadableByteChannel;
 import java.nio.channels.SeekableByteChannel;
 
@@ -321,6 +322,8 @@ public long readUnsignedVInt() throws IOException
         int extraBits = extraBytes * 8;
 
         long retval = buf.getLong(position);
+        if (buf.order() == ByteOrder.LITTLE_ENDIAN)
+            retval = Long.reverseBytes(retval);
         buf.position(position + extraBytes);
 
         // truncate the bytes we read in excess of those we needed

File: src/java/org/apache/cassandra/db/compaction/AbstractCompactionStrategy.java
Patch:
@@ -60,7 +60,7 @@ public abstract class AbstractCompactionStrategy
     protected static final String UNCHECKED_TOMBSTONE_COMPACTION_OPTION = "unchecked_tombstone_compaction";
     protected static final String COMPACTION_ENABLED = "enabled";
 
-    public final Map<String, String> options;
+    protected Map<String, String> options;
 
     protected final ColumnFamilyStore cfs;
     protected float tombstoneThreshold;

File: src/java/org/apache/cassandra/db/compaction/LeveledCompactionStrategy.java
Patch:
@@ -87,8 +87,6 @@ public int[] getAllLevelSize()
      */
     public synchronized AbstractCompactionTask getNextBackgroundTask(int gcBefore)
     {
-        if (!isEnabled())
-            return null;
         Collection<AbstractCompactionTask> tasks = getMaximalTask(gcBefore);
         if (tasks == null || tasks.size() == 0)
             return null;

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -164,6 +164,7 @@ public class Config
     public Double commitlog_sync_batch_window_in_ms;
     public Integer commitlog_sync_period_in_ms;
     public int commitlog_segment_size_in_mb = 32;
+    public boolean commitlog_segment_recycling = false;
 
     @Deprecated
     public int commitlog_periodic_queue_size = -1;

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegmentManager.java
Patch:
@@ -354,7 +354,7 @@ void recycleSegment(final CommitLogSegment segment)
             discardSegment(segment, false);
             return;
         }
-        if (isCapExceeded())
+        if (isCapExceeded() || !DatabaseDescriptor.getCommitLogSegmentRecyclingEnabled())
         {
             discardSegment(segment, true);
             return;

File: src/java/org/apache/cassandra/utils/concurrent/Ref.java
Patch:
@@ -498,7 +498,7 @@ private void removeExpected(Set<Tidy> candidates)
                 for (ColumnFamilyStore cfs : ks.getColumnFamilyStores())
                 {
                     View view = cfs.getTracker().getView();
-                    for (SSTableReader reader : Iterables.concat(view.sstables, view.compacting))
+                    for (SSTableReader reader : view.allKnownSSTables())
                         reader.addTo(expected);
                 }
             }

File: src/java/org/apache/cassandra/utils/concurrent/SharedCloseable.java
Patch:
@@ -33,4 +33,5 @@ public interface SharedCloseable extends AutoCloseable
     public SharedCloseable sharedCopy();
     public Throwable close(Throwable accumulate);
 
+    public void addTo(Ref.IdentityCollection identities);
 }

File: test/unit/org/apache/cassandra/MockSchema.java
Patch:
@@ -43,6 +43,7 @@
 import org.apache.cassandra.io.util.ChannelProxy;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.io.util.Memory;
+import org.apache.cassandra.io.util.RandomAccessReader;
 import org.apache.cassandra.io.util.SegmentedFile;
 import org.apache.cassandra.schema.KeyspaceMetadata;
 import org.apache.cassandra.schema.KeyspaceParams;
@@ -61,7 +62,7 @@ public class MockSchema
     public static final Keyspace ks = Keyspace.mockKS(KeyspaceMetadata.create("mockks", KeyspaceParams.simpleTransient(1)));
 
     public static final IndexSummary indexSummary;
-    private static final SegmentedFile segmentedFile = new BufferedSegmentedFile(new ChannelProxy(temp("mocksegmentedfile")), 0);
+    private static final SegmentedFile segmentedFile = new BufferedSegmentedFile(new ChannelProxy(temp("mocksegmentedfile")), RandomAccessReader.DEFAULT_BUFFER_SIZE, 0);
 
     public static Memtable memtable(ColumnFamilyStore cfs)
     {

File: test/unit/org/apache/cassandra/db/lifecycle/TransactionLogsTest.java
Patch:
@@ -48,6 +48,7 @@
 import org.apache.cassandra.io.sstable.metadata.StatsMetadata;
 import org.apache.cassandra.io.util.BufferedSegmentedFile;
 import org.apache.cassandra.io.util.ChannelProxy;
+import org.apache.cassandra.io.util.RandomAccessReader;
 import org.apache.cassandra.io.util.SegmentedFile;
 import org.apache.cassandra.utils.AlwaysPresentFilter;
 import org.apache.cassandra.utils.concurrent.AbstractTransactionalTest;
@@ -517,8 +518,8 @@ public static SSTableReader sstable(ColumnFamilyStore cfs, int generation, int s
             }
         }
 
-        SegmentedFile dFile = new BufferedSegmentedFile(new ChannelProxy(new File(descriptor.filenameFor(Component.DATA))), 0);
-        SegmentedFile iFile = new BufferedSegmentedFile(new ChannelProxy(new File(descriptor.filenameFor(Component.PRIMARY_INDEX))), 0);
+        SegmentedFile dFile = new BufferedSegmentedFile(new ChannelProxy(new File(descriptor.filenameFor(Component.DATA))), RandomAccessReader.DEFAULT_BUFFER_SIZE, 0);
+        SegmentedFile iFile = new BufferedSegmentedFile(new ChannelProxy(new File(descriptor.filenameFor(Component.PRIMARY_INDEX))), RandomAccessReader.DEFAULT_BUFFER_SIZE, 0);
 
         SerializationHeader header = SerializationHeader.make(cfs.metadata, Collections.EMPTY_LIST);
         StatsMetadata metadata = (StatsMetadata) new MetadataCollector(cfs.metadata.comparator)

File: src/java/org/apache/cassandra/cql3/UpdateParameters.java
Patch:
@@ -120,13 +120,13 @@ public void newRow(Clustering clustering) throws InvalidRequestException
         if (clustering == Clustering.STATIC_CLUSTERING)
         {
             if (staticBuilder == null)
-                staticBuilder = ArrayBackedRow.unsortedBuilder(updatedColumns.statics, nowInSec);
+                staticBuilder = BTreeBackedRow.unsortedBuilder(updatedColumns.statics, nowInSec);
             builder = staticBuilder;
         }
         else
         {
             if (regularBuilder == null)
-                regularBuilder = ArrayBackedRow.unsortedBuilder(updatedColumns.regulars, nowInSec);
+                regularBuilder = BTreeBackedRow.unsortedBuilder(updatedColumns.regulars, nowInSec);
             builder = regularBuilder;
         }
 

File: src/java/org/apache/cassandra/db/HintedHandOffManager.java
Patch:
@@ -137,7 +137,7 @@ public Mutation hintFor(Mutation mutation, long now, int ttl, UUID targetId)
         ByteBuffer value = ByteBuffer.wrap(FBUtilities.serialize(mutation, Mutation.serializer, MessagingService.current_version));
         Cell cell = BufferCell.expiring(hintColumn, now, ttl, FBUtilities.nowInSeconds(), value);
 
-        return new Mutation(PartitionUpdate.singleRowUpdate(SystemKeyspace.Hints, key, ArrayBackedRow.singleCellRow(clustering, cell)));
+        return new Mutation(PartitionUpdate.singleRowUpdate(SystemKeyspace.Hints, key, BTreeBackedRow.singleCellRow(clustering, cell)));
     }
 
     /*
@@ -181,7 +181,7 @@ private static void deleteHint(ByteBuffer tokenBytes, Clustering clustering, lon
     {
         DecoratedKey dk =  StorageService.getPartitioner().decorateKey(tokenBytes);
         Cell cell = BufferCell.tombstone(hintColumn, timestamp, FBUtilities.nowInSeconds());
-        PartitionUpdate upd = PartitionUpdate.singleRowUpdate(SystemKeyspace.Hints, dk, ArrayBackedRow.singleCellRow(clustering, cell));
+        PartitionUpdate upd = PartitionUpdate.singleRowUpdate(SystemKeyspace.Hints, dk, BTreeBackedRow.singleCellRow(clustering, cell));
         new Mutation(upd).applyUnsafe(); // don't bother with commitlog since we're going to flush as soon as we're done with delivery
     }
 

File: src/java/org/apache/cassandra/db/LegacyLayout.java
Patch:
@@ -353,7 +353,7 @@ public static Row extractStaticColumns(CFMetaData metadata, DataInputPlus in, Co
         for (ColumnDefinition column : statics)
             columnsToFetch.add(column.name.bytes);
 
-        Row.Builder builder = ArrayBackedRow.unsortedBuilder(statics, FBUtilities.nowInSeconds());
+        Row.Builder builder = BTreeBackedRow.unsortedBuilder(statics, FBUtilities.nowInSeconds());
         builder.newRow(Clustering.STATIC_CLUSTERING);
 
         boolean foundOne = false;
@@ -822,7 +822,7 @@ private CellGrouper(CFMetaData metadata, SerializationHelper helper, boolean isS
             this.metadata = metadata;
             this.isStatic = isStatic;
             this.helper = helper;
-            this.builder = ArrayBackedRow.sortedBuilder(isStatic ? metadata.partitionColumns().statics : metadata.partitionColumns().regulars);
+            this.builder = BTreeBackedRow.sortedBuilder(isStatic ? metadata.partitionColumns().statics : metadata.partitionColumns().regulars);
         }
 
         public static CellGrouper staticGrouper(CFMetaData metadata, SerializationHelper helper)

File: src/java/org/apache/cassandra/db/RowUpdateBuilder.java
Patch:
@@ -80,7 +80,7 @@ private void startRow(Clustering clustering)
         assert staticBuilder == null : "Cannot update both static and non-static columns with the same RowUpdateBuilder object";
         assert regularBuilder == null : "Cannot add the clustering twice to the same row";
 
-        regularBuilder = ArrayBackedRow.unsortedBuilder(update.columns().regulars, FBUtilities.nowInSeconds());
+        regularBuilder = BTreeBackedRow.unsortedBuilder(update.columns().regulars, FBUtilities.nowInSeconds());
         regularBuilder.newRow(clustering);
 
         // If a CQL table, add the "row marker"
@@ -105,7 +105,7 @@ private Row.Builder staticBuilder()
         assert regularBuilder == null : "Cannot update both static and non-static columns with the same RowUpdateBuilder object";
         if (staticBuilder == null)
         {
-            staticBuilder = ArrayBackedRow.unsortedBuilder(update.columns().statics, FBUtilities.nowInSeconds());
+            staticBuilder = BTreeBackedRow.unsortedBuilder(update.columns().statics, FBUtilities.nowInSeconds());
             staticBuilder.newRow(Clustering.STATIC_CLUSTERING);
         }
         return staticBuilder;
@@ -186,7 +186,7 @@ private static void deleteRow(PartitionUpdate update, long timestamp, int localD
         assert clusteringValues.length == update.metadata().comparator.size() || (clusteringValues.length == 0 && !update.columns().statics.isEmpty());
 
         boolean isStatic = clusteringValues.length != update.metadata().comparator.size();
-        Row.Builder builder = ArrayBackedRow.sortedBuilder(isStatic ? update.columns().statics : update.columns().regulars);
+        Row.Builder builder = BTreeBackedRow.sortedBuilder(isStatic ? update.columns().statics : update.columns().regulars);
 
         if (isStatic)
             builder.newRow(Clustering.STATIC_CLUSTERING);

File: src/java/org/apache/cassandra/db/UnfilteredDeserializer.java
Patch:
@@ -121,7 +121,7 @@ private CurrentDeserializer(CFMetaData metadata,
             super(metadata, in, helper);
             this.header = header;
             this.clusteringDeserializer = new ClusteringPrefix.Deserializer(metadata.comparator, in, header);
-            this.builder = ArrayBackedRow.sortedBuilder(helper.fetchedRegularColumns(header));
+            this.builder = BTreeBackedRow.sortedBuilder(helper.fetchedRegularColumns(header));
         }
 
         public boolean hasNext() throws IOException

File: src/java/org/apache/cassandra/db/index/AbstractSimplePerColumnSecondaryIndex.java
Patch:
@@ -115,7 +115,7 @@ public void delete(ByteBuffer rowKey, Clustering clustering, ByteBuffer cellValu
     {
         DecoratedKey valueKey = getIndexKeyFor(getIndexedValue(rowKey, clustering, cellValue, path));
 
-        Row row = ArrayBackedRow.emptyDeletedRow(makeIndexClustering(rowKey, clustering, path), deletion);
+        Row row = BTreeBackedRow.emptyDeletedRow(makeIndexClustering(rowKey, clustering, path), deletion);
         PartitionUpdate upd = PartitionUpdate.singleRowUpdate(indexCfs.metadata, valueKey, row);
 
         indexCfs.apply(upd, SecondaryIndexManager.nullUpdater, opGroup, null);
@@ -132,7 +132,7 @@ public void insert(ByteBuffer rowKey, Clustering clustering, Cell cell, Liveness
     {
         DecoratedKey valueKey = getIndexKeyFor(getIndexedValue(rowKey, clustering, cell));
 
-        Row row = ArrayBackedRow.noCellLiveRow(makeIndexClustering(rowKey, clustering, cell), info);
+        Row row = BTreeBackedRow.noCellLiveRow(makeIndexClustering(rowKey, clustering, cell), info);
         PartitionUpdate upd = PartitionUpdate.singleRowUpdate(indexCfs.metadata, valueKey, row);
 
         if (logger.isDebugEnabled())

File: src/java/org/apache/cassandra/db/index/composites/CompositesIndex.java
Patch:
@@ -112,7 +112,7 @@ protected static void addGenericClusteringColumns(CFMetaData.Builder indexMetada
 
     public void delete(IndexedEntry entry, OpOrder.Group opGroup, int nowInSec)
     {
-        Row row = ArrayBackedRow.emptyDeletedRow(entry.indexClustering, new DeletionTime(entry.timestamp, nowInSec));
+        Row row = BTreeBackedRow.emptyDeletedRow(entry.indexClustering, new DeletionTime(entry.timestamp, nowInSec));
         PartitionUpdate upd = PartitionUpdate.singleRowUpdate(indexCfs.metadata, entry.indexValue, row);
         indexCfs.apply(upd, SecondaryIndexManager.nullUpdater, opGroup, null);
 

File: src/java/org/apache/cassandra/db/partitions/AbstractThreadUnsafePartition.java
Patch:
@@ -167,7 +167,7 @@ public Row next(Clustering clustering)
                     activeDeletion = rt.deletionTime();
 
                 if (row == null)
-                    return activeDeletion.isLive() ? null : ArrayBackedRow.emptyDeletedRow(clustering, activeDeletion);
+                    return activeDeletion.isLive() ? null : BTreeBackedRow.emptyDeletedRow(clustering, activeDeletion);
 
                 return row.filter(columns, activeDeletion, true, metadata);
             }

File: src/java/org/apache/cassandra/db/partitions/PartitionUpdate.java
Patch:
@@ -822,8 +822,8 @@ public void setValue(ByteBuffer value)
         {
             // This is a bit of a giant hack as this is the only place where we mutate a Row object. This makes it more efficient
             // for counters however and this won't be needed post-#6506 so that's probably fine.
-            assert row instanceof ArrayBackedRow;
-            ((ArrayBackedRow)row).setValue(column, path, value);
+            assert row instanceof BTreeBackedRow;
+            ((BTreeBackedRow)row).setValue(column, path, value);
         }
     }
 }

File: src/java/org/apache/cassandra/db/rows/Rows.java
Patch:
@@ -49,7 +49,7 @@ public ColumnData next(ColumnDefinition column)
 
     private Rows() {}
 
-    public static final Row EMPTY_STATIC_ROW = ArrayBackedRow.emptyRow(Clustering.STATIC_CLUSTERING);
+    public static final Row EMPTY_STATIC_ROW = BTreeBackedRow.emptyRow(Clustering.STATIC_CLUSTERING);
 
     public static Row.Builder copy(Row row, Row.Builder builder)
     {
@@ -217,7 +217,7 @@ else if (cmp < 0)
     public static Row merge(Row row1, Row row2, int nowInSec)
     {
         Columns mergedColumns = row1.columns().mergeTo(row2.columns());
-        Row.Builder builder = ArrayBackedRow.sortedBuilder(mergedColumns);
+        Row.Builder builder = BTreeBackedRow.sortedBuilder(mergedColumns);
         merge(row1, row2, mergedColumns, builder, nowInSec, SecondaryIndexManager.nullUpdater);
         return builder.build();
     }

File: src/java/org/apache/cassandra/db/rows/UnfilteredRowIteratorSerializer.java
Patch:
@@ -204,7 +204,7 @@ public UnfilteredRowIterator deserialize(DataInputPlus in, int version, CFMetaDa
         final SerializationHeader sHeader = header.sHeader;
         return new AbstractUnfilteredRowIterator(metadata, header.key, header.partitionDeletion, sHeader.columns(), header.staticRow, header.isReversed, sHeader.stats())
         {
-            private final Row.Builder builder = ArrayBackedRow.sortedBuilder(sHeader.columns().regulars);
+            private final Row.Builder builder = BTreeBackedRow.sortedBuilder(sHeader.columns().regulars);
 
             protected Unfiltered computeNext()
             {

File: src/java/org/apache/cassandra/db/rows/UnfilteredRowIterators.java
Patch:
@@ -541,7 +541,7 @@ protected Unfiltered getReduced()
                 {
                     Row merged = rowMerger.merge(markerMerger.activeDeletion());
                     if (listener != null)
-                        listener.onMergedRows(merged == null ? ArrayBackedRow.emptyRow(rowMerger.mergedClustering()) : merged, columns().regulars, rowMerger.mergedRows());
+                        listener.onMergedRows(merged == null ? BTreeBackedRow.emptyRow(rowMerger.mergedClustering()) : merged, columns().regulars, rowMerger.mergedRows());
                     return merged;
                 }
                 else

File: src/java/org/apache/cassandra/db/rows/UnfilteredSerializer.java
Patch:
@@ -341,7 +341,7 @@ public Row deserializeStaticRow(DataInputPlus in, SerializationHeader header, Se
     {
         int flags = in.readUnsignedByte();
         assert !isEndOfPartition(flags) && kind(flags) == Unfiltered.Kind.ROW && isStatic(flags) : flags;
-        Row.Builder builder = ArrayBackedRow.sortedBuilder(helper.fetchedStaticColumns(header));
+        Row.Builder builder = BTreeBackedRow.sortedBuilder(helper.fetchedStaticColumns(header));
         builder.newRow(Clustering.STATIC_CLUSTERING);
         return deserializeRowBody(in, header, helper, flags, builder);
     }

File: src/java/org/apache/cassandra/io/sstable/SSTableSimpleIterator.java
Patch:
@@ -71,7 +71,7 @@ private CurrentFormatIterator(CFMetaData metadata, DataInputPlus in, Serializati
         {
             super(metadata, in, helper);
             this.header = header;
-            this.builder = ArrayBackedRow.sortedBuilder(helper.fetchedRegularColumns(header));
+            this.builder = BTreeBackedRow.sortedBuilder(helper.fetchedRegularColumns(header));
         }
 
         public Row readStaticRow() throws IOException

File: src/java/org/apache/cassandra/service/DataResolver.java
Patch:
@@ -214,7 +214,7 @@ private Row.Builder currentRow(int i, Clustering clustering)
             {
                 if (currentRows[i] == null)
                 {
-                    currentRows[i] = ArrayBackedRow.sortedBuilder(clustering == Clustering.STATIC_CLUSTERING ? columns.statics : columns.regulars);
+                    currentRows[i] = BTreeBackedRow.sortedBuilder(clustering == Clustering.STATIC_CLUSTERING ? columns.statics : columns.regulars);
                     currentRows[i].newRow(clustering);
                 }
                 return currentRows[i];

File: src/java/org/apache/cassandra/thrift/ThriftResultsMerger.java
Patch:
@@ -112,7 +112,7 @@ private PartitionMerger(UnfilteredRowIterator results, int nowInSec)
             super(results);
             assert results.metadata().isStaticCompactTable();
             this.nowInSec = nowInSec;
-            this.builder = ArrayBackedRow.sortedBuilder(results.columns().regulars);
+            this.builder = BTreeBackedRow.sortedBuilder(results.columns().regulars);
         }
 
         private void init()
@@ -220,7 +220,7 @@ private SuperColumnsPartitionMerger(UnfilteredRowIterator results, int nowInSec)
             this.superColumnMapColumn = results.metadata().compactValueColumn();
             assert superColumnMapColumn != null && superColumnMapColumn.type instanceof MapType;
 
-            this.builder = ArrayBackedRow.sortedBuilder(Columns.of(superColumnMapColumn));
+            this.builder = BTreeBackedRow.sortedBuilder(Columns.of(superColumnMapColumn));
             this.columnComparator = ((MapType)superColumnMapColumn.type).nameComparator();
         }
 

File: src/java/org/apache/cassandra/utils/btree/NodeBuilder.java
Patch:
@@ -263,7 +263,8 @@ NodeBuilder ascendToRoot()
     // builds a new root BTree node - must be called on root of operation
     Object[] toNode()
     {
-        assert buildKeyPosition <= FAN_FACTOR && (buildKeyPosition > 0 || getKeyEnd(copyFrom) > 0) : buildKeyPosition;
+        // we permit building empty trees as some constructions do not know in advance how many items they will contain
+        assert buildKeyPosition <= FAN_FACTOR : buildKeyPosition;
         return buildFromRange(0, buildKeyPosition, isLeaf(copyFrom), false);
     }
 

File: src/java/org/apache/cassandra/utils/btree/TreeCursor.java
Patch:
@@ -124,8 +124,8 @@ int seekTo(K key, boolean forwards, boolean skipOne)
 
             int cmp;
             if (key == test) cmp = 0; // check object identity first, since we utilise that in some places and it's very cheap
-            else cmp = comparator.compare(key, test);
-            if (forwards ? cmp <= 0 : cmp >= 0)
+            else cmp = comparator.compare(test, key); // order of provision matters for asymmetric comparators
+            if (forwards ? cmp >= 0 : cmp <= 0)
             {
                 // we've either matched, or excluded the value from being present
                 int index = cur.globalIndex();

File: src/java/org/apache/cassandra/utils/memory/AbstractAllocator.java
Patch:
@@ -21,7 +21,7 @@
 
 import org.apache.cassandra.db.Clustering;
 import org.apache.cassandra.db.Columns;
-import org.apache.cassandra.db.rows.ArrayBackedRow;
+import org.apache.cassandra.db.rows.BTreeBackedRow;
 import org.apache.cassandra.db.rows.Cell;
 import org.apache.cassandra.db.rows.Row;
 import org.apache.cassandra.utils.ByteBufferUtil;
@@ -51,13 +51,13 @@ public Row.Builder cloningArrayBackedRowBuilder(Columns columns)
         return new CloningArrayBackedRowBuilder(columns, this);
     }
 
-    private static class CloningArrayBackedRowBuilder extends ArrayBackedRow.SortedBuilder
+    private static class CloningArrayBackedRowBuilder extends BTreeBackedRow.Builder
     {
         private final AbstractAllocator allocator;
 
         private CloningArrayBackedRowBuilder(Columns columns, AbstractAllocator allocator)
         {
-            super(columns);
+            super(columns, true);
             this.allocator = allocator;
         }
 

File: test/unit/org/apache/cassandra/db/RowTest.java
Patch:
@@ -127,7 +127,7 @@ public void testResolve()
         ColumnDefinition defA = cfm.getColumnDefinition(new ColumnIdentifier("a", true));
         ColumnDefinition defB = cfm.getColumnDefinition(new ColumnIdentifier("b", true));
 
-        Row.Builder builder = ArrayBackedRow.unsortedBuilder(cfm.partitionColumns().regulars, nowInSeconds);
+        Row.Builder builder = BTreeBackedRow.unsortedBuilder(cfm.partitionColumns().regulars, nowInSeconds);
         builder.newRow(cfm.comparator.make("c1"));
         writeSimpleCellValue(builder, cfm, defA, "a1", 0);
         writeSimpleCellValue(builder, cfm, defA, "a2", 1);
@@ -152,7 +152,7 @@ public void testExpiringColumnExpiration() throws IOException
 
         Cell cell = BufferCell.expiring(def, 0, ttl, nowInSeconds, ((AbstractType) def.cellValueType()).decompose("a1"));
 
-        PartitionUpdate update = PartitionUpdate.singleRowUpdate(cfm, dk, ArrayBackedRow.singleCellRow(cfm.comparator.make("c1"), cell));
+        PartitionUpdate update = PartitionUpdate.singleRowUpdate(cfm, dk, BTreeBackedRow.singleCellRow(cfm.comparator.make("c1"), cell));
         new Mutation(update).applyUnsafe();
 
         // when we read with a nowInSeconds before the cell has expired,

File: test/unit/org/apache/cassandra/db/rows/RowAndDeletionMergeIteratorTest.java
Patch:
@@ -364,7 +364,7 @@ private UnfilteredRowIterator createMergeIterator(Iterator<Row> rows, Iterator<R
 
     private void addRow(PartitionUpdate update, int col1, int a)
     {
-        update.add(ArrayBackedRow.singleCellRow(update.metadata().comparator.make(col1), makeCell(cfm, defA, a, 0)));
+        update.add(BTreeBackedRow.singleCellRow(update.metadata().comparator.make(col1), makeCell(cfm, defA, a, 0)));
     }
 
     private Cell makeCell(CFMetaData cfm, ColumnDefinition columnDefinition, int value, long timestamp)

File: test/unit/org/apache/cassandra/db/rows/UnfilteredRowIteratorsMergeTest.java
Patch:
@@ -371,7 +371,7 @@ static Row emptyRowAt(int pos, Function<Integer, Integer> timeGenerator)
     {
         final Clustering clustering = clusteringFor(pos);
         final LivenessInfo live = LivenessInfo.create(metadata, timeGenerator.apply(pos), nowInSec);
-        return ArrayBackedRow.noCellLiveRow(clustering, live);
+        return BTreeBackedRow.noCellLiveRow(clustering, live);
     }
 
     private void dumpList(List<Unfiltered> list)

File: test/unit/org/apache/cassandra/triggers/TriggerExecutorTest.java
Patch:
@@ -268,7 +268,7 @@ private static CFMetaData makeCfMetaData(String ks, String cf, TriggerMetadata t
 
     private static PartitionUpdate makeCf(CFMetaData metadata, String key, String columnValue1, String columnValue2)
     {
-        Row.Builder builder = ArrayBackedRow.unsortedBuilder(metadata.partitionColumns().regulars, FBUtilities.nowInSeconds());
+        Row.Builder builder = BTreeBackedRow.unsortedBuilder(metadata.partitionColumns().regulars, FBUtilities.nowInSeconds());
         builder.newRow(Clustering.EMPTY);
         long ts = FBUtilities.timestampMicros();
         if (columnValue1 != null)

File: src/java/org/apache/cassandra/db/BatchlogManager.java
Patch:
@@ -39,6 +39,7 @@
 import org.apache.cassandra.cql3.UntypedResultSet;
 import org.apache.cassandra.db.partitions.PartitionUpdate;
 import org.apache.cassandra.db.compaction.CompactionManager;
+import org.apache.cassandra.db.lifecycle.SSTableSet;
 import org.apache.cassandra.db.marshal.UUIDType;
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.exceptions.WriteFailureException;
@@ -455,7 +456,8 @@ private void cleanup() throws ExecutionException, InterruptedException
         ColumnFamilyStore cfs = Keyspace.open(SystemKeyspace.NAME).getColumnFamilyStore(SystemKeyspace.BATCHLOG);
         cfs.forceBlockingFlush();
         Collection<Descriptor> descriptors = new ArrayList<>();
-        for (SSTableReader sstr : cfs.getSSTables())
+        // expects ALL sstables to be available for compaction, so just use live set...
+        for (SSTableReader sstr : cfs.getSSTables(SSTableSet.LIVE))
             descriptors.add(sstr.descriptor);
         if (!descriptors.isEmpty()) // don't pollute the logs if there is nothing to compact.
             CompactionManager.instance.submitUserDefined(cfs, descriptors, Integer.MAX_VALUE).get();

File: src/java/org/apache/cassandra/db/Keyspace.java
Patch:
@@ -38,6 +38,7 @@
 import org.apache.cassandra.db.index.SecondaryIndex;
 import org.apache.cassandra.db.index.SecondaryIndexManager;
 import org.apache.cassandra.db.partitions.PartitionUpdate;
+import org.apache.cassandra.db.lifecycle.SSTableSet;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.locator.AbstractReplicationStrategy;
 import org.apache.cassandra.schema.KeyspaceMetadata;
@@ -272,11 +273,11 @@ public static void clearSnapshot(String snapshotName, String keyspace)
     /**
      * @return A list of open SSTableReaders
      */
-    public List<SSTableReader> getAllSSTables()
+    public List<SSTableReader> getAllSSTables(SSTableSet sstableSet)
     {
         List<SSTableReader> list = new ArrayList<>(columnFamilyStores.size());
         for (ColumnFamilyStore cfStore : columnFamilyStores.values())
-            list.addAll(cfStore.getSSTables());
+            Iterables.addAll(list, cfStore.getSSTables(sstableSet));
         return list;
     }
 

File: src/java/org/apache/cassandra/db/PartitionRangeReadCommand.java
Patch:
@@ -25,6 +25,8 @@
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.db.lifecycle.SSTableSet;
+import org.apache.cassandra.db.lifecycle.View;
 import org.apache.cassandra.db.rows.*;
 import org.apache.cassandra.db.filter.*;
 import org.apache.cassandra.db.partitions.*;
@@ -157,7 +159,7 @@ protected void recordLatency(TableMetrics metric, long latencyNanos)
 
     protected UnfilteredPartitionIterator queryStorage(final ColumnFamilyStore cfs, ReadOrderGroup orderGroup)
     {
-        ColumnFamilyStore.ViewFragment view = cfs.select(cfs.viewFilter(dataRange().keyRange()));
+        ColumnFamilyStore.ViewFragment view = cfs.select(View.select(SSTableSet.LIVE, dataRange().keyRange()));
         Tracing.trace("Executing seq scan across {} sstables for {}", view.sstables.size(), dataRange().keyRange().getString(metadata().getKeyValidator()));
 
         // fetch data from current memtable, historical memtables, and SSTables in the correct order.

File: src/java/org/apache/cassandra/db/SinglePartitionNamesCommand.java
Patch:
@@ -25,6 +25,8 @@
 import org.apache.cassandra.concurrent.StageManager;
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.ColumnDefinition;
+import org.apache.cassandra.db.lifecycle.SSTableSet;
+import org.apache.cassandra.db.lifecycle.View;
 import org.apache.cassandra.db.rows.*;
 import org.apache.cassandra.db.partitions.*;
 import org.apache.cassandra.db.filter.*;
@@ -73,7 +75,7 @@ public SinglePartitionNamesCommand copy()
     protected UnfilteredRowIterator queryMemtableAndDiskInternal(ColumnFamilyStore cfs, boolean copyOnHeap)
     {
         Tracing.trace("Acquiring sstable references");
-        ColumnFamilyStore.ViewFragment view = cfs.select(cfs.viewFilter(partitionKey()));
+        ColumnFamilyStore.ViewFragment view = cfs.select(View.select(SSTableSet.LIVE, partitionKey()));
 
         ArrayBackedPartition result = null;
         ClusteringIndexNamesFilter filter = clusteringIndexFilter();

File: src/java/org/apache/cassandra/db/SinglePartitionSliceCommand.java
Patch:
@@ -23,6 +23,8 @@
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.db.filter.ClusteringIndexSliceFilter;
+import org.apache.cassandra.db.lifecycle.SSTableSet;
+import org.apache.cassandra.db.lifecycle.View;
 import org.apache.cassandra.db.rows.*;
 import org.apache.cassandra.db.filter.*;
 import org.apache.cassandra.db.partitions.Partition;
@@ -103,7 +105,7 @@ public SinglePartitionSliceCommand copy()
     protected UnfilteredRowIterator queryMemtableAndDiskInternal(ColumnFamilyStore cfs, boolean copyOnHeap)
     {
         Tracing.trace("Acquiring sstable references");
-        ColumnFamilyStore.ViewFragment view = cfs.select(cfs.viewFilter(partitionKey()));
+        ColumnFamilyStore.ViewFragment view = cfs.select(View.select(SSTableSet.LIVE, partitionKey()));
 
         List<UnfilteredRowIterator> iterators = new ArrayList<>(Iterables.size(view.memtables) + view.sstables.size());
         ClusteringIndexSliceFilter filter = clusteringIndexFilter();

File: src/java/org/apache/cassandra/db/SizeEstimatesRecorder.java
Patch:
@@ -23,6 +23,8 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import org.apache.cassandra.db.lifecycle.SSTableSet;
+import org.apache.cassandra.db.lifecycle.View;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
@@ -97,7 +99,7 @@ private void recordSizeEstimates(ColumnFamilyStore table, Collection<Range<Token
             {
                 while (refs == null)
                 {
-                    ColumnFamilyStore.ViewFragment view = table.select(table.viewFilter(Range.makeRowRange(range)));
+                    ColumnFamilyStore.ViewFragment view = table.select(View.select(SSTableSet.CANONICAL, Range.makeRowRange(range)));
                     refs = Refs.tryRef(view.sstables);
                 }
 

File: src/java/org/apache/cassandra/db/SystemKeyspace.java
Patch:
@@ -808,7 +808,7 @@ public static void checkHealth() throws ConfigurationException
         if (result.isEmpty() || !result.one().has("cluster_name"))
         {
             // this is a brand new node
-            if (!cfs.getSSTables().isEmpty())
+            if (!cfs.getLiveSSTables().isEmpty())
                 throw new ConfigurationException("Found system keyspace files, but they couldn't be loaded!");
 
             // no system files.  this is a new node.

File: src/java/org/apache/cassandra/db/commitlog/CommitLogReplayer.java
Patch:
@@ -45,6 +45,7 @@
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.rows.SerializationHelper;
 import org.apache.cassandra.db.partitions.PartitionUpdate;
+import org.apache.cassandra.db.lifecycle.SSTableSet;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.io.compress.CompressionParameters;
 import org.apache.cassandra.io.compress.ICompressor;
@@ -105,7 +106,7 @@ public static CommitLogReplayer create()
             // it's important to call RP.gRP per-cf, before aggregating all the positions w/ the Ordering.min call
             // below: gRP will return NONE if there are no flushed sstables, which is important to have in the
             // list (otherwise we'll just start replay from the first flush position that we do have, which is not correct).
-            ReplayPosition rp = ReplayPosition.getReplayPosition(cfs.getSSTables());
+            ReplayPosition rp = ReplayPosition.getReplayPosition(cfs.getSSTables(SSTableSet.CANONICAL));
 
             // but, if we've truncated the cf in question, then we need to need to start replay after the truncation
             ReplayPosition truncatedAt = SystemKeyspace.getTruncatedPosition(cfs.metadata.cfId);

File: src/java/org/apache/cassandra/db/compaction/CompactionController.java
Patch:
@@ -19,6 +19,8 @@
 
 import java.util.*;
 
+import org.apache.cassandra.db.lifecycle.SSTableSet;
+import org.apache.cassandra.db.lifecycle.View;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -83,7 +85,7 @@ private void refreshOverlaps()
         if (compacting == null)
             overlappingSSTables = Refs.tryRef(Collections.<SSTableReader>emptyList());
         else
-            overlappingSSTables = cfs.getAndReferenceOverlappingSSTables(compacting);
+            overlappingSSTables = cfs.getAndReferenceOverlappingSSTables(SSTableSet.LIVE, compacting);
         this.overlapIterator = new OverlapIterator<>(buildIntervals(overlappingSSTables));
     }
 

File: src/java/org/apache/cassandra/db/compaction/CompactionStrategyManager.java
Patch:
@@ -33,6 +33,8 @@
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.Memtable;
 import org.apache.cassandra.db.lifecycle.LifecycleTransaction;
+import org.apache.cassandra.db.lifecycle.SSTableSet;
+import org.apache.cassandra.db.lifecycle.View;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
@@ -138,7 +140,7 @@ public synchronized void pause()
 
     private void startup()
     {
-        for (SSTableReader sstable : cfs.getSSTables())
+        for (SSTableReader sstable : cfs.getSSTables(SSTableSet.CANONICAL))
         {
             if (sstable.openReason != SSTableReader.OpenReason.EARLY)
                 getCompactionStrategyFor(sstable).addSSTable(sstable);

File: src/java/org/apache/cassandra/db/compaction/SizeTieredCompactionStrategy.java
Patch:
@@ -36,6 +36,8 @@
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.utils.Pair;
 
+import static com.google.common.collect.Iterables.filter;
+
 public class SizeTieredCompactionStrategy extends AbstractCompactionStrategy
 {
     private static final Logger logger = LoggerFactory.getLogger(SizeTieredCompactionStrategy.class);
@@ -82,7 +84,7 @@ private List<SSTableReader> getNextBackgroundSSTables(final int gcBefore)
         int minThreshold = cfs.getMinimumCompactionThreshold();
         int maxThreshold = cfs.getMaximumCompactionThreshold();
 
-        Iterable<SSTableReader> candidates = filterSuspectSSTables(Sets.intersection(cfs.getUncompactingSSTables(), sstables));
+        Iterable<SSTableReader> candidates = filterSuspectSSTables(filter(cfs.getUncompactingSSTables(), sstables::contains));
 
         List<List<SSTableReader>> buckets = getBuckets(createSSTableAndLengthPairs(candidates), sizeTieredOptions.bucketHigh, sizeTieredOptions.bucketLow, sizeTieredOptions.minSSTableSize);
         logger.debug("Compaction buckets are {}", buckets);

File: src/java/org/apache/cassandra/db/lifecycle/LifecycleTransaction.java
Patch:
@@ -414,7 +414,7 @@ public Iterable<SSTableReader> current()
     private List<SSTableReader> restoreUpdatedOriginals()
     {
         Iterable<SSTableReader> torestore = filterIn(originals, logged.update, logged.obsolete);
-        return ImmutableList.copyOf(transform(torestore, (reader) -> current(reader).cloneWithNewStart(reader.first, null)));
+        return ImmutableList.copyOf(transform(torestore, (reader) -> current(reader).cloneWithRestoredStart(reader.first)));
     }
 
     /**

File: src/java/org/apache/cassandra/io/sstable/IndexSummaryManager.java
Patch:
@@ -28,6 +28,7 @@
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.*;
 
+import org.apache.cassandra.db.lifecycle.SSTableSet;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -192,7 +193,7 @@ private List<SSTableReader> getAllSSTables()
         for (Keyspace ks : Keyspace.all())
         {
             for (ColumnFamilyStore cfStore: ks.getColumnFamilyStores())
-                result.addAll(cfStore.getSSTables());
+                result.addAll(cfStore.getLiveSSTables());
         }
 
         return result;
@@ -216,7 +217,7 @@ private Pair<List<SSTableReader>, Map<UUID, LifecycleTransaction>> getCompacting
                 do
                 {
                     View view = cfStore.getTracker().getView();
-                    allSSTables = view.sstables;
+                    allSSTables = ImmutableSet.copyOf(view.sstables(SSTableSet.CANONICAL));
                     nonCompacting = ImmutableSet.copyOf(view.getUncompacting(allSSTables));
                 }
                 while (null == (txn = cfStore.getTracker().tryModify(nonCompacting, OperationType.UNKNOWN)));

File: test/long/org/apache/cassandra/db/compaction/LongCompactionsTest.java
Patch:
@@ -195,7 +195,7 @@ private void forceCompactions(ColumnFamilyStore cfs)
             FBUtilities.waitOnFutures(compactions);
         } while (CompactionManager.instance.getPendingTasks() > 0 || CompactionManager.instance.getActiveCompactions() > 0);
 
-        if (cfs.getSSTables().size() > 1)
+        if (cfs.getLiveSSTables().size() > 1)
         {
             CompactionManager.instance.performMaximal(cfs, false);
         }

File: test/unit/org/apache/cassandra/Util.java
Patch:
@@ -214,7 +214,7 @@ public static void createInitialRing(StorageService ss, IPartitioner partitioner
     public static Future<?> compactAll(ColumnFamilyStore cfs, int gcBefore)
     {
         List<Descriptor> descriptors = new ArrayList<>();
-        for (SSTableReader sstable : cfs.getSSTables())
+        for (SSTableReader sstable : cfs.getLiveSSTables())
             descriptors.add(sstable.descriptor);
         return CompactionManager.instance.submitUserDefined(cfs, descriptors, gcBefore);
     }

File: test/unit/org/apache/cassandra/cache/AutoSavingCacheTest.java
Patch:
@@ -63,10 +63,10 @@ public void testSerializeAndLoadKeyCache() throws Exception
             cfs.forceBlockingFlush();
         }
 
-        Assert.assertEquals(2, cfs.getSSTables().size());
+        Assert.assertEquals(2, cfs.getLiveSSTables().size());
 
         // preheat key cache
-        for (SSTableReader sstable : cfs.getSSTables())
+        for (SSTableReader sstable : cfs.getLiveSSTables())
             sstable.getPosition(Util.dk("key1"), SSTableReader.Operator.EQ);
 
         AutoSavingCache<KeyCacheKey, RowIndexEntry> keyCache = CacheService.instance.keyCache;
@@ -80,7 +80,7 @@ public void testSerializeAndLoadKeyCache() throws Exception
         // then load saved
         keyCache.loadSaved(cfs);
         Assert.assertEquals(2, keyCache.size());
-        for (SSTableReader sstable : cfs.getSSTables())
+        for (SSTableReader sstable : cfs.getLiveSSTables())
             Assert.assertNotNull(keyCache.get(new KeyCacheKey(cfs.metadata.cfId, sstable.descriptor, ByteBufferUtil.bytes("key1"))));
     }
 }

File: test/unit/org/apache/cassandra/db/CleanupTest.java
Patch:
@@ -140,7 +140,7 @@ public void testCleanupWithIndexes() throws IOException, ExecutionException, Int
         assertEquals(0, Util.getAll(Util.cmd(cfs).build()).size());
 
         // not only should it be gone but there should be no data on disk, not even tombstones
-        assert cfs.getSSTables().isEmpty();
+        assert cfs.getLiveSSTables().isEmpty();
 
         // 2ary indexes should result in no results, too (although tombstones won't be gone until compacted)
         assertEquals(0, Util.getAll(Util.cmd(cfs).filterOn("birthdate", Operator.EQ, VALUE).build()).size());
@@ -191,7 +191,7 @@ protected void fillCF(ColumnFamilyStore cfs, String colName, int rowsPerSSTable)
     protected List<Long> getMaxTimestampList(ColumnFamilyStore cfs)
     {
         List<Long> list = new LinkedList<Long>();
-        for (SSTableReader sstable : cfs.getSSTables())
+        for (SSTableReader sstable : cfs.getLiveSSTables())
             list.add(sstable.getMaxTimestamp());
         return list;
     }

File: test/unit/org/apache/cassandra/db/ColumnFamilyMetricTest.java
Patch:
@@ -62,7 +62,7 @@ public void testSizeMetric()
                     .applyUnsafe();
         }
         cfs.forceBlockingFlush();
-        Collection<SSTableReader> sstables = cfs.getSSTables();
+        Collection<SSTableReader> sstables = cfs.getLiveSSTables();
         long size = 0;
         for (SSTableReader reader : sstables)
         {

File: test/unit/org/apache/cassandra/db/HintedHandOffTest.java
Patch:
@@ -87,14 +87,14 @@ public void testCompactionOfHintsCF() throws Exception
 
         // flush data to disk
         hintStore.forceBlockingFlush();
-        assertEquals(1, hintStore.getSSTables().size());
+        assertEquals(1, hintStore.getLiveSSTables().size());
 
         // submit compaction
         HintedHandOffManager.instance.compact();
 
         // single row should not be removed because of gc_grace_seconds
         // is 10 hours and there are no any tombstones in sstable
-        assertEquals(1, hintStore.getSSTables().size());
+        assertEquals(1, hintStore.getLiveSSTables().size());
     }
 
     @Test

File: test/unit/org/apache/cassandra/db/KeyCacheTest.java
Patch:
@@ -147,7 +147,7 @@ public void testKeyCache() throws ExecutionException, InterruptedException
 
         assertKeyCacheSize(2, KEYSPACE1, COLUMN_FAMILY1);
 
-        Set<SSTableReader> readers = cfs.getTracker().getSSTables();
+        Set<SSTableReader> readers = cfs.getLiveSSTables();
         Refs<SSTableReader> refs = Refs.tryRef(readers);
         if (refs == null)
             throw new IllegalStateException();

File: test/unit/org/apache/cassandra/db/KeyspaceTest.java
Patch:
@@ -119,7 +119,7 @@ public void testGetSliceBloomFilterFalsePositive() throws Throwable
         for (String key : new String[]{"0", "2"})
             Util.assertEmpty(Util.cmd(cfs, key).build());
 
-        Collection<SSTableReader> sstables = cfs.getSSTables();
+        Collection<SSTableReader> sstables = cfs.getLiveSSTables();
         assertEquals(1, sstables.size());
         sstables.iterator().next().forceFilterFailures();
 
@@ -381,11 +381,11 @@ public void testGetSliceFromLarge() throws Throwable
         validateSliceLarge(cfs);
 
         // compact so we have a big row with more than the minimum index count
-        if (cfs.getSSTables().size() > 1)
+        if (cfs.getLiveSSTables().size() > 1)
             CompactionManager.instance.performMaximal(cfs, false);
 
         // verify that we do indeed have multiple index entries
-        SSTableReader sstable = cfs.getSSTables().iterator().next();
+        SSTableReader sstable = cfs.getLiveSSTables().iterator().next();
         RowIndexEntry indexEntry = sstable.getPosition(Util.dk("0"), SSTableReader.Operator.EQ);
         assert indexEntry.columnsIndex().size() > 2;
 

File: test/unit/org/apache/cassandra/db/SecondaryIndexTest.java
Patch:
@@ -431,7 +431,7 @@ public void testIndexCreate() throws IOException, InterruptedException, Executio
         future.get();
         // we had a bug (CASSANDRA-2244) where index would get created but not flushed -- check for that
         ColumnDefinition cDef = cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("birthdate"));
-        assert cfs.indexManager.getIndexForColumn(cDef).getIndexCfs().getSSTables().size() > 0;
+        assert cfs.indexManager.getIndexForColumn(cDef).getIndexCfs().getLiveSSTables().size() > 0;
 
         assertIndexedOne(cfs, ByteBufferUtil.bytes("birthdate"), 1L);
 

File: test/unit/org/apache/cassandra/db/compaction/BlacklistingCompactionsTest.java
Patch:
@@ -126,7 +126,7 @@ public void testBlacklisting(String compactionStrategy) throws Exception
             assertEquals(inserted.toString(), inserted.size(), Util.getAll(Util.cmd(cfs).build()).size());
         }
 
-        Collection<SSTableReader> sstables = cfs.getSSTables();
+        Collection<SSTableReader> sstables = cfs.getLiveSSTables();
         int currentSSTable = 0;
         int sstablesToCorrupt = 8;
 

File: test/unit/org/apache/cassandra/db/compaction/OneCompactionTest.java
Patch:
@@ -76,7 +76,7 @@ private void testCompaction(String columnFamilyName, int insertsPerTable)
             assertEquals(inserted.size(), Util.getAll(Util.cmd(store).build()).size());
         }
         CompactionManager.instance.performMaximal(store, false);
-        assertEquals(1, store.getSSTables().size());
+        assertEquals(1, store.getLiveSSTables().size());
     }
 
     @Test

File: test/unit/org/apache/cassandra/db/compaction/SizeTieredCompactionStrategyTest.java
Patch:
@@ -168,7 +168,7 @@ public void testPrepBucket() throws Exception
         }
         cfs.forceBlockingFlush();
 
-        List<SSTableReader> sstrs = new ArrayList<>(cfs.getSSTables());
+        List<SSTableReader> sstrs = new ArrayList<>(cfs.getLiveSSTables());
         Pair<List<SSTableReader>, Double> bucket;
 
         List<SSTableReader> interestingBucket = mostInterestingBucket(Collections.singletonList(sstrs.subList(0, 2)), 4, 32);

File: test/unit/org/apache/cassandra/db/lifecycle/RealTransactionsTest.java
Patch:
@@ -119,7 +119,7 @@ public void testFlush() throws IOException
 
         SSTableReader ssTableReader = getSSTable(cfs, 100);
 
-        String dataFolder = cfs.getSSTables().iterator().next().descriptor.directory.getPath();
+        String dataFolder = cfs.getLiveSSTables().iterator().next().descriptor.directory.getPath();
         String transactionLogsFolder = StringUtils.join(dataFolder, File.separator, Directories.TRANSACTIONS_SUBDIR);
 
         assertTrue(new File(transactionLogsFolder).exists());
@@ -132,7 +132,7 @@ private SSTableReader getSSTable(ColumnFamilyStore cfs, int numPartitions) throw
     {
         createSSTable(cfs, numPartitions);
 
-        Set<SSTableReader> sstables = new HashSet<>(cfs.getSSTables());
+        Set<SSTableReader> sstables = new HashSet<>(cfs.getLiveSSTables());
         assertEquals(1, sstables.size());
         return sstables.iterator().next();
     }

File: test/unit/org/apache/cassandra/io/sstable/LegacySSTableTest.java
Patch:
@@ -148,8 +148,8 @@ private void testStreaming(String version) throws Exception
                                              .execute().get();
 
         ColumnFamilyStore cfs = Keyspace.open(KSNAME).getColumnFamilyStore(CFNAME);
-        assert cfs.getSSTables().size() == 1;
-        sstable = cfs.getSSTables().iterator().next();
+        assert cfs.getLiveSSTables().size() == 1;
+        sstable = cfs.getLiveSSTables().iterator().next();
         for (String keystring : TEST_DATA)
         {
             ByteBuffer key = bytes(keystring);

File: test/unit/org/apache/cassandra/schema/DefsTest.java
Patch:
@@ -525,7 +525,7 @@ public void testDropIndex() throws ConfigurationException
 
         cfs.forceBlockingFlush();
         ColumnFamilyStore indexedCfs = cfs.indexManager.getIndexForColumn(cfs.metadata.getColumnDefinition(ByteBufferUtil.bytes("birthdate"))).getIndexCfs();
-        Descriptor desc = indexedCfs.getSSTables().iterator().next().descriptor;
+        Descriptor desc = indexedCfs.getLiveSSTables().iterator().next().descriptor;
 
         // drop the index
         CFMetaData meta = cfs.metadata.copy();

File: test/unit/org/apache/cassandra/streaming/StreamTransferTaskTest.java
Patch:
@@ -74,7 +74,7 @@ public void testScheduleTimeout() throws Exception
 
         // create streaming task that streams those two sstables
         StreamTransferTask task = new StreamTransferTask(session, cfs.metadata.cfId);
-        for (SSTableReader sstable : cfs.getSSTables())
+        for (SSTableReader sstable : cfs.getLiveSSTables())
         {
             List<Range<Token>> ranges = new ArrayList<>();
             ranges.add(new Range<>(sstable.first.getToken(), sstable.last.getToken()));

File: src/java/org/apache/cassandra/db/rows/UnfilteredSerializer.java
Patch:
@@ -21,8 +21,8 @@
 
 import org.apache.cassandra.config.ColumnDefinition;
 import org.apache.cassandra.db.*;
-import org.apache.cassandra.io.util.DataOutputPlus;
 import org.apache.cassandra.io.util.DataInputPlus;
+import org.apache.cassandra.io.util.DataOutputPlus;
 import org.apache.cassandra.utils.SearchIterator;
 
 /**

File: src/java/org/apache/cassandra/cache/OHCProvider.java
Patch:
@@ -25,6 +25,7 @@
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.db.partitions.CachedPartition;
+import org.apache.cassandra.io.util.DataInputBuffer;
 import org.apache.cassandra.io.util.DataOutputBufferFixed;
 import org.apache.cassandra.io.util.NIODataInputStream;
 import org.caffinitas.ohc.OHCache;
@@ -171,7 +172,7 @@ public IRowCacheEntry deserialize(ByteBuffer buf)
         {
             try
             {
-                NIODataInputStream in = new NIODataInputStream(buf, false);
+                NIODataInputStream in = new DataInputBuffer(buf, false);
                 boolean isSentinel = in.readBoolean();
                 if (isSentinel)
                     return new RowCacheSentinel(in.readLong());

File: src/java/org/apache/cassandra/db/HintedHandOffManager.java
Patch:
@@ -17,7 +17,6 @@
  */
 package org.apache.cassandra.db;
 
-import java.io.DataInputStream;
 import java.io.IOException;
 import java.lang.management.ManagementFactory;
 import java.net.InetAddress;
@@ -54,8 +53,8 @@
 import org.apache.cassandra.gms.Gossiper;
 import org.apache.cassandra.io.sstable.Descriptor;
 import org.apache.cassandra.io.sstable.SSTable;
+import org.apache.cassandra.io.util.DataInputBuffer;
 import org.apache.cassandra.io.util.DataInputPlus;
-import org.apache.cassandra.io.util.NIODataInputStream;
 import org.apache.cassandra.metrics.HintedHandoffMetrics;
 import org.apache.cassandra.net.MessageOut;
 import org.apache.cassandra.net.MessagingService;
@@ -410,7 +409,7 @@ private void doDeliverHintsToEndpoint(InetAddress endpoint)
                 Cell cell = hint.getCell(hintColumn);
 
                 final long timestamp = cell.timestamp();
-                DataInputPlus in = new NIODataInputStream(cell.value(), true);
+                DataInputPlus in = new DataInputBuffer(cell.value(), true);
                 Mutation mutation;
                 try
                 {

File: src/java/org/apache/cassandra/db/ReadResponse.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.cassandra.db.rows.*;
 import org.apache.cassandra.db.partitions.*;
 import org.apache.cassandra.io.IVersionedSerializer;
+import org.apache.cassandra.io.util.DataInputBuffer;
 import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputPlus;
 import org.apache.cassandra.io.util.DataOutputBuffer;
@@ -116,7 +117,7 @@ public UnfilteredPartitionIterator makeIterator()
         {
             try
             {
-                DataInputPlus in = new DataInputPlus.DataInputStreamPlus(ByteBufferUtil.inputStream(data));
+                DataInputPlus in = new DataInputBuffer(data, true);
                 return UnfilteredPartitionIterators.serializerForIntraNode().deserialize(in, MessagingService.current_version, flag);
             }
             catch (IOException e)

File: src/java/org/apache/cassandra/db/SystemKeyspace.java
Patch:
@@ -48,6 +48,7 @@
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
+import org.apache.cassandra.io.util.DataInputBuffer;
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.io.util.NIODataInputStream;
 import org.apache.cassandra.locator.IEndpointSnitch;
@@ -651,7 +652,7 @@ private static Pair<ReplayPosition, Long> truncationRecordFromBlob(ByteBuffer by
     {
         try
         {
-            NIODataInputStream in = new NIODataInputStream(bytes, true);
+            NIODataInputStream in = new DataInputBuffer(bytes, true);
             return Pair.create(ReplayPosition.serializer.deserialize(in), in.available() > 0 ? in.readLong() : Long.MIN_VALUE);
         }
         catch (IOException e)

File: src/java/org/apache/cassandra/db/commitlog/CommitLogReplayer.java
Patch:
@@ -38,7 +38,6 @@
 import org.apache.commons.lang3.StringUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-
 import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.concurrent.StageManager;
 import org.apache.cassandra.config.CFMetaData;
@@ -50,6 +49,7 @@
 import org.apache.cassandra.io.compress.CompressionParameters;
 import org.apache.cassandra.io.compress.ICompressor;
 import org.apache.cassandra.io.util.ByteBufferDataInput;
+import org.apache.cassandra.io.util.DataInputBuffer;
 import org.apache.cassandra.io.util.FileDataInput;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.io.util.NIODataInputStream;
@@ -474,7 +474,7 @@ void replayMutation(byte[] inputBuffer, int size,
     {
 
         final Mutation mutation;
-        try (NIODataInputStream bufIn = new NIODataInputStream(inputBuffer, 0, size))
+        try (NIODataInputStream bufIn = new DataInputBuffer(inputBuffer, 0, size))
         {
             mutation = Mutation.serializer.deserialize(bufIn,
                                                        desc.getMessagingVersion(),

File: src/java/org/apache/cassandra/db/partitions/PartitionUpdate.java
Patch:
@@ -31,10 +31,10 @@
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.filter.ColumnFilter;
 import org.apache.cassandra.db.rows.*;
+import org.apache.cassandra.io.util.DataInputBuffer;
 import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.io.util.DataOutputPlus;
-import org.apache.cassandra.io.util.NIODataInputStream;
 import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.serializers.MarshalException;
 import org.apache.cassandra.utils.FBUtilities;
@@ -229,7 +229,7 @@ public static PartitionUpdate fromBytes(ByteBuffer bytes, int version, Decorated
 
         try
         {
-            return serializer.deserialize(new NIODataInputStream(bytes, true),
+            return serializer.deserialize(new DataInputBuffer(bytes, true),
                                           version,
                                           SerializationHelper.Flag.LOCAL,
                                           version < MessagingService.VERSION_30 ? key : null);

File: test/long/org/apache/cassandra/db/commitlog/CommitLogStressTest.java
Patch:
@@ -57,7 +57,8 @@
 import org.apache.cassandra.db.rows.SerializationHelper;
 import org.apache.cassandra.db.partitions.PartitionUpdate;
 import org.apache.cassandra.db.marshal.UTF8Type;
-import org.apache.cassandra.io.util.NIODataInputStream;
+import org.apache.cassandra.io.util.DataInputBuffer;
+import org.apache.cassandra.io.util.DataInputPlus;
 
 public class CommitLogStressTest
 {
@@ -462,7 +463,7 @@ else if (desc.id == discardedPos.segment && entryLocation <= discardedPos.positi
                 // Skip over this mutation.
                 return;
 
-            NIODataInputStream bufIn = new NIODataInputStream(inputBuffer, 0, size);
+            DataInputPlus bufIn = new DataInputBuffer(inputBuffer, 0, size);
             Mutation mutation;
             try
             {

File: test/unit/org/apache/cassandra/db/PartitionTest.java
Patch:
@@ -31,8 +31,8 @@
 import org.apache.cassandra.db.marshal.AsciiType;
 import org.apache.cassandra.db.marshal.BytesType;
 import org.apache.cassandra.db.partitions.*;
+import org.apache.cassandra.io.util.DataInputBuffer;
 import org.apache.cassandra.io.util.DataOutputBuffer;
-import org.apache.cassandra.io.util.NIODataInputStream;
 import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.SchemaLoader;
@@ -78,7 +78,7 @@ public void testSingleColumn() throws IOException
         DataOutputBuffer bufOut = new DataOutputBuffer();
         CachedPartition.cacheSerializer.serialize(partition, bufOut);
 
-        CachedPartition deserialized = CachedPartition.cacheSerializer.deserialize(new NIODataInputStream(bufOut.getData()));
+        CachedPartition deserialized = CachedPartition.cacheSerializer.deserialize(new DataInputBuffer(bufOut.getData()));
 
         assert deserialized != null;
         assert deserialized.metadata().cfName.equals(CF_STANDARD1);
@@ -103,7 +103,7 @@ public void testManyColumns() throws IOException
         DataOutputBuffer bufOut = new DataOutputBuffer();
         CachedPartition.cacheSerializer.serialize(partition, bufOut);
 
-        CachedPartition deserialized = CachedPartition.cacheSerializer.deserialize(new NIODataInputStream(bufOut.getData()));
+        CachedPartition deserialized = CachedPartition.cacheSerializer.deserialize(new DataInputBuffer(bufOut.getData()));
 
         assertEquals(partition.columns().regulars.columnCount(), deserialized.columns().regulars.columnCount());
         assertTrue(deserialized.columns().regulars.getSimple(1).equals(partition.columns().regulars.getSimple(1)));

File: test/unit/org/apache/cassandra/db/ReadMessageTest.java
Patch:
@@ -38,9 +38,9 @@
 import org.apache.cassandra.db.partitions.FilteredPartition;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.io.IVersionedSerializer;
+import org.apache.cassandra.io.util.DataInputBuffer;
 import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputBuffer;
-import org.apache.cassandra.io.util.NIODataInputStream;
 import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.schema.KeyspaceParams;
 import org.apache.cassandra.utils.ByteBufferUtil;
@@ -145,7 +145,7 @@ private ReadCommand serializeAndDeserializeReadMessage(ReadCommand rm) throws IO
 
         rms.serialize(rm, out, MessagingService.current_version);
 
-        DataInputPlus dis = new NIODataInputStream(out.getData());
+        DataInputPlus dis = new DataInputBuffer(out.getData());
         return rms.deserialize(dis, MessagingService.current_version);
     }
 

File: test/unit/org/apache/cassandra/db/commitlog/CommitLogTestReplayer.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.Mutation;
 import org.apache.cassandra.db.rows.SerializationHelper;
+import org.apache.cassandra.io.util.DataInputBuffer;
 import org.apache.cassandra.io.util.NIODataInputStream;
 
 /**
@@ -59,7 +60,7 @@ public CommitLogTestReplayer(ReplayPosition discardedPos, Predicate<Mutation> pr
     @Override
     void replayMutation(byte[] inputBuffer, int size, final long entryLocation, final CommitLogDescriptor desc)
     {
-        NIODataInputStream bufIn = new NIODataInputStream(inputBuffer, 0, size);
+        NIODataInputStream bufIn = new DataInputBuffer(inputBuffer, 0, size);
         Mutation mutation;
         try
         {

File: test/unit/org/apache/cassandra/gms/GossipDigestTest.java
Patch:
@@ -22,9 +22,9 @@
 
 import java.io.IOException;
 
+import org.apache.cassandra.io.util.DataInputBuffer;
 import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputBuffer;
-import org.apache.cassandra.io.util.NIODataInputStream;
 
 import java.net.InetAddress;
 
@@ -49,7 +49,7 @@ public void test() throws IOException
         DataOutputBuffer output = new DataOutputBuffer();
         GossipDigest.serializer.serialize(expected, output, MessagingService.current_version);
 
-        DataInputPlus input = new NIODataInputStream(output.getData());
+        DataInputPlus input = new DataInputBuffer(output.getData());
         GossipDigest actual = GossipDigest.serializer.deserialize(input, MessagingService.current_version);
         assertEquals(0, expected.compareTo(actual));
     }

File: test/unit/org/apache/cassandra/utils/IntervalTreeTest.java
Patch:
@@ -30,10 +30,10 @@
 import org.junit.Test;
 import org.apache.cassandra.io.ISerializer;
 import org.apache.cassandra.io.IVersionedSerializer;
+import org.apache.cassandra.io.util.DataInputBuffer;
 import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.io.util.DataOutputPlus;
-import org.apache.cassandra.io.util.NIODataInputStream;
 
 import static org.junit.Assert.assertEquals;
 
@@ -186,7 +186,7 @@ public long serializedSize(String v)
 
         serializer.serialize(it, out, 0);
 
-        DataInputPlus in = new NIODataInputStream(out.toByteArray());
+        DataInputPlus in = new DataInputBuffer(out.toByteArray());
 
         IntervalTree<Integer, String, Interval<Integer, String>> it2 = serializer.deserialize(in, 0);
         List<Interval<Integer, String>> intervals2 = new ArrayList<Interval<Integer, String>>();

File: test/unit/org/apache/cassandra/utils/MerkleTreeTest.java
Patch:
@@ -31,6 +31,7 @@
 import org.apache.cassandra.dht.RandomPartitioner.BigIntegerToken;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.Token;
+import org.apache.cassandra.io.util.DataInputBuffer;
 import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.io.util.NIODataInputStream;
@@ -400,7 +401,7 @@ public void testSerialization() throws Exception
         MerkleTree.serializer.serialize(mt, out, MessagingService.current_version);
         byte[] serialized = out.toByteArray();
 
-        DataInputPlus in = new NIODataInputStream(serialized);
+        DataInputPlus in = new DataInputBuffer(serialized);
         MerkleTree restored = MerkleTree.serializer.deserialize(in, MessagingService.current_version);
 
         assertHashEquals(initialhash, restored.hash(full));

File: src/java/org/apache/cassandra/db/Keyspace.java
Patch:
@@ -395,7 +395,6 @@ public void apply(Mutation mutation, boolean writeCommitLog, boolean updateIndex
                 replayPosition = CommitLog.instance.add(mutation);
             }
 
-            DecoratedKey key = mutation.key();
             for (PartitionUpdate upd : mutation.getPartitionUpdates())
             {
                 ColumnFamilyStore cfs = columnFamilyStores.get(upd.metadata().cfId);

File: src/java/org/apache/cassandra/db/rows/ArrayBackedRow.java
Patch:
@@ -510,7 +510,7 @@ protected AbstractBuilder(Columns columns)
 
         public void newRow(Clustering clustering)
         {
-            assert cells.isEmpty(); // Ensures we've properly called build() if we've use this builder before
+            assert this.clustering == null; // Ensures we've properly called build() if we've use this builder before
             this.clustering = clustering;
         }
 

File: test/unit/org/apache/cassandra/db/PartitionTest.java
Patch:
@@ -164,7 +164,7 @@ public void testColumnStatsRecordsRowDeletesCorrectly()
             builder.add("val" + i, "val" + i);
         builder.build().applyUnsafe();
 
-        RowUpdateBuilder.deleteRow(cfs.metadata, 10, "key1", "c").applyUnsafe();
+        RowUpdateBuilder.deleteRowAt(cfs.metadata, 10L, localDeletionTime, "key1", "c").applyUnsafe();
         ArrayBackedPartition partition = Util.getOnlyPartitionUnfiltered(Util.cmd(cfs, "key1").build());
         RowStats stats = partition.stats();
         assertEquals(localDeletionTime, stats.minLocalDeletionTime);

File: src/java/org/apache/cassandra/db/columniterator/AbstractSSTableIterator.java
Patch:
@@ -456,7 +456,7 @@ public int blocksCount()
         // Check if we've crossed an index boundary (based on the mark on the beginning of the index block).
         public boolean isPastCurrentBlock()
         {
-            return currentIndexIdx < indexes.size() && reader.file.bytesPastMark(mark) >= currentIndex().width;
+            return reader.file.bytesPastMark(mark) >= currentIndex().width;
         }
 
         public int currentBlockIdx()

File: src/java/org/apache/cassandra/db/columniterator/SSTableIterator.java
Patch:
@@ -252,8 +252,9 @@ && metadata().comparator.compare(slice.end(), indexState.currentIndex().firstNam
         protected Unfiltered computeNext() throws IOException
         {
             // Our previous read might have made us cross an index block boundary. If so, update our informations.
-            if (indexState.isPastCurrentBlock())
-                indexState.setToBlock(indexState.currentBlockIdx() + 1);
+            int currentBlockIdx = indexState.currentBlockIdx();
+            if (indexState.isPastCurrentBlock() && currentBlockIdx + 1 < indexState.blocksCount())
+                indexState.setToBlock(currentBlockIdx + 1);
 
             // Return the next unfiltered unless we've reached the end, or we're beyond our slice
             // end (note that unless we're on the last block for the slice, there is no point

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -270,9 +270,9 @@ public ReplayPosition add(Mutation mutation)
             buffer.putInt((int) checksum.getValue());
 
             // checksummed mutation
-            Mutation.serializer.serialize(mutation, dos, MessagingService.current_version);
             copy = buffer.duplicate();
-            copy.limit((int) size);
+            Mutation.serializer.serialize(mutation, dos, MessagingService.current_version);
+            copy.limit(copy.position() + (int) size);
             checksum.update(copy);
             buffer.putInt((int) checksum.getValue());
         }

File: test/unit/org/apache/cassandra/db/RecoveryManagerFlushedTest.java
Patch:
@@ -29,6 +29,7 @@
 import org.apache.cassandra.db.commitlog.CommitLog;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.schema.KeyspaceParams;
+import org.apache.cassandra.schema.SchemaKeyspace;
 import org.apache.cassandra.utils.FBUtilities;
 
 public class RecoveryManagerFlushedTest
@@ -55,6 +56,8 @@ public void testWithFlush() throws Exception
     {
         // Flush everything that may be in the commit log now to start fresh
         FBUtilities.waitOnFutures(Keyspace.open(SystemKeyspace.NAME).flush());
+        FBUtilities.waitOnFutures(Keyspace.open(SchemaKeyspace.NAME).flush());
+
 
         CompactionManager.instance.disableAutoCompaction();
 

File: src/java/org/apache/cassandra/db/ReadResponse.java
Patch:
@@ -116,7 +116,7 @@ public UnfilteredPartitionIterator makeIterator()
         {
             try
             {
-                DataInput in = new DataInputStream(ByteBufferUtil.inputStream(data));
+                DataInputPlus in = new DataInputPlus.DataInputStreamPlus(ByteBufferUtil.inputStream(data));
                 return UnfilteredPartitionIterators.serializerForIntraNode().deserialize(in, MessagingService.current_version, flag);
             }
             catch (IOException e)

File: src/java/org/apache/cassandra/db/partitions/UnfilteredPartitionIterators.java
Patch:
@@ -17,7 +17,6 @@
  */
 package org.apache.cassandra.db.partitions;
 
-import java.io.DataInput;
 import java.io.IOError;
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -29,6 +28,7 @@
 import org.apache.cassandra.cql3.ColumnIdentifier;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.rows.*;
+import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputPlus;
 import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.utils.MergeIterator;
@@ -435,7 +435,7 @@ public void serialize(UnfilteredPartitionIterator iter, DataOutputPlus out, int
             out.writeBoolean(false);
         }
 
-        public UnfilteredPartitionIterator deserialize(final DataInput in, final int version, final SerializationHelper.Flag flag) throws IOException
+        public UnfilteredPartitionIterator deserialize(final DataInputPlus in, final int version, final SerializationHelper.Flag flag) throws IOException
         {
             if (version < MessagingService.VERSION_30)
                 throw new UnsupportedOperationException();

File: src/java/org/apache/cassandra/db/rows/UnfilteredRowIteratorSerializer.java
Patch:
@@ -26,6 +26,7 @@
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.db.*;
+import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputPlus;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.ByteBufferUtil;
@@ -174,7 +175,7 @@ public long serializedSize(UnfilteredRowIterator iterator, int version, int rowE
         return size;
     }
 
-    public Header deserializeHeader(DataInput in, int version, SerializationHelper.Flag flag) throws IOException
+    public Header deserializeHeader(DataInputPlus in, int version, SerializationHelper.Flag flag) throws IOException
     {
         CFMetaData metadata = CFMetaData.serializer.deserialize(in, version);
         DecoratedKey key = StorageService.getPartitioner().decorateKey(ByteBufferUtil.readWithLength(in));
@@ -207,7 +208,7 @@ public void deserialize(DataInput in, SerializationHelper helper, SerializationH
         while (UnfilteredSerializer.serializer.deserialize(in, header, helper, rowWriter, markerWriter) != null);
     }
 
-    public UnfilteredRowIterator deserialize(final DataInput in, int version, SerializationHelper.Flag flag) throws IOException
+    public UnfilteredRowIterator deserialize(final DataInputPlus in, int version, SerializationHelper.Flag flag) throws IOException
     {
         final Header h = deserializeHeader(in, version, flag);
 

File: src/java/org/apache/cassandra/utils/UUIDSerializer.java
Patch:
@@ -44,4 +44,4 @@ public long serializedSize(UUID uuid, int version)
     {
         return TypeSizes.sizeof(uuid.getMostSignificantBits()) + TypeSizes.sizeof(uuid.getLeastSignificantBits());
     }
-}
\ No newline at end of file
+}

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1200,7 +1200,7 @@ largest.cfs, ratio(usedOnHeap, usedOffHeap), ratio(liveOnHeap, liveOffHeap),
 
     private static String ratio(float onHeap, float offHeap)
     {
-        return String.format("%.0f/%.0f", onHeap, offHeap);
+        return String.format("%.2f/%.2f", onHeap, offHeap);
     }
 
     public void maybeUpdateRowCache(DecoratedKey key)

File: src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java
Patch:
@@ -129,11 +129,10 @@ public boolean announceMigration(boolean isLocalOnly) throws RequestValidationEx
                     // some data using the old type, and so we can't allow adding a collection with the same name unless
                     // the types are compatible (see #6276).
                     CFMetaData.DroppedColumn dropped = cfm.getDroppedColumns().get(columnName.bytes);
-                    // We could have type == null for old dropped columns, in which case we play it safe and refuse
-                    if (dropped != null && (dropped.type == null || (dropped.type instanceof CollectionType && !type.isCompatibleWith(dropped.type))))
+                    if (dropped != null && dropped.type instanceof CollectionType && !type.isCompatibleWith(dropped.type))
                         throw new InvalidRequestException(String.format("Cannot add a collection with the name %s " +
                                     "because a collection with the same name and a different type%s has already been used in the past",
-                                    columnName, dropped.type == null ? "" : " (" + dropped.type.asCQL3Type() + ")"));
+                                    columnName, " (" + dropped.type.asCQL3Type() + ')'));
                 }
 
                 Integer componentIndex = cfm.isCompound() ? cfm.comparator.size() : null;

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -1117,7 +1117,7 @@ private void validateIndexIntervalThresholds() throws ConfigurationException
                                                            "interval (%d).", maxIndexInterval, minIndexInterval));
     }
 
-    // The comparator to validate the definition name.
+    // The comparator to validate the definition name with thrift.
     public AbstractType<?> thriftColumnNameType()
     {
         if (isSuper())
@@ -1127,7 +1127,8 @@ public AbstractType<?> thriftColumnNameType()
             return ((MapType)def.type).nameComparator();
         }
 
-        return UTF8Type.instance;
+        assert isStaticCompactTable();
+        return clusteringColumns.get(0).type;
     }
 
     public CFMetaData addAllColumnDefinitions(Collection<ColumnDefinition> defs)

File: src/java/org/apache/cassandra/db/Memtable.java
Patch:
@@ -390,7 +390,7 @@ private SSTableReader writeSortedContents(ReplayPosition context, File sstableDi
                 }
                 else
                 {
-                    logger.info("Completed flushing %s; nothing needed to be retained.  Commitlog position was {}",
+                    logger.info("Completed flushing {}; nothing needed to be retained.  Commitlog position was {}",
                                 writer.getFilename(), context);
                     writer.abort();
                     ssTable = null;

File: src/java/org/apache/cassandra/transport/messages/CredentialsMessage.java
Patch:
@@ -89,6 +89,6 @@ public Message.Response execute(QueryState state)
     @Override
     public String toString()
     {
-        return "CREDENTIALS " + credentials;
+        return "CREDENTIALS";
     }
 }

File: src/java/org/apache/cassandra/service/ReadCallback.java
Patch:
@@ -121,6 +121,7 @@ public void response(MessageIn<TMessage> message)
         if (n >= blockfor && resolver.isDataPresent())
         {
             condition.signalAll();
+
             // kick off a background digest comparison if this is a result that (may have) arrived after
             // the original resolve that get() kicks off as soon as the condition is signaled
             if (blockfor < endpoints.size() && n == endpoints.size())

File: src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java
Patch:
@@ -116,7 +116,7 @@ public boolean announceMigration(boolean isLocalOnly) throws RequestValidationEx
                 }
 
                 // Cannot re-add a dropped counter column. See #7831.
-                if (meta.isCounter() && meta.getDroppedColumns().containsKey(columnName))
+                if (meta.isCounter() && meta.getDroppedColumns().containsKey(columnName.bytes))
                     throw new InvalidRequestException(String.format("Cannot re-add previously dropped counter column %s", columnName));
 
                 AbstractType<?> type = validator.getType();
@@ -130,7 +130,7 @@ public boolean announceMigration(boolean isLocalOnly) throws RequestValidationEx
                     // If there used to be a collection column with the same name (that has been dropped), we could still have
                     // some data using the old type, and so we can't allow adding a collection with the same name unless
                     // the types are compatible (see #6276).
-                    CFMetaData.DroppedColumn dropped = cfm.getDroppedColumns().get(columnName);
+                    CFMetaData.DroppedColumn dropped = cfm.getDroppedColumns().get(columnName.bytes);
                     // We could have type == null for old dropped columns, in which case we play it safe and refuse
                     if (dropped != null && (dropped.type == null || (dropped.type instanceof CollectionType && !type.isCompatibleWith(dropped.type))))
                         throw new InvalidRequestException(String.format("Cannot add a collection with the name %s " +

File: src/java/org/apache/cassandra/schema/LegacySchemaMigrator.java
Patch:
@@ -403,7 +403,7 @@ private static void addDroppedColumns(CFMetaData cfm, Map<String, Long> droppedT
             String name = entry.getKey();
             long time = entry.getValue();
             AbstractType<?> type = types.containsKey(name) ? TypeParser.parse(types.get(name)) : null;
-            cfm.getDroppedColumns().put(ColumnIdentifier.getInterned(name, true), new CFMetaData.DroppedColumn(type, time));
+            cfm.getDroppedColumns().put(UTF8Type.instance.decompose(name), new CFMetaData.DroppedColumn(type, time));
         }
     }
 

File: src/java/org/apache/cassandra/schema/SchemaKeyspace.java
Patch:
@@ -841,9 +841,9 @@ static void addTableToSchemaMutation(CFMetaData table, long timestamp, boolean w
              .add("read_repair_chance", table.getReadRepairChance())
              .add("speculative_retry", table.getSpeculativeRetry().toString());
 
-        for (Map.Entry<ColumnIdentifier, CFMetaData.DroppedColumn> entry : table.getDroppedColumns().entrySet())
+        for (Map.Entry<ByteBuffer, CFMetaData.DroppedColumn> entry : table.getDroppedColumns().entrySet())
         {
-            String name = entry.getKey().toString();
+            String name = UTF8Type.instance.getString(entry.getKey());
             CFMetaData.DroppedColumn column = entry.getValue();
             adder.addMapEntry("dropped_columns", name, column.droppedTime);
             if (column.type != null)
@@ -1073,7 +1073,7 @@ private static void addDroppedColumns(CFMetaData cfm, Map<String, Long> droppedT
             String name = entry.getKey();
             long time = entry.getValue();
             AbstractType<?> type = types.containsKey(name) ? TypeParser.parse(types.get(name)) : null;
-            cfm.getDroppedColumns().put(ColumnIdentifier.getInterned(name, true), new CFMetaData.DroppedColumn(type, time));
+            cfm.getDroppedColumns().put(UTF8Type.instance.decompose(name), new CFMetaData.DroppedColumn(type, time));
         }
     }
 

File: test/unit/org/apache/cassandra/schema/LegacySchemaMigratorTest.java
Patch:
@@ -403,9 +403,9 @@ private static void addTableToSchemaMutation(CFMetaData table, long timestamp, b
              .add("read_repair_chance", table.getReadRepairChance())
              .add("speculative_retry", table.getSpeculativeRetry().toString());
 
-        for (Map.Entry<ColumnIdentifier, CFMetaData.DroppedColumn> entry : table.getDroppedColumns().entrySet())
+        for (Map.Entry<ByteBuffer, CFMetaData.DroppedColumn> entry : table.getDroppedColumns().entrySet())
         {
-            String name = entry.getKey().toString();
+            String name = UTF8Type.instance.getString(entry.getKey());
             CFMetaData.DroppedColumn column = entry.getValue();
             adder.addMapEntry("dropped_columns", name, column.droppedTime);
         }

File: src/java/org/apache/cassandra/metrics/CompactionMetrics.java
Patch:
@@ -58,14 +58,14 @@ public CompactionMetrics(final ThreadPoolExecutor... collectors)
             public Integer value()
             {
                 int n = 0;
+                // add estimate number of compactions need to be done
                 for (String keyspaceName : Schema.instance.getKeyspaces())
                 {
                     for (ColumnFamilyStore cfs : Keyspace.open(keyspaceName).getColumnFamilyStores())
                         n += cfs.getCompactionStrategy().getEstimatedRemainingTasks();
                 }
-                for (ThreadPoolExecutor collector : collectors)
-                    n += collector.getTaskCount() - collector.getCompletedTaskCount();
-                return n;
+                // add number of currently running compactions
+                return n + compactions.size();
             }
         });
         completedTasks = Metrics.newGauge(factory.createMetricName("CompletedTasks"), new Gauge<Long>()

File: src/java/org/apache/cassandra/io/sstable/format/big/BigTableReader.java
Patch:
@@ -167,6 +167,9 @@ protected RowIndexEntry getPosition(RowPosition key, Operator op, boolean update
 
         int effectiveInterval = indexSummary.getEffectiveIndexIntervalAfterIndex(sampledIndex);
 
+        if (ifile == null)
+            return null;
+
         // scan the on-disk index, starting at the nearest sampled position.
         // The check against IndexInterval is to be exit the loop in the EQ case when the key looked for is not present
         // (bloom filter false positive). But note that for non-EQ cases, we might need to check the first key of the

File: test/unit/org/apache/cassandra/db/ScrubTest.java
Patch:
@@ -345,7 +345,7 @@ public void testScrubNoIndex() throws IOException, ExecutionException, Interrupt
         for (SSTableReader sstable : cfs.getSSTables())
             new File(sstable.descriptor.filenameFor(Component.PRIMARY_INDEX)).delete();
 
-        CompactionManager.instance.performScrub(cfs, false, true);
+        CompactionManager.instance.performScrub(cfs, false, true, true);
 
         // check data is still there
         rows = cfs.getRangeSlice(Util.range("", ""), null, new IdentityQueryFilter(), 1000);

File: src/java/org/apache/cassandra/db/partitions/PartitionUpdate.java
Patch:
@@ -488,14 +488,14 @@ private synchronized void sort()
             {
                 // current and previous are the same row. Merge current into previous
                 // (and so previous + 1 will be "free").
-                data.merge(current, previous, nowInSec);
+                merge(current, previous, nowInSec);
             }
             else
             {
                 // data[current] != [previous], so move current just after previous if needs be
                 ++previous;
                 if (previous != current)
-                    data.move(current, previous);
+                    move(current, previous);
             }
         }
 

File: src/java/org/apache/cassandra/db/compaction/CompactionTask.java
Patch:
@@ -240,6 +240,8 @@ public boolean apply(SSTableReader sstable)
             Collection<SSTableReader> oldSStables = this.sstables;
             if (!offline)
                 cfs.getDataTracker().markCompactedSSTablesReplaced(oldSStables, newSStables, compactionType);
+            else
+                Refs.release(Refs.selfRefs(newSStables));
 
             // log a bunch of statistics about the result and save to system table compaction_history
             long dTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);

File: src/java/org/apache/cassandra/db/ClusteringComparator.java
Patch:
@@ -162,7 +162,7 @@ public int compare(ClusteringPrefix c1, ClusteringPrefix c2)
         if (s1 == s2)
             return ClusteringPrefix.Kind.compare(c1.kind(), c2.kind());
 
-        return s1 < s2 ? c1.kind().prefixComparisonResult : -c2.kind().prefixComparisonResult;
+        return s1 < s2 ? c1.kind().comparedToClustering : -c2.kind().comparedToClustering;
     }
 
     public int compare(Clustering c1, Clustering c2)

File: tools/stress/src/org/apache/cassandra/stress/settings/OptionRatioDistribution.java
Patch:
@@ -87,7 +87,7 @@ public RatioDistributionFactory get()
             return new DelegateFactory(delegate.get(), divisor);
         if (defaultSpec == null)
             return null;
-        OptionRatioDistribution sub = new OptionRatioDistribution(delegate.prefix, null, null, true);
+        OptionRatioDistribution sub = new OptionRatioDistribution("", null, null, true);
         if (!sub.accept(defaultSpec))
             throw new IllegalStateException("Invalid default spec: " + defaultSpec);
         return sub.get();

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsInsert.java
Patch:
@@ -48,6 +48,8 @@ private SettingsInsert(InsertOptions options)
         this.selectRatio = options.selectRatio.get();
         this.rowPopulationRatio = options.rowPopulationRatio.get();
 
+
+
         this.batchType = !options.batchType.setByUser() ? null : BatchStatement.Type.valueOf(options.batchType.value());
     }
 
@@ -60,7 +62,7 @@ private static class InsertOptions extends GroupedOptions
         final OptionDistribution partitions = new OptionDistribution("partitions=", null, "The number of partitions to update in a single batch", false);
         final OptionSimple batchType = new OptionSimple("batchtype=", "unlogged|logged|counter", null, "Specify the type of batch statement (LOGGED, UNLOGGED or COUNTER)", false);
         final OptionRatioDistribution selectRatio = new OptionRatioDistribution("select-ratio=", null, "The uniform probability of visiting any CQL row in the generated partition", false);
-        final OptionRatioDistribution rowPopulationRatio = new OptionRatioDistribution("row-population-ratio=", null, "The percent of a given rows columns to populate", false);
+        final OptionRatioDistribution rowPopulationRatio = new OptionRatioDistribution("row-population-ratio=", "fixed(1)/1", "The percent of a given rows columns to populate", false);
 
         @Override
         public List<? extends Option> options()

File: src/java/org/apache/cassandra/dht/tokenallocator/TokenAllocation.java
Patch:
@@ -252,8 +252,8 @@ public boolean inAllocationRing(InetAddress other)
         }
         else
             throw new ConfigurationException(
-                                            String.format("Token allocation failed: the number of racks %d in datacentre %s is lower than its replication factor %d.",
-                                                          replicas, dc, racks));
+                    String.format("Token allocation failed: the number of racks %d in datacenter %s is lower than its replication factor %d.",
+                                  racks, dc, replicas));
     }
 }
 

File: src/java/org/apache/cassandra/cql3/ResultSet.java
Patch:
@@ -37,7 +37,7 @@
 public class ResultSet
 {
     public static final Codec codec = new Codec();
-    private static final ColumnIdentifier COUNT_COLUMN = new ColumnIdentifier("count", false);
+    public static final ColumnIdentifier COUNT_COLUMN = new ColumnIdentifier("count", false);
 
     public final Metadata metadata;
     public final List<List<ByteBuffer>> rows;

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -674,7 +674,7 @@ private static ResultSet buildCasFailureResultSet(ByteBuffer key, ColumnFamily c
         Selection selection;
         if (columnsWithConditions == null)
         {
-            selection = Selection.wildcard(cfDef);
+            selection = Selection.wildcard(cfDef, false, null);
         }
         else
         {

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -1537,7 +1537,7 @@ public ParsedStatement.Prepared prepare() throws InvalidRequestException
                 throw new InvalidRequestException("Only COUNT(*) and COUNT(1) operations are currently supported.");
 
             Selection selection = selectClause.isEmpty()
-                                ? Selection.wildcard(cfDef)
+                                ? Selection.wildcard(cfDef, parameters.isCount, parameters.countAlias)
                                 : Selection.fromSelectors(cfDef, selectClause);
 
             SelectStatement stmt = new SelectStatement(cfm, boundNames.size(), parameters, selection, prepareLimit(boundNames));

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -2075,7 +2075,7 @@ public void truncateBlocking()
         // position in the System keyspace.
         logger.debug("truncating {}", name);
 
-        if (keyspace.metadata.durableWrites || DatabaseDescriptor.isAutoSnapshot())
+        if (keyspace.getMetadata().durableWrites || DatabaseDescriptor.isAutoSnapshot())
         {
             // flush the CF being truncated before forcing the new segment
             forceBlockingFlush();

File: src/java/org/apache/cassandra/db/DataTracker.java
Patch:
@@ -130,7 +130,7 @@ public Memtable switchMemtable()
      */
     public void renewMemtable()
     {
-        assert !cfstore.keyspace.metadata.durableWrites;
+        assert !cfstore.keyspace.getMetadata().durableWrites;
 
         Memtable newMemtable = new Memtable(cfstore);
         View currentView, newView;

File: src/java/org/apache/cassandra/db/DefsTables.java
Patch:
@@ -333,7 +333,7 @@ private static void updateKeyspace(String ksName)
 
         if (!StorageService.instance.isClientMode())
         {
-            Keyspace.open(ksName).createReplicationStrategy(newKsm);
+            Keyspace.open(ksName).setMetadata(newKsm);
             MigrationManager.instance.notifyUpdateKeyspace(newKsm);
         }
     }

File: src/java/org/apache/cassandra/db/RowMutation.java
Patch:
@@ -208,7 +208,7 @@ public void addAll(IMutation m)
     public void apply()
     {
         Keyspace ks = Keyspace.open(keyspaceName);
-        ks.apply(this, ks.metadata.durableWrites);
+        ks.apply(this, ks.getMetadata().durableWrites);
     }
 
     public void applyUnsafe()

File: test/unit/org/apache/cassandra/db/CommitLogTest.java
Patch:
@@ -294,7 +294,7 @@ public void testTruncateWithoutSnapshotNonDurable()  throws ExecutionException,
         boolean prevAutoSnapshot = DatabaseDescriptor.isAutoSnapshot();
         DatabaseDescriptor.setAutoSnapshot(false);
         Keyspace notDurableKs = Keyspace.open("NoCommitlogSpace");
-        Assert.assertFalse(notDurableKs.metadata.durableWrites);
+        Assert.assertFalse(notDurableKs.getMetadata().durableWrites);
         ColumnFamilyStore cfs = notDurableKs.getColumnFamilyStore("Standard1");
         RowMutation rm;
         DecoratedKey dk = Util.dk("key1");

File: test/unit/org/apache/cassandra/service/ClientWarningsTest.java
Patch:
@@ -38,8 +38,6 @@ public class ClientWarningsTest extends CQLTester
     @BeforeClass
     public static void setUp()
     {
-        DatabaseDescriptor.setPartitioner(ByteOrderedPartitioner.instance);
-
         requireNetwork();
         DatabaseDescriptor.setBatchSizeWarnThresholdInKB(1);
     }

File: src/java/org/apache/cassandra/cql3/CQL3Type.java
Patch:
@@ -528,7 +528,7 @@ public CQL3Type prepare(String keyspace) throws InvalidRequestException
                 KSMetaData ksm = Schema.instance.getKSMetaData(name.getKeyspace());
                 if (ksm == null)
                     throw new InvalidRequestException("Unknown keyspace " + name.getKeyspace());
-                UserType type = ksm.userTypes.getType(name.getUserTypeName());
+                UserType type = ksm.types.getNullable(name.getUserTypeName());
                 if (type == null)
                     throw new InvalidRequestException("Unknown type " + name);
 

File: src/java/org/apache/cassandra/cql3/functions/UDFunction.java
Patch:
@@ -295,7 +295,7 @@ public void userTypeUpdated(String ksName, String typeName)
                     KSMetaData ksm = Schema.instance.getKSMetaData(ksName);
                     assert ksm != null;
 
-                    org.apache.cassandra.db.marshal.UserType ut = ksm.userTypes.getType(ByteBufferUtil.bytes(typeName));
+                    org.apache.cassandra.db.marshal.UserType ut = ksm.types.get(ByteBufferUtil.bytes(typeName)).get();
 
                     DataType newUserType = UDHelper.driverType(ut);
                     argDataTypes[i] = newUserType;

File: src/java/org/apache/cassandra/cql3/statements/CreateTypeStatement.java
Patch:
@@ -69,7 +69,7 @@ public void validate(ClientState state) throws RequestValidationException
         if (ksm == null)
             throw new InvalidRequestException(String.format("Cannot add type in unknown keyspace %s", name.getKeyspace()));
 
-        if (ksm.userTypes.getType(name.getUserTypeName()) != null && !ifNotExists)
+        if (ksm.types.get(name.getUserTypeName()).isPresent() && !ifNotExists)
             throw new InvalidRequestException(String.format("A user type of name %s already exists", name));
 
         for (CQL3Type.Raw type : columnTypes)
@@ -122,7 +122,7 @@ public boolean announceMigration(boolean isLocalOnly) throws InvalidRequestExcep
         assert ksm != null; // should haven't validate otherwise
 
         // Can happen with ifNotExists
-        if (ksm.userTypes.getType(name.getUserTypeName()) != null)
+        if (ksm.types.get(name.getUserTypeName()).isPresent())
             return false;
 
         UserType type = createType();

File: test/unit/org/apache/cassandra/cql3/selection/SelectionColumnMappingTest.java
Patch:
@@ -46,7 +46,7 @@ public void testSelectionColumnMapping() throws Throwable
                                     " v1 int," +
                                     " v2 ascii," +
                                     " v3 frozen<" + typeName + ">)");
-        userType = Schema.instance.getKSMetaData(KEYSPACE).userTypes.getType(ByteBufferUtil.bytes(typeName));
+        userType = Schema.instance.getKSMetaData(KEYSPACE).types.get(ByteBufferUtil.bytes(typeName)).get();
         functionName = createFunction(KEYSPACE, "int, ascii",
                                       "CREATE FUNCTION %s (i int, a ascii) " +
                                       "CALLED ON NULL INPUT " +

File: test/burn/org/apache/cassandra/concurrent/LongSharedExecutorPoolTest.java
Patch:
@@ -116,7 +116,7 @@ private void testPromptnessOfExecution(long intervalNanos, float loadIncrement)
         final ExecutorService[] executors = new ExecutorService[executorCount];
         for (int i = 0 ; i < executors.length ; i++)
         {
-            executors[i] = SharedExecutorPool.SHARED.newExecutor(threadCount, maxQueued, "test" + i, "test" + i);
+            executors[i] = JMXEnabledSharedExecutorPool.SHARED.newExecutor(threadCount, maxQueued, "test" + i, "test" + i);
             threadCounts[i] = threadCount;
             workCount[i] = new WeibullDistribution(2, maxQueued);
             threadCount *= 2;

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -1606,7 +1606,7 @@ public ParsedStatement.Prepared prepare() throws InvalidRequestException
                 Boolean indexed = stmt.restrictedNames.get(clusteringColumn);
                 if (indexed == null)
                     break;
-                if (!indexed)
+                if (!indexed || !stmt.usesSecondaryIndexing)
                     stmt.restrictedNames.remove(clusteringColumn);
             }
 

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -259,6 +259,8 @@ public class Config
     public static final int otc_coalescing_window_us_default = 200;
     public int otc_coalescing_window_us = otc_coalescing_window_us_default;
 
+    public int windows_timer_interval = 0;
+
     public boolean enable_user_defined_functions = false;
 
     public static boolean getOutboundBindAny()

File: src/java/org/apache/cassandra/transport/Server.java
Patch:
@@ -136,7 +136,6 @@ private void run()
         // Configure the server.
         eventExecutorGroup = new RequestThreadPoolExecutor();
 
-
         boolean hasEpoll = enableEpoll ? Epoll.isAvailable() : false;
         if (hasEpoll)
         {

File: src/java/org/apache/cassandra/io/sstable/SSTableReader.java
Patch:
@@ -264,6 +264,9 @@ public boolean apply(SSTableReader sstable)
             ICardinality cardinality = null;
             for (SSTableReader sstable : sstables)
             {
+                if (sstable.openReason == OpenReason.EARLY)
+                    continue;
+
                 try
                 {
                     CompactionMetadata metadata = (CompactionMetadata) sstable.descriptor.getMetadataSerializer().deserialize(sstable.descriptor, MetadataType.COMPACTION);

File: src/java/org/apache/cassandra/hadoop/cql3/CqlRecordReader.java
Patch:
@@ -37,7 +37,7 @@
 import com.datastax.driver.core.Cluster;
 import com.datastax.driver.core.ColumnDefinitions;
 import com.datastax.driver.core.ColumnMetadata;
-import com.datastax.driver.core.DateWithoutTime;
+import com.datastax.driver.core.LocalDate;
 import com.datastax.driver.core.Metadata;
 import com.datastax.driver.core.ResultSet;
 import com.datastax.driver.core.Row;
@@ -418,13 +418,13 @@ public Date getTimestamp(String s)
         }
 
         @Override
-        public DateWithoutTime getDate(int i)
+        public LocalDate getDate(int i)
         {
             return row.getDate(i);
         }
 
         @Override
-        public DateWithoutTime getDate(String s)
+        public LocalDate getDate(String s)
         {
             return row.getDate(s);
         }

File: test/long/org/apache/cassandra/db/commitlog/CommitLogStressTest.java
Patch:
@@ -161,7 +161,7 @@ public void cleanDir()
     @Test
     public void testRandomSize() throws Exception
     {
-        randomSize = false;
+        randomSize = true;
         discardedRun = false;
         testAllLogConfigs();
     }

File: src/java/org/apache/cassandra/auth/CassandraRoleManager.java
Patch:
@@ -43,7 +43,7 @@
 import org.mindrot.jbcrypt.BCrypt;
 
 /**
- * Responsible for the creation, maintainance and delation of roles
+ * Responsible for the creation, maintenance and deletion of roles
  * for the purposes of authentication and authorization.
  * Role data is stored internally, using the roles and role_members tables
  * in the system_auth keyspace.
@@ -65,7 +65,7 @@
  * extends CassandraRoleManager and which includes Option.PASSWORD in the Set<Option>
  * returned from supportedOptions/alterableOptions. Any additional processing
  * of the password itself (such as storing it in an alternative location) would
- * be added in overriden createRole and alterRole implementations.
+ * be added in overridden createRole and alterRole implementations.
  */
 public class CassandraRoleManager implements IRoleManager
 {
@@ -437,7 +437,7 @@ private void collectRoles(Role role, Set<RoleResource> collected, boolean includ
         for (String memberOf : role.memberOf)
         {
             Role granted = getRole(memberOf);
-            if (role.equals(NULL_ROLE))
+            if (granted.equals(NULL_ROLE))
                 continue;
             collected.add(RoleResource.role(granted.name));
             if (includeInherited)

File: src/java/org/apache/cassandra/transport/Frame.java
Patch:
@@ -34,6 +34,8 @@
 
 public class Frame
 {
+    public static final byte PROTOCOL_VERSION_MASK = 0x7f;
+
     public final Header header;
     public final ByteBuf body;
 
@@ -178,7 +180,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> re
 
             int firstByte = buffer.getByte(idx++);
             Message.Direction direction = Message.Direction.extractFromVersion(firstByte);
-            int version = firstByte & 0x7F;
+            int version = firstByte & PROTOCOL_VERSION_MASK;
 
             if (version > Server.CURRENT_VERSION)
                 throw new ProtocolException("Invalid or unsupported protocol version: " + version);

File: src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java
Patch:
@@ -369,7 +369,7 @@ public static SSTableReader openNoValidation(Descriptor descriptor, Set<Componen
     public static SSTableReader openForBatch(Descriptor descriptor, Set<Component> components, CFMetaData metadata, IPartitioner partitioner) throws IOException
     {
         // Minimum components without which we can't do anything
-        assert components.contains(Component.DATA) : "Data component is missing for sstable" + descriptor;
+        assert components.contains(Component.DATA) : "Data component is missing for sstable " + descriptor;
         assert components.contains(Component.PRIMARY_INDEX) : "Primary index component is missing for sstable " + descriptor;
 
         Map<MetadataType, MetadataComponent> sstableMetadata = descriptor.getMetadataSerializer().deserialize(descriptor,
@@ -415,7 +415,7 @@ private static SSTableReader open(Descriptor descriptor,
                                       boolean validate) throws IOException
     {
         // Minimum components without which we can't do anything
-        assert components.contains(Component.DATA) : "Data component is missing for sstable" + descriptor;
+        assert components.contains(Component.DATA) : "Data component is missing for sstable " + descriptor;
         assert components.contains(Component.PRIMARY_INDEX) : "Primary index component is missing for sstable " + descriptor;
 
         Map<MetadataType, MetadataComponent> sstableMetadata = descriptor.getMetadataSerializer().deserialize(descriptor,

File: src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java
Patch:
@@ -369,7 +369,7 @@ public static SSTableReader openNoValidation(Descriptor descriptor, Set<Componen
     public static SSTableReader openForBatch(Descriptor descriptor, Set<Component> components, CFMetaData metadata, IPartitioner partitioner) throws IOException
     {
         // Minimum components without which we can't do anything
-        assert components.contains(Component.DATA) : "Data component is missing for sstable" + descriptor;
+        assert components.contains(Component.DATA) : "Data component is missing for sstable " + descriptor;
         assert components.contains(Component.PRIMARY_INDEX) : "Primary index component is missing for sstable " + descriptor;
 
         Map<MetadataType, MetadataComponent> sstableMetadata = descriptor.getMetadataSerializer().deserialize(descriptor,
@@ -415,7 +415,7 @@ private static SSTableReader open(Descriptor descriptor,
                                       boolean validate) throws IOException
     {
         // Minimum components without which we can't do anything
-        assert components.contains(Component.DATA) : "Data component is missing for sstable" + descriptor;
+        assert components.contains(Component.DATA) : "Data component is missing for sstable " + descriptor;
         assert components.contains(Component.PRIMARY_INDEX) : "Primary index component is missing for sstable " + descriptor;
 
         Map<MetadataType, MetadataComponent> sstableMetadata = descriptor.getMetadataSerializer().deserialize(descriptor,

File: test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
Patch:
@@ -1109,7 +1109,7 @@ public void testSliceByNamesCommandOldMetadata() throws Throwable
         CellName cname = cellname("c1");
         Keyspace keyspace = Keyspace.open(keyspaceName);
         ColumnFamilyStore cfs = keyspace.getColumnFamilyStore(cfName);
-        cfs.clearUnsafe();
+        cfs.truncateBlocking();
 
         // Create a cell a 'high timestamp'
         putColsStandard(cfs, key, new BufferCell(cname, ByteBufferUtil.bytes("a"), 2));

File: src/java/org/apache/cassandra/db/RangeTombstoneList.java
Patch:
@@ -116,7 +116,7 @@ public void add(RangeTombstone tombstone)
     /**
      * Adds a new range tombstone.
      *
-     * This method will be faster if the new tombstone sort after all the currently existing ones (this is a common use case), 
+     * This method will be faster if the new tombstone sort after all the currently existing ones (this is a common use case),
      * but it doesn't assume it.
      */
     public void add(ByteBuffer start, ByteBuffer end, long markedAt, int delTime)
@@ -130,7 +130,7 @@ public void add(ByteBuffer start, ByteBuffer end, long markedAt, int delTime)
         int c = comparator.compare(ends[size-1], start);
 
         // Fast path if we add in sorted order
-        if (c <= 0)
+        if (c < 0)
         {
             addInternal(size, start, end, markedAt, delTime);
         }

File: src/java/org/apache/cassandra/cql3/functions/FunctionCall.java
Patch:
@@ -133,7 +133,7 @@ public Term prepare(String keyspace, ColumnSpecification receiver) throws Invali
 
             // Functions.get() will complain if no function "name" type check with the provided arguments.
             // We still have to validate that the return type matches however
-            if (!receiver.type.isValueCompatibleWith(scalarFun.returnType()))
+            if (!scalarFun.testAssignment(keyspace, receiver).isAssignable())
                 throw new InvalidRequestException(String.format("Type error: cannot assign result of function %s (type %s) to %s (type %s)",
                                                                 scalarFun.name(), scalarFun.returnType().asCQL3Type(),
                                                                 receiver.name, receiver.type.asCQL3Type()));

File: test/unit/org/apache/cassandra/cql3/UFIdentificationTest.java
Patch:
@@ -87,7 +87,7 @@ public void setup() throws Throwable
         sFunc = createEchoFunction("set<int>");
         mFunc = createEchoFunction("map<int, int>");
         uFunc = createEchoFunction("timeuuid");
-        udtFunc = createEchoFunction("frozen<" + userType + ">");
+        udtFunc = createEchoFunction(userType);
     }
 
     @Test

File: src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
Patch:
@@ -184,7 +184,7 @@ public SliceQueryFilter withUpdatedStart(Composite newStart, CFMetaData cfm)
             }
             else if (slice.includes(cmp, newStart))
             {
-                if (!reversed && sliceIncludesStatics(slice, cfm) && !newStart.equals(ByteBufferUtil.EMPTY_BYTE_BUFFER))
+                if (!reversed && sliceIncludesStatics(slice, cfm) && !newStart.isEmpty())
                     newSlices.add(new ColumnSlice(Composites.EMPTY, cfm.comparator.staticPrefix().end()));
 
                 newSlices.add(new ColumnSlice(newStart, slice.finish));

File: src/java/org/apache/cassandra/io/compress/CompressionParameters.java
Patch:
@@ -116,7 +116,7 @@ public void setCrcCheckChance(double crcCheckChance) throws ConfigurationExcepti
         validateCrcCheckChance(crcCheckChance);
         this.crcCheckChance = crcCheckChance;
 
-        if (liveMetadata != null)
+        if (liveMetadata != null && this != liveMetadata.compressionParameters)
             liveMetadata.compressionParameters.setCrcCheckChance(crcCheckChance);
     }
 

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1682,7 +1682,7 @@ public ExtendedFilter makeExtendedFilter(AbstractBounds<RowPosition> keyRange,
                                              boolean countCQL3Rows,
                                              long now)
     {
-        DataRange dataRange = new DataRange.Paging(keyRange, columnRange, columnStart, columnStop, metadata.comparator);
+        DataRange dataRange = new DataRange.Paging(keyRange, columnRange, columnStart, columnStop, metadata);
         return ExtendedFilter.create(this, dataRange, rowFilter, maxResults, countCQL3Rows, now);
     }
 
@@ -1714,7 +1714,7 @@ public ExtendedFilter makeExtendedFilter(AbstractBounds<RowPosition> range,
             // create a new SliceQueryFilter that selects all cells, but pass the original slice start and finish
             // through to DataRange.Paging to be used on the first and last partitions
             SliceQueryFilter newFilter = new SliceQueryFilter(ColumnSlice.ALL_COLUMNS_ARRAY, sfilter.isReversed(), sfilter.count);
-            dataRange = new DataRange.Paging(range, newFilter, sfilter.start(), sfilter.finish(), metadata.comparator);
+            dataRange = new DataRange.Paging(range, newFilter, sfilter.start(), sfilter.finish(), metadata);
         }
         else
         {

File: src/java/org/apache/cassandra/service/pager/RangeSliceQueryPager.java
Patch:
@@ -93,7 +93,7 @@ protected boolean containsPreviousLast(Row first)
             return false;
 
         // Same as SliceQueryPager, we ignore a deleted column
-        Column firstColumn = isReversed() ? lastColumn(first.cf) : firstColumn(first.cf);
+        Column firstColumn = isReversed() ? lastColumn(first.cf) : firstNonStaticColumn(first.cf);
         return !first.cf.deletionInfo().isDeleted(firstColumn)
             && firstColumn.isLive(timestamp())
             && lastReturnedName.equals(firstColumn.name());
@@ -102,7 +102,7 @@ protected boolean containsPreviousLast(Row first)
     protected boolean recordLast(Row last)
     {
         lastReturnedKey = last.key;
-        lastReturnedName = (isReversed() ? firstColumn(last.cf) : lastColumn(last.cf)).name();
+        lastReturnedName = (isReversed() ? firstNonStaticColumn(last.cf) : lastColumn(last.cf)).name();
         return true;
     }
 

File: src/java/org/apache/cassandra/service/pager/SliceQueryPager.java
Patch:
@@ -78,7 +78,7 @@ protected List<Row> queryNextPage(int pageSize, ConsistencyLevel consistencyLeve
         // more rows than we're supposed to.  See CASSANDRA-8108 for more details.
         SliceQueryFilter filter = command.filter.withUpdatedCount(Math.min(command.filter.count, pageSize));
         if (lastReturned != null)
-            filter = filter.withUpdatedStart(lastReturned, cfm.comparator);
+            filter = filter.withUpdatedStart(lastReturned, cfm);
 
         logger.debug("Querying next page of slice query; new filter: {}", filter);
         ReadCommand pageCmd = command.withUpdatedFilter(filter);
@@ -92,7 +92,7 @@ protected boolean containsPreviousLast(Row first)
         if (lastReturned == null)
             return false;
 
-        Column firstColumn = isReversed() ? lastColumn(first.cf) : firstColumn(first.cf);
+        Column firstColumn = isReversed() ? lastColumn(first.cf) : firstNonStaticColumn(first.cf);
         // Note: we only return true if the column is the lastReturned *and* it is live. If it is deleted, it is ignored by the
         // rest of the paging code (it hasn't been counted as live in particular) and we want to act as if it wasn't there.
         return !first.cf.deletionInfo().isDeleted(firstColumn)
@@ -102,7 +102,7 @@ protected boolean containsPreviousLast(Row first)
 
     protected boolean recordLast(Row last)
     {
-        Column lastColumn = isReversed() ? firstColumn(last.cf) : lastColumn(last.cf);
+        Column lastColumn = isReversed() ? firstNonStaticColumn(last.cf) : lastColumn(last.cf);
         lastReturned = lastColumn.name();
         return true;
     }

File: test/unit/org/apache/cassandra/cql3/MultiColumnRelationTest.java
Patch:
@@ -704,6 +704,8 @@ public void testMultipleClusteringColumnInequalityReversedComponents() throws Th
     {
         for (String tableSuffix : new String[]{"", "_compact"})
         {
+            execute("DELETE FROM %s.multiple_clustering_reversed" + tableSuffix + " WHERE a=0");
+
             // b and d are reversed in the clustering order
             execute("INSERT INTO %s.multiple_clustering_reversed" + tableSuffix + " (a, b, c, d) VALUES (0, 1, 0, 0)");
             execute("INSERT INTO %s.multiple_clustering_reversed" + tableSuffix + " (a, b, c, d) VALUES (0, 1, 1, 1)");

File: src/java/org/apache/cassandra/service/CacheService.java
Patch:
@@ -335,7 +335,7 @@ public class KeyCacheSerializer implements CacheSerializer<KeyCacheKey, RowIndex
     {
         public void serialize(KeyCacheKey key, DataOutput out) throws IOException
         {
-            RowIndexEntry entry = CacheService.instance.keyCache.get(key);
+            RowIndexEntry entry = CacheService.instance.keyCache.getInternal(key);
             if (entry == null)
                 return;
             ByteBufferUtil.writeWithLength(key.key, out);

File: src/java/org/apache/cassandra/db/compaction/Scrubber.java
Patch:
@@ -186,7 +186,7 @@ public void scrub()
                     }
 
                     if (dataSize > dataFile.length())
-                        throw new IOError(new IOException("Impossible row size " + dataSize));
+                        throw new IOError(new IOException("Impossible row size (greater than file length): " + dataSize));
 
                     if (dataStart != dataStartFromIndex)
                         outputHandler.warn(String.format("Data file row position %d differs from index file row position %d", dataStart, dataStartFromIndex));

File: src/java/org/apache/cassandra/db/compaction/Scrubber.java
Patch:
@@ -199,7 +199,7 @@ public void scrub()
                         throw new IOError(new IOException("Impossible row size (greater than file length): " + dataSize));
 
                     if (dataStart != dataStartFromIndex)
-                        outputHandler.warn(String.format("Data file row position %d differs from index file row position %d", dataStart, dataSizeFromIndex));
+                        outputHandler.warn(String.format("Data file row position %d differs from index file row position %d", dataStart, dataStartFromIndex));
 
                     if (dataSize != dataSizeFromIndex)
                         outputHandler.warn(String.format("Data file row size %d differs from index file row size %d", dataSize, dataSizeFromIndex));

File: test/unit/org/apache/cassandra/io/util/DataOutputTest.java
Patch:
@@ -247,7 +247,7 @@ private void testRead(DataInput test, DataInput canon) throws IOException
             test.readInt();
             assert false;
         }
-        catch (EOFException _)
+        catch (EOFException exc)
         {
         }
     }

File: test/unit/org/apache/cassandra/io/sstable/SSTableRewriterTest.java
Patch:
@@ -776,7 +776,8 @@ public void testCanonicalView() throws IOException
         }
         writer.abort();
         cfs.getDataTracker().unmarkCompacting(sstables);
-        truncateCF();
+        cfs.truncateBlocking();
+        SSTableDeletingTask.waitForDeletions();
         validateCFS(cfs);
     }
 

File: test/unit/org/apache/cassandra/io/sstable/SSTableRewriterTest.java
Patch:
@@ -774,8 +774,10 @@ public void testCanonicalView() throws IOException
                 }
             }
         }
-        writer.finish();
+        writer.abort();
         cfs.getDataTracker().unmarkCompacting(sstables);
+        truncateCF();
+        validateCFS(cfs);
     }
 
     private void validateKeys(Keyspace ks)

File: test/unit/org/apache/cassandra/io/sstable/SSTableRewriterTest.java
Patch:
@@ -817,8 +817,10 @@ public void testCanonicalView() throws IOException
                 }
             }
         }
-        writer.finish();
+        writer.abort();
         cfs.getDataTracker().unmarkCompacting(sstables);
+        truncateCF();
+        validateCFS(cfs);
     }
 
     private void validateKeys(Keyspace ks)

File: src/java/org/apache/cassandra/serializers/TimeSerializer.java
Patch:
@@ -46,7 +46,7 @@ public static Long timeStringToLong(String source) throws MarshalException
             try
             {
                 long result = Long.parseLong(source);
-                if (result < 0 || result > TimeUnit.DAYS.toNanos(1))
+                if (result < 0 || result >= TimeUnit.DAYS.toNanos(1))
                     throw new NumberFormatException("Input long out of bounds: " + source);
                 return result;
             }

File: src/java/org/apache/cassandra/cql3/CQL3Type.java
Patch:
@@ -48,8 +48,10 @@ public enum Native implements CQL3Type
         FLOAT       (FloatType.instance),
         INET        (InetAddressType.instance),
         INT         (Int32Type.instance),
+        SMALLINT    (ShortType.instance),
         TEXT        (UTF8Type.instance),
         TIMESTAMP   (TimestampType.instance),
+        TINYINT     (ByteType.instance),
         UUID        (UUIDType.instance),
         VARCHAR     (UTF8Type.instance),
         VARINT      (IntegerType.instance),

File: src/java/org/apache/cassandra/cql3/Constants.java
Patch:
@@ -198,7 +198,9 @@ public AssignmentTestable.TestResult testAssignment(String keyspace, ColumnSpeci
                         case DOUBLE:
                         case FLOAT:
                         case INT:
+                        case SMALLINT:
                         case TIMESTAMP:
+                        case TINYINT:
                         case VARINT:
                             return AssignmentTestable.TestResult.WEAKLY_ASSIGNABLE;
                     }

File: src/java/org/apache/cassandra/transport/DataType.java
Patch:
@@ -53,13 +53,14 @@ public enum DataType implements OptionCodec.Codecable<DataType>
     INET     (16, InetAddressType.instance, 1),
     DATE     (17, SimpleDateType.instance, 4),
     TIME     (18, TimeType.instance, 4),
+    SMALLINT (19, ShortType.instance, 4),
+    BYTE     (20, ByteType.instance, 4),
     LIST     (32, null, 1),
     MAP      (33, null, 1),
     SET      (34, null, 1),
     UDT      (48, null, 3),
     TUPLE    (49, null, 3);
 
-
     public static final OptionCodec<DataType> codec = new OptionCodec<DataType>(DataType.class);
 
     private final int id;

File: src/java/org/apache/cassandra/db/marshal/SimpleDateType.java
Patch:
@@ -39,6 +39,7 @@ public int compare(ByteBuffer o1, ByteBuffer o2)
         return ByteBufferUtil.compareUnsigned(o1, o2);
     }
 
+    @Override
     public boolean isByteOrderComparable()
     {
         return true;
@@ -61,7 +62,6 @@ public boolean isValueCompatibleWithInternal(AbstractType<?> otherType)
         return this == otherType || otherType == IntegerType.instance;
     }
 
-    @Override
     public Term fromJSONObject(Object parsed) throws MarshalException
     {
         try

File: src/java/org/apache/cassandra/db/marshal/TimeType.java
Patch:
@@ -45,6 +45,7 @@ public ByteBuffer fromString(String source) throws MarshalException
         return decompose(TimeSerializer.timeStringToLong(source));
     }
 
+    @Override
     public boolean isByteOrderComparable()
     {
         return true;
@@ -62,7 +63,6 @@ public boolean isValueCompatibleWithInternal(AbstractType<?> otherType)
         return this == otherType || otherType == LongType.instance;
     }
 
-    @Override
     public Term fromJSONObject(Object parsed) throws MarshalException
     {
         try
@@ -82,6 +82,7 @@ public String toJSONString(ByteBuffer buffer, int protocolVersion)
         return '"' + TimeSerializer.instance.toString(TimeSerializer.instance.deserialize(buffer)) + '"';
     }
 
+    @Override
     public CQL3Type asCQL3Type()
     {
         return CQL3Type.Native.TIME;

File: src/java/org/apache/cassandra/transport/Event.java
Patch:
@@ -29,9 +29,9 @@
 public abstract class Event
 {
     public enum Type {
-        TOPOLOGY_CHANGE(Server.VERSION_2),
-        STATUS_CHANGE(Server.VERSION_2),
-        SCHEMA_CHANGE(Server.VERSION_2),
+        TOPOLOGY_CHANGE(Server.VERSION_1),
+        STATUS_CHANGE(Server.VERSION_1),
+        SCHEMA_CHANGE(Server.VERSION_1),
         TRACE_COMPLETE(Server.VERSION_4);
 
         public final int minimumVersion;

File: test/unit/org/apache/cassandra/db/compaction/LeveledCompactionStrategyTest.java
Patch:
@@ -104,6 +104,9 @@ public void truncateSTandardLeveled()
     public void testGrouperLevels() throws Exception{
         ByteBuffer value = ByteBuffer.wrap(new byte[100 * 1024]); // 100 KB value, make it easy to have multiple files
 
+        //Need entropy to prevent compression so size is predictable with compression enabled/disabled
+        new Random().nextBytes(value.array());
+
         // Enough data to have a level 1 and 2
         int rows = 20;
         int columns = 10;

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -196,7 +196,7 @@ public void printBanner()
     {
         sessionState.out.println("Welcome to Cassandra CLI version " + FBUtilities.getReleaseVersionString() + "\n");
 
-        sessionState.out.println("The CLI is deprecated and will be removed in Cassandra 3.0.  Consider migrating to cqlsh.");
+        sessionState.out.println("The CLI is deprecated and will be removed in Cassandra 2.2.  Consider migrating to cqlsh.");
         sessionState.out.println("CQL is fully backwards compatible with Thrift data; see http://www.datastax.com/dev/blog/thrift-to-cql3\n");
 
         sessionState.out.println(getHelp().banner);

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -3770,6 +3770,8 @@ public String getDrainProgress()
      */
     public synchronized void drain() throws IOException, InterruptedException, ExecutionException
     {
+        inShutdownHook = true;
+        
         ExecutorService counterMutationStage = StageManager.getStage(Stage.COUNTER_MUTATION);
         ExecutorService mutationStage = StageManager.getStage(Stage.MUTATION);
         if (mutationStage.isTerminated() && counterMutationStage.isTerminated())

File: src/java/org/apache/cassandra/db/marshal/UserType.java
Patch:
@@ -145,6 +145,9 @@ public void validate(ByteBuffer bytes) throws MarshalException
     @Override
     public Term fromJSONObject(Object parsed) throws MarshalException
     {
+        if (parsed instanceof String)
+            parsed = Json.decodeJson((String) parsed);
+
         if (!(parsed instanceof Map))
             throw new MarshalException(String.format(
                     "Expected a map, but got a %s: %s", parsed.getClass().getSimpleName(), parsed));

File: src/java/org/apache/cassandra/io/sstable/SSTableLoader.java
Patch:
@@ -129,7 +129,7 @@ public boolean accept(File dir, String name)
                         Ref ref = sstable.tryRef();
                         if (ref == null)
                             throw new IllegalStateException("Could not acquire ref for "+sstable);
-                        StreamSession.SSTableStreamingSections details = new StreamSession.SSTableStreamingSections(sstable, ref, sstableSections, estimatedKeys, ActiveRepairService.UNREPAIRED_SSTABLE);
+                        StreamSession.SSTableStreamingSections details = new StreamSession.SSTableStreamingSections(ref, sstableSections, estimatedKeys, ActiveRepairService.UNREPAIRED_SSTABLE);
                         streamingDetails.put(endpoint, details);
                     }
 

File: src/java/org/apache/cassandra/utils/concurrent/Refs.java
Patch:
@@ -59,7 +59,7 @@ public void close()
      * @param referenced the object we have a Ref to
      * @return the Ref to said object
      */
-    public Ref get(T referenced)
+    public Ref<T> get(T referenced)
     {
         return references.get(referenced);
     }

File: test/unit/org/apache/cassandra/io/sstable/LegacySSTableTest.java
Patch:
@@ -118,7 +118,7 @@ private void testStreaming(String version) throws Exception
         ranges.add(new Range<>(p.getMinimumToken(), p.getToken(ByteBufferUtil.bytes("100"))));
         ranges.add(new Range<>(p.getToken(ByteBufferUtil.bytes("100")), p.getMinimumToken()));
         ArrayList<StreamSession.SSTableStreamingSections> details = new ArrayList<>();
-        details.add(new StreamSession.SSTableStreamingSections(sstable, sstable.ref(),
+        details.add(new StreamSession.SSTableStreamingSections(sstable.ref(),
                                                                sstable.getPositionsForRanges(ranges),
                                                                sstable.estimatedKeysForRanges(ranges), sstable.getSSTableMetadata().repairedAt));
         new StreamPlan("LegacyStreamingTest").transferFiles(FBUtilities.getBroadcastAddress(), details)

File: test/unit/org/apache/cassandra/streaming/StreamTransferTaskTest.java
Patch:
@@ -64,7 +64,7 @@ public void testScheduleTimeout() throws Exception
         {
             List<Range<Token>> ranges = new ArrayList<>();
             ranges.add(new Range<>(sstable.first.getToken(), sstable.last.getToken()));
-            task.addTransferFile(sstable, sstable.selfRef(), 1, sstable.getPositionsForRanges(ranges), 0);
+            task.addTransferFile(sstable.selfRef(), 1, sstable.getPositionsForRanges(ranges), 0);
         }
         assertEquals(2, task.getTotalNumberOfFiles());
 

File: test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java
Patch:
@@ -212,7 +212,7 @@ private Collection<StreamSession.SSTableStreamingSections> makeStreamingDetails(
         ArrayList<StreamSession.SSTableStreamingSections> details = new ArrayList<>();
         for (SSTableReader sstable : sstables)
         {
-            details.add(new StreamSession.SSTableStreamingSections(sstable, sstables.get(sstable),
+            details.add(new StreamSession.SSTableStreamingSections(sstables.get(sstable),
                                                                    sstable.getPositionsForRanges(ranges),
                                                                    sstable.estimatedKeysForRanges(ranges), sstable.getSSTableMetadata().repairedAt));
         }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1396,7 +1396,7 @@ public ColumnFamily getColumnFamily(QueryFilter filter)
             if (filter.filter instanceof SliceQueryFilter)
             {
                 // Log the number of tombstones scanned on single key queries
-                metric.tombstoneScannedHistogram.update(((SliceQueryFilter) filter.filter).lastIgnored());
+                metric.tombstoneScannedHistogram.update(((SliceQueryFilter) filter.filter).lastTombstones());
                 metric.liveScannedHistogram.update(((SliceQueryFilter) filter.filter).lastLive());
             }
         }

File: src/java/org/apache/cassandra/locator/ReconnectableSnitchHelper.java
Patch:
@@ -60,7 +60,6 @@ private void reconnect(InetAddress publicAddress, VersionedValue localAddressVal
     private void reconnect(InetAddress publicAddress, InetAddress localAddress)
     {
         if (snitch.getDatacenter(publicAddress).equals(localDc)
-                && MessagingService.instance().getVersion(publicAddress) == MessagingService.current_version
                 && !MessagingService.instance().getConnectionPool(publicAddress).endPoint().equals(localAddress))
         {
             MessagingService.instance().getConnectionPool(publicAddress).reset(localAddress);

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -114,6 +114,8 @@ public class Config
     public String broadcast_address;
     public String internode_authenticator;
 
+    /* intentionally left set to true, despite being set to false in stock 2.2 cassandra.yaml
+       we don't want to surprise Thrift users who have the setting blank in the yaml during 2.1->2.2 upgrade */
     public Boolean start_rpc = true;
     public String rpc_address;
     public String rpc_interface;

File: src/java/org/apache/cassandra/db/commitlog/AbstractCommitLogService.java
Patch:
@@ -177,7 +177,7 @@ public void awaitTermination() throws InterruptedException
 
     public long getCompletedTasks()
     {
-        return written.incrementAndGet();
+        return written.get();
     }
 
     public long getPendingTasks()

File: src/java/org/apache/cassandra/io/sstable/metadata/MetadataSerializer.java
Patch:
@@ -108,9 +108,10 @@ public Map<MetadataType, MetadataComponent> deserialize(Descriptor descriptor, F
         int numComponents = in.readInt();
         // read toc
         Map<MetadataType, Integer> toc = new HashMap<>(numComponents);
+        MetadataType[] values = MetadataType.values();
         for (int i = 0; i < numComponents; i++)
         {
-            toc.put(MetadataType.values()[in.readInt()], in.readInt());
+            toc.put(values[in.readInt()], in.readInt());
         }
         for (MetadataType type : types)
         {

File: src/java/org/apache/cassandra/cql3/functions/UDAggregate.java
Patch:
@@ -100,6 +100,8 @@ public boolean hasReferenceTo(Function function)
 
     public Iterable<Function> getFunctions()
     {
+        if (stateFunction == null)
+            return Collections.emptySet();
         if (finalFunction != null)
             return ImmutableSet.of(this, stateFunction, finalFunction);
         else

File: tools/stress/src/org/apache/cassandra/stress/util/DynamicList.java
Patch:
@@ -153,10 +153,11 @@ public Node<E> append(E value, int maxSize)
     public void remove(Node<E> node)
     {
         lock.writeLock().lock();
-        node.value = null;
         try
         {
             assert node.value != null;
+            node.value = null;
+
             size--;
 
             // go up through each level in the skip list, unlinking this node; this entails

File: test/unit/org/apache/cassandra/io/sstable/SSTableRewriterTest.java
Patch:
@@ -218,12 +218,12 @@ public void testFileRemoval() throws InterruptedException
         SSTableWriter writer = getWriter(cfs, dir);
         try
         {
-            for (int i = 0; i < 1000; i++)
+            for (int i = 0; i < 10000; i++)
                 writer.append(StorageService.getPartitioner().decorateKey(random(i, 10)), cf);
             SSTableReader s = writer.openEarly(1000);
             assert s != null;
             assertFileCounts(dir.list(), 2, 2);
-            for (int i = 1000; i < 2000; i++)
+            for (int i = 10000; i < 20000; i++)
                 writer.append(StorageService.getPartitioner().decorateKey(random(i, 10)), cf);
             SSTableReader s2 = writer.openEarly(1000);
             assertTrue(s.last.compareTo(s2.last) < 0);

File: src/java/org/apache/cassandra/io/compress/SnappyCompressor.java
Patch:
@@ -96,6 +96,8 @@ public int uncompress(byte[] input, int inputOffset, int inputLength, byte[] out
 
     public int uncompress(ByteBuffer input, ByteBuffer output) throws IOException
     {
+        if (input.hasArray() && output.hasArray())
+            return Snappy.rawUncompress(input.array(), input.arrayOffset() + input.position(), input.remaining(), output.array(), output.arrayOffset() + output.position());
         return Snappy.uncompress(input, output);
     }
 

File: src/java/org/apache/cassandra/io/util/RandomAccessReader.java
Patch:
@@ -65,8 +65,8 @@ protected ByteBuffer allocateBuffer(int bufferSize, boolean useDirectBuffer)
     {
         int size = (int) Math.min(fileLength, bufferSize);
         return useDirectBuffer
-                ? ByteBuffer.allocate(size)
-                : ByteBuffer.allocateDirect(size);
+                ? ByteBuffer.allocateDirect(size)
+                : ByteBuffer.allocate(size);
     }
 
     public static RandomAccessReader open(ChannelProxy channel, long overrideSize, PoolingSegmentedFile owner)

File: src/java/org/apache/cassandra/io/util/SegmentedFile.java
Patch:
@@ -133,7 +133,7 @@ public void dropPageCache(long before)
      */
     public static Builder getBuilder(Config.DiskAccessMode mode, boolean compressed)
     {
-        return compressed ? new CompressedSegmentedFile.Builder(null)
+        return compressed ? new CompressedPoolingSegmentedFile.Builder(null)
                           : mode == Config.DiskAccessMode.mmap ? new MmappedSegmentedFile.Builder()
                                                                : new BufferedPoolingSegmentedFile.Builder();
     }

File: src/java/org/apache/cassandra/db/AbstractRangeCommand.java
Patch:
@@ -62,7 +62,7 @@ public List<Row> postReconciliationProcessing(List<Row> rows)
 
     private List<Row> trim(List<Row> rows)
     {
-        if (countCQL3Rows())
+        if (countCQL3Rows() || ignoredTombstonedPartitions())
             return rows;
         else
             return rows.size() > limit() ? rows.subList(0, limit()) : rows;

File: src/java/org/apache/cassandra/hadoop/pig/CqlNativeStorage.java
Patch:
@@ -499,8 +499,8 @@ public ResourceSchema getSchema(String location, Job job) throws IOException
         for (ColumnInfo cdef : cfInfo.getColumns())
         {
             ResourceFieldSchema valSchema = new ResourceFieldSchema();
-            AbstractType validator = validators.get(cdef.getName());
-            valSchema.setName(new String(cdef.getName()));
+            AbstractType<?> validator = validators.get(ByteBufferUtil.bytes(cdef.getName()));
+            valSchema.setName(cdef.getName());
             valSchema.setType(StorageHelper.getPigType(validator));
             allSchemaFields.add(valSchema);
         }
@@ -901,7 +901,7 @@ public String[] getPartitionKeys(String location, Job job) throws IOException
         String[] partitionKeys = new String[tableMetadata.getPartitionKey().size()];
         for (int i = 0; i < tableMetadata.getPartitionKey().size(); i++)
         {
-            partitionKeys[i] = new String(tableMetadata.getPartitionKey().get(i).getName());
+            partitionKeys[i] = tableMetadata.getPartitionKey().get(i).getName();
         }
         return partitionKeys;
     }

File: src/java/org/apache/cassandra/db/compaction/Scrubber.java
Patch:
@@ -187,7 +187,7 @@ public void scrub()
                     if (key == null)
                         throw new IOError(new IOException("Unable to read row key from data file"));
 
-                    if (!key.key.equals(currentIndexKey))
+                    if (currentIndexKey != null && !key.key.equals(currentIndexKey))
                     {
                         throw new IOError(new IOException(String.format("Key from data file (%s) does not match key from index file (%s)",
                                 ByteBufferUtil.bytesToHex(key.key), ByteBufferUtil.bytesToHex(currentIndexKey))));

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -1308,7 +1308,7 @@ public void run()
         return executor.submit(runnable);
     }
 
-    static int getDefaultGcBefore(ColumnFamilyStore cfs)
+    public static int getDefaultGcBefore(ColumnFamilyStore cfs)
     {
         // 2ndary indexes have ExpiringColumns too, so we need to purge tombstones deleted before now. We do not need to
         // add any GcGrace however since 2ndary indexes are local to a node.

File: test/unit/org/apache/cassandra/cql3/CrcCheckChanceTest.java
Patch:
@@ -140,7 +140,7 @@ public void testDropDuringCompaction() throws Throwable
         }
 
         DatabaseDescriptor.setCompactionThroughputMbPerSec(1);
-        List<Future<?>> futures = CompactionManager.instance.submitMaximal(cfs, CompactionManager.GC_ALL); 
+        List<Future<?>> futures = CompactionManager.instance.submitMaximal(cfs, CompactionManager.getDefaultGcBefore(cfs), false); 
         execute("DROP TABLE %s");
 
         try

File: test/unit/org/apache/cassandra/utils/NoSpamLoggerTest.java
Patch:
@@ -191,6 +191,8 @@ private void checkMock(Level l)
    @Test
    public void testLoggedResult() throws Exception
    {
+       now = 5;
+
        NoSpamLogger.log( mock, Level.INFO, 5,  TimeUnit.NANOSECONDS, statement, param);
        checkMock(Level.INFO);
 

File: src/java/org/apache/cassandra/repair/RepairSession.java
Patch:
@@ -276,7 +276,7 @@ public void onFailure(Throwable t)
             {
                 logger.error(String.format("[repair #%s] Session completed with the following error", getId()), t);
                 Tracing.traceRepair("Session completed with the following error: {}", t);
-                setException(t);
+                forceShutdown(t);
             }
         });
     }

File: src/java/org/apache/cassandra/cql3/functions/Function.java
Patch:
@@ -50,8 +50,6 @@ public interface Function
      */
     public boolean isAggregate();
 
-    boolean usesFunction(String ksName, String functionName);
-
     Iterable<Function> getFunctions();
 
     boolean hasReferenceTo(Function function);

File: test/unit/org/apache/cassandra/cql3/CQLTester.java
Patch:
@@ -303,7 +303,9 @@ private static void removeAllSSTables(String ks, List<String> tables)
     private static boolean containsAny(String filename, List<String> tables)
     {
         for (int i = 0, m = tables.size(); i < m; i++)
-            if (filename.contains(tables.get(i)))
+            // don't accidentally delete in-use directories with the
+            // same prefix as a table to delete, i.e. table_1 & table_11
+            if (filename.contains(tables.get(i) + "-"))
                 return true;
         return false;
     }

File: test/unit/org/apache/cassandra/cql3/UFIdentificationTest.java
Patch:
@@ -158,7 +158,7 @@ public void testModificationStatementWithConditions() throws Throwable
 
     @Test @Ignore
     // Technically, attributes like timestamp and ttl are Terms so could potentially
-    // resolve to function calls (& so you can call usesFunction & getFunctions on them)
+    // resolve to function calls (& so you can call getFunctions on them)
     // However, this is currently disallowed by CQL syntax
     public void testModificationStatementWithAttributesFromFunction() throws Throwable
     {

File: src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java
Patch:
@@ -589,7 +589,7 @@ private Set<String> filterByColumn(Set<String> idxNames)
         {
             for (ColumnDefinition column : baseCfs.metadata.allColumns())
             {
-                if (candidate.indexes(column.name))
+                if (candidate.getColumnDefs().contains(column))
                 {
                     filtered.add(candidate.getIndexName());
                     break;

File: src/java/org/apache/cassandra/io/compress/CompressionParameters.java
Patch:
@@ -108,7 +108,6 @@ public void setLiveMetadata(final CFMetaData liveMetadata)
         if (liveMetadata == null)
             return;
 
-        assert this.liveMetadata == null || this.liveMetadata == liveMetadata;
         this.liveMetadata = liveMetadata;
     }
 

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegmentManager.java
Patch:
@@ -413,7 +413,7 @@ private long unusedCapacity()
      * Throws a flag that enables the behavior of keeping at least one spare segment
      * available at all times.
      */
-    public void enableReserveSegmentCreation()
+    void enableReserveSegmentCreation()
     {
         createReserveSegments = true;
         wakeManager();

File: test/unit/org/apache/cassandra/config/DatabaseDescriptorTest.java
Patch:
@@ -18,6 +18,7 @@
 */
 package org.apache.cassandra.config;
 
+import java.io.IOException;
 import java.net.Inet4Address;
 import java.net.Inet6Address;
 import java.net.InetAddress;
@@ -76,7 +77,7 @@ public void testKSMetaDataSerialization() throws ConfigurationException
 
     // this came as a result of CASSANDRA-995
     @Test
-    public void testTransKsMigration() throws ConfigurationException
+    public void testTransKsMigration() throws ConfigurationException, IOException
     {
         SchemaLoader.cleanupAndLeaveDirs();
         Schema.instance.loadFromDisk();

File: test/unit/org/apache/cassandra/dht/OrderPreservingPartitionerTest.java
Patch:
@@ -18,6 +18,8 @@
 */
 package org.apache.cassandra.dht;
 
+import java.io.IOException;
+
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -26,7 +28,7 @@
 public class OrderPreservingPartitionerTest extends PartitionerTestCase
 {
     @BeforeClass
-    public static void cleanStatesFromPreviousTest()
+    public static void cleanStatesFromPreviousTest() throws IOException
     {
         // Since OrderPreservingPartitioner#describeOwnership tries to read SSTables,
         // we need to clear data dir to clear garbage from previous test before running tests.

File: src/java/org/apache/cassandra/db/compaction/AbstractCompactionStrategy.java
Patch:
@@ -64,6 +64,7 @@ public abstract class AbstractCompactionStrategy
     protected float tombstoneThreshold;
     protected long tombstoneCompactionInterval;
     protected boolean uncheckedTombstoneCompaction;
+    protected boolean disableTombstoneCompactions = false;
 
     /**
      * pause/resume/getNextBackgroundTask must synchronize.  This guarantees that after pause completes,
@@ -288,6 +289,8 @@ public List<ICompactionScanner> getScanners(Collection<SSTableReader> toCompact)
      */
     protected boolean worthDroppingTombstones(SSTableReader sstable, int gcBefore)
     {
+        if (disableTombstoneCompactions)
+            return false;
         // since we use estimations to calculate, there is a chance that compaction will not drop tombstones actually.
         // if that happens we will end up in infinite compaction loop, so first we check enough if enough time has
         // elapsed since SSTable created.

File: src/java/org/apache/cassandra/auth/IRoleManager.java
Patch:
@@ -27,7 +27,7 @@
 /**
  * Responsible for managing roles (which also includes what
  * used to be known as users), including creation, deletion,
- * alteration and the granting & revoking of roles to other
+ * alteration and the granting and revoking of roles to other
  * roles.
  */
 public interface IRoleManager

File: src/java/org/apache/cassandra/auth/PasswordAuthenticator.java
Patch:
@@ -48,7 +48,7 @@
  * Since 3.0, the management of roles (creation, modification,
  * querying etc is the responsibility of IRoleManager. Use of
  * PasswordAuthenticator requires the use of CassandraRoleManager
- * for storage & retrieval of encryted passwords.
+ * for storage and retrieval of encrypted passwords.
  */
 public class PasswordAuthenticator implements IAuthenticator
 {

File: src/java/org/apache/cassandra/config/Schema.java
Patch:
@@ -204,7 +204,7 @@ public void clearKeyspaceDefinition(KSMetaData ksm)
     }
 
     /**
-     * Given a keyspace name & column family name, get the column family
+     * Given a keyspace name and column family name, get the column family
      * meta data. If the keyspace name or column family name is not valid
      * this function returns null.
      *

File: src/java/org/apache/cassandra/cql3/restrictions/MultiColumnRestriction.java
Patch:
@@ -85,7 +85,7 @@ public final Restriction mergeWith(Restriction otherRestriction) throws InvalidR
      * Returns the names of the columns that are specified within this <code>Restrictions</code> and the other one
      * as a comma separated <code>String</code>.
      *
-     * @param otherRestrictions the other restrictions
+     * @param otherRestriction the other restrictions
      * @return the names of the columns that are specified within this <code>Restrictions</code> and the other one
      * as a comma separated <code>String</code>.
      */

File: src/java/org/apache/cassandra/db/Directories.java
Patch:
@@ -55,16 +55,18 @@
  * Encapsulate handling of paths to the data files.
  *
  * Since v2.1, the directory layout is the following:
+ * <pre> {@code
  *   /<path_to_data_dir>/ks/cf1-cfId/ks-cf1-ka-1-Data.db
  *                         /cf2-cfId/ks-cf2-ka-1-Data.db
  *                         ...
+ * } </pre>                      
  *
  * cfId is an hex encoded CFID.
  *
  * For backward compatibility, Directories uses older directory layout if exists.
  *
  * In addition, more that one 'root' data directory can be specified so that
- * <path_to_data_dir> potentially represents multiple locations.
+ * {@code <path_to_data_dir>} potentially represents multiple locations.
  * Note that in the case of multiple locations, the manifest for the leveled
  * compaction is only in one of the location.
  *

File: src/java/org/apache/cassandra/io/util/UnbufferedDataOutputStreamPlus.java
Patch:
@@ -31,9 +31,10 @@
 /**
  * Base class for DataOutput implementations that does not have an optimized implementations of Plus methods
  * and does no buffering.
- * <p/>
+ * <p>
  * Unlike BufferedDataOutputStreamPlus this is capable of operating as an unbuffered output stream.
  * Currently necessary because SequentialWriter implements its own buffering along with mark/reset/truncate.
+ * </p>
  */
 public abstract class UnbufferedDataOutputStreamPlus extends DataOutputStreamPlus
 {

File: src/java/org/apache/cassandra/metrics/CassandraMetricsRegistry.java
Patch:
@@ -30,8 +30,9 @@
 
 /**
  * Makes integrating 3.0 metrics API with 2.0.
- * <p/>
+ * <p>
  * The 3.0 API comes with poor JMX integration
+ * </p>
  */
 public class CassandraMetricsRegistry extends MetricRegistry
 {

File: src/java/org/apache/cassandra/repair/messages/RepairOption.java
Patch:
@@ -53,6 +53,7 @@ public class RepairOption
      * Available options are:
      *
      * <table>
+     *     <caption>Repair Options</caption>
      *     <thead>
      *         <tr>
      *             <th>key</th>

File: src/java/org/apache/cassandra/thrift/CustomTThreadPoolServer.java
Patch:
@@ -54,7 +54,7 @@
 
 /**
  * Slightly modified version of the Apache Thrift TThreadPoolServer.
- * <p/>
+ * <p>
  * This allows passing an executor so you have more control over the actual
  * behaviour of the tasks being run.
  * <p/>

File: src/java/org/apache/cassandra/tools/NodeProbe.java
Patch:
@@ -510,7 +510,7 @@ public void takeSnapshot(String snapshotName, String columnFamily, String... key
      * 
      * @param snapshotName
      *            the name of the snapshot.
-     * @param columnfamilylist
+     * @param columnFamilyList
      *            list of columnfamily from different keyspace in the form of ks1.cf1 ks2.cf2
      */
     public void takeMultipleColumnFamilySnapshot(String snapshotName, String... columnFamilyList)

File: src/java/org/apache/cassandra/transport/messages/AuthResponse.java
Patch:
@@ -28,7 +28,7 @@
 
 /**
  * A SASL token message sent from client to server. Some SASL
- * mechanisms & clients may send an initial token before
+ * mechanisms and clients may send an initial token before
  * receiving a challenge from the server.
  */
 public class AuthResponse extends Message.Request

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -1479,7 +1479,7 @@ public static long getTotalCommitlogSpaceInMB()
 
     public static int getSSTablePreempiveOpenIntervalInMB()
     {
-        return conf.sstable_preemptive_open_interval_in_mb;
+        return FBUtilities.isWindows() ? -1 : conf.sstable_preemptive_open_interval_in_mb;
     }
 
     public static boolean getTrickleFsync()

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegmentManager.java
Patch:
@@ -466,6 +466,7 @@ else if (!flushes.containsKey(dirtyCFId))
     public void stopUnsafe(boolean deleteSegments)
     {
         logger.debug("CLSM closing and clearing existing commit log segments...");
+        createReserveSegments = false;
 
         while (!segmentManagementTasks.isEmpty())
             Thread.yield();
@@ -509,7 +510,7 @@ private static void closeAndDeleteSegmentUnsafe(CommitLogSegment segment, boolea
         }
         catch (AssertionError ignored)
         {
-            // segment file does not exit
+            // segment file does not exist
         }
     }
 
@@ -519,7 +520,6 @@ private static void closeAndDeleteSegmentUnsafe(CommitLogSegment segment, boolea
     public void startUnsafe()
     {
         start();
-        wakeManager();
     }
 
     /**

File: test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
Patch:
@@ -115,6 +115,7 @@ public class ColumnFamilyStoreTest
     public static final String CF_STANDARD2 = "Standard2";
     public static final String CF_STANDARD3 = "Standard3";
     public static final String CF_STANDARD4 = "Standard4";
+    public static final String CF_STANDARD5 = "Standard5";
     public static final String CF_STANDARDINT = "StandardInteger1";
     public static final String CF_SUPER1 = "Super1";
     public static final String CF_SUPER6 = "Super6";
@@ -142,6 +143,7 @@ public static void defineSchema() throws ConfigurationException
                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD2),
                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD3),
                                     SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD4),
+                                    SchemaLoader.standardCFMD(KEYSPACE1, CF_STANDARD5),
                                     SchemaLoader.indexCFMD(KEYSPACE1, CF_INDEX1, true),
                                     SchemaLoader.indexCFMD(KEYSPACE1, CF_INDEX2, false),
                                     SchemaLoader.superCFMD(KEYSPACE1, CF_SUPER1, LongType.instance),
@@ -1874,7 +1876,7 @@ protected SSTableWriter getWriter()
     public void testLoadNewSSTablesAvoidsOverwrites() throws Throwable
     {
         String ks = KEYSPACE1;
-        String cf = CF_STANDARD1;
+        String cf = CF_STANDARD5;
         ColumnFamilyStore cfs = Keyspace.open(ks).getColumnFamilyStore(cf);
         cfs.truncateBlocking();
         SSTableDeletingTask.waitForDeletions();

File: test/unit/org/apache/cassandra/db/CommitLogTest.java
Patch:
@@ -311,7 +311,7 @@ public void testVersions()
     }
 
     @Test
-    public void testTruncateWithoutSnapshot()
+    public void testTruncateWithoutSnapshot() throws IOException
     {
         CommitLog.instance.resetUnsafe(true);
         boolean prev = DatabaseDescriptor.isAutoSnapshot();
@@ -340,7 +340,7 @@ public void testTruncateWithoutSnapshot()
     }
 
     @Test
-    public void testTruncateWithoutSnapshotNonDurable()
+    public void testTruncateWithoutSnapshotNonDurable() throws IOException
     {
         CommitLog.instance.resetUnsafe(true);
         boolean prevAutoSnapshot = DatabaseDescriptor.isAutoSnapshot();

File: test/unit/org/apache/cassandra/db/RecoveryManager2Test.java
Patch:
@@ -82,8 +82,7 @@ public void testWithFlush() throws Exception
         logger.debug("begin manual replay");
         // replay the commit log (nothing on Standard1 should be replayed since everything was flushed, so only the row on Standard2
         // will be replayed)
-        CommitLog.instance.resetUnsafe(false);
-        int replayed = CommitLog.instance.recover();
+        int replayed = CommitLog.instance.resetUnsafe(false);
         assert replayed == 1 : "Expecting only 1 replayed mutation, got " + replayed;
     }
 

File: src/java/org/apache/cassandra/cql3/Lists.java
Patch:
@@ -342,7 +342,7 @@ public void execute(ByteBuffer rowKey, ColumnFamily cf, Composite prefix, Update
 
             List<Cell> existingList = params.getPrefetchedList(rowKey, column.name);
             int idx = ByteBufferUtil.toInt(index);
-            if (existingList == null)
+            if (existingList == null || existingList.size() == 0)
                 throw new InvalidRequestException("Attempted to set an element on a list which is null");
             if (idx < 0 || idx >= existingList.size())
                 throw new InvalidRequestException(String.format("List index %d out of bound, list has size %d", idx, existingList.size()));
@@ -500,7 +500,7 @@ public void execute(ByteBuffer rowKey, ColumnFamily cf, Composite prefix, Update
 
             List<Cell> existingList = params.getPrefetchedList(rowKey, column.name);
             int idx = ByteBufferUtil.toInt(index.get(params.options));
-            if (existingList == null)
+            if (existingList == null || existingList.size() == 0)
                 throw new InvalidRequestException("Attempted to delete an element from a list which is null");
             if (idx < 0 || idx >= existingList.size())
                 throw new InvalidRequestException(String.format("List index %d out of bound, list has size %d", idx, existingList.size()));

File: src/java/org/apache/cassandra/db/composites/CellNames.java
Patch:
@@ -63,6 +63,7 @@ public static CellNameType fromAbstractType(AbstractType<?> type, boolean isDens
             }
             else
             {
+                assert type != null;
                 return new SimpleSparseCellNameType(type);
             }
         }

File: src/java/org/apache/cassandra/db/composites/CellNames.java
Patch:
@@ -63,6 +63,7 @@ public static CellNameType fromAbstractType(AbstractType<?> type, boolean isDens
             }
             else
             {
+                assert type != null;
                 return new SimpleSparseCellNameType(type);
             }
         }

File: src/java/org/apache/cassandra/serializers/TypeSerializer.java
Patch:
@@ -35,4 +35,3 @@ public interface TypeSerializer<T>
 
     public Class<T> getType();
 }
-

File: src/java/org/apache/cassandra/transport/DataType.java
Patch:
@@ -49,8 +49,6 @@ public enum DataType implements OptionCodec.Codecable<DataType>
     VARINT   (14, IntegerType.instance),
     TIMEUUID (15, TimeUUIDType.instance),
     INET     (16, InetAddressType.instance),
-    DATE     (17, DateType.instance),
-    TIME     (18, TimeType.instance),
     LIST     (32, null),
     MAP      (33, null),
     SET      (34, null),

File: src/java/org/apache/cassandra/tools/NodeTool.java
Patch:
@@ -54,7 +54,9 @@ public static void main(String... args)
                 Ring.class,
                 NetStats.class,
                 CfStats.class,
+                TableStats.class,
                 CfHistograms.class,
+                TableHistograms.class,
                 Cleanup.class,
                 ClearSnapshot.class,
                 Compact.class,

File: src/java/org/apache/cassandra/locator/ReconnectableSnitchHelper.java
Patch:
@@ -81,7 +81,7 @@ public void onJoin(InetAddress endpoint, EndpointState epState)
 
     public void onChange(InetAddress endpoint, ApplicationState state, VersionedValue value)
     {
-        if (preferLocal && !Gossiper.instance.isDeadState(epState) && state == ApplicationState.INTERNAL_IP)
+        if (preferLocal && !Gossiper.instance.isDeadState(Gossiper.instance.getEndpointStateForEndpoint(endpoint)) && state == ApplicationState.INTERNAL_IP)
             reconnect(endpoint, value);
     }
 

File: src/java/org/apache/cassandra/utils/SigarLibrary.java
Patch:
@@ -140,11 +140,11 @@ private boolean isSwapEnabled()
             long swapSize = swap.getTotal();
             if (swapSize > 0)
             {
-                return false;
+                return true;
             }
             else
             {
-                return true;
+                return false;
             }
         }
         catch (SigarException sigarException)

File: test/unit/org/apache/cassandra/db/compaction/DateTieredCompactionStrategyTest.java
Patch:
@@ -288,7 +288,7 @@ public void testDropExpiredSSTables() throws InterruptedException
         // create 2 sstables
         DecoratedKey key = Util.dk(String.valueOf("expired"));
         RowMutation rm = new RowMutation(KEYSPACE1, key.key);
-        rm.add(CF_STANDARD1, ByteBufferUtil.bytes("column"), value, System.currentTimeMillis(), 5);
+        rm.add(CF_STANDARD1, ByteBufferUtil.bytes("column"), value, System.currentTimeMillis(), 1);
         rm.apply();
         cfs.forceBlockingFlush();
         SSTableReader expiredSSTable = cfs.getSSTables().iterator().next();
@@ -308,12 +308,13 @@ public void testDropExpiredSSTables() throws InterruptedException
         DateTieredCompactionStrategy dtcs = new DateTieredCompactionStrategy(cfs, options);
         dtcs.startup();
         assertNull(dtcs.getNextBackgroundTask((int) (System.currentTimeMillis() / 1000)));
-        Thread.sleep(7000);
+        Thread.sleep(2000);
         AbstractCompactionTask t = dtcs.getNextBackgroundTask((int) (System.currentTimeMillis()/1000));
         assertNotNull(t);
         assertEquals(1, Iterables.size(t.sstables));
         SSTableReader sstable = t.sstables.iterator().next();
         assertEquals(sstable, expiredSSTable);
+        cfs.getDataTracker().unmarkCompacting(cfs.getSSTables());
     }
 
 }

File: src/java/org/apache/cassandra/tools/nodetool/Snapshot.java
Patch:
@@ -42,7 +42,7 @@ public class Snapshot extends NodeToolCmd
     @Option(title = "tag", name = {"-t", "--tag"}, description = "The name of the snapshot")
     private String snapshotName = Long.toString(System.currentTimeMillis());
 
-    @Option(title = "kclist", name = { "-kc", "--kc-list" }, description = "The list of Keyspace.Column family to take snapshot.(you must not specify only keyspace)")
+    @Option(title = "ktlist", name = { "-kc", "--kc.list", "-kt", "--kt-list" }, description = "The list of Keyspace.table to take snapshot.(you must not specify only keyspace)")
     private String kcList = null;
 
     @Override
@@ -53,6 +53,7 @@ public void execute(NodeProbe probe)
             StringBuilder sb = new StringBuilder();
 
             sb.append("Requested creating snapshot(s) for ");
+
             // Create a separate path for kclist to avoid breaking of already existing scripts
             if (null != kcList && !kcList.isEmpty())
             {

File: test/unit/org/apache/cassandra/io/sstable/IndexSummaryTest.java
Patch:
@@ -90,6 +90,7 @@ public void testSerialization() throws IOException
         assertEquals(dis.readUTF(), "JUNK");
         is.close();
         FileUtils.closeQuietly(dis);
+        random.right.close();
     }
 
     @Test

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -88,7 +88,7 @@ private static void maybeInitJmx()
             }
             else
             {
-                System.setProperty("java.rmi.server.hostname","127.0.0.1");
+                System.setProperty("java.rmi.server.hostname", InetAddress.getLoopbackAddress().getHostAddress());
 
                 try
                 {

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -160,7 +160,7 @@ private static void maybeInitJmx()
             }
             else
             {
-                System.setProperty("java.rmi.server.hostname","127.0.0.1");
+                System.setProperty("java.rmi.server.hostname", InetAddress.getLoopbackAddress().getHostAddress());
 
                 try
                 {

File: src/java/org/apache/cassandra/auth/CassandraRoleManager.java
Patch:
@@ -110,7 +110,7 @@ static int getGensaltLogRounds()
          int rounds = Integer.getInteger(GENSALT_LOG2_ROUNDS_PROPERTY, 10);
          if (rounds < 4 || rounds > 31)
          throw new ConfigurationException(String.format("Bad value for system property -D%s." +
-                                                        "Please use a value 4 and 31",
+                                                        "Please use a value between 4 and 31 inclusively",
                                                         GENSALT_LOG2_ROUNDS_PROPERTY));
          return rounds;
     }

File: src/java/org/apache/cassandra/tools/SSTableMetadataViewer.java
Patch:
@@ -69,7 +69,7 @@ public static void main(String[] args) throws IOException
                     out.printf("SSTable Level: %d%n", stats.sstableLevel);
                     out.printf("Repaired at: %d%n", stats.repairedAt);
                     out.println(stats.replayPosition);
-                    out.println("Estimated tombstone drop times:%n");
+                    out.println("Estimated tombstone drop times:");
                     for (Map.Entry<Double, Long> entry : stats.estimatedTombstoneDropTime.getAsMap().entrySet())
                     {
                         out.printf("%-10s:%10s%n",entry.getKey().intValue(), entry.getValue());

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -32,6 +32,7 @@
 import com.google.common.collect.Collections2;
 import com.google.common.collect.Iterables;
 
+import org.apache.cassandra.cql3.statements.CFPropDefs;
 import org.apache.cassandra.serializers.MarshalException;
 import org.apache.commons.lang3.StringUtils;
 
@@ -1318,12 +1319,14 @@ private CfDef updateCfDefAttributes(Tree statement, CfDef cfDefToUpdate)
                 if (threshold <= 0)
                     throw new RuntimeException("Disabling compaction by setting min/max compaction thresholds to 0 has been deprecated, set compaction_strategy_options={'enabled':false} instead");
                 cfDef.setMin_compaction_threshold(threshold);
+                cfDef.putToCompaction_strategy_options(CFPropDefs.KW_MINCOMPACTIONTHRESHOLD, Integer.toString(threshold));
                 break;
             case MAX_COMPACTION_THRESHOLD:
                 threshold = Integer.parseInt(mValue);
                 if (threshold <= 0)
                     throw new RuntimeException("Disabling compaction by setting min/max compaction thresholds to 0 has been deprecated, set compaction_strategy_options={'enabled':false} instead");
                 cfDef.setMax_compaction_threshold(Integer.parseInt(mValue));
+                cfDef.putToCompaction_strategy_options(CFPropDefs.KW_MAXCOMPACTIONTHRESHOLD, Integer.toString(threshold));
                 break;
             case REPLICATE_ON_WRITE:
                 cfDef.setReplicate_on_write(Boolean.parseBoolean(mValue));

File: src/java/org/apache/cassandra/net/OutboundTcpConnection.java
Patch:
@@ -130,7 +130,7 @@ private static CoalescingStrategy newCoalescingStrategy(String displayName)
     private volatile long completed;
     private final AtomicLong dropped = new AtomicLong();
     private volatile int currentMsgBufferCount = 0;
-    private int targetVersion;
+    private int targetVersion = MessagingService.current_version;
 
     public OutboundTcpConnection(OutboundTcpConnectionPool pool)
     {

File: test/unit/org/apache/cassandra/utils/NoSpamLoggerTest.java
Patch:
@@ -191,6 +191,8 @@ private void checkMock(Level l)
    @Test
    public void testLoggedResult() throws Exception
    {
+       now = 5;
+
        NoSpamLogger.log( mock, Level.INFO, 5,  TimeUnit.NANOSECONDS, statement, param);
        checkMock(Level.INFO);
 

File: src/java/org/apache/cassandra/utils/StatusLogger.java
Patch:
@@ -52,13 +52,13 @@ public static void log()
 
         for (Stage stage : Stage.jmxEnabledStages())
         {
-            System.out.printf("%-25s%10s%10s%15s%10s%18s%n",
+            logger.info(String.format("%-25s%10s%10s%15s%10s%18s%n",
                               stage.getJmxName(),
                               ThreadPoolMetrics.getJmxMetric(server, stage.getJmxType(), stage.getJmxName(), "ActiveTasks"),
                               ThreadPoolMetrics.getJmxMetric(server, stage.getJmxType(), stage.getJmxName(), "PendingTasks"),
                               ThreadPoolMetrics.getJmxMetric(server, stage.getJmxType(), stage.getJmxName(), "CompletedTasks"),
                               ThreadPoolMetrics.getJmxMetric(server, stage.getJmxType(), stage.getJmxName(), "CurrentlyBlockedTasks"),
-                              ThreadPoolMetrics.getJmxMetric(server, stage.getJmxType(), stage.getJmxName(), "TotalBlockedTasks"));
+                              ThreadPoolMetrics.getJmxMetric(server, stage.getJmxType(), stage.getJmxName(), "TotalBlockedTasks")));
         }
 
         // one offs

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -1027,7 +1027,7 @@ private void doValidationCompaction(ColumnFamilyStore cfs, Validator validator)
 
                 for (SSTableReader sstable : sstableCandidates.sstables)
                 {
-                    if (!(new Bounds<>(sstable.first.getToken(), sstable.last.getToken()).intersects(Arrays.asList(validator.desc.range))))
+                    if (new Bounds<>(sstable.first.getToken(), sstable.last.getToken()).intersects(Collections.singletonList(validator.desc.range)))
                     {
                         sstablesToValidate.add(sstable);
                     }

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -26,7 +26,7 @@
 import java.rmi.registry.LocateRegistry;
 import java.rmi.server.RMIServerSocketFactory;
 import java.util.*;
-    import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeUnit;
 import javax.management.MBeanServer;
 import javax.management.ObjectName;
 import javax.management.StandardMBean;

File: src/java/org/apache/cassandra/locator/NetworkTopologyStrategy.java
Patch:
@@ -85,7 +85,7 @@ public List<InetAddress> calculateNaturalEndpoints(Token searchToken, TokenMetad
         // replicas we have found in each DC
         Map<String, Set<InetAddress>> dcReplicas = new HashMap<>(datacenters.size());
         for (Map.Entry<String, Integer> dc : datacenters.entrySet())
-            dcReplicas.put(dc.getKey(), new HashSet<>(dc.getValue()));
+            dcReplicas.put(dc.getKey(), new HashSet<InetAddress>(dc.getValue()));
 
         Topology topology = tokenMetadata.getTopology();
         // all endpoints in each DC, so we can check when we have exhausted all the members of a DC
@@ -97,13 +97,13 @@ public List<InetAddress> calculateNaturalEndpoints(Token searchToken, TokenMetad
         // tracks the racks we have already placed replicas in
         Map<String, Set<String>> seenRacks = new HashMap<>(datacenters.size());
         for (Map.Entry<String, Integer> dc : datacenters.entrySet())
-            seenRacks.put(dc.getKey(), new HashSet<>());
+            seenRacks.put(dc.getKey(), new HashSet<String>());
 
         // tracks the endpoints that we skipped over while looking for unique racks
         // when we relax the rack uniqueness we can append this to the current result so we don't have to wind back the iterator
         Map<String, Set<InetAddress>> skippedDcEndpoints = new HashMap<>(datacenters.size());
         for (Map.Entry<String, Integer> dc : datacenters.entrySet())
-            skippedDcEndpoints.put(dc.getKey(), new LinkedHashSet<>());
+            skippedDcEndpoints.put(dc.getKey(), new LinkedHashSet<InetAddress>());
 
         Iterator<Token> tokenIter = TokenMetadata.ringIterator(tokenMetadata.sortedTokens(), searchToken, false);
         while (tokenIter.hasNext() && !hasSufficientReplicas(dcReplicas, allEndpoints))

File: src/java/org/apache/cassandra/db/compaction/DateTieredCompactionStrategy.java
Patch:
@@ -74,7 +74,7 @@ private List<SSTableReader> getNextBackgroundSSTables(final int gcBefore)
         if (!isEnabled() || cfs.getSSTables().isEmpty())
             return Collections.emptyList();
 
-        Set<SSTableReader> uncompacting = cfs.getUncompactingSSTables();
+        Set<SSTableReader> uncompacting = Sets.intersection(sstables, cfs.getUncompactingSSTables());
 
         // Find fully expired SSTables. Those will be included no matter what.
         Set<SSTableReader> expired = CompactionController.getFullyExpiredSSTables(cfs, uncompacting, cfs.getOverlappingSSTables(uncompacting), gcBefore);

File: test/unit/org/apache/cassandra/db/compaction/DateTieredCompactionStrategyTest.java
Patch:
@@ -306,6 +306,8 @@ public void testDropExpiredSSTables() throws InterruptedException
         options.put(DateTieredCompactionStrategyOptions.TIMESTAMP_RESOLUTION_KEY, "MILLISECONDS");
         options.put(DateTieredCompactionStrategyOptions.MAX_SSTABLE_AGE_KEY, Double.toString((1d / (24 * 60 * 60))));
         DateTieredCompactionStrategy dtcs = new DateTieredCompactionStrategy(cfs, options);
+        for (SSTableReader sstable : cfs.getSSTables())
+            dtcs.addSSTable(sstable);
         dtcs.startup();
         assertNull(dtcs.getNextBackgroundTask((int) (System.currentTimeMillis() / 1000)));
         Thread.sleep(7000);

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -59,7 +59,7 @@ public class Config
     public volatile boolean hinted_handoff_enabled_global = true;
     public String hinted_handoff_enabled;
     public Set<String> hinted_handoff_enabled_by_dc = Sets.newConcurrentHashSet();
-    public volatile Integer max_hint_window_in_ms = 3600 * 1000; // one hour
+    public volatile Integer max_hint_window_in_ms = 3 * 3600 * 1000; // three hours
 
     public SeedProviderDef seed_provider;
     public DiskAccessMode disk_access_mode = DiskAccessMode.auto;

File: src/java/org/apache/cassandra/cache/AutoSavingCache.java
Patch:
@@ -127,7 +127,8 @@ public int loadSaved(ColumnFamilyStore cfs)
                 for (Future<Pair<K, V>> future : futures)
                 {
                     Pair<K, V> entry = future.get();
-                    put(entry.left, entry.right);
+                    if (entry != null && entry.right != null)
+                    	put(entry.left, entry.right);
                 }
             }
             catch (Exception e)

File: src/java/org/apache/cassandra/io/sstable/CQLSSTableWriter.java
Patch:
@@ -469,8 +469,7 @@ public Builder withBufferSizeInMB(int size)
          * added in SSTable sorted order (and an exception will be thrown if that
          * is not the case during insertion). The SSTable sorted order means that
          * rows are added such that their partition key respect the partitioner
-         * order and for a given partition, that the rows respect the clustering
-         * columns order.
+         * order.
          * <p>
          * You should thus only use this option is you know that you can provide
          * the rows in order, which is rarely the case. If you can provide the

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -1050,8 +1050,6 @@ private Collection<SSTableReader> doAntiCompaction(ColumnFamilyStore cfs, Collec
         List<SSTableReader> anticompactedSSTables = new ArrayList<>();
         int repairedKeyCount = 0;
         int unrepairedKeyCount = 0;
-        // TODO(5351): we can do better here:
-        int expectedBloomFilterSize = Math.max(cfs.metadata.getMinIndexInterval(), (int)(SSTableReader.getApproximateKeyCount(repairedSSTables)));
         logger.info("Performing anticompaction on {} sstables", repairedSSTables.size());
         // iterate over sstables to check if the repaired / unrepaired ranges intersect them.
         for (SSTableReader sstable : repairedSSTables)
@@ -1075,6 +1073,7 @@ private Collection<SSTableReader> doAntiCompaction(ColumnFamilyStore cfs, Collec
             try (AbstractCompactionStrategy.ScannerList scanners = cfs.getCompactionStrategy().getScanners(new HashSet<>(Collections.singleton(sstable)));
                  CompactionController controller = new CompactionController(cfs, sstableAsSet, CFMetaData.DEFAULT_GC_GRACE_SECONDS))
             {
+                int expectedBloomFilterSize = Math.max(cfs.metadata.getMinIndexInterval(), (int)sstable.estimatedKeys());
                 repairedSSTableWriter.switchWriter(CompactionManager.createWriter(cfs, destination, expectedBloomFilterSize, repairedAt, sstable));
                 unRepairedSSTableWriter.switchWriter(CompactionManager.createWriter(cfs, destination, expectedBloomFilterSize, ActiveRepairService.UNREPAIRED_SSTABLE, sstable));
 

File: src/java/org/apache/cassandra/cql3/restrictions/SingleColumnRestriction.java
Patch:
@@ -132,7 +132,7 @@ public void addIndexExpressionTo(List<IndexExpression> expressions,
         public CompositesBuilder appendTo(CompositesBuilder builder, QueryOptions options)
         {
             builder.addElementToAll(value.bindAndGet(options));
-            checkFalse(builder.containsNull(), "Invalid null value in condition for column %s", columnDef);
+            checkFalse(builder.containsNull(), "Invalid null value in condition for column %s", columnDef.name);
             return builder;
         }
 
@@ -178,7 +178,7 @@ public final Restriction doMergeWith(Restriction otherRestriction) throws Invali
         public CompositesBuilder appendTo(CompositesBuilder builder, QueryOptions options)
         {
             builder.addEachElementToAll(getValues(options));
-            checkFalse(builder.containsNull(), "Invalid null value in condition for column %s", columnDef);
+            checkFalse(builder.containsNull(), "Invalid null value in condition for column %s", columnDef.name);
             return builder;
         }
 

File: src/java/org/apache/cassandra/io/sstable/IndexSummary.java
Patch:
@@ -86,6 +86,7 @@ public IndexSummary(IPartitioner partitioner, Memory offsets, int offsetCount, M
         this.offsets = offsets;
         this.entries = entries;
         this.samplingLevel = samplingLevel;
+        assert samplingLevel > 0;
     }
 
     private IndexSummary(IndexSummary copy)

File: test/unit/org/apache/cassandra/io/sstable/IndexSummaryTest.java
Patch:
@@ -257,7 +257,7 @@ public void testOriginalIndexLookup()
         assertEquals(128, BASE_SAMPLING_LEVEL);
         assertEquals(Arrays.asList(0, 32, 64, 96), Downsampling.getOriginalIndexes(4));
         assertEquals(Arrays.asList(0, 64), Downsampling.getOriginalIndexes(2));
-        assertEquals(Arrays.asList(), Downsampling.getOriginalIndexes(0));
+        assertEquals(Arrays.asList(0), Downsampling.getOriginalIndexes(1));
     }
 
     @Test

File: src/java/org/apache/cassandra/service/MigrationTask.java
Patch:
@@ -59,7 +59,7 @@ public void runMayThrow() throws Exception
 
         if (!FailureDetector.instance.isAlive(endpoint))
         {
-            logger.error("Can't send migration request: node {} is down.", endpoint);
+            logger.debug("Can't send schema pull request: node {} is down.", endpoint);
             return;
         }
 

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1618,7 +1618,7 @@ else if (Gossiper.instance.compareEndpointStartup(endpoint, currentOwner) > 0)
         if (!localTokensToRemove.isEmpty())
             SystemKeyspace.updateLocalTokens(Collections.<Token>emptyList(), localTokensToRemove);
 
-        if (isMoving)
+        if (isMoving || operationMode == Mode.MOVING)
         {
             tokenMetadata.removeFromMoving(endpoint);
 

File: src/java/org/apache/cassandra/metrics/ConnectionMetrics.java
Patch:
@@ -64,7 +64,7 @@ public class ConnectionMetrics
     public ConnectionMetrics(InetAddress ip, final OutboundTcpConnectionPool connectionPool)
     {
         // ipv6 addresses will contain colons, which are invalid in a JMX ObjectName
-        address = ip.getHostAddress().replaceAll(":", ".");
+        address = ip.getHostAddress().replace(':', '.');
 
         factory = new DefaultNameFactory("Connection", address);
 

File: src/java/org/apache/cassandra/metrics/HintedHandoffMetrics.java
Patch:
@@ -55,7 +55,7 @@ public DifferencingCounter load(InetAddress address)
     {
         public Counter load(InetAddress address)
         {
-            return Metrics.newCounter(factory.createMetricName("Hints_created-" + address.getHostAddress()));
+            return Metrics.newCounter(factory.createMetricName("Hints_created-" + address.getHostAddress().replace(':', '.')));
         }
     });
 
@@ -88,7 +88,7 @@ public class DifferencingCounter
 
         public DifferencingCounter(InetAddress address)
         {
-            this.meter = Metrics.newCounter(factory.createMetricName("Hints_not_stored-" + address.getHostAddress()));
+            this.meter = Metrics.newCounter(factory.createMetricName("Hints_not_stored-" + address.getHostAddress().replace(':', '.')));
         }
 
         public long difference()

File: src/java/org/apache/cassandra/metrics/StreamingMetrics.java
Patch:
@@ -52,7 +52,7 @@ public static StreamingMetrics get(InetAddress ip)
 
     public StreamingMetrics(final InetAddress peer)
     {
-        MetricNameFactory factory = new DefaultNameFactory("Streaming", peer.getHostAddress().replaceAll(":", "."));
+        MetricNameFactory factory = new DefaultNameFactory("Streaming", peer.getHostAddress().replace(':', '.'));
         incomingBytes = Metrics.newCounter(factory.createMetricName("IncomingBytes"));
         outgoingBytes= Metrics.newCounter(factory.createMetricName("OutgoingBytes"));
     }

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -1077,12 +1077,12 @@ public static String getCommitLogLocation()
         return conf.commitlog_directory;
     }
 
-    public static ParametrizedClass getCommitLogCompression()
+    public static ParameterizedClass getCommitLogCompression()
     {
         return conf.commitlog_compression;
     }
 
-    public static void setCommitLogCompression(ParametrizedClass compressor)
+    public static void setCommitLogCompression(ParameterizedClass compressor)
     {
         conf.commitlog_compression = compressor;
     }

File: src/java/org/apache/cassandra/config/YamlConfigurationLoader.java
Patch:
@@ -104,7 +104,7 @@ public Config loadConfig(URL url) throws ConfigurationException
             logConfig(configBytes);
 
             org.yaml.snakeyaml.constructor.Constructor constructor = new org.yaml.snakeyaml.constructor.Constructor(Config.class);
-            TypeDescription seedDesc = new TypeDescription(ParametrizedClass.class);
+            TypeDescription seedDesc = new TypeDescription(ParameterizedClass.class);
             seedDesc.putMapPropertyType("parameters", String.class, String.class);
             constructor.addTypeDescription(seedDesc);
             MissingPropertiesChecker propertiesChecker = new MissingPropertiesChecker();

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -35,7 +35,7 @@
 import com.github.tjake.ICRC32;
 import org.apache.cassandra.config.Config;
 import org.apache.cassandra.config.DatabaseDescriptor;
-import org.apache.cassandra.config.ParametrizedClass;
+import org.apache.cassandra.config.ParameterizedClass;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.io.FSWriteError;
 import org.apache.cassandra.io.compress.CompressionParameters;
@@ -69,7 +69,7 @@ public class CommitLog implements CommitLogMBean
     final AbstractCommitLogService executor;
 
     final ICompressor compressor;
-    public ParametrizedClass compressorClass;
+    public ParameterizedClass compressorClass;
     final public String location;
 
     static private CommitLog construct()

File: src/java/org/apache/cassandra/io/compress/CompressionParameters.java
Patch:
@@ -33,7 +33,7 @@
 import org.apache.commons.lang3.builder.EqualsBuilder;
 import org.apache.commons.lang3.builder.HashCodeBuilder;
 import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.config.ParametrizedClass;
+import org.apache.cassandra.config.ParameterizedClass;
 import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.io.IVersionedSerializer;
@@ -207,7 +207,7 @@ private static ICompressor createCompressor(Class<?> compressorClass, Map<String
         }
     }
 
-    public static ICompressor createCompressor(ParametrizedClass compression) throws ConfigurationException {
+    public static ICompressor createCompressor(ParameterizedClass compression) throws ConfigurationException {
         return createCompressor(parseCompressorClass(compression.class_name), copyOptions(compression.parameters));
     }
 

File: src/java/org/apache/cassandra/io/sstable/SSTableReader.java
Patch:
@@ -2029,12 +2029,12 @@ public void run()
                     if (barrier != null)
                         barrier.await();
                     bf.close();
-                    dfile.close();
-                    ifile.close();
                     if (summary != null)
                         summary.close();
                     if (runOnClose != null)
                         runOnClose.run();
+                    dfile.close();
+                    ifile.close();
                     typeRef.release();
                 }
             });

File: src/java/org/apache/cassandra/io/util/SafeMemory.java
Patch:
@@ -52,11 +52,13 @@ public SafeMemory sharedCopy()
     public void free()
     {
         ref.release();
+        peer = 0;
     }
 
     public void close()
     {
         ref.ensureReleased();
+        peer = 0;
     }
 
     public SafeMemory copy(long newSize)

File: src/java/org/apache/cassandra/transport/Server.java
Patch:
@@ -66,6 +66,7 @@ public class Server implements CassandraDaemon.Server
     private static final Logger logger = LoggerFactory.getLogger(Server.class);
     private static final boolean enableEpoll = Boolean.valueOf(System.getProperty("cassandra.native.epoll.enabled", "true"));
 
+    public static final int VERSION_1 = 1;
     public static final int VERSION_2 = 2;
     public static final int VERSION_3 = 3;
     public static final int VERSION_4 = 4;

File: src/java/org/apache/cassandra/io/compress/CompressedSequentialWriter.java
Patch:
@@ -229,6 +229,9 @@ public synchronized void resetAndTruncate(FileMark mark)
         bufferOffset = current - validBufferBytes;
         chunkCount = realMark.nextChunkIndex - 1;
 
+        // mark as dirty so we don't lose the bytes on subsequent reBuffer calls
+        isDirty = true;
+
         // truncate data and index file
         truncate(chunkOffset);
         metadataWriter.resetAndTruncate(realMark.nextChunkIndex - 1);

File: src/java/org/apache/cassandra/io/compress/CompressedSequentialWriter.java
Patch:
@@ -229,6 +229,9 @@ public synchronized void resetAndTruncate(FileMark mark)
         bufferOffset = current - validBufferBytes;
         chunkCount = realMark.nextChunkIndex - 1;
 
+        // mark as dirty so we don't lose the bytes on subsequent reBuffer calls
+        isDirty = true;
+
         // truncate data and index file
         truncate(chunkOffset);
         metadataWriter.resetAndTruncate(realMark.nextChunkIndex - 1);

File: src/java/org/apache/cassandra/cql3/Lists.java
Patch:
@@ -494,10 +494,8 @@ public void execute(ByteBuffer rowKey, ColumnFamily cf, Composite prefix, Update
             if (index == null)
                 throw new InvalidRequestException("Invalid null value for list index");
 
-            assert index instanceof Constants.Value;
-
             List<Cell> existingList = params.getPrefetchedList(rowKey, column.name);
-            int idx = ByteBufferUtil.toInt(((Constants.Value)index).bytes);
+            int idx = ByteBufferUtil.toInt(index.get(params.options));
             if (idx < 0 || idx >= existingList.size())
                 throw new InvalidRequestException(String.format("List index %d out of bound, list has size %d", idx, existingList.size()));
 

File: src/java/org/apache/cassandra/cql3/Maps.java
Patch:
@@ -378,9 +378,8 @@ public void execute(ByteBuffer rowKey, ColumnFamily cf, Composite prefix, Update
             Term.Terminal key = t.bind(params.options);
             if (key == null)
                 throw new InvalidRequestException("Invalid null map key");
-            assert key instanceof Constants.Value;
 
-            CellName cellName = cf.getComparator().create(prefix, column, ((Constants.Value)key).bytes);
+            CellName cellName = cf.getComparator().create(prefix, column, key.get(params.options));
             cf.addColumn(params.makeTombstone(cellName));
         }
     }

File: src/java/org/apache/cassandra/cql3/Operation.java
Patch:
@@ -414,7 +414,7 @@ else if (!(receiver.type.isMultiCell()))
                     return new Lists.DiscarderByIndex(receiver, idx);
                 case SET:
                     Term elt = element.prepare(keyspace, Sets.valueSpecOf(receiver));
-                    return new Sets.Discarder(receiver, elt);
+                    return new Sets.ElementDiscarder(receiver, elt);
                 case MAP:
                     Term key = element.prepare(keyspace, Maps.keySpecOf(receiver));
                     return new Maps.DiscarderByKey(receiver, key);

File: src/java/org/apache/cassandra/dht/BootStrapper.java
Patch:
@@ -84,7 +84,7 @@ public void bootstrap(StreamStateStore stateStore, boolean useStrictConsistency)
         }
         catch (InterruptedException e)
         {
-            throw new RuntimeException("Interrupted while waiting on boostrap to complete. Bootstrap will have to be restarted.");
+            throw new RuntimeException("Interrupted while waiting on bootstrap to complete. Bootstrap will have to be restarted.");
         }
         catch (ExecutionException e)
         {

File: src/java/org/apache/cassandra/dht/AbstractBounds.java
Patch:
@@ -261,7 +261,7 @@ public static <T extends RingPosition<T>> Boundary<T> maxLeft(Boundary<T> left1,
 
     public static <T extends RingPosition<T>> Boundary<T> maxLeft(Boundary<T> left1, Boundary<T> left2)
     {
-        int c = left1.boundary.compareTo(left1.boundary);
+        int c = left1.boundary.compareTo(left2.boundary);
         if (c != 0)
             return c > 0 ? left1 : left2;
         // return the exclusive version, if either

File: test/unit/org/apache/cassandra/io/sstable/SSTableScannerTest.java
Patch:
@@ -114,7 +114,7 @@ private static DecoratedKey dk(int key)
 
     private static Token token(int key)
     {
-        return key == Integer.MIN_VALUE ? ByteOrderedPartitioner.MINIMUM : new BytesToken(toKey(key).getBytes());
+        return key == Integer.MIN_VALUE ? ByteOrderedPartitioner.MINIMUM : new ByteOrderedPartitioner.BytesToken(toKey(key).getBytes());
     }
 
     private static RowPosition min(int key)
@@ -134,8 +134,8 @@ private static DataRange dataRange(RowPosition start, boolean startInclusive, Ro
 
     private static Range<Token> rangeFor(int start, int end)
     {
-        return new Range<Token>(new BytesToken(toKey(start).getBytes()),
-                                end == Integer.MIN_VALUE ? ByteOrderedPartitioner.MINIMUM : new BytesToken(toKey(end).getBytes()));
+        return new Range<Token>(new ByteOrderedPartitioner.BytesToken(toKey(start).getBytes()),
+                                end == Integer.MIN_VALUE ? ByteOrderedPartitioner.MINIMUM : new ByteOrderedPartitioner.BytesToken(toKey(end).getBytes()));
     }
 
     private static Collection<Range<Token>> makeRanges(int ... keys)

File: src/java/org/apache/cassandra/io/util/DataIntegrityMetadata.java
Patch:
@@ -104,7 +104,7 @@ public static class FileDigestValidator implements Closeable
         public FileDigestValidator(Descriptor descriptor) throws IOException
         {
             this.descriptor = descriptor;
-            checksum = descriptor.version.hasAllAdlerChecksums() ? new Adler32() : new PureJavaCrc32();
+            checksum = descriptor.version.hasAllAdlerChecksums() ? new Adler32() : CRC32Factory.instance.create();
             digestReader = RandomAccessReader.open(new File(descriptor.filenameFor(Component.DIGEST)));
             dataReader = RandomAccessReader.open(new File(descriptor.filenameFor(Component.DATA)));
             try

File: src/java/org/apache/cassandra/db/index/composites/CompositesIndexOnCollectionKeyAndValue.java
Patch:
@@ -72,7 +72,7 @@ private ByteBuffer extractCollectionKey(IndexedEntry entry)
 
     private ByteBuffer extractIndexKeyComponent(IndexedEntry entry, int component)
     {
-        return ((CompositeType)getIndexKeyComparator()).extractComponent(entry.indexValue.getKey(), component);
+        return CompositeType.extractComponent(entry.indexValue.getKey(), component);
     }
 
     private ByteBuffer extractCollectionValue(IndexedEntry entry)

File: src/java/org/apache/cassandra/cql3/functions/JavaSourceUDFFactory.java
Patch:
@@ -202,7 +202,7 @@ private static String generateExecuteInternalMethod(List<ColumnIdentifier> argNa
      *     }
      *     catch (Throwable t)
      *     {
-     *         logger.info("Invocation of function '{}' failed", this, t);
+     *         logger.debug("Invocation of function '{}' failed", this, t);
      *         if (t instanceof VirtualMachineError)
      *             throw (VirtualMachineError)t;
      *         throw org.apache.cassandra.exceptions.FunctionExecutionException.build(this, t);
@@ -244,7 +244,7 @@ private static String generateExecuteMethod(List<ColumnIdentifier> argNames, Cla
                     "  }\n" +
                     "  catch (Throwable t)\n" +
                     "  {\n" +
-                    "    logger.info(\"Invocation of function '{}' failed\", this, t);\n" +
+                    "    logger.debug(\"Invocation of function '{}' failed\", this, t);\n" +
                     // handle OutOfMemoryError and other fatals not here!
                     "    if (t instanceof VirtualMachineError)\n" +
                     "      throw (VirtualMachineError)t;\n" +

File: src/java/org/apache/cassandra/cql3/functions/ScriptBasedUDF.java
Patch:
@@ -139,7 +139,7 @@ else if (javaReturnType == BigDecimal.class)
         }
         catch (RuntimeException | ScriptException e)
         {
-            logger.info("Execution of UDF '{}' failed", name, e);
+            logger.debug("Execution of UDF '{}' failed", name, e);
             throw FunctionExecutionException.create(this, e);
         }
     }

File: src/java/org/apache/cassandra/cql3/functions/JavaSourceUDFFactory.java
Patch:
@@ -202,7 +202,7 @@ private static String generateExecuteInternalMethod(List<ColumnIdentifier> argNa
      *     }
      *     catch (Throwable t)
      *     {
-     *         logger.error("Invocation of function '{}' failed", this, t);
+     *         logger.info("Invocation of function '{}' failed", this, t);
      *         if (t instanceof VirtualMachineError)
      *             throw (VirtualMachineError)t;
      *         throw org.apache.cassandra.exceptions.FunctionExecutionException.build(this, t);
@@ -244,7 +244,7 @@ private static String generateExecuteMethod(List<ColumnIdentifier> argNames, Cla
                     "  }\n" +
                     "  catch (Throwable t)\n" +
                     "  {\n" +
-                    "    logger.error(\"Invocation of function '{}' failed\", this, t);\n" +
+                    "    logger.info(\"Invocation of function '{}' failed\", this, t);\n" +
                     // handle OutOfMemoryError and other fatals not here!
                     "    if (t instanceof VirtualMachineError)\n" +
                     "      throw (VirtualMachineError)t;\n" +

File: tools/stress/src/org/apache/cassandra/stress/operations/userdefined/SchemaStatement.java
Patch:
@@ -35,6 +35,7 @@
 import org.apache.cassandra.stress.generate.Row;
 import org.apache.cassandra.stress.settings.StressSettings;
 import org.apache.cassandra.stress.settings.ValidationType;
+import org.apache.cassandra.stress.util.JavaDriverClient;
 import org.apache.cassandra.stress.util.Timer;
 import org.apache.cassandra.thrift.CqlResult;
 import org.apache.cassandra.transport.SimpleClient;
@@ -62,6 +63,8 @@ public SchemaStatement(Timer timer, StressSettings settings, DataSpec spec,
         int i = 0;
         for (ColumnDefinitions.Definition definition : statement.getVariables())
             argumentIndex[i++] = spec.partitionGenerator.indexOf(definition.getName());
+
+        statement.setConsistencyLevel(JavaDriverClient.from(cl));
     }
 
     BoundStatement bindRow(Row row)

File: src/java/org/apache/cassandra/config/ColumnDefinition.java
Patch:
@@ -486,6 +486,6 @@ public Map<String,String> getIndexOptions()
      */
     public boolean hasIndexOption(String name)
     {
-        return indexOptions.containsKey(name);
+        return indexOptions != null && indexOptions.containsKey(name);
     }
 }

File: tools/stress/src/org/apache/cassandra/stress/util/TimingIntervals.java
Patch:
@@ -97,7 +97,7 @@ public String medianLatencies()
     }
     public String rankLatencies(float rank)
     {
-        return str(TimingInterval.TimingParameter.MEDIANLATENCY, rank);
+        return str(TimingInterval.TimingParameter.RANKLATENCY, rank);
     }
     public String errorCounts()
     {

File: src/java/org/apache/cassandra/serializers/TypeSerializer.java
Patch:
@@ -35,3 +35,4 @@ public interface TypeSerializer<T>
 
     public Class<T> getType();
 }
+

File: src/java/org/apache/cassandra/transport/DataType.java
Patch:
@@ -49,6 +49,8 @@ public enum DataType implements OptionCodec.Codecable<DataType>
     VARINT   (14, IntegerType.instance),
     TIMEUUID (15, TimeUUIDType.instance),
     INET     (16, InetAddressType.instance),
+    DATE     (17, DateType.instance),
+    TIME     (18, TimeType.instance),
     LIST     (32, null),
     MAP      (33, null),
     SET      (34, null),

File: src/java/org/apache/cassandra/io/compress/CompressedSequentialWriter.java
Patch:
@@ -132,7 +132,7 @@ protected void flushData()
             // write data itself
             out.write(compressed.buffer, 0, compressedLength);
             // write corresponding checksum
-            crcMetadata.append(compressed.buffer, 0, compressedLength);
+            crcMetadata.append(compressed.buffer, 0, compressedLength, true);
             lastFlushOffset += compressedLength + 4;
         }
         catch (IOException e)

File: src/java/org/apache/cassandra/io/util/ChecksummedSequentialWriter.java
Patch:
@@ -37,7 +37,7 @@ public ChecksummedSequentialWriter(File file, int bufferSize, File crcPath)
     protected void flushData()
     {
         super.flushData();
-        crcMetadata.append(buffer, 0, validBufferBytes);
+        crcMetadata.append(buffer, 0, validBufferBytes, false);
     }
 
     public void writeFullChecksum(Descriptor descriptor)

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsPopulation.java
Patch:
@@ -107,7 +107,7 @@ public List<? extends Option> options()
     private static final class SequentialOptions extends GenerateOptions
     {
         final OptionSimple populate;
-        final OptionDistribution lookback = new OptionDistribution("read-lookback=", "fixed(1)", "Select read seeds from the recently visited write seeds");
+        final OptionDistribution lookback = new OptionDistribution("read-lookback=", null, "Select read seeds from the recently visited write seeds");
         final OptionSimple nowrap = new OptionSimple("no-wrap", "", null, "Terminate the stress test once all seeds in the range have been visited", false);
 
         public SequentialOptions(String defaultLimit)

File: test/unit/org/apache/cassandra/io/sstable/SSTableRewriterTest.java
Patch:
@@ -219,6 +219,7 @@ public void testFileRemoval() throws InterruptedException
             for (int i = 0; i < 1000; i++)
                 writer.append(StorageService.getPartitioner().decorateKey(random(i, 10)), cf);
             SSTableReader s = writer.openEarly(1000);
+            assert s != null;
             assertFileCounts(dir.list(), 2, 2);
             for (int i = 1000; i < 2000; i++)
                 writer.append(StorageService.getPartitioner().decorateKey(random(i, 10)), cf);
@@ -817,7 +818,7 @@ private int assertFileCounts(String [] files, int expectedtmplinkCount, int expe
         {
             if (f.endsWith("-CRC.db"))
                 continue;
-            if (f.contains("-tmplink-"))
+            if (f.contains("tmplink-"))
                 tmplinkcount++;
             else if (f.contains("tmp-"))
                 tmpcount++;

File: test/unit/org/apache/cassandra/SchemaLoader.java
Patch:
@@ -178,9 +178,6 @@ public static void schemaDefinition(String testName) throws ConfigurationExcepti
                                            standardCFMD(ks1, "StandardLowIndexInterval").minIndexInterval(8)
                                                                                         .maxIndexInterval(256)
                                                                                         .caching(CachingOptions.NONE),
-                                           standardCFMD(ks1, "StandardRace").minIndexInterval(8)
-                                                                            .maxIndexInterval(256)
-                                                                            .caching(CachingOptions.NONE),
                                            standardCFMD(ks1, "UUIDKeys").keyValidator(UUIDType.instance),
                                            CFMetaData.denseCFMetaData(ks1, "MixedTypes", LongType.instance).keyValidator(UUIDType.instance).defaultValidator(BooleanType.instance),
                                            CFMetaData.denseCFMetaData(ks1, "MixedTypesComposite", composite).keyValidator(composite).defaultValidator(BooleanType.instance),

File: src/java/org/apache/cassandra/io/util/RandomAccessReader.java
Patch:
@@ -49,6 +49,8 @@ public class RandomAccessReader extends RandomAccessFile implements FileDataInpu
     // channel liked with the file, used to retrieve data and force updates.
     protected final FileChannel channel;
 
+    // this can be overridden at construction to a value shorter than the true length of the file;
+    // if so, it acts as an imposed limit on reads, rather than a convenience property
     private final long fileLength;
 
     protected final PoolingSegmentedFile owner;

File: src/java/org/apache/cassandra/cache/OHCProvider.java
Patch:
@@ -266,7 +266,7 @@ public void write(ByteBuffer buffer) throws IOException
                 throw new UnsupportedOperationException("IMPLEMENT ME");
         }
 
-        public void write(Memory memory) throws IOException
+        public void write(Memory memory, long offset, long length) throws IOException
         {
             throw new UnsupportedOperationException("IMPLEMENT ME");
         }

File: src/java/org/apache/cassandra/io/sstable/IndexSummary.java
Patch:
@@ -218,7 +218,7 @@ Memory getEntries()
         return entries;
     }
 
-    long getOffHeapSize()
+    public long getOffHeapSize()
     {
         return offsetCount * 4 + entriesLength;
     }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1179,7 +1179,7 @@ public void apply(DecoratedKey key, ColumnFamily columnFamily, SecondaryIndexMan
         Memtable mt = data.getMemtableFor(opGroup, replayPosition);
         final long timeDelta = mt.put(key, columnFamily, indexer, opGroup);
         maybeUpdateRowCache(key);
-        metric.samplers.get(Sampler.WRITES).addSample(key.getKey());
+        metric.samplers.get(Sampler.WRITES).addSample(key.getKey(), key.hashCode(), 1);
         metric.writeLatency.addNano(System.nanoTime() - start);
         if(timeDelta < Long.MAX_VALUE)
             metric.colUpdateTimeDeltaHistogram.update(timeDelta);
@@ -1915,7 +1915,7 @@ public ColumnFamily getTopLevelColumns(QueryFilter filter, int gcBefore)
             columns = controller.getTopLevelColumns(Memtable.MEMORY_POOL.needToCopyOnHeap());
         }
         if (columns != null)
-            metric.samplers.get(Sampler.READS).addSample(filter.key.getKey());
+            metric.samplers.get(Sampler.READS).addSample(filter.key.getKey(), filter.key.hashCode(), 1);
         metric.updateSSTableIterated(controller.getSstablesIterated());
         return columns;
     }

File: src/java/org/apache/cassandra/utils/TopKSampler.java
Patch:
@@ -81,15 +81,15 @@ public synchronized SamplerResult<T> finishSampling(int count)
 
     public void addSample(T item)
     {
-        addSample(item, 1);
+        addSample(item, item.hashCode(), 1);
     }
 
     /**
      * Adds a sample to statistics collection. This method is non-blocking and will
      * use the "Sampler" thread pool to record results if the sampler is enabled.  If not
      * sampling this is a NOOP
      */
-    public void addSample(final T item, final int value)
+    public void addSample(final T item, final long hash, final int value)
     {
         if (enabled)
         {
@@ -107,7 +107,7 @@ public void run()
                             try
                             {
                                 summary.offer(item, value);
-                                hll.offer(item);
+                                hll.offerHashed(hash);
                             } catch (Exception e)
                             {
                                 logger.debug("Failure to offer sample", e);

File: src/java/org/apache/cassandra/db/commitlog/AbstractCommitLogService.java
Patch:
@@ -182,6 +182,6 @@ public long getCompletedTasks()
 
     public long getPendingTasks()
     {
-        return pending.incrementAndGet();
+        return pending.get();
     }
 }
\ No newline at end of file

File: src/java/org/apache/cassandra/streaming/StreamManager.java
Patch:
@@ -63,17 +63,17 @@ public static StreamRateLimiter getRateLimiter(InetAddress peer)
 
     public static class StreamRateLimiter
     {
-        private static final double ONE_MEGA_BIT = 1024 * 1024 * 8;
+        private static final double BYTES_PER_MEGABIT = 1024 * 1024 / 8;
         private static final RateLimiter limiter = RateLimiter.create(Double.MAX_VALUE);
         private static final RateLimiter interDCLimiter = RateLimiter.create(Double.MAX_VALUE);
         private final boolean isLocalDC;
 
         public StreamRateLimiter(InetAddress peer)
         {
-            double throughput = ((double) DatabaseDescriptor.getStreamThroughputOutboundMegabitsPerSec()) * ONE_MEGA_BIT;
+            double throughput = ((double) DatabaseDescriptor.getStreamThroughputOutboundMegabitsPerSec()) * BYTES_PER_MEGABIT;
             mayUpdateThroughput(throughput, limiter);
 
-            double interDCThroughput = ((double) DatabaseDescriptor.getInterDCStreamThroughputOutboundMegabitsPerSec()) * ONE_MEGA_BIT;
+            double interDCThroughput = ((double) DatabaseDescriptor.getInterDCStreamThroughputOutboundMegabitsPerSec()) * BYTES_PER_MEGABIT;
             mayUpdateThroughput(interDCThroughput, interDCLimiter);
 
             if (DatabaseDescriptor.getLocalDataCenter() != null && DatabaseDescriptor.getEndpointSnitch() != null)

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -1797,7 +1797,7 @@ else if (logger.isDebugEnabled())
                     }
                     else
                     {
-                        actualRowsPerRange = i / fetchedRows;
+                        actualRowsPerRange = fetchedRows / i;
                         concurrencyFactor = Math.max(1, Math.min(ranges.size() - i, Math.round(remainingRows / actualRowsPerRange)));
                     }
                     logger.debug("Didn't get enough response rows; actual rows per range: {}; remaining rows: {}, new concurrent requests: {}",

File: test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java
Patch:
@@ -416,6 +416,8 @@ public void testGetPositionsForRangesFromTableOpenedForBulkLoading() throws IOEx
 
         // re-open the same sstable as it would be during bulk loading
         Set<Component> components = Sets.newHashSet(Component.DATA, Component.PRIMARY_INDEX);
+        if (sstable.components.contains(Component.COMPRESSION_INFO))
+            components.add(Component.COMPRESSION_INFO);
         SSTableReader bulkLoaded = SSTableReader.openForBatch(sstable.descriptor, components, store.metadata, sstable.partitioner);
         sections = bulkLoaded.getPositionsForRanges(ranges);
         assert sections.size() == 1 : "Expected to find range in sstable opened for bulk loading";

File: test/unit/org/apache/cassandra/cql3/SelectWithTokenFunctionTest.java
Patch:
@@ -225,7 +225,6 @@ public void testTokenFunctionWithCompoundPartitionAndClusteringCols() throws Thr
     {
         createTable("CREATE TABLE IF NOT EXISTS %s (a int, b int, c int, d int, PRIMARY KEY ((a, b), c, d))");
         // just test that the queries don't error
-        // note: these shouldn't require ALLOW FILTERING
         execute("SELECT * FROM %s WHERE token(a, b) > token(0, 0) AND c > 10 ALLOW FILTERING;");
         execute("SELECT * FROM %s WHERE c > 10 AND token(a, b) > token(0, 0) ALLOW FILTERING;");
         execute("SELECT * FROM %s WHERE token(a, b) > token(0, 0) AND (c, d) > (0, 0) ALLOW FILTERING;");

File: src/java/org/apache/cassandra/io/util/SafeMemory.java
Patch:
@@ -90,9 +90,9 @@ public String name()
     }
 
     @Inline
-    protected void checkPosition(long offset)
+    protected void checkBounds(long start, long end)
     {
         assert peer != 0 || size == 0 : ref.printDebugInfo();
-        super.checkPosition(offset);
+        super.checkBounds(start, end);
     }
 }

File: src/java/org/apache/cassandra/service/StorageServiceMBean.java
Patch:
@@ -268,7 +268,7 @@ public interface StorageServiceMBean extends NotificationEmitter
      * You can track repair progress by subscribing JMX notification sent from this StorageServiceMBean.
      * Notification format is:
      *   type: "repair"
-     *   userObject: int array of length 2, [0]=command number, [1]=ordinal of AntiEntropyService.Status
+     *   userObject: int array of length 2, [0]=command number, [1]=ordinal of ActiveRepairService.Status
      *
      * @return Repair command number, or 0 if nothing to repair
      */
@@ -279,7 +279,7 @@ public interface StorageServiceMBean extends NotificationEmitter
      * You can track repair progress by subscribing JMX notification sent from this StorageServiceMBean.
      * Notification format is:
      *   type: "repair"
-     *   userObject: int array of length 2, [0]=command number, [1]=ordinal of AntiEntropyService.Status
+     *   userObject: int array of length 2, [0]=command number, [1]=ordinal of ActiveRepairService.Status
      *
      * @param parallelismDegree 0: sequential, 1: parallel, 2: DC parallel
      * @return Repair command number, or 0 if nothing to repair
@@ -303,7 +303,7 @@ public interface StorageServiceMBean extends NotificationEmitter
      * You can track repair progress by subscribing JMX notification sent from this StorageServiceMBean.
      * Notification format is:
      *   type: "repair"
-     *   userObject: int array of length 2, [0]=command number, [1]=ordinal of AntiEntropyService.Status
+     *   userObject: int array of length 2, [0]=command number, [1]=ordinal of ActiveRepairService.Status
      *
      * @return Repair command number, or 0 if nothing to repair
      */

File: src/java/org/apache/cassandra/service/pager/AbstractQueryPager.java
Patch:
@@ -17,7 +17,6 @@
  */
 package org.apache.cassandra.service.pager;
 
-import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -215,7 +214,7 @@ List<Row> discardFirst(List<Row> rows, int toDiscard)
         {
             Row first = rows.get(i++);
             firstKey = first.key;
-            firstCf = first.cf.cloneMeShallow();
+            firstCf = first.cf.cloneMeShallow(isReversed());
             toDiscard -= isReversed()
                        ? discardLast(first.cf, toDiscard, firstCf)
                        : discardFirst(first.cf, toDiscard, firstCf);
@@ -255,7 +254,7 @@ List<Row> discardLast(List<Row> rows, int toDiscard)
         {
             Row last = rows.get(i--);
             lastKey = last.key;
-            lastCf = last.cf.cloneMeShallow();
+            lastCf = last.cf.cloneMeShallow(isReversed());
             toDiscard -= isReversed()
                        ? discardFirst(last.cf, toDiscard, lastCf)
                        : discardLast(last.cf, toDiscard, lastCf);

File: src/java/org/apache/cassandra/cql3/functions/JavaSourceUDFFactory.java
Patch:
@@ -248,7 +248,7 @@ private static String generateExecuteMethod(List<ColumnIdentifier> argNames, Cla
                     // handle OutOfMemoryError and other fatals not here!
                     "    if (t instanceof VirtualMachineError)\n" +
                     "      throw (VirtualMachineError)t;\n" +
-                    "    throw org.apache.cassandra.exceptions.FunctionExecutionException.build(this, t);\n" +
+                    "    throw org.apache.cassandra.exceptions.FunctionExecutionException.create(this, t);\n" +
                     "  }\n" +
                     "}");
 

File: src/java/org/apache/cassandra/io/sstable/SSTableRewriter.java
Patch:
@@ -370,7 +370,7 @@ private List<SSTableReader> finishAndMaybeThrow(long repairedAt, boolean throwEa
 
         while (!finishedEarly.isEmpty())
         {
-            Finished f = finishedEarly.poll();
+            Finished f = finishedEarly.peek();
             if (f.writer.getFilePointer() > 0)
             {
                 if (f.reader != null)
@@ -389,6 +389,7 @@ private List<SSTableReader> finishAndMaybeThrow(long repairedAt, boolean throwEa
                 f.writer.abort();
                 assert f.reader == null;
             }
+            finishedEarly.poll();
         }
 
         if (throwLate)

File: src/java/org/apache/cassandra/tools/NodeTool.java
Patch:
@@ -2066,7 +2066,7 @@ public void execute(NodeProbe probe)
             
             StringBuffer errors = new StringBuffer();
 
-            Map<InetAddress, Float> ownerships;
+            Map<InetAddress, Float> ownerships = null;
             try
             {
                 ownerships = probe.effectiveOwnership(keyspace);
@@ -2079,7 +2079,7 @@ public void execute(NodeProbe probe)
             catch (IllegalArgumentException ex)
             {
                 System.out.printf("%nError: " + ex.getMessage() + "%n");
-                return;
+                System.exit(1);
             }
 
             Map<String, SetHostStat> dcs = getOwnershipByDc(probe, resolveIp, tokensToEndpoints, ownerships);

File: src/java/org/apache/cassandra/io/sstable/SSTableSimpleUnsortedWriter.java
Patch:
@@ -227,7 +227,7 @@ else if (!first)
                             throw new AssertionError("Empty partition");
                         first = false;
                     }
-                    writer.close(true);
+                    writer.close();
                 }
             }
             catch (Throwable e)

File: src/java/org/apache/cassandra/io/sstable/SSTableSimpleWriter.java
Patch:
@@ -71,7 +71,7 @@ public void close()
         {
             if (currentKey != null)
                 writeRow(currentKey, columnFamily);
-            writer.close(true);
+            writer.close();
         }
         catch (FSError e)
         {

File: src/java/org/apache/cassandra/io/sstable/SSTableReader.java
Patch:
@@ -593,7 +593,10 @@ public void releaseSummary() throws IOException
     private void validate()
     {
         if (this.first.compareTo(this.last) > 0)
+        {
+            releaseReference();
             throw new IllegalStateException(String.format("SSTable first key %s > last key %s", this.first, this.last));
+        }
     }
 
     /** get the position in the index file to start scanning to find the given key (at most indexInterval keys away) */

File: src/java/org/apache/cassandra/io/sstable/SSTableSimpleUnsortedWriter.java
Patch:
@@ -227,7 +227,7 @@ else if (!first)
                             throw new AssertionError("Empty partition");
                         first = false;
                     }
-                    writer.close();
+                    writer.close(true);
                 }
             }
             catch (Throwable e)

File: src/java/org/apache/cassandra/io/sstable/SSTableSimpleWriter.java
Patch:
@@ -72,7 +72,7 @@ public void close()
         {
             if (currentKey != null)
                 writeRow(currentKey, columnFamily);
-            writer.close();
+            writer.close(true);
         }
         catch (FSError e)
         {

File: src/java/org/apache/cassandra/io/sstable/SSTableReader.java
Patch:
@@ -593,7 +593,10 @@ public void releaseSummary() throws IOException
     private void validate()
     {
         if (this.first.compareTo(this.last) > 0)
+        {
+            releaseReference();
             throw new IllegalStateException(String.format("SSTable first key %s > last key %s", this.first, this.last));
+        }
     }
 
     /** get the position in the index file to start scanning to find the given key (at most indexInterval keys away) */

File: src/java/org/apache/cassandra/io/sstable/SSTableSimpleUnsortedWriter.java
Patch:
@@ -227,7 +227,7 @@ else if (!first)
                             throw new AssertionError("Empty partition");
                         first = false;
                     }
-                    writer.close();
+                    writer.close(true);
                 }
             }
             catch (Throwable e)

File: src/java/org/apache/cassandra/io/sstable/SSTableSimpleWriter.java
Patch:
@@ -72,7 +72,7 @@ public void close()
         {
             if (currentKey != null)
                 writeRow(currentKey, columnFamily);
-            writer.close();
+            writer.close(true);
         }
         catch (FSError e)
         {

File: tools/stress/src/org/apache/cassandra/stress/settings/StressSettings.java
Patch:
@@ -239,8 +239,8 @@ private static String[] repairParams(String[] args)
             first = false;
         }
         return sb.toString()
-                 .replaceAll("\s+([,=()])", "$1")
-                 .replaceAll("([,=(])\s+", "$1")
+                 .replaceAll("\\s+([,=()])", "$1")
+                 .replaceAll("([,=(])\\s+", "$1")
                  .split(" +");
     }
 

File: src/java/org/apache/cassandra/utils/memory/MemoryUtil.java
Patch:
@@ -243,7 +243,7 @@ public static void setBytes(long address, ByteBuffer buffer)
         if (buffer.isDirect())
             setBytes(unsafe.getLong(buffer, DIRECT_BYTE_BUFFER_ADDRESS_OFFSET) + start, address, count);
         else
-            setBytes(address, buffer.array(), start, count);
+            setBytes(address, buffer.array(), buffer.arrayOffset() + start, count);
     }
 
     /**

File: src/java/org/apache/cassandra/utils/memory/MemoryUtil.java
Patch:
@@ -243,7 +243,7 @@ public static void setBytes(long address, ByteBuffer buffer)
         if (buffer.isDirect())
             setBytes(unsafe.getLong(buffer, DIRECT_BYTE_BUFFER_ADDRESS_OFFSET) + start, address, count);
         else
-            setBytes(address, buffer.array(), start, count);
+            setBytes(address, buffer.array(), buffer.arrayOffset() + start, count);
     }
 
     /**

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -366,7 +366,7 @@ public void run()
             waitForGossipToSettle();
 
         // schedule periodic dumps of table size estimates into SystemKeyspace.SIZE_ESTIMATES_CF
-        ScheduledExecutors.optionalTasks.scheduleWithFixedDelay(SizeEstimatesRecorder.instance, 30, 5 * 60, TimeUnit.SECONDS);
+        // ScheduledExecutors.optionalTasks.scheduleWithFixedDelay(SizeEstimatesRecorder.instance, 30, 5 * 60, TimeUnit.SECONDS);
 
         // Thrift
         InetAddress rpcAddr = DatabaseDescriptor.getRpcAddress();

File: test/unit/org/apache/cassandra/SchemaLoader.java
Patch:
@@ -429,11 +429,11 @@ public static CFMetaData jdbcSparseCFMD(String ksName, String cfName, AbstractTy
 
     public static void cleanupAndLeaveDirs()
     {
-        CommitLog.instance.resetUnsafe(); // unmap CLS before attempting to delete or Windows complains
+        CommitLog.instance.allocator.stopUnsafe(); // unmap CLS before attempting to delete or Windows complains
         mkdirs();
         cleanup();
         mkdirs();
-        CommitLog.instance.resetUnsafe(); // cleanup screws w/ CommitLog, this brings it back to safe state
+        CommitLog.instance.allocator.startUnsafe(); // cleanup screws w/ CommitLog, this brings it back to safe state
     }
 
     public static void cleanup()

File: src/java/org/apache/cassandra/cql3/Lists.java
Patch:
@@ -385,9 +385,9 @@ public void execute(ByteBuffer rowKey, ColumnFamily cf, ColumnNameBuilder prefix
 
             List<ByteBuffer> toAdd = ((Lists.Value)value).elements;
             ColumnNameBuilder column = maybeUpdatePrefix(cf.metadata(), prefix).add(columnName.key);
-            for (int i = 0; i < toAdd.size(); i++)
+            for (int i = toAdd.size() - 1; i >= 0; i--)
             {
-                ColumnNameBuilder b = i == toAdd.size() - 1 ? column : column.copy();
+                ColumnNameBuilder b = i == 0 ? column : column.copy();
                 PrecisionTime pt = PrecisionTime.getNext(time);
                 ByteBuffer uuid = ByteBuffer.wrap(UUIDGen.getTimeUUIDBytes(pt.millis, pt.nanos));
                 ByteBuffer cellName = b.add(uuid).build();

File: src/java/org/apache/cassandra/service/ActiveRepairService.java
Patch:
@@ -122,6 +122,8 @@ protected ActiveRepairService()
      */
     public RepairFuture submitRepairSession(UUID parentRepairSession, Range<Token> range, String keyspace, RepairParallelism parallelismDegree, Set<InetAddress> endpoints, String... cfnames)
     {
+        if (cfnames.length == 0)
+            return null;
         RepairSession session = new RepairSession(parentRepairSession, range, keyspace, parallelismDegree, endpoints, cfnames);
         if (session.endpoints.isEmpty())
             return null;

File: src/java/org/apache/cassandra/db/commitlog/CommitLogArchiver.java
Patch:
@@ -211,7 +211,7 @@ else if (fromHeader != null)
                     descriptor = fromHeader;
                 else descriptor = fromName;
 
-                if (descriptor.version > CommitLogDescriptor.VERSION_21)
+                if (descriptor.version > CommitLogDescriptor.VERSION_30)
                     throw new IllegalStateException("Unsupported commit log version: " + descriptor.version);
 
                 File toFile = new File(DatabaseDescriptor.getCommitLogLocation(), descriptor.fileName());

File: src/java/org/apache/cassandra/io/sstable/CQLSSTableWriter.java
Patch:
@@ -549,7 +549,7 @@ public void addColumn(Cell cell)
             };
         }
 
-        protected void addColumn(Column column) throws IOException
+        protected void addColumn(Cell cell) throws IOException
         {
             throw new UnsupportedOperationException();
         }

File: src/java/org/apache/cassandra/io/sstable/SSTableSimpleUnsortedWriter.java
Patch:
@@ -167,6 +167,7 @@ private void sync() throws IOException
 
         checkForWriterException();
 
+        columnFamily = null;
         try
         {
             writeQueue.put(buffer);
@@ -178,6 +179,7 @@ private void sync() throws IOException
         }
         buffer = new Buffer();
         currentSize = 0;
+        columnFamily = getColumnFamily();
     }
 
     private void checkForWriterException() throws IOException

File: src/java/org/apache/cassandra/io/sstable/SSTableSimpleUnsortedWriter.java
Patch:
@@ -167,6 +167,7 @@ private void sync() throws IOException
 
         checkForWriterException();
 
+        columnFamily = null;
         try
         {
             writeQueue.put(buffer);
@@ -178,6 +179,7 @@ private void sync() throws IOException
         }
         buffer = new Buffer();
         currentSize = 0;
+        columnFamily = getColumnFamily();
     }
 
     private void checkForWriterException() throws IOException

File: src/java/org/apache/cassandra/utils/memory/NativeAllocator.java
Patch:
@@ -104,6 +104,9 @@ public MemtableAllocator.DataReclaimer reclaimer()
     public long allocate(int size, OpOrder.Group opGroup)
     {
         assert size >= 0;
+        offHeap().allocate(size, opGroup);
+        // satisfy large allocations directly from JVM since they don't cause fragmentation
+        // as badly, and fill up our regions quickly
         if (size > MAX_CLONED_SIZE)
             return allocateOversize(size, opGroup);
 
@@ -150,7 +153,6 @@ private long allocateOversize(int size, OpOrder.Group opGroup)
     {
         // satisfy large allocations directly from JVM since they don't cause fragmentation
         // as badly, and fill up our regions quickly
-        offHeap().allocate(size, opGroup);
         Region region = new Region(allocator.allocate(size), size);
         regions.add(region);
 

File: src/java/org/apache/cassandra/io/sstable/format/SSTableReader.java
Patch:
@@ -469,6 +469,7 @@ public static SSTableReader internalOpen(Descriptor desc,
         reader.ifile = ifile;
         reader.dfile = dfile;
         reader.indexSummary = isummary;
+        reader.tidy.setup(reader);
 
         return reader;
     }

File: src/java/org/apache/cassandra/config/ColumnDefinition.java
Patch:
@@ -298,7 +298,7 @@ public static ColumnDefinition fromThrift(String ksName, String cfName, Abstract
     public static List<ColumnDefinition> fromThrift(String ksName, String cfName, AbstractType<?> thriftComparator, AbstractType<?> thriftSubcomparator, List<ColumnDef> thriftDefs) throws SyntaxException, ConfigurationException
     {
         if (thriftDefs == null)
-            return Collections.emptyList();
+            return new ArrayList<>();
 
         List<ColumnDefinition> defs = new ArrayList<>(thriftDefs.size());
         for (ColumnDef thriftColumnDef : thriftDefs)

File: src/java/org/apache/cassandra/utils/SigarLibrary.java
Patch:
@@ -165,7 +165,7 @@ public void warnIfRunningInDegradedMode()
             if (swapEnabled || !goodAddressSpace || !goodFileLimits || !goodProcNumber)
             {
                 logger.warn("Cassandra server running in degraded mode. Is swap disabled? : {},  Address space adequate? : {}, " +
-                            " nofile limit adequate? : {}, nproc limit adequate? : {} ", swapEnabled, goodAddressSpace,
+                            " nofile limit adequate? : {}, nproc limit adequate? : {} ", !swapEnabled, goodAddressSpace,
                             goodFileLimits, goodProcNumber );
             }
             else

File: src/java/org/apache/cassandra/tools/NodeTool.java
Patch:
@@ -55,6 +55,7 @@
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.JVMStabilityInspector;
 
+import org.apache.commons.lang3.ArrayUtils;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Throwables.getStackTraceAsString;
@@ -63,7 +64,6 @@
 import static java.lang.Integer.parseInt;
 import static java.lang.String.format;
 import static org.apache.commons.lang3.ArrayUtils.EMPTY_STRING_ARRAY;
-import static org.apache.commons.lang3.ArrayUtils.isEmpty;
 import static org.apache.commons.lang3.StringUtils.*;
 
 public class NodeTool
@@ -1019,7 +1019,7 @@ public void execute(NodeProbe probe)
             long[] estimatedRowSizeHistogram = store.getEstimatedRowSizeHistogram();
             long[] estimatedColumnCountHistogram = store.getEstimatedColumnCountHistogram();
 
-            if (isEmpty(estimatedRowSizeHistogram) || isEmpty(estimatedColumnCountHistogram))
+            if (ArrayUtils.isEmpty(estimatedRowSizeHistogram) || ArrayUtils.isEmpty(estimatedColumnCountHistogram))
             {
                 System.err.println("No SSTables exists, unable to calculate 'Partition Size' and 'Cell Count' percentiles");
             }

File: src/java/org/apache/cassandra/cql3/restrictions/TokenFilter.java
Patch:
@@ -192,10 +192,10 @@ private static RangeSet<Token> toRangeSet(TokenRestriction slice, QueryOptions o
             Token start = deserializeToken(slice.bounds(START, options).get(0));
 
             BoundType startBoundType = toBoundType(slice.isInclusive(START));
-            BoundType endBoundType = toBoundType(slice.isInclusive(END));
 
             if (slice.hasBound(END))
             {
+                BoundType endBoundType = toBoundType(slice.isInclusive(END));
                 Token end = deserializeToken(slice.bounds(END, options).get(0));
 
                 if (start.equals(end) && (BoundType.OPEN == startBoundType || BoundType.OPEN == endBoundType))

File: src/java/org/apache/cassandra/auth/IAuthorizer.java
Patch:
@@ -48,8 +48,8 @@ public interface IAuthorizer
      *
      * @param performer User who grants the permissions.
      * @param permissions Set of permissions to grant.
-     * @param to Name of the role to which the permissions are to be granted.
      * @param resource Resource on which to grant the permissions.
+     * @param grantee name of the role to which the permissions are to be granted.
      *
      * @throws RequestValidationException
      * @throws RequestExecutionException
@@ -80,7 +80,7 @@ void revoke(AuthenticatedUser performer, Set<Permission> permissions, IResource
      *                    matching ones.
      * @param resource The resource on which permissions are requested. Can be null, in which case permissions on all
      *                 resources should be returned.
-     * @param of The name of the role whose permissions are requested. Can be null, in which case permissions of every
+     * @param grantee The name of the role whose permissions are requested. Can be null, in which case permissions of every
      *           role should be returned.
      *
      * @return All of the matching permission that the requesting user is authorized to know about.

File: src/java/org/apache/cassandra/db/AtomicBTreeColumns.java
Patch:
@@ -55,8 +55,9 @@
  * isolated (in the sense of ACID). Typically a addAll is guaranteed that no
  * other thread can see the state where only parts but not all columns have
  * been added.
- * <p/>
+ * <p>
  * WARNING: removing element through getSortedColumns().iterator() is *not* supported
+ * </p>
  */
 public class AtomicBTreeColumns extends ColumnFamily
 {

File: src/java/org/apache/cassandra/gms/IFailureDetector.java
Patch:
@@ -41,7 +41,7 @@ public interface IFailureDetector
      * This method is invoked by any entity wanting to interrogate the status of an endpoint.
      * In our case it would be the Gossiper. The Failure Detector will then calculate Phi and
      * deem an endpoint as suspicious or alive as explained in the Hayashibara paper.
-     * <p/>
+     *
      * param ep endpoint for which we interpret the inter arrival times.
      */
     public void interpret(InetAddress ep);
@@ -50,7 +50,7 @@ public interface IFailureDetector
      * This method is invoked by the receiver of the heartbeat. In our case it would be
      * the Gossiper. Gossiper inform the Failure Detector on receipt of a heartbeat. The
      * FailureDetector will then sample the arrival time as explained in the paper.
-     * <p/>
+     *
      * param ep endpoint being reported.
      */
     public void report(InetAddress ep);

File: src/java/org/apache/cassandra/hadoop/cql3/CqlBulkRecordWriter.java
Patch:
@@ -136,6 +136,7 @@ public void onSuccess(StreamState finalState)
     }
     
     /**
+     * <p>
      * The column values must correspond to the order in which
      * they appear in the insert stored procedure. 
      * 

File: src/java/org/apache/cassandra/io/sstable/Component.java
Patch:
@@ -111,7 +111,9 @@ public String name()
     }
 
     /**
+     * {@code
      * Filename of the form "<ksname>/<cfname>-[tmp-][<version>-]<gen>-<component>",
+     * }
      * @return A Descriptor for the SSTable, and a Component for this particular file.
      * TODO move descriptor into Component field
      */

File: src/java/org/apache/cassandra/io/util/FastByteArrayOutputStream.java
Patch:
@@ -72,7 +72,7 @@ public FastByteArrayOutputStream() {
      *            initial size for the underlying byte array, must be
      *            non-negative.
      * @throws IllegalArgumentException
-     *             if {@code size} < 0.
+     *             if {@code size < 0}.
      */
     public FastByteArrayOutputStream(int size) {
         if (size >= 0) {

File: src/java/org/apache/cassandra/locator/CloudstackSnitch.java
Patch:
@@ -44,9 +44,11 @@
 import org.apache.cassandra.utils.JVMStabilityInspector;
 
 /**
+ * {@code
  * A snitch that assumes a Cloudstack Zone follows the typical convention
  * <country>-<location>-<availability zone> and uses the country/location
  * tuple as a datacenter and the availability zone as a rack
+ * }
  */
 
 public class CloudstackSnitch extends AbstractNetworkTopologySnitch

File: src/java/org/apache/cassandra/locator/PropertyFileSnitch.java
Patch:
@@ -37,8 +37,9 @@
 import org.apache.commons.lang3.StringUtils;
 
 /**
+ * <p>
  * Used to determine if two IP's are in the same datacenter or on the same rack.
- * <p/>
+ * </p>
  * Based on a properties file in the following format:
  *
  * 10.0.0.13=DC1:RAC2

File: src/java/org/apache/cassandra/tools/SSTableExport.java
Patch:
@@ -387,7 +387,6 @@ public static void export(Descriptor desc, String[] excludes, CFMetaData metadat
      * export the contents of the SSTable to JSON.
      *
      * @param args command lines arguments
-     * @throws IOException            on failure to open/read/write files or output streams
      * @throws ConfigurationException on configuration failure (wrong params given)
      */
     public static void main(String[] args) throws ConfigurationException

File: src/java/org/apache/cassandra/tools/SSTableImport.java
Patch:
@@ -459,7 +459,6 @@ private JsonParser getParser(String fileName) throws IOException
      * using an optional command line argument, or supplied on standard in.
      *
      * @param args command line arguments
-     * @throws IOException on failure to open/read/write files or output streams
      * @throws ParseException on failure to parse JSON input
      * @throws ConfigurationException on configuration error.
      */

File: src/java/org/apache/cassandra/tools/SSTableRepairedAtSetter.java
Patch:
@@ -36,8 +36,9 @@
  *
  * If you know you ran repair 2 weeks ago, you can do something like
  *
+ * {@code
  * sstablerepairset --is-repaired -f <(find /var/lib/cassandra/data/.../ -iname "*Data.db*" -mtime +14)
- *
+ * }
  */
 public class SSTableRepairedAtSetter
 {

File: src/java/org/apache/cassandra/utils/concurrent/OpOrder.java
Patch:
@@ -30,6 +30,7 @@
  *
  * <p>The typical usage is something like:
  * <pre>
+ * {@code
      public final class ExampleShared
      {
         final OpOrder order = new OpOrder();
@@ -73,6 +74,7 @@ public void produce()
             }
         }
     }
+ * }
  * </pre>
  */
 public class OpOrder

File: tools/stress/src/org/apache/cassandra/stress/Operation.java
Patch:
@@ -105,9 +105,9 @@ boolean ready(WorkManager permits, RateLimiter rateLimiter)
                     break;
 
                 if (spec.useRatio == null)
-                    success = partitionCache.get(i).reset(seed, spec.targetCount, this);
+                    success = partitionCache.get(i).reset(seed, spec.targetCount, isWrite());
                 else
-                    success = partitionCache.get(i).reset(seed, spec.useRatio.next(), this);
+                    success = partitionCache.get(i).reset(seed, spec.useRatio.next(), isWrite());
             }
         }
         partitionCount = i;

File: src/java/org/apache/cassandra/db/index/composites/CompositesSearcher.java
Patch:
@@ -219,6 +219,7 @@ else if (!currentKey.equals(dk))
                         {
                             DecoratedKey previousKey = currentKey;
                             currentKey = dk;
+                            previousPrefix = null;
 
                             // We're done with the previous row, return it if it had data, continue otherwise
                             indexCells.addFirst(cell);

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -314,7 +314,7 @@ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(String keys
             pendingEndpoints = ImmutableList.copyOf(Iterables.filter(pendingEndpoints, isLocalDc));
         }
         int participants = pendingEndpoints.size() + naturalEndpoints.size();
-        int requiredParticipants = (participants + 1) / 2; // See CASSANDRA-8346, CASSANDRA-833
+        int requiredParticipants = participants / 2 + 1; // See CASSANDRA-8346, CASSANDRA-833
         List<InetAddress> liveEndpoints = ImmutableList.copyOf(Iterables.filter(Iterables.concat(naturalEndpoints, pendingEndpoints), IAsyncCallback.isAlive));
         if (liveEndpoints.size() < requiredParticipants)
             throw new UnavailableException(consistencyForPaxos, requiredParticipants, liveEndpoints.size());

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -314,7 +314,7 @@ private static Pair<List<InetAddress>, Integer> getPaxosParticipants(String keys
             pendingEndpoints = ImmutableList.copyOf(Iterables.filter(pendingEndpoints, isLocalDc));
         }
         int participants = pendingEndpoints.size() + naturalEndpoints.size();
-        int requiredParticipants = participants + 1  / 2; // See CASSANDRA-833
+        int requiredParticipants = (participants + 1) / 2; // See CASSANDRA-8346, CASSANDRA-833
         List<InetAddress> liveEndpoints = ImmutableList.copyOf(Iterables.filter(Iterables.concat(naturalEndpoints, pendingEndpoints), IAsyncCallback.isAlive));
         if (liveEndpoints.size() < requiredParticipants)
             throw new UnavailableException(consistencyForPaxos, requiredParticipants, liveEndpoints.size());

File: test/unit/org/apache/cassandra/io/sstable/SSTableRewriterTest.java
Patch:
@@ -174,6 +174,7 @@ public void getPositionsTest() throws InterruptedException
         int filecounts = assertFileCounts(sstables.iterator().next().descriptor.directory.list(), 0, 0);
         assertEquals(1, filecounts);
         cfs.truncateBlocking();
+        Thread.sleep(1000); // make sure the deletion tasks have run etc
         validateCFS(cfs);
     }
 
@@ -467,6 +468,7 @@ public void testNumberOfFiles_truncate() throws Exception
         Thread.sleep(1000);
         assertFileCounts(s.descriptor.directory.list(), 0, 0);
         cfs.truncateBlocking();
+        Thread.sleep(1000); // make sure the deletion tasks have run etc
         validateCFS(cfs);
     }
 

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -844,7 +844,7 @@ else if (firstRestriction.isIN())
                 // For composites, if there was preceding component and we're computing the end, we must change the last component
                 // End-Of-Component, otherwise we would be selecting only one record.
                 Composite prefix = builder.build();
-                return Collections.singletonList(!prefix.isEmpty() && eocBound == Bound.END ? prefix.end() : prefix.start());
+                return Collections.singletonList(eocBound == Bound.END ? prefix.end() : prefix.start());
             }
             if (r.isSlice())
             {
@@ -869,7 +869,7 @@ else if (firstRestriction.isIN())
                             throw new InvalidRequestException(String.format("Invalid null clustering key part %s", def.name));
                         Composite prefix = builder.buildWith(val);
                         // See below for why this
-                        s.add((eocBound == Bound.END && builder.remainingCount() > 0) ? prefix.end() : prefix.start());
+                        s.add(builder.remainingCount() == 0 ? prefix : (eocBound == Bound.END ? prefix.end() : prefix.start()));
                     }
                     return new ArrayList<>(s);
                 }
@@ -887,7 +887,7 @@ else if (firstRestriction.isIN())
         // case using the eoc would be bad, since for the random partitioner we have no guarantee that
         // prefix.end() will sort after prefix (see #5240).
         Composite prefix = builder.build();
-        return Collections.singletonList(eocBound == Bound.END && builder.remainingCount() > 0 ? prefix.end() : prefix.start());
+        return Collections.singletonList(builder.remainingCount() == 0 ? prefix : (eocBound == Bound.END ? prefix.end() : prefix.start()));
     }
 
     private static Composite.EOC eocForRelation(Operator op)

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -844,7 +844,7 @@ else if (firstRestriction.isIN())
                 // For composites, if there was preceding component and we're computing the end, we must change the last component
                 // End-Of-Component, otherwise we would be selecting only one record.
                 Composite prefix = builder.build();
-                return Collections.singletonList(!prefix.isEmpty() && eocBound == Bound.END ? prefix.end() : prefix);
+                return Collections.singletonList(!prefix.isEmpty() && eocBound == Bound.END ? prefix.end() : prefix.start());
             }
             if (r.isSlice())
             {
@@ -869,7 +869,7 @@ else if (firstRestriction.isIN())
                             throw new InvalidRequestException(String.format("Invalid null clustering key part %s", def.name));
                         Composite prefix = builder.buildWith(val);
                         // See below for why this
-                        s.add((eocBound == Bound.END && builder.remainingCount() > 0) ? prefix.end() : prefix);
+                        s.add((eocBound == Bound.END && builder.remainingCount() > 0) ? prefix.end() : prefix.start());
                     }
                     return new ArrayList<>(s);
                 }
@@ -887,7 +887,7 @@ else if (firstRestriction.isIN())
         // case using the eoc would be bad, since for the random partitioner we have no guarantee that
         // prefix.end() will sort after prefix (see #5240).
         Composite prefix = builder.build();
-        return Collections.singletonList(eocBound == Bound.END && builder.remainingCount() > 0 ? prefix.end() : prefix);
+        return Collections.singletonList(eocBound == Bound.END && builder.remainingCount() > 0 ? prefix.end() : prefix.start());
     }
 
     private static Composite.EOC eocForRelation(Operator op)

File: src/java/org/apache/cassandra/db/composites/CellNameType.java
Patch:
@@ -197,7 +197,7 @@ public interface Deserializer
         public boolean hasUnprocessed() throws IOException;
 
         /**
-         * Comparare the next name to read to the provided Composite.
+         * Compare the next name to read to the provided Composite.
          * This does not consume the next name.
          */
         public int compareNextTo(Composite composite) throws IOException;

File: src/java/org/apache/cassandra/hadoop/cql3/CqlRecordReader.java
Patch:
@@ -69,8 +69,6 @@ public class CqlRecordReader extends RecordReader<Long, Row>
 {
     private static final Logger logger = LoggerFactory.getLogger(CqlRecordReader.class);
 
-    public static final int DEFAULT_CQL_PAGE_LIMIT = 1000;
-
     private ColumnFamilySplit split;
     private RowIterator rowIterator;
 

File: examples/hadoop_cql3_word_count/src/WordCount.java
Patch:
@@ -26,7 +26,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.apache.cassandra.hadoop.cql3.CqlPagingInputFormat;
 import org.apache.cassandra.hadoop.cql3.CqlInputFormat;
 import org.apache.cassandra.hadoop.ConfigHelper;
 import org.apache.cassandra.utils.ByteBufferUtil;
@@ -247,7 +246,7 @@ public int run(String[] args) throws Exception
         else
         {
             job.setMapperClass(TokenizerMapper.class);
-            job.setInputFormatClass(CqlPagingInputFormat.class);
+            job.setInputFormatClass(CqlInputFormat.class);
             ConfigHelper.setInputRpcPort(job.getConfiguration(), "9160");
         }
 

File: examples/hadoop_cql3_word_count/src/WordCountCounters.java
Patch:
@@ -25,7 +25,6 @@
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.hadoop.cql3.CqlConfigHelper;
-import org.apache.cassandra.hadoop.cql3.CqlPagingInputFormat;
 import org.apache.cassandra.hadoop.cql3.CqlInputFormat;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.conf.Configured;
@@ -156,7 +155,7 @@ public int run(String[] args) throws Exception
         else
         {
             job.setMapperClass(SumMapper.class);
-            job.setInputFormatClass(CqlPagingInputFormat.class);
+            job.setInputFormatClass(CqlInputFormat.class);
             ConfigHelper.setInputRpcPort(job.getConfiguration(), "9160");
         }
 

File: src/java/org/apache/cassandra/hadoop/pig/CqlStorage.java
Patch:
@@ -76,7 +76,7 @@ public CqlStorage(int pageSize)
     {
         super();
         this.pageSize = pageSize;
-        DEFAULT_INPUT_FORMAT = "org.apache.cassandra.hadoop.cql3.CqlPagingInputFormat";
+        DEFAULT_INPUT_FORMAT = "org.apache.cassandra.hadoop.cql3.CqlInputFormat";
         DEFAULT_OUTPUT_FORMAT = "org.apache.cassandra.hadoop.cql3.CqlOutputFormat";
     }   
 

File: examples/hadoop_cql3_word_count/src/WordCount.java
Patch:
@@ -26,7 +26,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.apache.cassandra.hadoop.cql3.CqlPagingInputFormat;
 import org.apache.cassandra.hadoop.cql3.CqlInputFormat;
 import org.apache.cassandra.hadoop.ConfigHelper;
 import org.apache.cassandra.utils.ByteBufferUtil;
@@ -247,7 +246,7 @@ public int run(String[] args) throws Exception
         else
         {
             job.setMapperClass(TokenizerMapper.class);
-            job.setInputFormatClass(CqlPagingInputFormat.class);
+            job.setInputFormatClass(CqlInputFormat.class);
             ConfigHelper.setInputRpcPort(job.getConfiguration(), "9160");
         }
 

File: examples/hadoop_cql3_word_count/src/WordCountCounters.java
Patch:
@@ -25,7 +25,6 @@
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.hadoop.cql3.CqlConfigHelper;
-import org.apache.cassandra.hadoop.cql3.CqlPagingInputFormat;
 import org.apache.cassandra.hadoop.cql3.CqlInputFormat;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.conf.Configured;
@@ -156,7 +155,7 @@ public int run(String[] args) throws Exception
         else
         {
             job.setMapperClass(SumMapper.class);
-            job.setInputFormatClass(CqlPagingInputFormat.class);
+            job.setInputFormatClass(CqlInputFormat.class);
             ConfigHelper.setInputRpcPort(job.getConfiguration(), "9160");
         }
 

File: src/java/org/apache/cassandra/hadoop/pig/CqlStorage.java
Patch:
@@ -76,7 +76,7 @@ public CqlStorage(int pageSize)
     {
         super();
         this.pageSize = pageSize;
-        DEFAULT_INPUT_FORMAT = "org.apache.cassandra.hadoop.cql3.CqlPagingInputFormat";
+        DEFAULT_INPUT_FORMAT = "org.apache.cassandra.hadoop.cql3.CqlInputFormat";
         DEFAULT_OUTPUT_FORMAT = "org.apache.cassandra.hadoop.cql3.CqlOutputFormat";
     }   
 

File: src/java/org/apache/cassandra/cql3/statements/DropTypeStatement.java
Patch:
@@ -121,7 +121,7 @@ else if (toCheck instanceof CollectionType)
             else if (toCheck instanceof SetType)
                 return isUsedBy(((SetType)toCheck).getElementsType());
             else
-                return isUsedBy(((MapType)toCheck).getKeysType()) || isUsedBy(((MapType)toCheck).getKeysType());
+                return isUsedBy(((MapType)toCheck).getKeysType()) || isUsedBy(((MapType)toCheck).getValuesType());
         }
         return false;
     }

File: src/java/org/apache/cassandra/net/MessageOut.java
Patch:
@@ -128,8 +128,8 @@ public int serializedSize(int version)
         size += TypeSizes.NATIVE.sizeof(parameters.size());
         for (Map.Entry<String, byte[]> entry : parameters.entrySet())
         {
-            TypeSizes.NATIVE.sizeof(entry.getKey());
-            TypeSizes.NATIVE.sizeof(entry.getValue().length);
+            size += TypeSizes.NATIVE.sizeof(entry.getKey());
+            size += TypeSizes.NATIVE.sizeof(entry.getValue().length);
             size += entry.getValue().length;
         }
 

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1749,6 +1749,7 @@ public List<Row> filter(AbstractScanIterator rowIterator, ExtendedFilter filter)
         List<Row> rows = new ArrayList<Row>();
         int columnsCount = 0;
         int total = 0, matched = 0;
+        boolean ignoreTombstonedPartitions = filter.ignoreTombstonedPartitions();
 
         try
         {
@@ -1784,7 +1785,8 @@ public List<Row> filter(AbstractScanIterator rowIterator, ExtendedFilter filter)
                 }
 
                 rows.add(new Row(rawRow.key, data));
-                matched++;
+                if (!ignoreTombstonedPartitions || !data.hasOnlyTombstones(filter.timestamp))
+                    matched++;
 
                 if (data != null)
                     columnsCount += filter.lastCounted(data);

File: test/unit/org/apache/cassandra/db/compaction/DateTieredCompactionStrategyTest.java
Patch:
@@ -70,7 +70,7 @@ public void testOptionsValidation() throws ConfigurationException
         {
             options.put(DateTieredCompactionStrategyOptions.BASE_TIME_KEY, "-1337");
             validateOptions(options);
-            fail(String.format("%Negative %s should be rejected", DateTieredCompactionStrategyOptions.BASE_TIME_KEY));
+            fail(String.format("Negative %s should be rejected", DateTieredCompactionStrategyOptions.BASE_TIME_KEY));
         }
         catch (ConfigurationException e)
         {
@@ -81,7 +81,7 @@ public void testOptionsValidation() throws ConfigurationException
         {
             options.put(DateTieredCompactionStrategyOptions.MAX_SSTABLE_AGE_KEY, "-1337");
             validateOptions(options);
-            fail(String.format("%Negative %s should be rejected", DateTieredCompactionStrategyOptions.MAX_SSTABLE_AGE_KEY));
+            fail(String.format("Negative %s should be rejected", DateTieredCompactionStrategyOptions.MAX_SSTABLE_AGE_KEY));
         }
         catch (ConfigurationException e)
         {

File: test/unit/org/apache/cassandra/cql3/CreateIndexStatementTest.java
Patch:
@@ -79,7 +79,7 @@ private void testCreateAndDropIndex(String indexName, boolean addKeyspaceOnDrop)
         else
         {
             execute("USE " + KEYSPACE);
-            dropIndex("DROP INDEX " + indexName);
+            execute("DROP INDEX " + indexName);
         }
 
         assertInvalidMessage("No secondary indexes on the restricted columns support the provided operators",

File: test/unit/org/apache/cassandra/streaming/StreamTransferTaskTest.java
Patch:
@@ -64,7 +64,7 @@ public void testScheduleTimeout() throws Exception
         {
             List<Range<Token>> ranges = new ArrayList<>();
             ranges.add(new Range<>(sstable.first.getToken(), sstable.last.getToken()));
-            task.addTransferFile(sstable, 1, sstable.getPositionsForRanges(ranges), 0);
+            task.addTransferFile(sstable, 1, sstable.getPositionsForRanges(ranges));
         }
         assertEquals(2, task.getTotalNumberOfFiles());
 

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -1945,7 +1945,7 @@ else if (!canRestrictFurtherComponents)
                             break;
                         }
                         throw new InvalidRequestException(String.format(
-                                "PRIMARY KEY column \"%s\" cannot be restricted (preceding column \"%s\" is either not restricted or by a non-EQ relation)", cdef.name, previous));
+                                "PRIMARY KEY column \"%s\" cannot be restricted (preceding column \"%s\" is either not restricted or by a non-EQ relation)", cdef.name, previous.name));
                     }
                 }
                 else if (restriction.isSlice())

File: test/unit/org/apache/cassandra/cql3/UseStatementTest.java
Patch:
@@ -24,6 +24,6 @@ public class UseStatementTest extends CQLTester
     @Test
     public void testUseStatementWithBindVariable() throws Throwable
     {
-        assertInvalidSyntaxMessage("Bind variables cannot be used for keyspace or table names", "USE ?");
+        assertInvalidSyntaxMessage("Bind variables cannot be used for keyspace names", "USE ?");
     }
 }

File: src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java
Patch:
@@ -49,13 +49,13 @@ public class CreateIndexStatement extends SchemaAlteringStatement
     private final boolean ifNotExists;
 
     public CreateIndexStatement(CFName name,
-                                String indexName,
+                                IndexName indexName,
                                 IndexTarget.Raw target,
                                 IndexPropDefs properties,
                                 boolean ifNotExists)
     {
         super(name);
-        this.indexName = indexName;
+        this.indexName = indexName.getIdx();
         this.rawTarget = target;
         this.properties = properties;
         this.ifNotExists = ifNotExists;

File: examples/hadoop_cql3_word_count/src/WordCount.java
Patch:
@@ -26,6 +26,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import org.apache.cassandra.hadoop.cql3.CqlPagingInputFormat;
 import org.apache.cassandra.hadoop.cql3.CqlInputFormat;
 import org.apache.cassandra.hadoop.ConfigHelper;
 import org.apache.cassandra.utils.ByteBufferUtil;
@@ -246,7 +247,7 @@ public int run(String[] args) throws Exception
         else
         {
             job.setMapperClass(TokenizerMapper.class);
-            job.setInputFormatClass(CqlInputFormat.class);
+            job.setInputFormatClass(CqlPagingInputFormat.class);
             ConfigHelper.setInputRpcPort(job.getConfiguration(), "9160");
         }
 

File: examples/hadoop_cql3_word_count/src/WordCountCounters.java
Patch:
@@ -25,6 +25,7 @@
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.hadoop.cql3.CqlConfigHelper;
+import org.apache.cassandra.hadoop.cql3.CqlPagingInputFormat;
 import org.apache.cassandra.hadoop.cql3.CqlInputFormat;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.conf.Configured;
@@ -155,7 +156,7 @@ public int run(String[] args) throws Exception
         else
         {
             job.setMapperClass(SumMapper.class);
-            job.setInputFormatClass(CqlInputFormat.class);
+            job.setInputFormatClass(CqlPagingInputFormat.class);
             ConfigHelper.setInputRpcPort(job.getConfiguration(), "9160");
         }
 

File: src/java/org/apache/cassandra/hadoop/pig/CqlStorage.java
Patch:
@@ -74,7 +74,7 @@ public CqlStorage(int pageSize)
     {
         super();
         this.pageSize = pageSize;
-        DEFAULT_INPUT_FORMAT = "org.apache.cassandra.hadoop.cql3.CqlInputFormat";
+        DEFAULT_INPUT_FORMAT = "org.apache.cassandra.hadoop.cql3.CqlPagingInputFormat";
         DEFAULT_OUTPUT_FORMAT = "org.apache.cassandra.hadoop.cql3.CqlOutputFormat";
     }   
 

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegmentManager.java
Patch:
@@ -145,8 +145,7 @@ public void runMayThrow() throws Exception
                             }
                             catch (InterruptedException e)
                             {
-                                // shutdown signal; exit cleanly
-                                continue;
+                                throw new AssertionError();
                             }
                         }
 
@@ -536,7 +535,7 @@ public void resetUnsafe()
     public void shutdown()
     {
         run = false;
-        managerThread.interrupt();
+        segmentManagementTasks.add(Callables.<CommitLogSegment>returning(null));
     }
 
     /**

File: src/java/org/apache/cassandra/db/compaction/CompactionTask.java
Patch:
@@ -146,6 +146,7 @@ public boolean apply(SSTableReader sstable)
             long estimatedTotalKeys = Math.max(cfs.metadata.getMinIndexInterval(), SSTableReader.getApproximateKeyCount(actuallyCompact));
             long estimatedSSTables = Math.max(1, SSTableReader.getTotalBytes(actuallyCompact) / strategy.getMaxSSTableBytes());
             long keysPerSSTable = (long) Math.ceil((double) estimatedTotalKeys / estimatedSSTables);
+            long expectedSSTableSize = Math.min(getExpectedWriteSize(), strategy.getMaxSSTableBytes());
             logger.debug("Expected bloom filter size : {}", keysPerSSTable);
 
             try (AbstractCompactionStrategy.ScannerList scanners = strategy.getScanners(actuallyCompact))
@@ -173,7 +174,7 @@ public boolean apply(SSTableReader sstable)
                         return;
                     }
 
-                    writer.switchWriter(createCompactionWriter(cfs.directories.getLocationForDisk(getWriteDirectory(estimatedTotalKeys/estimatedSSTables)), keysPerSSTable, minRepairedAt));
+                    writer.switchWriter(createCompactionWriter(cfs.directories.getLocationForDisk(getWriteDirectory(expectedSSTableSize)), keysPerSSTable, minRepairedAt));
                     while (iter.hasNext())
                     {
                         if (ci.isStopRequested())
@@ -185,7 +186,7 @@ public boolean apply(SSTableReader sstable)
                             totalKeysWritten++;
                             if (newSSTableSegmentThresholdReached(writer.currentWriter()))
                             {
-                                writer.switchWriter(createCompactionWriter(cfs.directories.getLocationForDisk(getWriteDirectory(estimatedTotalKeys/estimatedSSTables)), keysPerSSTable, minRepairedAt));
+                                writer.switchWriter(createCompactionWriter(cfs.directories.getLocationForDisk(getWriteDirectory(expectedSSTableSize)), keysPerSSTable, minRepairedAt));
                             }
                         }
 

File: examples/hadoop_cql3_word_count/src/WordCount.java
Patch:
@@ -26,7 +26,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.apache.cassandra.hadoop.cql3.CqlPagingInputFormat;
 import org.apache.cassandra.hadoop.cql3.CqlInputFormat;
 import org.apache.cassandra.hadoop.ConfigHelper;
 import org.apache.cassandra.utils.ByteBufferUtil;
@@ -247,7 +246,7 @@ public int run(String[] args) throws Exception
         else
         {
             job.setMapperClass(TokenizerMapper.class);
-            job.setInputFormatClass(CqlPagingInputFormat.class);
+            job.setInputFormatClass(CqlInputFormat.class);
             ConfigHelper.setInputRpcPort(job.getConfiguration(), "9160");
         }
 

File: examples/hadoop_cql3_word_count/src/WordCountCounters.java
Patch:
@@ -25,7 +25,6 @@
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.hadoop.cql3.CqlConfigHelper;
-import org.apache.cassandra.hadoop.cql3.CqlPagingInputFormat;
 import org.apache.cassandra.hadoop.cql3.CqlInputFormat;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.conf.Configured;
@@ -156,7 +155,7 @@ public int run(String[] args) throws Exception
         else
         {
             job.setMapperClass(SumMapper.class);
-            job.setInputFormatClass(CqlPagingInputFormat.class);
+            job.setInputFormatClass(CqlInputFormat.class);
             ConfigHelper.setInputRpcPort(job.getConfiguration(), "9160");
         }
 

File: src/java/org/apache/cassandra/hadoop/pig/CqlStorage.java
Patch:
@@ -74,7 +74,7 @@ public CqlStorage(int pageSize)
     {
         super();
         this.pageSize = pageSize;
-        DEFAULT_INPUT_FORMAT = "org.apache.cassandra.hadoop.cql3.CqlPagingInputFormat";
+        DEFAULT_INPUT_FORMAT = "org.apache.cassandra.hadoop.cql3.CqlInputFormat";
         DEFAULT_OUTPUT_FORMAT = "org.apache.cassandra.hadoop.cql3.CqlOutputFormat";
     }   
 

File: src/java/org/apache/cassandra/cql3/statements/GrantStatement.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.util.Set;
 
-import org.apache.cassandra.auth.IResource;
+import org.apache.cassandra.auth.DataResource;
 import org.apache.cassandra.auth.Permission;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.exceptions.RequestExecutionException;
@@ -30,7 +30,7 @@
 
 public class GrantStatement extends PermissionAlteringStatement
 {
-    public GrantStatement(Set<Permission> permissions, IResource resource, String username)
+    public GrantStatement(Set<Permission> permissions, DataResource resource, String username)
     {
         super(permissions, resource, username);
     }

File: src/java/org/apache/cassandra/cql3/statements/ListPermissionsStatement.java
Patch:
@@ -52,10 +52,10 @@ public class ListPermissionsStatement extends AuthorizationStatement
     private final String username;
     private final boolean recursive;
 
-    public ListPermissionsStatement(Set<Permission> permissions, IResource resource, String username, boolean recursive)
+    public ListPermissionsStatement(Set<Permission> permissions, DataResource resource, String username, boolean recursive)
     {
         this.permissions = permissions;
-        this.resource = (DataResource) resource;
+        this.resource = resource;
         this.username = username;
         this.recursive = recursive;
     }

File: src/java/org/apache/cassandra/cql3/statements/PermissionAlteringStatement.java
Patch:
@@ -34,10 +34,10 @@ public abstract class PermissionAlteringStatement extends AuthorizationStatement
     protected DataResource resource;
     protected final String username;
 
-    protected PermissionAlteringStatement(Set<Permission> permissions, IResource resource, String username)
+    protected PermissionAlteringStatement(Set<Permission> permissions, DataResource resource, String username)
     {
         this.permissions = permissions;
-        this.resource = (DataResource) resource;
+        this.resource = resource;
         this.username = username;
     }
 

File: src/java/org/apache/cassandra/cql3/statements/RevokeStatement.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.util.Set;
 
-import org.apache.cassandra.auth.IResource;
+import org.apache.cassandra.auth.DataResource;
 import org.apache.cassandra.auth.Permission;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.exceptions.RequestExecutionException;
@@ -30,7 +30,7 @@
 
 public class RevokeStatement extends PermissionAlteringStatement
 {
-    public RevokeStatement(Set<Permission> permissions, IResource resource, String username)
+    public RevokeStatement(Set<Permission> permissions, DataResource resource, String username)
     {
         super(permissions, resource, username);
     }

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -212,7 +212,7 @@ public ResultMessage.Rows execute(QueryState state, QueryOptions options) throws
         else
         {
             List<ReadCommand> commands = getSliceCommands(variables, limitForQuery, now);
-            command = commands == null ? null : new Pageable.ReadCommands(commands);
+            command = commands == null ? null : new Pageable.ReadCommands(commands, limitForQuery);
         }
 
         int pageSize = options.getPageSize();

File: test/unit/org/apache/cassandra/service/QueryPagerTest.java
Patch:
@@ -236,7 +236,7 @@ public void MultiQueryTest() throws Exception
         QueryPager pager = QueryPagers.localPager(new Pageable.ReadCommands(new ArrayList<ReadCommand>() {{
             add(sliceQuery("k1", "c2", "c6", 10));
             add(sliceQuery("k4", "c3", "c5", 10));
-        }}));
+        }}, 10));
 
         List<Row> page;
 

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -1035,9 +1035,6 @@ private Collection<SSTableReader> doAntiCompaction(ColumnFamilyStore cfs, Collec
                         unrepairedKeyCount++;
                     }
                 }
-                // we have the same readers being rewritten by both writers, so we ask the first one NOT to close them
-                // so that the second one can do so safely, without leaving us with references < 0 or any other ugliness
-                // add repaired table with a non-null timestamp field to be saved in SSTableMetadata#repairedAt
                 anticompactedSSTables.addAll(repairedSSTableWriter.finish(repairedAt));
                 anticompactedSSTables.addAll(unRepairedSSTableWriter.finish(ActiveRepairService.UNREPAIRED_SSTABLE));
                 cfs.getDataTracker().markCompactedSSTablesReplaced(sstableAsSet, anticompactedSSTables, OperationType.ANTICOMPACTION);

File: src/java/org/apache/cassandra/db/compaction/CompactionIterable.java
Patch:
@@ -24,6 +24,7 @@
 import com.google.common.collect.ImmutableList;
 
 import org.apache.cassandra.db.columniterator.OnDiskAtomIterator;
+import org.apache.cassandra.io.sstable.ISSTableScanner;
 import org.apache.cassandra.utils.CloseableIterator;
 import org.apache.cassandra.utils.MergeIterator;
 
@@ -37,7 +38,7 @@ public int compare(OnDiskAtomIterator i1, OnDiskAtomIterator i2)
         }
     };
 
-    public CompactionIterable(OperationType type, List<ICompactionScanner> scanners, CompactionController controller)
+    public CompactionIterable(OperationType type, List<ISSTableScanner> scanners, CompactionController controller)
     {
         super(controller, type, scanners);
     }
@@ -77,7 +78,7 @@ protected AbstractCompactedRow getReduced()
             {
                 rows.clear();
                 long n = 0;
-                for (ICompactionScanner scanner : scanners)
+                for (ISSTableScanner scanner : scanners)
                     n += scanner.getCurrentPosition();
                 bytesRead = n;
             }

File: src/java/org/apache/cassandra/db/compaction/WrappingCompactionStrategy.java
Patch:
@@ -22,13 +22,15 @@
 import java.util.Collection;
 import java.util.List;
 import java.util.concurrent.Callable;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.Token;
+import org.apache.cassandra.io.sstable.ISSTableScanner;
 import org.apache.cassandra.io.sstable.SSTableReader;
 import org.apache.cassandra.notifications.INotification;
 import org.apache.cassandra.notifications.INotificationConsumer;
@@ -318,7 +320,7 @@ public synchronized ScannerList getScanners(Collection<SSTableReader> sstables,
                 unrepairedSSTables.add(sstable);
         ScannerList repairedScanners = repaired.getScanners(repairedSSTables, range);
         ScannerList unrepairedScanners = unrepaired.getScanners(unrepairedSSTables, range);
-        List<ICompactionScanner> scanners = new ArrayList<>(repairedScanners.scanners.size() + unrepairedScanners.scanners.size());
+        List<ISSTableScanner> scanners = new ArrayList<>(repairedScanners.scanners.size() + unrepairedScanners.scanners.size());
         scanners.addAll(repairedScanners.scanners);
         scanners.addAll(unrepairedScanners.scanners);
         return new ScannerList(scanners);

File: src/java/org/apache/cassandra/tools/SSTableExport.java
Patch:
@@ -321,7 +321,7 @@ static void export(SSTableReader reader, PrintStream outs, String[] excludes, CF
             excludeSet = new HashSet<String>(Arrays.asList(excludes));
 
         SSTableIdentityIterator row;
-        SSTableScanner scanner = reader.getScanner();
+        ISSTableScanner scanner = reader.getScanner();
         try
         {
             outs.println("[");

File: test/unit/org/apache/cassandra/db/compaction/LeveledCompactionStrategyTest.java
Patch:
@@ -34,6 +34,7 @@
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.Token;
+import org.apache.cassandra.io.sstable.ISSTableScanner;
 import org.apache.cassandra.io.sstable.SSTableReader;
 import org.apache.cassandra.notifications.SSTableAddedNotification;
 import org.apache.cassandra.notifications.SSTableRepairStatusChanged;
@@ -145,9 +146,9 @@ public void testCompactionProgress() throws Exception
 
         // get LeveledScanner for level 1 sstables
         Collection<SSTableReader> sstables = strategy.manifest.getLevel(1);
-        List<ICompactionScanner> scanners = strategy.getScanners(sstables).scanners;
+        List<ISSTableScanner> scanners = strategy.getScanners(sstables).scanners;
         assertEquals(1, scanners.size()); // should be one per level
-        ICompactionScanner scanner = scanners.get(0);
+        ISSTableScanner scanner = scanners.get(0);
         // scan through to the end
         while (scanner.hasNext())
             scanner.next();

File: test/unit/org/apache/cassandra/db/compaction/TTLExpiryTest.java
Patch:
@@ -29,8 +29,8 @@
 import org.apache.cassandra.Util;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.columniterator.OnDiskAtomIterator;
+import org.apache.cassandra.io.sstable.ISSTableScanner;
 import org.apache.cassandra.io.sstable.SSTableReader;
-import org.apache.cassandra.io.sstable.SSTableScanner;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
 import java.util.Collections;
@@ -181,7 +181,7 @@ public void testNoExpire() throws InterruptedException
         cfs.enableAutoCompaction(true);
         assertEquals(1, cfs.getSSTables().size());
         SSTableReader sstable = cfs.getSSTables().iterator().next();
-        SSTableScanner scanner = sstable.getScanner(DataRange.allData(sstable.partitioner));
+        ISSTableScanner scanner = sstable.getScanner(DataRange.allData(sstable.partitioner));
         assertTrue(scanner.hasNext());
         while(scanner.hasNext())
         {

File: test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java
Patch:
@@ -56,7 +56,6 @@
 import org.apache.cassandra.db.RowPosition;
 import org.apache.cassandra.db.columniterator.IdentityQueryFilter;
 import org.apache.cassandra.db.compaction.CompactionManager;
-import org.apache.cassandra.db.compaction.ICompactionScanner;
 import org.apache.cassandra.db.composites.Composites;
 import org.apache.cassandra.dht.LocalPartitioner;
 import org.apache.cassandra.dht.LocalToken;
@@ -347,7 +346,7 @@ public void testGetScannerForNoIntersectingRanges()
         boolean foundScanner = false;
         for (SSTableReader s : store.getSSTables())
         {
-            ICompactionScanner scanner = s.getScanner(new Range<Token>(t(0), t(1), s.partitioner), null);
+            ISSTableScanner scanner = s.getScanner(new Range<Token>(t(0), t(1), s.partitioner), null);
             scanner.next(); // throws exception pre 5407
             foundScanner = true;
         }

File: test/unit/org/apache/cassandra/io/sstable/SSTableUtils.java
Patch:
@@ -69,8 +69,8 @@ public static File tempSSTableFile(String keyspaceName, String cfname, int gener
 
     public static void assertContentEquals(SSTableReader lhs, SSTableReader rhs)
     {
-        SSTableScanner slhs = lhs.getScanner();
-        SSTableScanner srhs = rhs.getScanner();
+        ISSTableScanner slhs = lhs.getScanner();
+        ISSTableScanner srhs = rhs.getScanner();
         while (slhs.hasNext())
         {
             OnDiskAtomIterator ilhs = slhs.next();

File: src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java
Patch:
@@ -85,8 +85,8 @@ public void validate(ClientState state) throws RequestValidationException
         properties.validate();
 
         // TODO: we could lift that limitation
-        if (cfm.getCfDef().isCompact && cd.type != ColumnDefinition.Type.REGULAR)
-            throw new InvalidRequestException(String.format("Secondary index on %s column %s is not yet supported for compact table", cd.type, columnName));
+        if ((cfm.getCfDef().isCompact || !cfm.getCfDef().isComposite) && cd.type != ColumnDefinition.Type.REGULAR)
+            throw new InvalidRequestException("Secondary indexes are not supported on PRIMARY KEY columns in COMPACT STORAGE tables");
 
         // It would be possible to support 2ndary index on static columns (but not without modifications of at least ExtendedFilter and
         // CompositesIndex) and maybe we should, but that means a query like:

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -2536,6 +2536,7 @@ public int forceRepairRangeAsync(String beginToken,
                                      boolean fullRepair,
                                      String... columnFamilies)
     {
+        if (FBUtilities.isWindows() && parallelismDegree != RepairParallelism.PARALLEL)
         {
             logger.warn("Snapshot-based repair is not yet supported on Windows.  Reverting to parallel repair.");
             parallelismDegree = RepairParallelism.PARALLEL;

File: src/java/org/apache/cassandra/utils/FBUtilities.java
Patch:
@@ -70,8 +70,8 @@ public class FBUtilities
     public static final BigInteger TWO = new BigInteger("2");
     private static final String DEFAULT_TRIGGER_DIR = "triggers";
 
+    private static final String OPERATING_SYSTEM = System.getProperty("os.name").toLowerCase();
     private static final boolean IS_WINDOWS = OPERATING_SYSTEM.contains("windows");
-
     private static final boolean HAS_PROCFS = !IS_WINDOWS && (new File(File.separator + "proc")).exists();
 
     private static volatile InetAddress localInetAddress;

File: src/java/org/apache/cassandra/utils/SigarLibrary.java
Patch:
@@ -110,7 +110,7 @@ private boolean hasAcceptableFileLimits()
     private boolean hasAcceptableAddressSpace()
     {
         // Check is invalid on Windows
-        if (!FBUtilities.isUnix())
+        if (FBUtilities.isWindows())
             return true;
 
         try

File: test/pig/org/apache/pig/test/MiniCluster.java
Patch:
@@ -50,7 +50,7 @@ protected void setupMiniDfsAndMrClusters() {
 
             // Builds and starts the mini dfs and mapreduce clusters
             Configuration config = new Configuration();
-            if (!FBUtilities.isUnix())
+            if (FBUtilities.isWindows())
                 config.set("fs.file.impl", WindowsLocalFileSystem.class.getName());
             m_dfs = new MiniDFSCluster(config, dataNodes, true, null);
             m_fileSys = m_dfs.getFileSystem();

File: src/java/org/apache/cassandra/cql3/QueryProcessor.java
Patch:
@@ -543,6 +543,7 @@ public static ParsedStatement parseStatement(String queryStr) throws SyntaxExcep
         }
         catch (RuntimeException re)
         {
+            logger.error(String.format("The statement: [%s] could not be parsed.", queryStr), re);
             throw new SyntaxException(String.format("Failed parsing statement: [%s] reason: %s %s",
                                                     queryStr,
                                                     re.getClass().getSimpleName(),

File: src/java/org/apache/cassandra/cql3/QueryProcessor.java
Patch:
@@ -542,6 +542,7 @@ public static ParsedStatement parseStatement(String queryStr) throws SyntaxExcep
         }
         catch (RuntimeException re)
         {
+            logger.error(String.format("The statement: [%s] could not be parsed.", queryStr), re);
             throw new SyntaxException(String.format("Failed parsing statement: [%s] reason: %s %s",
                                                     queryStr,
                                                     re.getClass().getSimpleName(),

File: src/java/org/apache/cassandra/utils/memory/NativeAllocator.java
Patch:
@@ -17,6 +17,8 @@
  */
 package org.apache.cassandra.utils.memory;
 
+import java.util.HashMap;
+import java.util.Map;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.atomic.AtomicInteger;

File: src/java/org/apache/cassandra/io/compress/CompressionParameters.java
Patch:
@@ -105,6 +105,9 @@ public CompressionParameters copy()
 
     public void setLiveMetadata(final CFMetaData liveMetadata)
     {
+        if (liveMetadata == null)
+            return;
+
         assert this.liveMetadata == null || this.liveMetadata == liveMetadata;
         this.liveMetadata = liveMetadata;
     }

File: src/java/org/apache/cassandra/db/compaction/DateTieredCompactionStrategyOptions.java
Patch:
@@ -26,7 +26,7 @@ public final class DateTieredCompactionStrategyOptions
 {
     protected static final TimeUnit DEFAULT_TIMESTAMP_RESOLUTION = TimeUnit.MICROSECONDS;
     protected static final long DEFAULT_MAX_SSTABLE_AGE_DAYS = 365;
-    protected static final long DEFAULT_BASE_TIME_SECONDS = 60 * 60;
+    protected static final long DEFAULT_BASE_TIME_SECONDS = 60;
     protected static final String TIMESTAMP_RESOLUTION_KEY = "timestamp_resolution";
     protected static final String MAX_SSTABLE_AGE_KEY = "max_sstable_age_days";
     protected static final String BASE_TIME_KEY = "base_time_seconds";

File: src/java/org/apache/cassandra/utils/concurrent/Accumulator.java
Patch:
@@ -89,7 +89,7 @@ public void add(E item)
 
     public boolean isEmpty()
     {
-        return presentCount != 0;
+        return presentCount == 0;
     }
 
     /**

File: tools/stress/src/org/apache/cassandra/stress/settings/CliOption.java
Patch:
@@ -31,6 +31,7 @@ public enum CliOption
     COL("Column details such as size and count distribution, data generator, names, comparator and if super columns should be used", SettingsColumn.helpPrinter()),
     RATE("Thread count, rate limit or automatic mode (default is auto)", SettingsRate.helpPrinter()),
     MODE("Thrift or CQL with options", SettingsMode.helpPrinter()),
+    ERRORS("How to handle errors when encountered during stress", SettingsErrors.helpPrinter()),
     SCHEMA("Replication settings, compression, compaction, etc.", SettingsSchema.helpPrinter()),
     NODE("Nodes to connect to", SettingsNode.helpPrinter()),
     LOG("Where to log progress to, and the interval at which to do it", SettingsLog.helpPrinter()),

File: src/java/org/apache/cassandra/repair/LocalSyncTask.java
Patch:
@@ -103,7 +103,7 @@ public void handleStreamEvent(StreamEvent event)
 
     public void onSuccess(StreamState result)
     {
-        String message = String.format("Sync complete between %s and %s on %s", desc.sessionId, r1.endpoint, r2.endpoint, desc.columnFamily);
+        String message = String.format("Sync complete using session %s between %s and %s on %s", desc.sessionId, r1.endpoint, r2.endpoint, desc.columnFamily);
         logger.info("[repair #{}] {}", desc.sessionId, message);
         Tracing.traceRepair(message);
         set(stat);

File: tools/stress/src/org/apache/cassandra/stress/util/Timing.java
Patch:
@@ -80,7 +80,7 @@ private <E> TimingResult<E> snap(Random rnd, Callable<E> call) throws Interrupte
 
         // TODO fail gracefully after timeout if a thread is stuck
         if (!ready.await(5L, TimeUnit.MINUTES))
-            throw new RuntimeException("Timed out waiting for a timer thread - seems one got stuck");
+            throw new RuntimeException("Timed out waiting for a timer thread - seems one got stuck. Check GC/Heap size");
 
         boolean done = true;
         // reports have been filled in by timer threadCount, so merge

File: src/java/org/apache/cassandra/service/StorageServiceMBean.java
Patch:
@@ -358,6 +358,9 @@ public interface StorageServiceMBean extends NotificationEmitter
     /** get the operational mode (leaving, joining, normal, decommissioned, client) **/
     public String getOperationMode();
 
+    /** Returns whether the storage service is starting or not */
+    public boolean isStarting();
+
     /** get the progress of a drain operation */
     public String getDrainProgress();
 

File: src/java/org/apache/cassandra/tools/SSTableRepairedAtSetter.java
Patch:
@@ -58,7 +58,7 @@ public static void main(final String[] args) throws IOException
         {
             out.println("This command should be run with Cassandra stopped, otherwise you will get very strange behavior");
             out.println("Verify that Cassandra is not running and then execute the command like this:");
-            out.println("Usage: sstablelevelreset --really-set [--is-repaired | --is-unrepaired] [-f <sstable-list> | <sstables>]");
+            out.println("Usage: sstablerepairedset --really-set [--is-repaired | --is-unrepaired] [-f <sstable-list> | <sstables>]");
             System.exit(1);
         }
 

File: test/unit/org/apache/cassandra/service/PaxosStateTest.java
Patch:
@@ -45,6 +45,7 @@ public class PaxosStateTest
     public static void setUpClass() throws Throwable
     {
         SchemaLoader.loadSchema();
+        SchemaLoader.schemaDefinition("PaxosStateTest");
     }
 
     @AfterClass
@@ -56,7 +57,7 @@ public static void stopGossiper()
     @Test
     public void testCommittingAfterTruncation() throws Exception
     {
-        ColumnFamilyStore cfs = Keyspace.open("Keyspace1").getColumnFamilyStore("Standard1");
+        ColumnFamilyStore cfs = Keyspace.open("PaxosStateTestKeyspace1").getColumnFamilyStore("Standard1");
         DecoratedKey key = Util.dk("key" + System.nanoTime());
         CellName name = Util.cellname("col");
         ByteBuffer value = ByteBufferUtil.bytes(0);

File: test/unit/org/apache/cassandra/tools/SSTableImportTest.java
Patch:
@@ -156,6 +156,7 @@ public void testImportWithAsciiKeyValidator() throws IOException, URISyntaxExcep
         // Import JSON to temp SSTable file
         String jsonUrl = resourcePath("SimpleCF.json");
         File tempSS = tempSSTableFile("Keyspace1", "AsciiKeys");
+        System.setProperty("skip.key.validator", "false");
         new SSTableImport(true).importJson(jsonUrl, "Keyspace1", "AsciiKeys", tempSS.getPath());
 
         // Verify results

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -57,6 +57,7 @@
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.UUIDGen;
+import org.github.jamm.Unmetered;
 
 import static org.apache.cassandra.utils.FBUtilities.fromJsonList;
 import static org.apache.cassandra.utils.FBUtilities.fromJsonMap;
@@ -65,6 +66,7 @@
 /**
  * This class can be tricky to modify. Please read http://wiki.apache.org/cassandra/ConfigurationNotes for how to do so safely.
  */
+@Unmetered
 public final class CFMetaData
 {
     private static final Logger logger = LoggerFactory.getLogger(CFMetaData.class);

File: src/java/org/apache/cassandra/cql3/functions/Function.java
Patch:
@@ -22,7 +22,9 @@
 
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.exceptions.InvalidRequestException;
+import org.github.jamm.Unmetered;
 
+@Unmetered
 public interface Function
 {
     public String name();

File: src/java/org/apache/cassandra/db/marshal/AbstractType.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.cassandra.exceptions.SyntaxException;
 import org.apache.cassandra.serializers.TypeSerializer;
 import org.apache.cassandra.serializers.MarshalException;
+import org.github.jamm.Unmetered;
 
 /**
  * Specifies a Comparator for a specific type of ByteBuffer.
@@ -37,6 +38,7 @@
  * should always handle those values even if they normally do not
  * represent a valid ByteBuffer for the type being compared.
  */
+@Unmetered
 public abstract class AbstractType<T> implements Comparator<ByteBuffer>
 {
     public final Comparator<ByteBuffer> reverseComparator;

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -684,7 +684,7 @@ private static ResultSet buildCasFailureResultSet(ByteBuffer key, ColumnFamily c
             }
             for (ColumnIdentifier id : columnsWithConditions)
                 names.add(cfDef.get(id));
-            selection = Selection.forColumns(names);
+            selection = Selection.forColumns(new ArrayList<>(names));
         }
 
         long now = System.currentTimeMillis();

File: test/unit/org/apache/cassandra/cql3/UFTest.java
Patch:
@@ -698,9 +698,9 @@ public void testScriptReturnTypeCasting() throws Throwable
 
         // declared rtype = decimal , return type = int
         execute("CREATE OR REPLACE FUNCTION "+KEYSPACE+".js(val double) RETURNS decimal LANGUAGE javascript\n" +
-                "AS '100;';");
+                "AS 'parseInt(\"100\");';");
         assertRows(execute("SELECT key, val, js(val) FROM %s"),
-                   row(1, 1d, BigDecimal.valueOf(100L)));
+                   row(1, 1d, BigDecimal.valueOf(100d)));
         execute("DROP FUNCTION "+KEYSPACE+".js(double)");
 
         // declared rtype = decimal , return type = double

File: test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java
Patch:
@@ -215,13 +215,13 @@ private void clearAndLoad(ColumnFamilyStore cfs)
     public void testReadRateTracking()
     {
         // try to make sure CASSANDRA-8239 never happens again
-        Keyspace keyspace = Keyspace.open("Keyspace1");
+        Keyspace keyspace = Keyspace.open(KEYSPACE1);
         ColumnFamilyStore store = keyspace.getColumnFamilyStore("Standard1");
 
         for (int j = 0; j < 10; j++)
         {
             ByteBuffer key = ByteBufferUtil.bytes(String.valueOf(j));
-            Mutation rm = new Mutation("Keyspace1", key);
+            Mutation rm = new Mutation(KEYSPACE1, key);
             rm.add("Standard1", cellname("0"), ByteBufferUtil.EMPTY_BYTE_BUFFER, j);
             rm.apply();
         }

File: src/java/org/apache/cassandra/io/sstable/SSTableScanner.java
Patch:
@@ -63,6 +63,7 @@ public class SSTableScanner implements ICompactionScanner
     SSTableScanner(SSTableReader sstable, DataRange dataRange, RateLimiter limiter)
     {
         assert sstable != null;
+        sstable.acquireReference();
 
         this.dfile = limiter == null ? sstable.openDataReader() : sstable.openDataReader(limiter);
         this.ifile = sstable.openIndexReader();
@@ -92,6 +93,7 @@ public class SSTableScanner implements ICompactionScanner
     SSTableScanner(SSTableReader sstable, Collection<Range<Token>> tokenRanges, RateLimiter limiter)
     {
         assert sstable != null;
+        sstable.acquireReference();
 
         this.dfile = limiter == null ? sstable.openDataReader() : sstable.openDataReader(limiter);
         this.ifile = sstable.openIndexReader();
@@ -159,6 +161,7 @@ private void seekToCurrentRangeStart()
     public void close() throws IOException
     {
         FileUtils.close(dfile, ifile);
+        sstable.releaseReference();
     }
 
     public long getLengthInBytes()

File: src/java/org/apache/cassandra/thrift/CustomTThreadPoolServer.java
Patch:
@@ -35,6 +35,7 @@
 import org.apache.cassandra.concurrent.NamedThreadFactory;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.EncryptionOptions.ClientEncryptionOptions;
+import org.apache.cassandra.security.SSLFactory;
 import org.apache.thrift.TException;
 import org.apache.thrift.TProcessor;
 import org.apache.thrift.protocol.TProtocol;
@@ -254,7 +255,7 @@ public TServer buildTServer(Args args)
                     }
                     TServerSocket sslServer = TSSLTransportFactory.getServerSocket(addr.getPort(), 0, addr.getAddress(), params);
                     SSLServerSocket sslServerSocket = (SSLServerSocket) sslServer.getServerSocket();
-                    sslServerSocket.setEnabledProtocols(new String[] {"SSLv2Hello", "TLSv1", "TLSv1.1", "TLSv1.2"});
+                    sslServerSocket.setEnabledProtocols(SSLFactory.ACCEPTED_PROTOCOLS);
                     serverTransport = new TCustomServerSocket(sslServer.getServerSocket(), args.keepAlive, args.sendBufferSize, args.recvBufferSize);
                 }
                 else

File: src/java/org/apache/cassandra/transport/Server.java
Patch:
@@ -296,7 +296,7 @@ public ChannelPipeline getPipeline() throws Exception
             sslEngine.setUseClientMode(false);
             sslEngine.setEnabledCipherSuites(encryptionOptions.cipher_suites);
             sslEngine.setNeedClientAuth(encryptionOptions.require_client_auth);
-            sslEngine.setEnabledProtocols(new String[] {"SSLv2Hello", "TLSv1", "TLSv1.1", "TLSv1.2"});
+            sslEngine.setEnabledProtocols(SSLFactory.ACCEPTED_PROTOCOLS);
             
             SslHandler sslHandler = new SslHandler(sslEngine);
             sslHandler.setIssueHandshake(true);

File: src/java/org/apache/cassandra/transport/SimpleClient.java
Patch:
@@ -259,7 +259,7 @@ public ChannelPipeline getPipeline() throws Exception
             SSLEngine sslEngine = sslContext.createSSLEngine();
             sslEngine.setUseClientMode(true);
             sslEngine.setEnabledCipherSuites(encryptionOptions.cipher_suites);
-            sslEngine.setEnabledProtocols(new String[] {"SSLv2Hello", "TLSv1", "TLSv1.1", "TLSv1.2"});
+            sslEngine.setEnabledProtocols(SSLFactory.ACCEPTED_PROTOCOLS);
             ChannelPipeline pipeline = super.getPipeline();
 
             pipeline.addFirst("ssl", new SslHandler(sslEngine));

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -217,7 +217,7 @@ public final class CFMetaData
                                                              + "started_at timestamp,"
                                                              + "parameters map<text, text>,"
                                                              + "duration int"
-                                                             + ") WITH COMMENT='traced sessions'",
+                                                             + ") WITH COMMENT='traced sessions' AND default_time_to_live=86400",
                                                              Tracing.TRACE_KS);
 
     public static final CFMetaData TraceEventsCf = compile("CREATE TABLE " + Tracing.EVENTS_CF + " ("
@@ -228,7 +228,7 @@ public final class CFMetaData
                                                            + "activity text,"
                                                            + "source_elapsed int,"
                                                            + "PRIMARY KEY (session_id, event_id)"
-                                                           + ")",
+                                                           + ") WITH default_time_to_live=86400",
                                                            Tracing.TRACE_KS);
 
     public static final CFMetaData BatchlogCf = compile("CREATE TABLE " + SystemKeyspace.BATCHLOG_CF + " ("

File: src/java/org/apache/cassandra/hadoop/HadoopCompat.java
Patch:
@@ -36,7 +36,6 @@
 import org.apache.hadoop.mapreduce.TaskAttemptContext;
 import org.apache.hadoop.mapreduce.TaskAttemptID;
 import org.apache.hadoop.mapreduce.TaskInputOutputContext;
-import org.apache.cassandra.utils.JVMStabilityInspector;
 
 /*
  * This is based on ContextFactory.java from hadoop-2.0.x sources.
@@ -132,7 +131,6 @@ public class HadoopCompat {
                     get_counter = Class.forName(PACKAGE + ".TaskAttemptContext").getMethod("getCounter", String.class,
                             String.class);
                 } catch (Exception e) {
-                    JVMStabilityInspector.inspectThrowable(e);
                     get_counter = Class.forName(PACKAGE + ".TaskInputOutputContext").getMethod("getCounter",
                             String.class, String.class);
                 }

File: src/java/org/apache/cassandra/tools/NodeTool.java
Patch:
@@ -2340,7 +2340,7 @@ public void execute(NodeProbe probe)
         }
     }
 
-    @Command(name = "disablehandoff", description = "Disable gossip (effectively marking the node down)")
+    @Command(name = "disablehandoff", description = "Disable storing hinted handoffs")
     public static class DisableHandoff extends NodeToolCmd
     {
         @Override

File: src/java/org/apache/cassandra/cql3/AbstractMarker.java
Patch:
@@ -99,7 +99,7 @@ public INRaw(int bindIndex)
         private static ColumnSpecification makeInReceiver(ColumnSpecification receiver)
         {
             ColumnIdentifier inName = new ColumnIdentifier("in(" + receiver.name + ")", true);
-            return new ColumnSpecification(receiver.ksName, receiver.cfName, inName, ListType.getInstance(receiver.type));
+            return new ColumnSpecification(receiver.ksName, receiver.cfName, inName, ListType.getInstance(receiver.type, false));
         }
 
         @Override

File: src/java/org/apache/cassandra/cql3/CQL3Row.java
Patch:
@@ -27,7 +27,7 @@ public interface CQL3Row
 {
     public ByteBuffer getClusteringColumn(int i);
     public Cell getColumn(ColumnIdentifier name);
-    public List<Cell> getCollection(ColumnIdentifier name);
+    public List<Cell> getMultiCellColumn(ColumnIdentifier name);
 
     public interface Builder
     {

File: src/java/org/apache/cassandra/cql3/Constants.java
Patch:
@@ -369,7 +369,7 @@ public Deleter(ColumnDefinition column)
         public void execute(ByteBuffer rowKey, ColumnFamily cf, Composite prefix, UpdateParameters params) throws InvalidRequestException
         {
             CellName cname = cf.getComparator().create(prefix, column);
-            if (column.type.isCollection())
+            if (column.type.isMultiCell())
                 cf.addAtom(params.makeRangeTombstone(cname.slice()));
             else
                 cf.addColumn(params.makeTombstone(cname));

File: src/java/org/apache/cassandra/cql3/UntypedResultSet.java
Patch:
@@ -272,19 +272,19 @@ public long getLong(String column)
         public <T> Set<T> getSet(String column, AbstractType<T> type)
         {
             ByteBuffer raw = data.get(column);
-            return raw == null ? null : SetType.getInstance(type).compose(raw);
+            return raw == null ? null : SetType.getInstance(type, true).compose(raw);
         }
 
         public <T> List<T> getList(String column, AbstractType<T> type)
         {
             ByteBuffer raw = data.get(column);
-            return raw == null ? null : ListType.getInstance(type).compose(raw);
+            return raw == null ? null : ListType.getInstance(type, true).compose(raw);
         }
 
         public <K, V> Map<K, V> getMap(String column, AbstractType<K> keyType, AbstractType<V> valueType)
         {
             ByteBuffer raw = data.get(column);
-            return raw == null ? null : MapType.getInstance(keyType, valueType).compose(raw);
+            return raw == null ? null : MapType.getInstance(keyType, valueType, true).compose(raw);
         }
 
         public List<ColumnSpecification> getColumns()

File: src/java/org/apache/cassandra/cql3/UpdateParameters.java
Patch:
@@ -97,6 +97,6 @@ public List<Cell> getPrefetchedList(ByteBuffer rowKey, ColumnIdentifier cql3Colu
             return Collections.emptyList();
 
         CQL3Row row = prefetchedLists.get(rowKey);
-        return row == null ? Collections.<Cell>emptyList() : row.getCollection(cql3ColumnName);
+        return row == null ? Collections.<Cell>emptyList() : row.getMultiCellColumn(cql3ColumnName);
     }
 }

File: src/java/org/apache/cassandra/cql3/UserTypes.java
Patch:
@@ -24,6 +24,7 @@
 import org.apache.cassandra.db.marshal.UserType;
 import org.apache.cassandra.db.marshal.UTF8Type;
 import org.apache.cassandra.exceptions.InvalidRequestException;
+import org.apache.cassandra.transport.Server;
 
 /**
  * Static helper methods and classes for user types.
@@ -171,7 +172,7 @@ private ByteBuffer[] bindInternal(QueryOptions options) throws InvalidRequestExc
                 buffers[i] = values.get(i).bindAndGet(options);
                 // Inside UDT values, we must force the serialization of collections to v3 whatever protocol
                 // version is in use since we're going to store directly that serialized value.
-                if (version < 3 && type.fieldType(i).isCollection() && buffers[i] != null)
+                if (version < Server.VERSION_3 && type.fieldType(i).isCollection() && buffers[i] != null)
                     buffers[i] = ((CollectionType)type.fieldType(i)).getSerializer().reserializeToV3(buffers[i]);
             }
             return buffers;

File: src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java
Patch:
@@ -56,7 +56,7 @@ public void addUpdateForKey(ColumnFamily cf, ByteBuffer key, Composite prefix, U
             // However, if we delete only static colums, it's fine since we won't really use the prefix anyway.
             for (Operation deletion : deletions)
                 if (!deletion.column.isStatic())
-                    throw new InvalidRequestException(String.format("Missing mandatory PRIMARY KEY part %s since %s specified", getFirstEmptyKey(), deletion.column.name));
+                    throw new InvalidRequestException(String.format("Primary key column '%s' must be specified in order to delete column '%s'", getFirstEmptyKey().name, deletion.column.name));
         }
 
         if (deletions.isEmpty())

File: src/java/org/apache/cassandra/cql3/statements/DropTypeStatement.java
Patch:
@@ -117,11 +117,11 @@ else if (toCheck instanceof ColumnToCollectionType)
         else if (toCheck instanceof CollectionType)
         {
             if (toCheck instanceof ListType)
-                return isUsedBy(((ListType)toCheck).elements);
+                return isUsedBy(((ListType)toCheck).getElementsType());
             else if (toCheck instanceof SetType)
-                return isUsedBy(((SetType)toCheck).elements);
+                return isUsedBy(((SetType)toCheck).getElementsType());
             else
-                return isUsedBy(((MapType)toCheck).keys) || isUsedBy(((MapType)toCheck).keys);
+                return isUsedBy(((MapType)toCheck).getKeysType()) || isUsedBy(((MapType)toCheck).getKeysType());
         }
         return false;
     }

File: src/java/org/apache/cassandra/db/CFRowAdder.java
Patch:
@@ -64,7 +64,7 @@ public CFRowAdder add(String cql3ColumnName, Object value)
     public CFRowAdder resetCollection(String cql3ColumnName)
     {
         ColumnDefinition def = getDefinition(cql3ColumnName);
-        assert def.type.isCollection();
+        assert def.type.isCollection() && def.type.isMultiCell();
         Composite name = cf.getComparator().create(prefix, def);
         cf.addAtom(new RangeTombstone(name.start(), name.end(), timestamp - 1, ldt));
         return this;
@@ -75,7 +75,7 @@ public CFRowAdder addMapEntry(String cql3ColumnName, Object key, Object value)
         ColumnDefinition def = getDefinition(cql3ColumnName);
         assert def.type instanceof MapType;
         MapType mt = (MapType)def.type;
-        CellName name = cf.getComparator().create(prefix, def, mt.keys.decompose(key));
+        CellName name = cf.getComparator().create(prefix, def, mt.getKeysType().decompose(key));
         return add(name, def, value);
     }
 

File: src/java/org/apache/cassandra/db/composites/AbstractCellNameType.java
Patch:
@@ -304,7 +304,7 @@ public Cell getColumn(ColumnIdentifier name)
                         return cell;
                     }
 
-                    public List<Cell> getCollection(ColumnIdentifier name)
+                    public List<Cell> getMultiCellColumn(ColumnIdentifier name)
                     {
                         return null;
                     }
@@ -446,7 +446,7 @@ public Cell getColumn(ColumnIdentifier name)
             return columns == null ? null : columns.get(name);
         }
 
-        public List<Cell> getCollection(ColumnIdentifier name)
+        public List<Cell> getMultiCellColumn(ColumnIdentifier name)
         {
             return collections == null ? null : collections.get(name);
         }

File: src/java/org/apache/cassandra/db/composites/CellNameType.java
Patch:
@@ -95,7 +95,7 @@ public interface CellNameType extends CType
     public boolean supportCollections();
 
     /**
-     * The type of the collections (or null if the type has not collections).
+     * The type of the collections (or null if the type does not have any non-frozen collections).
      */
     public ColumnToCollectionType collectionType();
 

File: src/java/org/apache/cassandra/db/index/SecondaryIndexSearcher.java
Patch:
@@ -18,12 +18,14 @@
 package org.apache.cassandra.db.index;
 
 import java.nio.ByteBuffer;
+import java.nio.charset.CharacterCodingException;
 import java.util.*;
 
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.filter.ExtendedFilter;
 import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.tracing.Tracing;
+import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 
 public abstract class SecondaryIndexSearcher

File: src/java/org/apache/cassandra/db/index/composites/CompositesIndex.java
Patch:
@@ -58,7 +58,7 @@ protected CellNameType getIndexComparator()
 
     public static CompositesIndex create(ColumnDefinition cfDef)
     {
-        if (cfDef.type.isCollection())
+        if (cfDef.type.isCollection() && cfDef.type.isMultiCell())
         {
             switch (((CollectionType)cfDef.type).kind)
             {
@@ -90,7 +90,7 @@ public static CompositesIndex create(ColumnDefinition cfDef)
     // Check SecondaryIndex.getIndexComparator if you want to know why this is static
     public static CellNameType getIndexComparator(CFMetaData baseMetadata, ColumnDefinition cfDef)
     {
-        if (cfDef.type.isCollection())
+        if (cfDef.type.isCollection() && cfDef.type.isMultiCell())
         {
             switch (((CollectionType)cfDef.type).kind)
             {

File: src/java/org/apache/cassandra/db/index/composites/CompositesIndexOnCollectionValue.java
Patch:
@@ -98,7 +98,7 @@ public IndexedEntry decodeEntry(DecoratedKey indexedValue, Cell indexEntry)
     @Override
     public boolean supportsOperator(Operator operator)
     {
-        return operator == Operator.CONTAINS;
+        return operator == Operator.CONTAINS && !(columnDef.type instanceof SetType);
     }
 
     @Override

File: src/java/org/apache/cassandra/db/marshal/ColumnToCollectionType.java
Patch:
@@ -33,7 +33,7 @@
 public class ColumnToCollectionType extends AbstractType<ByteBuffer>
 {
     // interning instances
-    private static final Map<Map<ByteBuffer, CollectionType>, ColumnToCollectionType> instances = new HashMap<Map<ByteBuffer, CollectionType>, ColumnToCollectionType>();
+    private static final Map<Map<ByteBuffer, CollectionType>, ColumnToCollectionType> instances = new HashMap<>();
 
     public final Map<ByteBuffer, CollectionType> defined;
 

File: src/java/org/apache/cassandra/db/marshal/UserType.java
Patch:
@@ -60,7 +60,7 @@ public static UserType getInstance(TypeParser parser) throws ConfigurationExcept
         for (Pair<ByteBuffer, AbstractType> p : params.right)
         {
             columnNames.add(p.left);
-            columnTypes.add(p.right);
+            columnTypes.add(p.right.freeze());
         }
         return new UserType(keyspace, name, columnNames, columnTypes);
     }

File: tools/stress/src/org/apache/cassandra/stress/generate/values/Lists.java
Patch:
@@ -33,7 +33,7 @@ public class Lists extends Generator<List>
 
     public Lists(String name, Generator valueType, GeneratorConfig config)
     {
-        super(ListType.getInstance(valueType.type), config, name, List.class);
+        super(ListType.getInstance(valueType.type, true), config, name, List.class);
         this.valueType = valueType;
         buffer = new Object[(int) sizeDistribution.maxValue()];
     }

File: tools/stress/src/org/apache/cassandra/stress/generate/values/Sets.java
Patch:
@@ -32,7 +32,7 @@ public class Sets extends Generator<Set>
 
     public Sets(String name, Generator valueType, GeneratorConfig config)
     {
-        super(SetType.getInstance(valueType.type), config, name, Set.class);
+        super(SetType.getInstance(valueType.type, true), config, name, Set.class);
         this.valueType = valueType;
     }
 

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -3200,7 +3200,7 @@ private void calculateToFromStreams(Collection<Token> newTokens, List<String> ke
                     }
 
                     // stream requests
-                    Multimap<InetAddress, Range<Token>> workMap = RangeStreamer.getWorkMap(rangesToFetchWithPreferredEndpoints);
+                    Multimap<InetAddress, Range<Token>> workMap = RangeStreamer.getWorkMap(rangesToFetchWithPreferredEndpoints, keyspace);
                     for (InetAddress address : workMap.keySet())
                     {
                         InetAddress preferred = SystemKeyspace.getPreferredIP(address);

File: src/java/org/apache/cassandra/gms/VersionedValue.java
Patch:
@@ -43,9 +43,9 @@
  * application wants to make available to the rest of the nodes in the cluster.
  * Whenever a piece of state needs to be disseminated to the rest of cluster wrap
  * the state in an instance of <i>ApplicationState</i> and add it to the Gossiper.
- * <p/>
+ * <p></p>
  * e.g. if we want to disseminate load information for node A do the following:
- * <p/>
+ * <p></p>
  * ApplicationState loadState = new ApplicationState(<string representation of load>);
  * Gossiper.instance.addApplicationState("LOAD STATE", loadState);
  */

File: src/java/org/apache/cassandra/hadoop/AbstractColumnFamilyOutputFormat.java
Patch:
@@ -67,8 +67,6 @@ public abstract class AbstractColumnFamilyOutputFormat<K, Y> extends OutputForma
      *
      * @param context
      *            information about the job
-     * @throws IOException
-     *             when output should not be attempted
      */
     public void checkOutputSpecs(JobContext context)
     {

File: src/java/org/apache/cassandra/hadoop/ColumnFamilyOutputFormat.java
Patch:
@@ -60,7 +60,6 @@ public ColumnFamilyRecordWriter getRecordWriter(org.apache.hadoop.fs.FileSystem
      * @param context
      *            the information about the current task.
      * @return a {@link RecordWriter} to write the output for the job.
-     * @throws IOException
      */
     public ColumnFamilyRecordWriter getRecordWriter(final TaskAttemptContext context) throws InterruptedException
     {

File: src/java/org/apache/cassandra/io/IVersionedSerializer.java
Patch:
@@ -30,7 +30,7 @@ public interface IVersionedSerializer<T>
      * @param t type that needs to be serialized
      * @param out DataOutput into which serialization needs to happen.
      * @param version protocol version
-     * @throws java.io.IOException
+     * @throws java.io.IOException if serialization fails
      */
     public void serialize(T t, DataOutputPlus out, int version) throws IOException;
 
@@ -39,7 +39,7 @@ public interface IVersionedSerializer<T>
      * @param in DataInput from which deserialization needs to happen.
      * @param version protocol version
      * @return the type that was deserialized
-     * @throws IOException
+     * @throws IOException if deserialization fails
      */
     public T deserialize(DataInput in, int version) throws IOException;
 

File: src/java/org/apache/cassandra/io/compress/CompressionMetadata.java
Patch:
@@ -340,6 +340,8 @@ public long chunkOffsetBy(int chunkIndex)
         /**
          * Reset the writer so that the next chunk offset written will be the
          * one of {@code chunkIndex}.
+         * 
+         * @param chunkIndex the next index to write
          */
         public void resetAndTruncate(int chunkIndex)
         {

File: src/java/org/apache/cassandra/io/util/DataOutputBuffer.java
Patch:
@@ -74,6 +74,8 @@ public void write(ByteBuffer buffer) throws IOException
     /**
      * Returns the current contents of the buffer. Data is only valid to
      * {@link #getLength()}.
+     * 
+     * @return the buffer contents
      */
     public byte[] getData()
     {
@@ -93,7 +95,7 @@ public ByteBuffer asByteBuffer()
         return ByteBuffer.wrap(out.buf, 0, out.count);
     }
 
-    /** Returns the length of the valid data currently in the buffer. */
+    /** @return the length of the valid data currently in the buffer. */
     public int getLength()
     {
         return ((FastByteArrayOutputStream) out).count;

File: src/java/org/apache/cassandra/io/util/SequentialWriter.java
Patch:
@@ -322,11 +322,13 @@ public long getFilePointer()
     }
 
     /**
-     * Return the current file pointer of the underlying on-disk file.
+     * Returns the current file pointer of the underlying on-disk file.
      * Note that since write works by buffering data, the value of this will increase by buffer
      * size and not every write to the writer will modify this value.
      * Furthermore, for compressed files, this value refers to compressed data, while the
      * writer getFilePointer() refers to uncompressedFile
+     * 
+     * @return the current file pointer
      */
     public long getOnDiskFilePointer()
     {

File: src/java/org/apache/cassandra/repair/RepairJob.java
Patch:
@@ -50,6 +50,7 @@ public class RepairJob extends AbstractFuture<RepairResult> implements Runnable
      * @param session RepairSession that this RepairJob belongs
      * @param columnFamily name of the ColumnFamily to repair
      * @param isSequential when true, validation runs sequentially among replica
+     * @param repairedAt when the repair occurred (millis)
      * @param taskExecutor Executor to run various repair tasks
      */
     public RepairJob(RepairSession session,

File: src/java/org/apache/cassandra/repair/RepairSession.java
Patch:
@@ -106,10 +106,13 @@ public class RepairSession extends AbstractFuture<List<RepairResult>> implements
     /**
      * Create new repair session.
      *
+     * @param parentRepairSession the parent sessions id
+     * @param id this sessions id
      * @param range range to repair
      * @param keyspace name of keyspace
      * @param isSequential true if performing repair on snapshots sequentially
      * @param endpoints the data centers that should be part of the repair; null for all DCs
+     * @param repairedAt when the repair occurred (millis)
      * @param cfnames names of columnfamilies
      */
     public RepairSession(UUID parentRepairSession,

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -91,8 +91,6 @@ public CassandraDaemon(boolean runManaged) {
      * This is a hook for concrete daemons to initialize themselves suitably.
      *
      * Subclasses should override this to finish the job (listening on ports, etc.)
-     *
-     * @throws IOException
      */
     protected void setup()
     {

File: src/java/org/apache/cassandra/utils/memory/SlabAllocator.java
Patch:
@@ -34,12 +34,12 @@
  * The SlabAllocator is a bump-the-pointer allocator that allocates
  * large (2MB by default) regions and then doles them out to threads that request
  * slices into the array.
- * <p/>
+ * <p></p>
  * The purpose of this class is to combat heap fragmentation in long lived
  * objects: by ensuring that all allocations with similar lifetimes
  * only to large regions of contiguous memory, we ensure that large blocks
  * get freed up at the same time.
- * <p/>
+ * <p></p>
  * Otherwise, variable length byte arrays allocated end up
  * interleaved throughout the heap, and the old generation gets progressively
  * more fragmented until a stop-the-world compacting collection occurs.

File: src/java/org/apache/cassandra/db/SystemKeyspace.java
Patch:
@@ -120,7 +120,8 @@ public static void finishStartup()
         for (String cfname : Arrays.asList(SystemKeyspace.SCHEMA_KEYSPACES_CF,
                                            SystemKeyspace.SCHEMA_COLUMNFAMILIES_CF,
                                            SystemKeyspace.SCHEMA_COLUMNS_CF,
-                                           SystemKeyspace.SCHEMA_TRIGGERS_CF))
+                                           SystemKeyspace.SCHEMA_TRIGGERS_CF,
+                                           SystemKeyspace.SCHEMA_USER_TYPES_CF))
             executeOnceInternal(String.format("DELETE FROM system.%s WHERE keyspace_name = ?", cfname), ksmd.name);
 
         // (+1 to timestamp to make sure we don't get shadowed by the tombstones we just added)

File: src/java/org/apache/cassandra/cql3/QueryProcessor.java
Patch:
@@ -56,7 +56,7 @@ public class QueryProcessor implements QueryHandler
     public static final QueryProcessor instance = new QueryProcessor();
 
     private static final Logger logger = LoggerFactory.getLogger(QueryProcessor.class);
-    private static final MemoryMeter meter = new MemoryMeter().withGuessing(MemoryMeter.Guess.FALLBACK_BEST);
+    private static final MemoryMeter meter = new MemoryMeter().withGuessing(MemoryMeter.Guess.FALLBACK_BEST).ignoreKnownSingletons();
     private static final long MAX_CACHE_PREPARED_MEMORY = Runtime.getRuntime().maxMemory() / 256;
 
     private static EntryWeigher<MD5Digest, ParsedStatement.Prepared> cqlMemoryUsageWeigher = new EntryWeigher<MD5Digest, ParsedStatement.Prepared>()

File: src/java/org/apache/cassandra/utils/ObjectSizes.java
Patch:
@@ -33,7 +33,8 @@ public class ObjectSizes
 {
     private static final MemoryMeter meter = new MemoryMeter()
                                              .omitSharedBufferOverhead()
-                                             .withGuessing(MemoryMeter.Guess.FALLBACK_UNSAFE);
+                                             .withGuessing(MemoryMeter.Guess.FALLBACK_UNSAFE)
+                                             .ignoreKnownSingletons();
 
     private static final long BUFFER_EMPTY_SIZE = measure(ByteBufferUtil.EMPTY_BYTE_BUFFER);
     private static final long STRING_EMPTY_SIZE = measure("");

File: src/java/org/apache/cassandra/cql3/statements/RawSelector.java
Patch:
@@ -22,10 +22,10 @@
 
 public class RawSelector
 {
-    public final Selectable selectable;
+    public final Selectable.Raw selectable;
     public final ColumnIdentifier alias;
 
-    public RawSelector(Selectable selectable, ColumnIdentifier alias)
+    public RawSelector(Selectable.Raw selectable, ColumnIdentifier alias)
     {
         this.selectable = selectable;
         this.alias = alias;

File: src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java
Patch:
@@ -465,7 +465,7 @@ public void deleteFromIndexes(DecoratedKey key, List<Column> indexedColumnsInRow
                 }
                 else
                 {
-                    ((PerColumnSecondaryIndex) index).delete(key.key, column);
+                    ((PerColumnSecondaryIndex) index).deleteForCleanup(key.key, column);
                 }
             }
         }
@@ -618,7 +618,7 @@ public void update(Column oldColumn, Column column)
         {
             if (oldColumn.equals(column))
                 return;
-            
+
             for (SecondaryIndex index : indexFor(column.name()))
             {
                 if (index instanceof PerColumnSecondaryIndex)

File: src/java/org/apache/cassandra/cql/QueryProcessor.java
Patch:
@@ -33,7 +33,7 @@
 import org.apache.cassandra.cql.hooks.PostPreparationHook;
 import org.apache.cassandra.cql.hooks.PreExecutionHook;
 import org.apache.cassandra.cql.hooks.PreparationContext;
-import org.apache.cassandra.db.CounterCell;
+import org.apache.cassandra.cql3.Operator;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.composites.CellName;
 import org.apache.cassandra.db.composites.CellNameType;
@@ -193,7 +193,7 @@ private static List<org.apache.cassandra.db.Row> multiRangeSlice(CFMetaData meta
             ByteBuffer value = columnRelation.getValue().getByteBuffer(metadata.getValueValidator(metadata.comparator.cellFromByteBuffer(entity)), variables);
 
             expressions.add(new IndexExpression(entity,
-                                                IndexExpression.Operator.valueOf(columnRelation.operator().toString()),
+                                                Operator.valueOf(columnRelation.operator().name()),
                                                 value));
         }
 

File: src/java/org/apache/cassandra/db/index/composites/CompositesIndexOnCollectionValue.java
Patch:
@@ -23,6 +23,7 @@
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.ColumnDefinition;
+import org.apache.cassandra.cql3.Operator;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.composites.CBuilder;
 import org.apache.cassandra.db.composites.CellName;
@@ -95,9 +96,9 @@ public IndexedEntry decodeEntry(DecoratedKey indexedValue, Cell indexEntry)
     }
 
     @Override
-    public boolean supportsOperator(IndexExpression.Operator operator)
+    public boolean supportsOperator(Operator operator)
     {
-        return operator == IndexExpression.Operator.CONTAINS;
+        return operator == Operator.CONTAINS;
     }
 
     @Override

File: src/java/org/apache/cassandra/db/marshal/CompositeType.java
Patch:
@@ -30,7 +30,7 @@
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.exceptions.SyntaxException;
 import org.apache.cassandra.cql3.ColumnIdentifier;
-import org.apache.cassandra.cql3.Relation;
+import org.apache.cassandra.cql3.Operator;
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.serializers.MarshalException;
 import org.apache.cassandra.utils.ByteBufferUtil;
@@ -430,7 +430,7 @@ public ByteBuffer buildAsEndOfRange()
             return bb;
         }
 
-        public ByteBuffer buildForRelation(Relation.Type op)
+        public ByteBuffer buildForRelation(Operator op)
         {
             /*
              * Given the rules for eoc (end-of-component, see AbstractCompositeType.compare()),

File: src/java/org/apache/cassandra/thrift/ThriftConversion.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.Collections;
 import java.util.List;
 
+import org.apache.cassandra.cql3.Operator;
 import org.apache.cassandra.db.WriteType;
 import org.apache.cassandra.exceptions.RequestExecutionException;
 import org.apache.cassandra.exceptions.RequestTimeoutException;
@@ -124,7 +125,7 @@ public static List<org.apache.cassandra.db.IndexExpression> fromThrift(List<Inde
         for (IndexExpression expr : exprs)
         {
             converted.add(new org.apache.cassandra.db.IndexExpression(expr.column_name,
-                                                                      org.apache.cassandra.db.IndexExpression.Operator.findByOrdinal(expr.op.getValue()),
+                                                                      Operator.valueOf(expr.op.name()),
                                                                       expr.value));
         }
         return converted;

File: test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java
Patch:
@@ -44,6 +44,7 @@
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.cql3.Operator;
 import org.apache.cassandra.db.BufferDecoratedKey;
 import org.apache.cassandra.db.ColumnFamily;
 import org.apache.cassandra.db.ColumnFamilyStore;
@@ -456,7 +457,7 @@ private void assertIndexQueryWorks(ColumnFamilyStore indexedCFS)
             clearAndLoad(cfs);
 
         // query using index to see if sstable for secondary index opens
-        IndexExpression expr = new IndexExpression(ByteBufferUtil.bytes("birthdate"), IndexExpression.Operator.EQ, ByteBufferUtil.bytes(1L));
+        IndexExpression expr = new IndexExpression(ByteBufferUtil.bytes("birthdate"), Operator.EQ, ByteBufferUtil.bytes(1L));
         List<IndexExpression> clause = Arrays.asList(expr);
         Range<RowPosition> range = Util.range("", "");
         List<Row> rows = indexedCFS.search(range, clause, new IdentityQueryFilter(), 100);

File: test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java
Patch:
@@ -36,6 +36,7 @@
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.cql3.Operator;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.columniterator.IdentityQueryFilter;
 import org.apache.cassandra.db.context.CounterContext;
@@ -241,7 +242,7 @@ public void mutate(String key, String col, long timestamp) throws Exception
         {
             long val = key.hashCode();
             IndexExpression expr = new IndexExpression(ByteBufferUtil.bytes("birthdate"),
-                                                       IndexExpression.Operator.EQ,
+                                                       Operator.EQ,
                                                        ByteBufferUtil.bytes(val));
             List<IndexExpression> clause = Arrays.asList(expr);
             IDiskAtomFilter filter = new IdentityQueryFilter();

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -1540,7 +1540,7 @@ public CFMetaData validate() throws ConfigurationException
 
                 if (c.getIndexType() == IndexType.CUSTOM)
                 {
-                    if (c.getIndexOptions() == null || !c.getIndexOptions().containsKey(SecondaryIndex.CUSTOM_INDEX_OPTION_NAME))
+                    if (c.getIndexOptions() == null || !c.hasIndexOption(SecondaryIndex.CUSTOM_INDEX_OPTION_NAME))
                         throw new ConfigurationException("Required index option missing: " + SecondaryIndex.CUSTOM_INDEX_OPTION_NAME);
                 }
 

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -1496,7 +1496,7 @@ private boolean[] processRelationEntity(SelectStatement stmt, Relation relation,
                 handleUnrecognizedEntity(entity, relation);
 
             stmt.restrictedColumns.add(def);
-            if (def.isIndexed() && relation.operator().allowsIndexQuery())
+            if (relation.operator().allowsIndexQueryOn(def))
                 return new boolean[]{true, def.kind == ColumnDefinition.Kind.CLUSTERING_COLUMN};
             return new boolean[]{false, false};
         }

File: src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java
Patch:
@@ -528,7 +528,7 @@ public List<SecondaryIndexSearcher> getIndexSearchersForQuery(List<IndexExpressi
         {
             SecondaryIndex index = getIndexForColumn(ix.column);
 
-            if (index == null)
+            if (index == null || !index.supportsOperator(ix.operator))
                 continue;
 
             Set<ByteBuffer> columns = groupByIndexType.get(index.indexTypeForGrouping());

File: src/java/org/apache/cassandra/db/CollationController.java
Patch:
@@ -123,6 +123,7 @@ private ColumnFamily collectTimeOrderedData(boolean copyOnHeap)
                     break;
 
                 Tracing.trace("Merging data from sstable {}", sstable.descriptor.generation);
+                sstable.incrementReadCount();
                 OnDiskAtomIterator iter = reducedFilter.getSSTableColumnIterator(sstable);
                 iterators.add(iter);
                 isEmpty = false;

File: src/java/org/apache/cassandra/cql3/QueryOptions.java
Patch:
@@ -242,7 +242,7 @@ public List<ByteBuffer> getValues()
     // Options that are likely to not be present in most queries
     static class SpecificOptions
     {
-        private static final SpecificOptions DEFAULT = new SpecificOptions(-1, null, null, -1L);
+        private static final SpecificOptions DEFAULT = new SpecificOptions(-1, null, null, Long.MIN_VALUE);
 
         private final int pageSize;
         private final PagingState state;

File: src/java/org/apache/cassandra/db/HintedHandOffManager.java
Patch:
@@ -257,6 +257,9 @@ protected void compact()
         for (SSTable sstable : hintStore.getDataTracker().getUncompactingSSTables())
             descriptors.add(sstable.descriptor);
 
+        if (descriptors.isEmpty())
+            return;
+
         try
         {
             CompactionManager.instance.submitUserDefined(hintStore, descriptors, (int) (System.currentTimeMillis() / 1000)).get();

File: src/java/org/apache/cassandra/db/HintedHandOffManager.java
Patch:
@@ -260,6 +260,9 @@ protected void compact()
         for (SSTable sstable : hintStore.getDataTracker().getUncompactingSSTables())
             descriptors.add(sstable.descriptor);
 
+        if (descriptors.isEmpty())
+            return;
+
         try
         {
             CompactionManager.instance.submitUserDefined(hintStore, descriptors, (int) (System.currentTimeMillis() / 1000)).get();

File: test/unit/org/apache/cassandra/io/sstable/CQLSSTableWriterTest.java
Patch:
@@ -248,7 +248,7 @@ public CFMetaData getCFMetaData(String keyspace, String cfName)
 
         loader.stream().get();
 
-        UntypedResultSet rs = QueryProcessor.processInternal("SELECT * FROM cql_keyspace.table2;");
+        UntypedResultSet rs = QueryProcessor.executeInternal("SELECT * FROM cql_keyspace.table2;");
         assertEquals(threads.length * NUMBER_WRITES_IN_RUNNABLE, rs.size());
     }
 }

File: test/unit/org/apache/cassandra/db/ColumnFamilyMetricTest.java
Patch:
@@ -23,7 +23,7 @@
 import org.junit.Test;
 
 import org.apache.cassandra.SchemaLoader;
-import org.apache.cassandra.io.sstable.format.SSTableReader;
+import org.apache.cassandra.io.sstable.SSTableReader;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
 import static org.junit.Assert.assertEquals;

File: test/unit/org/apache/cassandra/db/ColumnFamilyMetricTest.java
Patch:
@@ -23,7 +23,7 @@
 import org.junit.Test;
 
 import org.apache.cassandra.SchemaLoader;
-import org.apache.cassandra.io.sstable.SSTableReader;
+import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
 import static org.junit.Assert.assertEquals;
@@ -47,7 +47,7 @@ public void testSizeMetric()
         {
             ByteBuffer key = ByteBufferUtil.bytes(String.valueOf(j));
             Mutation rm = new Mutation("Keyspace1", key);
-            rm.add("Standard2", cellname("0"), ByteBufferUtil.EMPTY_BYTE_BUFFER, j);
+            rm.add("Standard1", cellname("0"), ByteBufferUtil.EMPTY_BYTE_BUFFER, j);
             rm.apply();
         }
         store.forceBlockingFlush();

File: src/java/org/apache/cassandra/io/sstable/SSTableDeletingTask.java
Patch:
@@ -46,14 +46,12 @@ public class SSTableDeletingTask implements Runnable
     private final Descriptor desc;
     private final Set<Component> components;
     private DataTracker tracker;
-    private final long size;
 
     public SSTableDeletingTask(SSTableReader referent)
     {
         this.referent = referent;
         this.desc = referent.descriptor;
         this.components = referent.components;
-        this.size = referent.bytesOnDisk();
     }
 
     public void setTracker(DataTracker tracker)
@@ -68,6 +66,8 @@ public void schedule()
 
     public void run()
     {
+        long size = referent.bytesOnDisk();
+
         if (tracker != null)
             tracker.notifyDeleting(referent);
 

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -126,8 +126,8 @@ public class DatabaseDescriptor
         }
         catch (Exception e)
         {
-            throw new ExceptionInInitializerError(e.getMessage() + "\nFatal configuration error; unable to start. See log for stacktrace.");
             JVMStabilityInspector.inspectThrowable(e);
+            throw new ExceptionInInitializerError(e.getMessage() + "\nFatal configuration error; unable to start. See log for stacktrace.");
         }
     }
 

File: src/java/org/apache/cassandra/thrift/ThriftServer.java
Patch:
@@ -34,9 +34,9 @@
 public class ThriftServer implements CassandraDaemon.Server
 {
     private static Logger logger = LoggerFactory.getLogger(ThriftServer.class);
-    protected final static String SYNC = "sync";
-    protected final static String ASYNC = "async";
-    protected final static String HSHA = "hsha";
+    public final static String SYNC = "sync";
+    public final static String ASYNC = "async";
+    public final static String HSHA = "hsha";
 
     protected final InetAddress address;
     protected final int port;

File: src/java/org/apache/cassandra/triggers/TriggerExecutor.java
Patch:
@@ -53,10 +53,10 @@ private TriggerExecutor()
      */
     public void reloadClasses()
     {
-        File tiggerDirectory = FBUtilities.cassandraTriggerDir();
-        if (tiggerDirectory == null)
+        File triggerDirectory = FBUtilities.cassandraTriggerDir();
+        if (triggerDirectory == null)
             return;
-        customClassLoader = new CustomClassLoader(parent, tiggerDirectory);
+        customClassLoader = new CustomClassLoader(parent, triggerDirectory);
         cachedTriggers.clear();
     }
 

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.ColumnDefinition;
 import org.apache.cassandra.cql3.*;
+import org.apache.cassandra.cql3.selection.Selection;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.composites.CBuilder;
 import org.apache.cassandra.db.composites.Composite;

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -32,6 +32,8 @@
 import org.apache.cassandra.auth.Permission;
 import org.apache.cassandra.cql3.*;
 import org.apache.cassandra.cql3.statements.SingleColumnRestriction.Contains;
+import org.apache.cassandra.cql3.selection.RawSelector;
+import org.apache.cassandra.cql3.selection.Selection;
 import org.apache.cassandra.db.composites.*;
 import org.apache.cassandra.db.composites.Composite.EOC;
 import org.apache.cassandra.transport.messages.ResultMessage;

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1977,7 +1977,7 @@ public void onAlive(InetAddress endpoint, EndpointState state)
 
         if (tokenMetadata.isMember(endpoint))
         {
-            HintedHandOffManager.instance.scheduleHintDelivery(endpoint);
+            HintedHandOffManager.instance.scheduleHintDelivery(endpoint, true);
             for (IEndpointLifecycleSubscriber subscriber : lifecycleSubscribers)
                 subscriber.onUp(endpoint);
         }

File: src/java/org/apache/cassandra/db/index/composites/CompositesIndexOnCollectionKey.java
Patch:
@@ -74,7 +74,7 @@ protected Composite makeIndexColumnPrefix(ByteBuffer rowKey, Composite cellName)
         int count = 1 + baseCfs.metadata.clusteringColumns().size();
         CBuilder builder = getIndexComparator().builder();
         builder.add(rowKey);
-        for (int i = 0; i < count - 1; i++)
+        for (int i = 0; i < Math.min(cellName.size(), count - 1); i++)
             builder.add(cellName.get(i));
         return builder.build();
     }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -2149,7 +2149,7 @@ public void snapshotWithoutFlush(String snapshotName, Predicate<SSTableReader> p
             {
                 for (SSTableReader ssTable : currentView.sstables)
                 {
-                    if (ssTable.isOpenEarly || (predicate != null && !predicate.apply(ssTable)))
+                    if (ssTable.openReason == SSTableReader.OpenReason.EARLY || (predicate != null && !predicate.apply(ssTable)))
                     {
                         continue;
                     }

File: src/java/org/apache/cassandra/io/sstable/SSTableDeletingTask.java
Patch:
@@ -51,7 +51,7 @@ public class SSTableDeletingTask implements Runnable
     public SSTableDeletingTask(SSTableReader referent)
     {
         this.referent = referent;
-        if (referent.isOpenEarly)
+        if (referent.openReason == SSTableReader.OpenReason.EARLY)
         {
             this.desc = referent.descriptor.asType(Descriptor.Type.TEMPLINK);
             this.components = Sets.newHashSet(Component.DATA, Component.PRIMARY_INDEX);

File: src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
Patch:
@@ -397,7 +397,7 @@ public SSTableReader openEarly(long maxDataAge)
                                                            components, metadata,
                                                            partitioner, ifile,
                                                            dfile, iwriter.summary.build(partitioner, exclusiveUpperBoundOfReadableIndex),
-                                                           iwriter.bf, maxDataAge, sstableMetadata, true);
+                                                           iwriter.bf, maxDataAge, sstableMetadata, SSTableReader.OpenReason.EARLY);
 
         // now it's open, find the ACTUAL last readable key (i.e. for which the data file has also been flushed)
         sstable.first = getMinimalKey(first);
@@ -448,7 +448,7 @@ public SSTableReader closeAndOpenReader(long maxDataAge, long repairedAt)
                                                            iwriter.bf,
                                                            maxDataAge,
                                                            sstableMetadata,
-                                                           false);
+                                                           SSTableReader.OpenReason.NORMAL);
         sstable.first = getMinimalKey(first);
         sstable.last = getMinimalKey(last);
         // try to save the summaries to disk

File: src/java/org/apache/cassandra/cql3/ResultSet.java
Patch:
@@ -266,7 +266,7 @@ private Metadata(EnumSet<Flag> flags, List<ColumnSpecification> names, int colum
 
         public Metadata copy()
         {
-            return new Metadata(flags, names, columnCount, pagingState);
+            return new Metadata(EnumSet.copyOf(flags), names, columnCount, pagingState);
         }
 
         // The maximum number of values that the ResultSet can hold. This can be bigger than columnCount due to CASSANDRA-4911

File: src/java/org/apache/cassandra/cql3/statements/Selection.java
Patch:
@@ -287,7 +287,7 @@ public class ResultSetBuilder
 
         private ResultSetBuilder(long now)
         {
-            this.resultSet = new ResultSet(getResultMetadata(), new ArrayList<List<ByteBuffer>>());
+            this.resultSet = new ResultSet(getResultMetadata().copy(), new ArrayList<List<ByteBuffer>>());
             this.timestamps = collectTimestamps ? new long[columns.size()] : null;
             this.ttls = collectTTLs ? new int[columns.size()] : null;
             this.now = now;

File: src/java/org/apache/cassandra/db/composites/AbstractCellNameType.java
Patch:
@@ -184,6 +184,7 @@ public IVersionedSerializer<IDiskAtomFilter> diskAtomFilterSerializer()
 
     public CellName cellFromByteBuffer(ByteBuffer bytes)
     {
+        // we're not guaranteed to get a CellName back from fromByteBuffer(), so it's on the caller to guarantee this
         return (CellName)fromByteBuffer(bytes);
     }
 

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -933,8 +933,8 @@ else if (del.super_column != null)
                                      del.timestamp);
             else
                 mutation.deleteRange(cfm.cfName,
-                                     cfm.comparator.cellFromByteBuffer(del.predicate.getSlice_range().start),
-                                     cfm.comparator.cellFromByteBuffer(del.predicate.getSlice_range().finish),
+                                     cfm.comparator.fromByteBuffer(del.predicate.getSlice_range().start),
+                                     cfm.comparator.fromByteBuffer(del.predicate.getSlice_range().finish),
                                      del.timestamp);
         }
         else

File: src/java/org/apache/cassandra/io/sstable/SSTableReader.java
Patch:
@@ -1128,7 +1128,9 @@ public CompressionMetadata getCompressionMetadata()
 
         CompressionMetadata cmd = ((ICompressedFile) dfile).getMetadata();
 
-        cmd.parameters.setLiveMetadata(Schema.instance.getCFMetaData(descriptor));
+        //We need the parent cf metadata
+        String cfName = metadata.isSecondaryIndex() ? metadata.getParentColumnFamilyName() : metadata.cfName;
+        cmd.parameters.setLiveMetadata(Schema.instance.getCFMetaData(metadata.ksName, cfName));
 
         return cmd;
     }

File: src/java/org/apache/cassandra/io/sstable/SSTableReader.java
Patch:
@@ -1128,7 +1128,9 @@ public CompressionMetadata getCompressionMetadata()
 
         CompressionMetadata cmd = ((ICompressedFile) dfile).getMetadata();
 
-        cmd.parameters.setLiveMetadata(Schema.instance.getCFMetaData(descriptor));
+        //We need the parent cf metadata
+        String cfName = metadata.isSecondaryIndex() ? metadata.getParentColumnFamilyName() : metadata.cfName;
+        cmd.parameters.setLiveMetadata(Schema.instance.getCFMetaData(metadata.ksName, cfName));
 
         return cmd;
     }

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -811,7 +811,7 @@ public void printCompactionThroughput(PrintStream outs)
      */
     public void printStreamThroughput(PrintStream outs)
     {
-        outs.println("Current stream throughput: " + probe.getStreamThroughput() + " MB/s");
+        outs.println("Current stream throughput: " + probe.getStreamThroughput() + " Mb/s");
     }
 
     /**

File: test/unit/org/apache/cassandra/db/marshal/DynamicCompositeTypeTest.java
Patch:
@@ -207,7 +207,7 @@ public void testFullRoundReversed() throws Exception
         ByteBuffer cname5 = createDynamicCompositeKey("test2", uuids[1], 42, false, true);
 
         ByteBuffer key = ByteBufferUtil.bytes("kr");
-        RowMutation rm = new RowMutation("Keyspace1", key);
+        Mutation rm = new Mutation("Keyspace1", key);
         addColumn(rm, cname5);
         addColumn(rm, cname1);
         addColumn(rm, cname4);
@@ -217,7 +217,7 @@ public void testFullRoundReversed() throws Exception
 
         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(Util.dk("kr"), cfName, System.currentTimeMillis()));
 
-        Iterator<Column> iter = cf.getSortedColumns().iterator();
+        Iterator<Cell> iter = cf.getSortedColumns().iterator();
 
         assert iter.next().name().equals(cname5);
         assert iter.next().name().equals(cname4);

File: test/unit/org/apache/cassandra/SchemaLoader.java
Patch:
@@ -126,6 +126,8 @@ public static Collection<KSMetaData> schemaDefinition(boolean withOldCfIds) thro
         Map<Byte, AbstractType<?>> aliases = new HashMap<Byte, AbstractType<?>>();
         aliases.put((byte)'b', BytesType.instance);
         aliases.put((byte)'t', TimeUUIDType.instance);
+        aliases.put((byte)'B', ReversedType.getInstance(BytesType.instance));
+        aliases.put((byte)'T', ReversedType.getInstance(TimeUUIDType.instance));
         AbstractType<?> dynamicComposite = DynamicCompositeType.getInstance(aliases);
 
         // these column definitions will will be applied to the jdbc utf and integer column familes respectively.

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
Patch:
@@ -424,7 +424,7 @@ public int compare(File f, File f2)
         {
             CommitLogDescriptor desc = CommitLogDescriptor.fromFileName(f.getName());
             CommitLogDescriptor desc2 = CommitLogDescriptor.fromFileName(f2.getName());
-            return (int) (desc.id - desc2.id);
+            return Long.compare(desc.id, desc2.id);
         }
     }
 }

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -24,6 +24,7 @@
 import com.google.common.base.Objects;
 import com.google.common.base.Predicate;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Iterators;
 
 import org.github.jamm.MemoryMeter;
 
@@ -1815,7 +1816,7 @@ else if (!restriction.isSlice())
                 previous = cname;
             }
 
-            if (stmt.onToken && cfDef.partitionKeyCount() > 0)
+            if (stmt.onToken)
                 checkTokenFunctionArgumentsOrder(cfDef);
         }
 
@@ -1827,7 +1828,7 @@ else if (!restriction.isSlice())
          */
         private void checkTokenFunctionArgumentsOrder(CFDefinition cfDef) throws InvalidRequestException
         {
-            Iterator<Name> iter = cfDef.partitionKeys().iterator();
+            Iterator<Name> iter = Iterators.cycle(cfDef.partitionKeys());
             for (Relation relation : whereClause)
             {
                 SingleColumnRelation singleColumnRelation = (SingleColumnRelation) relation;

File: src/java/org/apache/cassandra/service/ClientState.java
Patch:
@@ -148,7 +148,7 @@ public String getRawKeyspace()
     public String getKeyspace() throws InvalidRequestException
     {
         if (keyspace == null)
-            throw new InvalidRequestException("No keyspace has been specified. USE a keyspace, or explicity specify keyspace.tablename");
+            throw new InvalidRequestException("No keyspace has been specified. USE a keyspace, or explicitly specify keyspace.tablename");
         return keyspace;
     }
 

File: src/java/org/apache/cassandra/db/compaction/Upgrader.java
Patch:
@@ -88,8 +88,9 @@ public void upgrade()
         outputHandler.output("Upgrading " + sstable);
 
         SSTableRewriter writer = new SSTableRewriter(cfs, toUpgrade, CompactionTask.getMaxDataAge(this.toUpgrade), OperationType.UPGRADE_SSTABLES, true);
-        try (CloseableIterator<AbstractCompactedRow> iter = new CompactionIterable(compactionType, strategy.getScanners(this.toUpgrade), controller).iterator())
+        try (AbstractCompactionStrategy.ScannerList scanners = strategy.getScanners(this.toUpgrade))
         {
+            Iterator<AbstractCompactedRow> iter = new CompactionIterable(compactionType, scanners.scanners, controller).iterator();
             writer.switchWriter(createCompactionWriter(sstable.getSSTableMetadata().repairedAt));
             while (iter.hasNext())
             {

File: src/java/org/apache/cassandra/utils/CloseableIterator.java
Patch:
@@ -21,6 +21,6 @@
 import java.util.Iterator;
 
 // so we can instantiate anonymous classes implementing both interfaces
-public interface CloseableIterator<T> extends Iterator<T>, Closeable
+public interface CloseableIterator<T> extends Iterator<T>, AutoCloseable, Closeable
 {
 }

File: test/unit/org/apache/cassandra/db/compaction/LeveledCompactionStrategyTest.java
Patch:
@@ -143,7 +143,7 @@ public void testCompactionProgress() throws Exception
 
         // get LeveledScanner for level 1 sstables
         Collection<SSTableReader> sstables = strategy.manifest.getLevel(1);
-        List<ICompactionScanner> scanners = strategy.getScanners(sstables);
+        List<ICompactionScanner> scanners = strategy.getScanners(sstables).scanners;
         assertEquals(1, scanners.size()); // should be one per level
         ICompactionScanner scanner = scanners.get(0);
         // scan through to the end

File: tools/stress/src/org/apache/cassandra/stress/settings/OptionReplication.java
Patch:
@@ -51,7 +51,8 @@ public String getStrategy()
     public Map<String, String> getOptions()
     {
         Map<String, String> options = extraOptions();
-        options.put("replication_factor", factor.value());
+        if (!options.containsKey("replication_factor") && (strategy.value().equals("org.apache.cassandra.locator.SimpleStrategy") || factor.setByUser()))
+            options.put("replication_factor", factor.value());
         return options;
     }
 

File: src/java/org/apache/cassandra/cache/KeyCacheKey.java
Patch:
@@ -44,9 +44,9 @@ public KeyCacheKey(UUID cfId, Descriptor desc, ByteBuffer key)
         assert this.key != null;
     }
 
-    public PathInfo getPathInfo()
+    public UUID getCFId()
     {
-        return new PathInfo(desc.ksname, desc.cfname, cfId);
+        return cfId;
     }
 
     public String toString()

File: tools/stress/src/org/apache/cassandra/stress/util/SmartThriftClient.java
Patch:
@@ -22,7 +22,6 @@
 
 
 import java.net.InetAddress;
-import java.net.UnknownHostException;
 import java.nio.ByteBuffer;
 import java.util.*;
 import java.util.concurrent.ConcurrentHashMap;
@@ -64,7 +63,7 @@ public SmartThriftClient(StressSettings settings, String keyspace, Metadata meta
         }
         else
         {
-            whiteset = settings.node.resolveAll();
+            whiteset = settings.node.resolveAllSpecified();
             whitelist = Arrays.asList(whiteset.toArray(new InetAddress[0]));
         }
     }

File: src/java/org/apache/cassandra/tools/NodeTool.java
Patch:
@@ -2373,7 +2373,7 @@ public void execute(NodeProbe probe)
             double mean = stats[2] / stats[5];
             double stdev = Math.sqrt((stats[3] / stats[5]) - (mean * mean));
             System.out.printf("%20s%20s%20s%20s%20s%20s%n", "Interval (ms)", "Max GC Elapsed (ms)", "Total GC Elapsed (ms)", "Stdev GC Elapsed (ms)", "GC Reclaimed (MB)", "Collections");
-            System.out.printf("%20.0f%20.0f%20.0f%20.0f%20.0f%n", stats[0], stats[1], stats[2], stdev, stats[4], stats[5]);
+            System.out.printf("%20.0f%20.0f%20.0f%20.0f%20.0f%20.0f%n", stats[0], stats[1], stats[2], stdev, stats[4], stats[5]);
         }
     }
 

File: tools/stress/src/org/apache/cassandra/stress/settings/OptionRatioDistribution.java
Patch:
@@ -90,7 +90,7 @@ public static RatioDistributionFactory get(String spec)
     {
         OptionRatioDistribution opt = new OptionRatioDistribution("", "", "", true);
         if (!opt.accept(spec))
-            throw new IllegalArgumentException();
+            throw new IllegalArgumentException("Invalid ratio definition: "+spec);
         return opt.get();
     }
 

File: tools/stress/src/org/apache/cassandra/stress/StressMetrics.java
Patch:
@@ -22,6 +22,7 @@
 
 
 import java.io.PrintStream;
+import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
@@ -56,16 +57,15 @@ public StressMetrics(PrintStream output, final long logIntervalMillis, StressSet
     {
         this.output = output;
         Callable<JmxCollector.GcStats> gcStatsCollector;
+        totalGcStats = new JmxCollector.GcStats(0);
         try
         {
             gcStatsCollector = new JmxCollector(settings.node.nodes, settings.port.jmxPort);
-            totalGcStats = new JmxCollector.GcStats(0);
         }
         catch (Throwable t)
         {
             t.printStackTrace();
             System.err.println("Failed to connect over JMX; not collecting these stats");
-            totalGcStats = new JmxCollector.GcStats(Double.POSITIVE_INFINITY);
             gcStatsCollector = new Callable<JmxCollector.GcStats>()
             {
                 public JmxCollector.GcStats call() throws Exception
@@ -149,6 +149,7 @@ public void stop() throws InterruptedException
     private void update() throws InterruptedException
     {
         Timing.TimingResult<JmxCollector.GcStats> result = timing.snap(gcStatsCollector);
+        totalGcStats = JmxCollector.GcStats.aggregate(Arrays.asList(totalGcStats, result.extra));
         if (result.timing.partitionCount != 0)
             printRow("", result.timing, timing.getHistory(), result.extra, rowRateUncertainty, output);
         rowRateUncertainty.update(result.timing.adjustedRowRate());

File: src/java/org/apache/cassandra/tools/NodeTool.java
Patch:
@@ -2371,7 +2371,7 @@ public void execute(NodeProbe probe)
             double[] stats = probe.getAndResetGCStats();
             double mean = stats[2] / stats[5];
             double stdev = Math.sqrt((stats[3] / stats[5]) - (mean * mean));
-            System.out.printf("%20s%20s%20s%20s%20s%n", "Interval (ms)", "Max GC Elapsed (ms)", "Total GC Elapsed (ms)", "Stdev GC Elapsed (ms)", "GC Reclaimed (MB)", "Collections");
+            System.out.printf("%20s%20s%20s%20s%20s%20s%n", "Interval (ms)", "Max GC Elapsed (ms)", "Total GC Elapsed (ms)", "Stdev GC Elapsed (ms)", "GC Reclaimed (MB)", "Collections");
             System.out.printf("%20.0d%20.0d%20.0d%20.0d%20.0d%n", stats[0], stats[1], stats[2], stdev, stats[4], stats[5]);
         }
     }

File: tools/stress/src/org/apache/cassandra/stress/util/Timing.java
Patch:
@@ -73,6 +73,8 @@ private <E> TimingResult<E> snap(Random rnd, Callable<E> call) throws Interrupte
         }
         catch (Exception e)
         {
+            if (e instanceof InterruptedException)
+                throw (InterruptedException) e;
             throw new RuntimeException(e);
         }
 

File: src/java/org/apache/cassandra/locator/YamlFileNetworkTopologySnitch.java
Patch:
@@ -367,11 +367,11 @@ private void maybeSetApplicationState()
         if (es == null)
             return;
         final VersionedValue vv = es.getApplicationState(ApplicationState.INTERNAL_IP);
-        if ((vv != null && !vv.value.equals(localNodeData.dcLocalAddress.toString()))
+        if ((vv != null && !vv.value.equals(localNodeData.dcLocalAddress.getHostAddress()))
             || vv == null)
         {
             Gossiper.instance.addLocalApplicationState(ApplicationState.INTERNAL_IP,
-                StorageService.instance.valueFactory.internalIP(localNodeData.dcLocalAddress.toString()));
+                StorageService.instance.valueFactory.internalIP(localNodeData.dcLocalAddress.getHostAddress()));
         }
     }
 

File: tools/stress/src/org/apache/cassandra/stress/StressProfile.java
Patch:
@@ -535,7 +535,7 @@ static <V> void lowerCase(Map<String, V> map)
         while (iter.hasNext())
         {
             Map.Entry<String, V> e = iter.next();
-            if (!e.getKey().toLowerCase().equalsIgnoreCase(e.getKey()))
+            if (!e.getKey().equalsIgnoreCase(e.getKey()))
             {
                 reinsert.add(e);
                 iter.remove();

File: tools/stress/src/org/apache/cassandra/stress/operations/predefined/ThriftInserter.java
Patch:
@@ -94,7 +94,9 @@ protected List<Column> getColumns()
         for (int i = 0 ; i < values.size() ; i++)
             columns.add(new Column(names.get(i))
                         .setValue(values.get(i))
-                        .setTimestamp(FBUtilities.timestampMicros()));
+                        .setTimestamp(settings.columns.timestamp != null
+                                      ? Long.parseLong(settings.columns.timestamp)
+                                      : FBUtilities.timestampMicros()));
         return columns;
     }
 

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsCommandUser.java
Patch:
@@ -96,7 +96,6 @@ public List<? extends Option> options()
         {
             return ImmutableList.<Option>builder().add(ops, clustering, profile).addAll(parent.options()).build();
         }
-
     }
 
     // CLI utility methods
@@ -105,6 +104,7 @@ public static SettingsCommandUser build(String[] params)
     {
         GroupedOptions options = GroupedOptions.select(params,
                 new Options(new Uncertainty()),
+                new Options(new Duration()),
                 new Options(new Count()));
         if (options == null)
         {
@@ -119,7 +119,8 @@ public static void printHelp()
     {
         GroupedOptions.printOptions(System.out, "user",
                                     new Options(new Uncertainty()),
-                                    new Options(new Count()));
+                                    new Options(new Count()),
+                                    new Options(new Duration()));
     }
 
     public static Runnable helpPrinter()

File: tools/stress/src/org/apache/cassandra/stress/StressMetrics.java
Patch:
@@ -132,8 +132,8 @@ private void update() throws InterruptedException
 
     // PRINT FORMATTING
 
-    public static final String HEADFORMAT = "%-10s,%8s,%8s,%8s,%8s,%8s,%8s,%8s,%8s,%8s,%7s,%9s";
-    public static final String ROWFORMAT =  "%-10d,%8.0f,%8.0f,%8.0f,%8.1f,%8.1f,%8.1f,%8.1f,%8.1f,%8.1f,%7.1f,%9.5f";
+    public static final String HEADFORMAT = "%-10s,%8s,%8s,%8s,%8s,%8s,%8s,%8s,%8s,%8s,%8s,%7s,%9s";
+    public static final String ROWFORMAT =  "%-10d,%8.0f,%8.0f,%8.0f,%8.0f,%8.1f,%8.1f,%8.1f,%8.1f,%8.1f,%8.1f,%7.1f,%9.5f";
 
     private static void printHeader(String prefix, PrintStream output)
     {

File: tools/stress/src/org/apache/cassandra/stress/StressAction.java
Patch:
@@ -198,7 +198,7 @@ private StressMetrics run(OpDistributionFactory operations, int threadCount, lon
         if (durationUnits != null)
         {
             Uninterruptibles.sleepUninterruptibly(duration, durationUnits);
-            workQueue.stop();
+            workManager.stop();
         }
         else if (opCount <= 0)
         {

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsCommand.java
Patch:
@@ -127,7 +127,7 @@ static class Duration extends Options
         @Override
         public List<? extends Option> options()
         {
-            return Arrays.asList(duration, retries, ignoreErrors, consistencyLevel, atOnce);
+            return Arrays.asList(duration, noWarmup, consistencyLevel);
         }
     }
 

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -430,6 +430,7 @@ else if (!sstableRange.intersects(r))
                     logger.info("SSTable {} ({}) does not intersect repaired range {}, not touching repairedAt.", sstable, sstableRange, r);
                     nonAnticompacting.add(sstable);
                     sstableIterator.remove();
+                    break;
                 }
                 else
                 {

File: src/java/org/apache/cassandra/db/Memtable.java
Patch:
@@ -52,7 +52,7 @@ public class Memtable
     private static final Logger logger = LoggerFactory.getLogger(Memtable.class);
 
     static final MemtablePool MEMORY_POOL = DatabaseDescriptor.getMemtableAllocatorPool();
-    private static final int ROW_OVERHEAD_HEAP_SIZE = estimateRowOverhead(Integer.valueOf(System.getProperty("cassandra.memtable_row_overhead_computation_step", "100000")));
+    private static final int ROW_OVERHEAD_HEAP_SIZE = estimateRowOverhead(Integer.parseInt(System.getProperty("cassandra.memtable_row_overhead_computation_step", "100000")));
 
     private final MemtableAllocator allocator;
     private final AtomicLong liveDataSize = new AtomicLong(0);

File: src/java/org/apache/cassandra/dht/RangeStreamer.java
Patch:
@@ -47,7 +47,7 @@
 public class RangeStreamer
 {
     private static final Logger logger = LoggerFactory.getLogger(RangeStreamer.class);
-    public static final boolean useStrictConsistency = Boolean.valueOf(System.getProperty("cassandra.consistent.rangemovement","true"));
+    public static final boolean useStrictConsistency = Boolean.parseBoolean(System.getProperty("cassandra.consistent.rangemovement","true"));
     private final Collection<Token> tokens;
     private final TokenMetadata metadata;
     private final InetAddress address;

File: src/java/org/apache/cassandra/hadoop/cql3/CqlConfigHelper.java
Patch:
@@ -525,15 +525,15 @@ private static Optional<Integer> getIntSetting(String parameter, Configuration c
         String setting = conf.get(parameter);
         if (setting == null)
             return Optional.absent();
-        return Optional.of(Integer.parseInt(setting));  
+        return Optional.of(Integer.valueOf(setting));  
     }
 
     private static Optional<Boolean> getBooleanSetting(String parameter, Configuration conf)
     {
         String setting = conf.get(parameter);
         if (setting == null)
             return Optional.absent();
-        return Optional.of(Boolean.parseBoolean(setting));  
+        return Optional.of(Boolean.valueOf(setting));  
     }
 
     private static Optional<String> getStringSetting(String parameter, Configuration conf)

File: src/java/org/apache/cassandra/tools/StandaloneSplitter.java
Patch:
@@ -201,7 +201,7 @@ public static Options parseArgs(String cmdArgs[])
                 opts.sizeInMB = DEFAULT_SSTABLE_SIZE;
 
                 if (cmd.hasOption(SIZE_OPTION))
-                    opts.sizeInMB = Integer.valueOf(cmd.getOptionValue(SIZE_OPTION));
+                    opts.sizeInMB = Integer.parseInt(cmd.getOptionValue(SIZE_OPTION));
 
                 return opts;
             }

File: tools/stress/src/org/apache/cassandra/stress/settings/OptionAnyProbabilities.java
Patch:
@@ -48,7 +48,7 @@ boolean accept(String param)
             String[] args = param.split("=");
             if (args.length == 2 && args[1].length() > 0 && args[0].length() > 0)
             {
-                if (options.put(args[0], Double.parseDouble(args[1])) != null)
+                if (options.put(args[0], Double.valueOf(args[1])) != null)
                     throw new IllegalArgumentException(args[0] + " set twice");
                 return true;
             }

File: src/java/org/apache/cassandra/db/composites/AbstractSimpleCellNameType.java
Patch:
@@ -86,7 +86,6 @@ static int compareUnsigned(Composite c1, Composite c2)
     {
         ByteBuffer b1 = c1.toByteBuffer();
         ByteBuffer b2 = c2.toByteBuffer();
-        assert b1.hasRemaining() & b2.hasRemaining();
         return ByteBufferUtil.compareUnsigned(b1, b2);
     }
 

File: test/unit/org/apache/cassandra/cql3/DeleteTest.java
Patch:
@@ -117,7 +117,6 @@ public static void setup() throws Exception
     public static void tearDown() throws Exception
     {
         cluster.close();
-        cassandra.stop();
     }
 
     @Test

File: src/java/org/apache/cassandra/cql3/CQL3Type.java
Patch:
@@ -404,7 +404,8 @@ private RawCollection(CollectionType.Kind kind, CQL3Type.Raw keys, CQL3Type.Raw
 
             public Raw freeze()
             {
-                keys.freeze();
+                if (keys != null)
+                    keys.freeze();
                 values.freeze();
                 return super.freeze();
             }

File: src/java/org/apache/cassandra/hadoop/cql3/CqlBulkOutputFormat.java
Patch:
@@ -38,7 +38,7 @@
  * ColumnFamily.
  *
  * <p>
- * As is the case with the {@link org.apache.cassandra.hadoop.CqlOutputFormat}, 
+ * As is the case with the {@link org.apache.cassandra.hadoop.cql3.CqlOutputFormat}, 
  * you need to set the prepared statement in your
  * Hadoop job Configuration. The {@link CqlConfigHelper} class, through its
  * {@link ConfigHelper#setOutputPreparedStatement} method, is provided to make this

File: src/java/org/apache/cassandra/metrics/LatencyMetrics.java
Patch:
@@ -93,7 +93,7 @@ public LatencyMetrics(MetricNameFactory factory, String namePrefix)
      *
      * @param factory MetricName factory to use
      * @param namePrefix Prefix to append to each metric name
-     * @param parents... any amount of parents to replicate updates to
+     * @param parents any amount of parents to replicate updates to
      */
     public LatencyMetrics(MetricNameFactory factory, String namePrefix, LatencyMetrics ... parents)
     {

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -748,7 +748,6 @@ else if (ifExists)
                         {
                             case PARTITION_KEY:
                             case CLUSTERING_COLUMN:
-                                throw new InvalidRequestException(String.format("PRIMARY KEY part %s found in SET part", entry.left));
                                 throw new InvalidRequestException(String.format("PRIMARY KEY column '%s' cannot have IF conditions", entry.left));
                             default:
                                 stmt.addCondition(condition);

File: src/java/org/apache/cassandra/streaming/StreamPlan.java
Patch:
@@ -143,7 +143,7 @@ public StreamPlan listeners(StreamEventHandler handler, StreamEventHandler... ha
      */
     public boolean isEmpty()
     {
-        return coordinator.hasActiveSessions();
+        return !coordinator.hasActiveSessions();
     }
 
     /**

File: src/java/org/apache/cassandra/cql3/Lists.java
Patch:
@@ -76,7 +76,7 @@ public Term prepare(String keyspace, ColumnSpecification receiver) throws Invali
                 Term t = rt.prepare(keyspace, valueSpec);
 
                 if (t.containsBindMarker())
-                    throw new InvalidRequestException(String.format("Invalid list literal for %s: bind variables are not supported inside collection literals", receiver));
+                    throw new InvalidRequestException(String.format("Invalid list literal for %s: bind variables are not supported inside collection literals", receiver.name));
 
                 if (t instanceof Term.NonTerminal)
                     allTerminal = false;
@@ -90,13 +90,13 @@ public Term prepare(String keyspace, ColumnSpecification receiver) throws Invali
         private void validateAssignableTo(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
         {
             if (!(receiver.type instanceof ListType))
-                throw new InvalidRequestException(String.format("Invalid list literal for %s of type %s", receiver, receiver.type.asCQL3Type()));
+                throw new InvalidRequestException(String.format("Invalid list literal for %s of type %s", receiver.name, receiver.type.asCQL3Type()));
 
             ColumnSpecification valueSpec = Lists.valueSpecOf(receiver);
             for (Term.Raw rt : elements)
             {
                 if (!rt.isAssignableTo(keyspace, valueSpec))
-                    throw new InvalidRequestException(String.format("Invalid list literal for %s: value %s is not of type %s", receiver, rt, valueSpec.type.asCQL3Type()));
+                    throw new InvalidRequestException(String.format("Invalid list literal for %s: value %s is not of type %s", receiver.name, rt, valueSpec.type.asCQL3Type()));
             }
         }
 

File: src/java/org/apache/cassandra/cql3/statements/BatchStatement.java
Patch:
@@ -127,7 +127,7 @@ public void validate(ClientState state) throws InvalidRequestException
             statement.validate(state);
 
             if (hasConditions && statement.requiresRead())
-                throw new InvalidRequestException("Operations using list indexes are not allowed with IF conditions");
+                throw new InvalidRequestException("Operations on lists requiring a read (setting by index and deletions by index or value) are not allowed with IF conditions");
         }
     }
 

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -157,7 +157,7 @@ public void validate(ClientState state) throws InvalidRequestException
                 throw new InvalidRequestException("Cannot provide custom timestamp for conditional update");
 
             if (requiresRead())
-                throw new InvalidRequestException("Operations using list indexes are not allowed with IF conditions");
+                throw new InvalidRequestException("Operations on lists requiring a read (setting by index and deletions by index or value) are not allowed with IF conditions");
         }
 
         if (isCounter())

File: src/java/org/apache/cassandra/streaming/StreamResultFuture.java
Patch:
@@ -106,7 +106,7 @@ public static synchronized StreamResultFuture initReceivingSide(UUID planId,
         StreamResultFuture future = StreamManager.instance.getReceivingStream(planId);
         if (future == null)
         {
-            final StreamSession session = new StreamSession(from);
+            final StreamSession session = new StreamSession(from, null);
 
             // The main reason we create a StreamResultFuture on the receiving side is for JMX exposure.
             future = new StreamResultFuture(planId, description, Collections.singleton(session));

File: test/unit/org/apache/cassandra/streaming/StreamTransferTaskTest.java
Patch:
@@ -43,7 +43,7 @@ public void testScheduleTimeout() throws Exception
         String ks = "Keyspace1";
         String cf = "Standard1";
 
-        StreamSession session = new StreamSession(FBUtilities.getBroadcastAddress());
+        StreamSession session = new StreamSession(FBUtilities.getBroadcastAddress(), null);
         ColumnFamilyStore cfs = Keyspace.open(ks).getColumnFamilyStore(cf);
 
         // create two sstables

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -242,7 +242,9 @@ public void uncaughtException(Thread t, Throwable e)
         for (Pair<String, String> kscf : unfinishedCompactions.keySet())
         {
             CFMetaData cfm = Schema.instance.getCFMetaData(kscf.left, kscf.right);
-            ColumnFamilyStore.removeUnfinishedCompactionLeftovers(cfm, unfinishedCompactions.get(kscf));
+            // CFMetaData can be null if CF is already dropped
+            if (cfm != null)
+                ColumnFamilyStore.removeUnfinishedCompactionLeftovers(cfm, unfinishedCompactions.get(kscf));
         }
         SystemKeyspace.discardCompactionsInProgress();
 

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -167,8 +167,8 @@ public List<Future<?>> submitBackground(final ColumnFamilyStore cfs)
 
         // we must schedule it at least once, otherwise compaction will stop for a CF until next flush
         do {
-            futures.add(executor.submit(new BackgroundCompactionTask(cfs)));
             compactingCF.add(cfs);
+            futures.add(executor.submit(new BackgroundCompactionTask(cfs)));
             // if we have room for more compactions, then fill up executor
         } while (executor.getActiveCount() + futures.size() < executor.getMaximumPoolSize());
 

File: test/unit/org/apache/cassandra/db/index/PerRowSecondaryIndexTest.java
Patch:
@@ -147,18 +147,18 @@ public void testRowDelete()
     public void testInvalidSearch() throws IOException
     {
         Mutation rm;
-        rm = new Mutation("PerRowSecondaryIndex", ByteBufferUtil.bytes("k4"));
+        rm = new Mutation(KEYSPACE1, ByteBufferUtil.bytes("k4"));
         rm.add("Indexed1", Util.cellname("indexed"), ByteBufferUtil.bytes("foo"), 1);
         rm.apply();
         
         // test we can search:
-        UntypedResultSet result = QueryProcessor.executeInternal("SELECT * FROM \"PerRowSecondaryIndex\".\"Indexed1\" WHERE indexed = 'foo'");
+        UntypedResultSet result = QueryProcessor.executeInternal(String.format("SELECT * FROM \"%s\".\"Indexed1\" WHERE indexed = 'foo'", KEYSPACE1));
         assertEquals(1, result.size());
 
         // test we can't search if the searcher doesn't validate the expression:
         try
         {
-            QueryProcessor.executeInternal("SELECT * FROM \"PerRowSecondaryIndex\".\"Indexed1\" WHERE indexed = 'invalid'");
+            QueryProcessor.executeInternal(String.format("SELECT * FROM \"%s\".\"Indexed1\" WHERE indexed = 'invalid'", KEYSPACE1));
             fail("Query should have been invalid!");
         }
         catch (Exception e)

File: src/java/org/apache/cassandra/transport/Frame.java
Patch:
@@ -23,7 +23,6 @@
 import java.util.List;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
 import io.netty.channel.*;
 import io.netty.handler.codec.ByteToMessageDecoder;
 import io.netty.handler.codec.MessageToMessageDecoder;
@@ -296,7 +295,8 @@ public void encode(ChannelHandlerContext ctx, Frame frame, List<Object> results)
             header.writeByte(type.opcode);
             header.writeInt(frame.body.readableBytes());
 
-            results.add(Unpooled.wrappedBuffer(header, frame.body));
+            results.add(header);
+            results.add(frame.body);
         }
     }
 

File: src/java/org/apache/cassandra/hadoop/cql3/CqlRecordReader.java
Patch:
@@ -546,7 +546,7 @@ private String buildQuery()
         String partitionKeyList = makeColumnList(partitionKeys);
 
         return String.format("SELECT %s FROM %s.%s WHERE token(%s)>? AND token(%s)<=?" + getAdditionalWhereClauses(),
-                             selectColumnList, keyspace, cfName, partitionKeyList, partitionKeyList);
+                             selectColumnList, quote(keyspace), quote(cfName), partitionKeyList, partitionKeyList);
     }
 
     private String getAdditionalWhereClauses()

File: src/java/org/apache/cassandra/hadoop/cql3/CqlRecordReader.java
Patch:
@@ -149,7 +149,7 @@ public void initialize(InputSplit split, TaskAttemptContext context) throws IOEx
         }
 
         if (cluster != null)
-            session = cluster.connect(keyspace);
+            session = cluster.connect(quote(keyspace));
 
         if (session == null)
           throw new RuntimeException("Can't create connection session");

File: test/unit/org/apache/cassandra/cql3/UFTest.java
Patch:
@@ -171,7 +171,7 @@ public void nonNamespaceUserFunctions() throws Throwable
     {
         createTable("CREATE TABLE %s (key int primary key, val double)");
 
-        execute("create or replace function sin ( input double ) returns double 'org.apache.cassandra.cql3.udf.StdLibMath'");
+        execute("create or replace function sin ( input double ) returns double 'org.apache.cassandra.cql3.UFTest'");
 
         execute("INSERT INTO %s (key, val) VALUES (?, ?)", 1, 1d);
         execute("INSERT INTO %s (key, val) VALUES (?, ?)", 2, 2d);

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -829,6 +829,9 @@ public static long getTimeout(MessagingService.Verb verb)
                 return getTruncateRpcTimeout();
             case READ_REPAIR:
             case MUTATION:
+            case PAXOS_COMMIT:
+            case PAXOS_PREPARE:
+            case PAXOS_PROPOSE:
             case COUNTER_MUTATION:
                 return getWriteRpcTimeout();
             default:

File: src/java/org/apache/cassandra/hadoop/cql3/CqlConfigHelper.java
Patch:
@@ -60,7 +60,7 @@
 
 public class CqlConfigHelper
 {
-    private static final String INPUT_CQL_COLUMNS_CONFIG = "cassandra.input.columnfamily.columns"; // separate by colon ,
+    private static final String INPUT_CQL_COLUMNS_CONFIG = "cassandra.input.columnfamily.columns";
     private static final String INPUT_CQL_PAGE_ROW_SIZE_CONFIG = "cassandra.input.page.row.size";
     private static final String INPUT_CQL_WHERE_CLAUSE_CONFIG = "cassandra.input.where.clause";
     private static final String INPUT_CQL = "cassandra.input.cql";

File: src/java/org/apache/cassandra/hadoop/pig/CqlStorage.java
Patch:
@@ -59,9 +59,9 @@ public class CqlStorage extends AbstractCassandraStorage
     protected RecordWriter<Map<String, ByteBuffer>, List<ByteBuffer>> writer;
 
     protected int pageSize = 1000;
-    private String columns;
+    protected String columns;
     protected String outputQuery;
-    private String whereClause;
+    protected String whereClause;
     private boolean hasCompactValueAlias = false;
         
     public CqlStorage()

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -911,7 +911,7 @@ else if (del.predicate != null && del.predicate.slice_range != null)
             if (del.super_column == null && Schema.instance.getColumnFamilyType(rm.getKeyspaceName(), cfName) == ColumnFamilyType.Super)
                 rm.deleteRange(cfName,
                                SuperColumns.startOf(del.predicate.getSlice_range().start),
-                               SuperColumns.startOf(del.predicate.getSlice_range().finish),
+                               SuperColumns.endOf(del.predicate.getSlice_range().finish),
                                del.timestamp);
             else if (del.super_column != null)
                 rm.deleteRange(cfName,

File: test/pig/org/apache/cassandra/pig/PigTestBase.java
Patch:
@@ -66,6 +66,9 @@ public class PigTestBase extends SchemaLoader
     protected static MiniCluster cluster; 
     protected static PigServer pig;
     protected static String defaultParameters= "init_address=localhost&rpc_port=9170&partitioner=org.apache.cassandra.dht.ByteOrderedPartitioner";
+    protected static String nativeParameters = "&core_conns=2&max_conns=10&min_simult_reqs=3&max_simult_reqs=10&native_timeout=10000000"  +
+                                               "&native_read_timeout=10000000&send_buff_size=4096&receive_buff_size=4096&solinger=3" +
+                                               "&tcp_nodelay=true&reuse_address=true&keep_alive=true&native_port=9052";
 
     static
     {

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -956,8 +956,8 @@ protected void beforeExecute(Thread t, Runnable r)
         @Override
         public void afterExecute(Runnable r, Throwable t)
         {
-            super.afterExecute(r, t);
-
+            DebuggableThreadPoolExecutor.maybeResetTraceSessionWrapper(r);
+    
             if (t == null)
                 t = DebuggableThreadPoolExecutor.extractThrowable(r);
 

File: src/java/org/apache/cassandra/hadoop/cql3/CqlConfigHelper.java
Patch:
@@ -518,7 +518,6 @@ public void onUp(Host host)
                 liveRemoteHosts.add(host);
             }
 
-            @Override
             public void onSuspected(Host host)
             {
             }

File: test/unit/org/apache/cassandra/cql3/CQLTester.java
Patch:
@@ -85,7 +85,7 @@ public void afterTest() throws Throwable
         currentTypes.clear();
 
         // We want to clean up after the test, but dropping a table is rather long so just do that asynchronously
-        StorageService.tasks.execute(new Runnable()
+        StorageService.optionalTasks.execute(new Runnable()
         {
             public void run()
             {

File: src/java/org/apache/cassandra/cql3/UserTypes.java
Patch:
@@ -171,7 +171,7 @@ private ByteBuffer[] bindInternal(QueryOptions options) throws InvalidRequestExc
                 buffers[i] = values.get(i).bindAndGet(options);
                 // Inside UDT values, we must force the serialization of collections to v3 whatever protocol
                 // version is in use since we're going to store directly that serialized value.
-                if (version < 3 && type.fieldType(i).isCollection())
+                if (version < 3 && type.fieldType(i).isCollection() && buffers[i] != null)
                     buffers[i] = ((CollectionType)type.fieldType(i)).getSerializer().reserializeToV3(buffers[i]);
             }
             return buffers;

File: test/unit/org/apache/cassandra/io/util/DataOutputTest.java
Patch:
@@ -236,8 +236,9 @@ private void testRead(DataInput test, DataInput canon) throws IOException
             test.readInt();
             assert false;
         }
-        catch (EOFException _)
+        catch (EOFException ignore)
         {
+            // it worked
         }
     }
 

File: tools/stress/src/org/apache/cassandra/stress/settings/OptionReplication.java
Patch:
@@ -80,8 +80,9 @@ public String apply(String name)
                         throw new IllegalArgumentException(clazz + " is not a replication strategy");
                     strategy = fullname;
                     break;
-                } catch (Exception _)
+                } catch (Exception ignore)
                 {
+                    // will throw below if strategy is still null
                 }
             }
             if (strategy == null)

File: src/java/org/apache/cassandra/db/AbstractCell.java
Patch:
@@ -164,7 +164,7 @@ public void validateFields(CFMetaData metadata) throws MarshalException
 
         AbstractType<?> valueValidator = metadata.getValueValidator(name());
         if (valueValidator != null)
-            valueValidator.validate(value());
+            valueValidator.validateCellValue(value());
     }
 
     public static Cell create(CellName name, ByteBuffer value, long timestamp, int ttl, CFMetaData metadata)

File: src/java/org/apache/cassandra/io/sstable/ColumnNameHelper.java
Patch:
@@ -64,7 +64,7 @@ public static List<ByteBuffer> maxComponents(List<ByteBuffer> maxSeen, Composite
     {
         // For a cell name, no reason to look more than the clustering prefix
         // (and comparing the collection element would actually crash)
-        int size = candidate instanceof CellName ? ((CellName)candidate).clusteringSize() : candidate.size();
+        int size = Math.min(candidate.size(), comparator.clusteringPrefixSize());
 
         if (maxSeen.isEmpty())
             return getComponents(candidate, size);
@@ -92,7 +92,7 @@ public static List<ByteBuffer> minComponents(List<ByteBuffer> minSeen, Composite
     {
         // For a cell name, no reason to look more than the clustering prefix
         // (and comparing the collection element would actually crash)
-        int size = candidate instanceof CellName ? ((CellName)candidate).clusteringSize() : candidate.size();
+        int size = Math.min(candidate.size(), comparator.clusteringPrefixSize());
 
         if (minSeen.isEmpty())
             return getComponents(candidate, size);

File: tools/stress/src/org/apache/cassandra/stress/StressProfile.java
Patch:
@@ -331,7 +331,7 @@ public SchemaInsert getInsert(Timer timer, PartitionGenerator generator, StressS
                     partitions = OptionDistribution.get(!insert.containsKey("partitions") ? "fixed(1)" : insert.remove("partitions"));
                     pervisit = OptionRatioDistribution.get(!insert.containsKey("pervisit") ? "fixed(1)/1" : insert.remove("pervisit"));
                     perbatch = OptionRatioDistribution.get(!insert.containsKey("perbatch") ? "fixed(1)/1" : insert.remove("perbatch"));
-                    batchType = !insert.containsKey("batchtype") ? BatchStatement.Type.UNLOGGED : BatchStatement.Type.valueOf(insert.remove("batchtype"));
+                    batchType = !insert.containsKey("batchtype") ? BatchStatement.Type.LOGGED : BatchStatement.Type.valueOf(insert.remove("batchtype"));
                     if (!insert.isEmpty())
                         throw new IllegalArgumentException("Unrecognised insert option(s): " + insert);
 

File: test/unit/org/apache/cassandra/service/MoveTest.java
Patch:
@@ -138,7 +138,8 @@ public void newTestWriteEndpointsDuringMove() throws Exception
                 	numMoved++;
                 }
             }
-            assertEquals("mismatched number of moved token", numMoved, 1);
+            // This assertion isn't reliable in 2.0 and 2.1.  See CASSANDRA-7390
+            // assertEquals("mismatched number of moved token", numMoved, 1);
         }
 
         // moving endpoint back to the normal state

File: src/java/org/apache/cassandra/db/ColumnFamily.java
Patch:
@@ -411,8 +411,8 @@ public ColumnStats getColumnStats()
         {
             RangeTombstone rangeTombstone = it.next();
             tombstones.update(rangeTombstone.getLocalDeletionTime());
-            minTimestampSeen = Math.min(minTimestampSeen, rangeTombstone.minTimestamp());
-            maxTimestampSeen = Math.max(maxTimestampSeen, rangeTombstone.maxTimestamp());
+            minTimestampSeen = Math.min(minTimestampSeen, rangeTombstone.timestamp());
+            maxTimestampSeen = Math.max(maxTimestampSeen, rangeTombstone.timestamp());
             minColumnNamesSeen = ColumnNameHelper.minComponents(minColumnNamesSeen, rangeTombstone.min, metadata.comparator);
             maxColumnNamesSeen = ColumnNameHelper.maxComponents(maxColumnNamesSeen, rangeTombstone.max, metadata.comparator);
         }

File: src/java/org/apache/cassandra/db/compaction/LazilyCompactedRow.java
Patch:
@@ -245,8 +245,8 @@ protected OnDiskAtom getReduced()
                 else
                 {
                     tombstones.update(t.getLocalDeletionTime());
-                    minTimestampSeen = Math.min(minTimestampSeen, t.minTimestamp());
-                    maxTimestampSeen = Math.max(maxTimestampSeen, t.maxTimestamp());
+                    minTimestampSeen = Math.min(minTimestampSeen, t.timestamp());
+                    maxTimestampSeen = Math.max(maxTimestampSeen, t.timestamp());
                     minColumnNameSeen = ColumnNameHelper.minComponents(minColumnNameSeen, t.min, controller.cfs.metadata.comparator);
                     maxColumnNameSeen = ColumnNameHelper.maxComponents(maxColumnNameSeen, t.max, controller.cfs.metadata.comparator);
                     return t;

File: src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
Patch:
@@ -266,8 +266,8 @@ public long appendFromStream(DecoratedKey key, CFMetaData metadata, DataInput in
         {
             RangeTombstone rangeTombstone = rangeTombstoneIterator.next();
             tombstones.update(rangeTombstone.getLocalDeletionTime());
-            minTimestamp = Math.min(minTimestamp, rangeTombstone.minTimestamp());
-            maxTimestamp = Math.max(maxTimestamp, rangeTombstone.maxTimestamp());
+            minTimestamp = Math.min(minTimestamp, rangeTombstone.timestamp());
+            maxTimestamp = Math.max(maxTimestamp, rangeTombstone.timestamp());
 
             minColumnNames = ColumnNameHelper.minComponents(minColumnNames, rangeTombstone.min, metadata.comparator);
             maxColumnNames = ColumnNameHelper.maxComponents(maxColumnNames, rangeTombstone.max, metadata.comparator);

File: test/unit/org/apache/cassandra/service/MoveTest.java
Patch:
@@ -137,7 +137,8 @@ public void newTestWriteEndpointsDuringMove() throws Exception
                 	numMoved++;
                 }
             }
-            assertEquals("mismatched number of moved token", numMoved, 1);
+            // This assertion isn't reliable in 2.1.  See CASSANDRA-7390
+            // assertEquals("mismatched number of moved token", numMoved, 1);
         }
 
         // moving endpoint back to the normal state

File: src/java/org/apache/cassandra/net/OutboundTcpConnection.java
Patch:
@@ -219,7 +219,7 @@ private void writeConnected(QueuedMessage qm, boolean flush)
                 {
                     state.trace(message);
                     if (qm.message.verb == MessagingService.Verb.REQUEST_RESPONSE)
-                        Tracing.instance.stopNonLocal(state);
+                        Tracing.instance.doneWithNonLocalSession(state);
                 }
             }
 

File: src/java/org/apache/cassandra/db/Memtable.java
Patch:
@@ -467,7 +467,7 @@ public void run()
                 }
                 if (newRatio > MAX_SANE_LIVE_RATIO)
                 {
-                    logger.warn("setting live ratio to maximum of {} instead of {}", MAX_SANE_LIVE_RATIO, newRatio);
+                    logger.debug("setting live ratio to maximum of {} instead of {}", MAX_SANE_LIVE_RATIO, newRatio);
                     newRatio = MAX_SANE_LIVE_RATIO;
                 }
 
@@ -478,8 +478,8 @@ public void run()
                 else
                     memtable.liveRatio = (memtable.liveRatio + newRatio) / 2.0;
 
-                logger.info("{} liveRatio is {} (just-counted was {}).  calculation took {}ms for {} cells",
-                            cfs, memtable.liveRatio, newRatio, TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start), objects);
+                logger.debug("{} liveRatio is {} (just-counted was {}).  calculation took {}ms for {} cells",
+                             cfs, memtable.liveRatio, newRatio, TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start), objects);
             }
             finally
             {

File: src/java/org/apache/cassandra/hadoop/pig/CqlNativeStorage.java
Patch:
@@ -127,6 +127,8 @@ public void setLocation(String location, Job job) throws IOException
             CqlConfigHelper.setInputMaxConnections(conf, nativeMaxConnections);
         if (nativeMinSimultReqs != null)
             CqlConfigHelper.setInputMinSimultReqPerConnections(conf, nativeMinSimultReqs);
+        if (nativeMaxSimultReqs != null)
+            CqlConfigHelper.setInputMaxSimultReqPerConnections(conf, nativeMaxSimultReqs);
         if (nativeConnectionTimeout != null)
             CqlConfigHelper.setInputNativeConnectionTimeout(conf, nativeConnectionTimeout);
         if (nativeReadConnectionTimeout != null)

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -1405,7 +1405,7 @@ static class LocalRangeSliceRunnable extends DroppableRunnable
 
         LocalRangeSliceRunnable(AbstractRangeCommand command, ReadCallback<RangeSliceReply, Iterable<Row>> handler)
         {
-            super(MessagingService.Verb.READ);
+            super(MessagingService.Verb.RANGE_SLICE);
             this.command = command;
             this.handler = handler;
         }
@@ -1590,7 +1590,7 @@ public static List<Row> getRangeSlice(AbstractRangeCommand command, ConsistencyL
                         && filteredEndpoints.get(0).equals(FBUtilities.getBroadcastAddress())
                         && OPTIMIZE_LOCAL_REQUESTS)
                     {
-                        StageManager.getStage(Stage.READ).execute(new LocalRangeSliceRunnable(nodeCmd, handler));
+                        StageManager.getStage(Stage.READ).execute(new LocalRangeSliceRunnable(nodeCmd, handler), Tracing.instance.get());
                     }
                     else
                     {

File: test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
Patch:
@@ -150,7 +150,7 @@ public void testRecoverPITUnordered() throws Exception
 
             ColumnFamily cf = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
             cf.addColumn(column("name-" + i, "value", ts));
-            RowMutation rm = new RowMutation("Keyspace1", dk.key, cf);
+            RowMutation rm = new RowMutation("Keyspace1", dk.getKey(), cf);
             rm.apply();
         }
 

File: test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
Patch:
@@ -136,7 +136,7 @@ public void testRecoverPITUnordered() throws Exception
         Date date = CommitLogArchiver.format.parse("2112:12:12 12:12:12");
         long timeMS = date.getTime();
 
-        Keyspace keyspace1 = Keyspace.open(KEYSPACE1);
+        Keyspace keyspace1 = Keyspace.open("Keyspace1");
         DecoratedKey dk = Util.dk("dkey");
 
         // Col 0 and 9 are the only ones to be recovered
@@ -148,9 +148,9 @@ public void testRecoverPITUnordered() throws Exception
             else
                 ts = TimeUnit.MILLISECONDS.toMicros(timeMS + (i * 1000));
 
-            ColumnFamily cf = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard1");
+            ColumnFamily cf = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
             cf.addColumn(column("name-" + i, "value", ts));
-            Mutation rm = new Mutation(KEYSPACE1, dk.getKey(), cf);
+            RowMutation rm = new RowMutation("Keyspace1", dk.key, cf);
             rm.apply();
         }
 

File: test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
Patch:
@@ -136,7 +136,7 @@ public void testRecoverPITUnordered() throws Exception
         Date date = CommitLogArchiver.format.parse("2112:12:12 12:12:12");
         long timeMS = date.getTime();
 
-        Keyspace keyspace1 = Keyspace.open(KEYSPACE1);
+        Keyspace keyspace1 = Keyspace.open("Keyspace1");
         DecoratedKey dk = Util.dk("dkey");
 
         // Col 0 and 9 are the only ones to be recovered
@@ -148,9 +148,9 @@ public void testRecoverPITUnordered() throws Exception
             else
                 ts = TimeUnit.MILLISECONDS.toMicros(timeMS + (i * 1000));
 
-            ColumnFamily cf = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard1");
+            ColumnFamily cf = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
             cf.addColumn(column("name-" + i, "value", ts));
-            Mutation rm = new Mutation(KEYSPACE1, dk.getKey(), cf);
+            RowMutation rm = new RowMutation("Keyspace1", dk.key, cf);
             rm.apply();
         }
 

File: test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
Patch:
@@ -137,7 +137,7 @@ public void testRecoverPITUnordered() throws Exception
         Date date = CommitLogArchiver.format.parse("2112:12:12 12:12:12");
         long timeMS = date.getTime();
 
-        Keyspace keyspace1 = Keyspace.open(KEYSPACE1);
+        Keyspace keyspace1 = Keyspace.open("Keyspace1");
         DecoratedKey dk = Util.dk("dkey");
 
         // Col 0 and 9 are the only ones to be recovered
@@ -149,9 +149,9 @@ public void testRecoverPITUnordered() throws Exception
             else
                 ts = TimeUnit.MILLISECONDS.toMicros(timeMS + (i * 1000));
 
-            ColumnFamily cf = ArrayBackedSortedColumns.factory.create(KEYSPACE1, "Standard1");
+            ColumnFamily cf = ArrayBackedSortedColumns.factory.create("Keyspace1", "Standard1");
             cf.addColumn(column("name-" + i, "value", ts));
-            Mutation rm = new Mutation(KEYSPACE1, dk.getKey(), cf);
+            RowMutation rm = new RowMutation("Keyspace1", dk.key, cf);
             rm.apply();
         }
 

File: src/java/org/apache/cassandra/db/DefsTables.java
Patch:
@@ -537,7 +537,7 @@ private static void dropType(UserType ut)
         ksm.userTypes.removeType(ut);
 
         if (!StorageService.instance.isClientMode())
-            MigrationManager.instance.notifyUpdateUserType(ut);
+            MigrationManager.instance.notifyDropUserType(ut);
     }
 
     private static KSMetaData makeNewKeyspaceDefinition(KSMetaData ksm, CFMetaData toExclude)

File: src/java/org/apache/cassandra/transport/DataType.java
Patch:
@@ -202,8 +202,9 @@ public static Pair<DataType, Object> fromType(AbstractType type, int version)
         // shouldn't have to care about it.
         if (type instanceof ReversedType)
             type = ((ReversedType)type).baseType;
+
         // For compatibility sake, we still return DateType as the timestamp type in resultSet metadata (#5723)
-        else if (type instanceof DateType)
+        if (type instanceof DateType)
             type = TimestampType.instance;
 
         DataType dt = dataTypeMap.get(type);

File: src/java/org/apache/cassandra/service/ClientState.java
Patch:
@@ -67,7 +67,8 @@ public class ClientState
                                        SystemKeyspace.PEERS_CF,
                                        SystemKeyspace.SCHEMA_KEYSPACES_CF,
                                        SystemKeyspace.SCHEMA_COLUMNFAMILIES_CF,
-                                       SystemKeyspace.SCHEMA_COLUMNS_CF };
+                                       SystemKeyspace.SCHEMA_COLUMNS_CF,
+                                       SystemKeyspace.SCHEMA_USER_TYPES_CF};
         for (String cf : cfs)
             READABLE_SYSTEM_RESOURCES.add(DataResource.columnFamily(Keyspace.SYSTEM_KS, cf));
 

File: src/java/org/apache/cassandra/transport/DataType.java
Patch:
@@ -146,8 +146,9 @@ public static Pair<DataType, Object> fromType(AbstractType type)
         // shouldn't have to care about it.
         if (type instanceof ReversedType)
             type = ((ReversedType)type).baseType;
+
         // For compatibility sake, we still return DateType as the timestamp type in resultSet metadata (#5723)
-        else if (type instanceof DateType)
+        if (type instanceof DateType)
             type = TimestampType.instance;
 
         DataType dt = dataTypeMap.get(type);

File: src/java/org/apache/cassandra/service/ClientState.java
Patch:
@@ -67,7 +67,8 @@ public class ClientState
                                        SystemKeyspace.PEERS_CF,
                                        SystemKeyspace.SCHEMA_KEYSPACES_CF,
                                        SystemKeyspace.SCHEMA_COLUMNFAMILIES_CF,
-                                       SystemKeyspace.SCHEMA_COLUMNS_CF };
+                                       SystemKeyspace.SCHEMA_COLUMNS_CF,
+                                       SystemKeyspace.SCHEMA_USER_TYPES_CF};
         for (String cf : cfs)
             READABLE_SYSTEM_RESOURCES.add(DataResource.columnFamily(Keyspace.SYSTEM_KS, cf));
 

File: src/java/org/apache/cassandra/db/DefsTables.java
Patch:
@@ -543,7 +543,7 @@ private static void dropType(UserType ut)
         ksm.userTypes.removeType(ut);
 
         if (!StorageService.instance.isClientMode())
-            MigrationManager.instance.notifyUpdateUserType(ut);
+            MigrationManager.instance.notifyDropUserType(ut);
     }
 
     private static KSMetaData makeNewKeyspaceDefinition(KSMetaData ksm, CFMetaData toExclude)

File: examples/hadoop_word_count/src/WordCountCounters.java
Patch:
@@ -18,8 +18,10 @@
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.util.SortedMap;
 
 import org.apache.cassandra.db.Cell;
+import org.apache.cassandra.thrift.*;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: src/java/org/apache/cassandra/tools/NodeTool.java
Patch:
@@ -2299,10 +2299,10 @@ public void execute(NodeProbe probe)
         }
     }
     
-    @Command(name = "setlogginglevel", description = "Set a log level for a given logger. If both classQualifer and level are empty/null, it will reset based on the initial configuration")
+    @Command(name = "setlogginglevel", description = "Set the log level threshold for a given class. If both class and level are empty/null, it will reset to the initial configuration")
     public static class SetLoggingLevel extends NodeToolCmd
     {
-        @Arguments(usage = "<classQualifer> <level>", description = "The logger classQualifer and the logger level (can be empty)")
+        @Arguments(usage = "<class> <level>", description = "The class to change the level for and the log level threshold to set (can be empty)")
         private List<String> args = new ArrayList<>();
 
         @Override

File: src/java/org/apache/cassandra/db/composites/BoundedComposite.java
Patch:
@@ -23,6 +23,9 @@
 import org.apache.cassandra.utils.memory.AbstractAllocator;
 import org.apache.cassandra.utils.ObjectSizes;
 
+/**
+ * Wraps another Composite and adds an EOC byte to track whether this is a slice start or end.
+ */
 public class BoundedComposite extends AbstractComposite
 {
     private static final long EMPTY_SIZE = ObjectSizes.measure(new BoundedComposite(null, false));

File: src/java/org/apache/cassandra/db/compaction/LazilyCompactedRow.java
Patch:
@@ -118,7 +118,7 @@ public long write(DataOutput out) throws IOException
         DataOutputBuffer clockOut = new DataOutputBuffer();
         DeletionTime.serializer.serialize(emptyColumnFamily.deletionInfo().getTopLevelDeletion(), clockOut);
 
-        long dataSize = clockOut.getLength() + columnSerializedSize;
+        long dataSize = clockOut.getLength() + columnSerializedSize + this.indexBuilder.getOpenedMarkerSize();
         if (logger.isDebugEnabled())
             logger.debug(String.format("clock / column sizes are %s / %s", clockOut.getLength(), columnSerializedSize));
         assert dataSize > 0;

File: src/java/org/apache/cassandra/cql3/QueryProcessor.java
Patch:
@@ -455,7 +455,7 @@ public static ParsedStatement parseStatement(String queryStr) throws SyntaxExcep
 
             // The errorCollector has queue up any errors that the lexer and parser may have encountered
             // along the way, if necessary, we turn the last error into exceptions here.
-            errorCollector.throwLastSyntaxError();
+            errorCollector.throwFirstSyntaxError();
 
             return statement;
         }

File: test/unit/org/apache/cassandra/io/sstable/LegacySSTableTest.java
Patch:
@@ -56,7 +56,7 @@
 public class LegacySSTableTest
 {
     public static final String LEGACY_SSTABLE_PROP = "legacy-sstable-root";
-    public static final String KSNAME = "LegacySSTableTest";
+    public static final String KSNAME = "Keyspace1";
     public static final String CFNAME = "Standard1";
 
     public static Set<String> TEST_DATA;

File: src/java/org/apache/cassandra/tools/NodeTool.java
Patch:
@@ -1835,7 +1835,8 @@ public void execute(NodeProbe probe)
             {
                 ownerships = probe.effectiveOwnership(keyspace);
                 hasEffectiveOwns = true;
-            } catch (IllegalStateException e)
+            }
+            catch (IllegalStateException e)
             {
                 ownerships = probe.getOwnership();
                 System.out.printf("Note: Ownership information does not include topology; for complete information, specify a keyspace%n");
@@ -1943,7 +1944,7 @@ private String getFormat(
                 buf.append(addressPlaceholder);               // address
                 buf.append("%-9s  ");                         // load
                 if (!isTokenPerNode)
-                    buf.append("%-6s  ");                     // "Tokens"
+                    buf.append("%-11s  ");                     // "Tokens"
                 if (hasEffectiveOwns)
                     buf.append("%-16s  ");                    // "Owns (effective)"
                 else

File: test/unit/org/apache/cassandra/cql3/CQLTester.java
Patch:
@@ -62,8 +62,6 @@ public abstract class CQLTester
     private String currentTable;
     private final Set<String> currentTypes = new HashSet<>();
 
-    private final Set<String> currentTypes = new HashSet<>();
-
     @BeforeClass
     public static void setUpClass() throws Throwable
     {

File: test/unit/org/apache/cassandra/cql3/CQLTester.java
Patch:
@@ -62,8 +62,6 @@ public abstract class CQLTester
     private String currentTable;
     private final Set<String> currentTypes = new HashSet<>();
 
-    private final Set<String> currentTypes = new HashSet<>();
-
     @BeforeClass
     public static void setUpClass() throws Throwable
     {

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -1697,6 +1697,7 @@ else if (!existingRestriction.isContains())
                     boolean isKey = newRel.operator() == Relation.Type.CONTAINS_KEY;
                     receiver = makeCollectionReceiver(receiver, isKey);
                     Term t = newRel.getValue().prepare(keyspace(), receiver);
+                    t.collectMarkerSpecification(boundNames);
                     ((SingleColumnRestriction.Contains)existingRestriction).add(t, isKey);
                 }
             }

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -397,7 +397,8 @@ public void performAnticompaction(ColumnFamilyStore cfs,
                                       Collection<SSTableReader> validatedForRepair,
                                       long repairedAt) throws InterruptedException, ExecutionException, IOException
     {
-        logger.info("Starting anticompaction for ranges {}", ranges);
+        logger.info("Starting anticompaction");
+        logger.debug("Starting anticompaction for ranges {}", ranges);
         Set<SSTableReader> sstables = new HashSet<>(validatedForRepair);
         Set<SSTableReader> mutatedRepairStatuses = new HashSet<>();
         Set<SSTableReader> nonAnticompacting = new HashSet<>();

File: src/java/org/apache/cassandra/db/marshal/CollectionType.java
Patch:
@@ -60,6 +60,9 @@ protected CollectionType(Kind kind)
 
     public abstract List<ByteBuffer> serializedValues(List<Cell> cells);
 
+    @Override
+    public abstract CollectionSerializer<T> getSerializer();
+
     @Override
     public String toString()
     {

File: src/java/org/apache/cassandra/streaming/StreamReader.java
Patch:
@@ -79,7 +79,7 @@ public StreamReader(FileMessageHeader header, StreamSession session)
      */
     public SSTableWriter read(ReadableByteChannel channel) throws IOException
     {
-        logger.info("reading file from {}, repairedAt = {}", session.peer, repairedAt);
+        logger.debug("reading file from {}, repairedAt = {}", session.peer, repairedAt);
         long totalSize = totalSize();
 
         Pair<String, String> kscf = Schema.instance.getCF(cfId);

File: src/java/org/apache/cassandra/streaming/compress/CompressedStreamReader.java
Patch:
@@ -61,7 +61,7 @@ public CompressedStreamReader(FileMessageHeader header, StreamSession session)
     @Override
     public SSTableWriter read(ReadableByteChannel channel) throws IOException
     {
-        logger.info("reading file from {}, repairedAt = {}", session.peer, repairedAt);
+        logger.debug("reading file from {}, repairedAt = {}", session.peer, repairedAt);
         long totalSize = totalSize();
 
         Pair<String, String> kscf = Schema.instance.getCF(cfId);

File: src/java/org/apache/cassandra/cql3/CFDefinition.java
Patch:
@@ -152,7 +152,7 @@ public Collection<Name> regularColumns()
 
     public Collection<Name> staticColumns()
     {
-        return regularColumns.values();
+        return staticColumns.values();
     }
 
     public Name compactValue()

File: test/unit/org/apache/cassandra/db/CommitLogTest.java
Patch:
@@ -297,7 +297,7 @@ public void testCommitFailurePolicy_stop()
 
             DatabaseDescriptor.setCommitFailurePolicy(Config.CommitFailurePolicy.stop);
             commitDir.setWritable(false);
-            Mutation rm = new Mutation("Keyspace1", bytes("k"));
+            Mutation rm = new Mutation(KEYSPACE1, bytes("k"));
             rm.add("Standard1", Util.cellname("c1"), ByteBuffer.allocate(100), 0);
 
             // Adding it twice (won't change segment)

File: src/java/org/apache/cassandra/locator/CloudstackSnitch.java
Patch:
@@ -27,7 +27,6 @@
 import java.net.InetAddress;
 import java.net.URL;
 import java.net.URI;
-import java.nio.charset.StandardCharsets;
 import java.util.Map;
 import java.util.regex.Pattern;
 import java.util.regex.Matcher;
@@ -137,7 +136,7 @@ String csQueryMetadata(String url) throws ConfigurationException, IOException
             byte[] b = new byte[cl];
             is = new DataInputStream(new BufferedInputStream(conn.getInputStream()));
             is.readFully(b);
-            return new String(b, StandardCharsets.UTF_8);
+            return new String(b, FBUtilities.UTF_8);
         } 
         finally 
         {

File: src/java/org/apache/cassandra/utils/FBUtilities.java
Patch:
@@ -27,6 +27,7 @@
 import java.net.URL;
 import java.net.UnknownHostException;
 import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.*;
@@ -63,6 +64,8 @@
 
 public class FBUtilities
 {
+    public static final Charset UTF_8 = Charset.forName("UTF-8");
+
     private static final Logger logger = LoggerFactory.getLogger(FBUtilities.class);
 
     private static ObjectMapper jsonMapper = new ObjectMapper(new JsonFactory());

File: src/java/org/apache/cassandra/cql3/statements/ColumnGroupMap.java
Patch:
@@ -136,13 +136,13 @@ public void add(Column c)
 
             if (currentGroup == null)
             {
-                currentGroup = new ColumnGroupMap(current, composite.isStaticName(c.name()));
+                currentGroup = new ColumnGroupMap(current, CompositeType.isStaticName(c.name()));
                 currentGroup.add(current, idx, c);
                 previous = current;
                 return;
             }
 
-            if (!isSameGroup(current))
+            if ((currentGroup.isStatic && !CompositeType.isStaticName(c.name())) || !isSameGroup(current))
             {
                 groups.add(currentGroup);
                 // Note that we know that only the first group built can be static

File: src/java/org/apache/cassandra/transport/messages/ExecuteMessage.java
Patch:
@@ -102,12 +102,12 @@ public Message.Response execute(QueryState state)
         {
             QueryHandler handler = state.getClientState().getCQLQueryHandler();
             ParsedStatement.Prepared prepared = handler.getPrepared(statementId);
+            if (prepared == null)
+                throw new PreparedQueryNotFoundException(statementId);
+
             options.prepare(prepared.boundNames);
             CQLStatement statement = prepared.statement;
 
-            if (statement == null)
-                throw new PreparedQueryNotFoundException(statementId);
-
             if (options.getPageSize() == 0)
                 throw new ProtocolException("The page size cannot be 0");
 

File: src/java/org/apache/cassandra/service/FileCacheService.java
Patch:
@@ -69,7 +69,7 @@ public void onRemoval(RemovalNotification<String, Queue<RandomAccessReader>> not
                 if (cachedInstances.size() > 0)
                     logger.debug("Evicting cold readers for {}", cachedInstances.peek().getPath());
 
-                for (RandomAccessReader reader : cachedInstances)
+                for (RandomAccessReader reader = cachedInstances.poll(); reader != null; reader = cachedInstances.poll())
                 {
                     memoryUsage.addAndGet(-1 * reader.getTotalBufferSize());
                     reader.deallocate();

File: src/java/org/apache/cassandra/db/CollationController.java
Patch:
@@ -77,6 +77,7 @@ private ColumnFamily collectTimeOrderedData()
         try
         {
             Tracing.trace("Merging memtable contents");
+            long mostRecentRowTombstone = Long.MIN_VALUE;
             for (Memtable memtable : view.memtables)
             {
                 OnDiskAtomIterator iter = filter.getMemtableColumnIterator(memtable);
@@ -89,6 +90,7 @@ private ColumnFamily collectTimeOrderedData()
                 }
 
                 container.addAll(temp, HeapAllocator.instance);
+                mostRecentRowTombstone = container.deletionInfo().getTopLevelDeletion().markedForDeleteAt;
                 temp.clear();
             }
 
@@ -102,7 +104,6 @@ private ColumnFamily collectTimeOrderedData()
             Collections.sort(view.sstables, SSTable.maxTimestampComparator);
 
             // read sorted sstables
-            long mostRecentRowTombstone = Long.MIN_VALUE;
             for (SSTableReader sstable : view.sstables)
             {
                 // if we've already seen a row tombstone with a timestamp greater
@@ -122,15 +123,14 @@ private ColumnFamily collectTimeOrderedData()
                 if (iter.getColumnFamily() != null)
                 {
                     ColumnFamily cf = iter.getColumnFamily();
-                    if (cf.isMarkedForDelete())
-                        mostRecentRowTombstone = cf.deletionInfo().getTopLevelDeletion().markedForDeleteAt;
                     temp.delete(cf);
                     sstablesIterated++;
                     while (iter.hasNext())
                         temp.addAtom(iter.next());
                 }
 
                 container.addAll(temp, HeapAllocator.instance);
+                mostRecentRowTombstone = container.deletionInfo().getTopLevelDeletion().markedForDeleteAt;
                 temp.clear();
             }
 

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -777,8 +777,6 @@ public static boolean isReplacing()
             logger.info("Replace address on first boot requested; this node is already bootstrapped");
             return false;
         }
-        if (getReplaceAddress() != null && SystemTable.bootstrapComplete())
-            throw new RuntimeException("Cannot replace address with a node that is already bootstrapped");
         return getReplaceAddress() != null;
     }
 

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -608,6 +608,8 @@ private void joinTokenRing(int delay) throws ConfigurationException
             throw new RuntimeException("Replace method removed; use cassandra.replace_address instead");
         if (DatabaseDescriptor.isReplacing())
         {
+            if (SystemTable.bootstrapComplete())
+                throw new RuntimeException("Cannot replace address with a node that is already bootstrapped");
             if (!DatabaseDescriptor.isAutoBootstrap())
                 throw new RuntimeException("Trying to replace_address with auto_bootstrap disabled will not work, check your configuration");
             tokens = prepareReplacementInfo();

File: test/unit/org/apache/cassandra/cql3/DeleteTest.java
Patch:
@@ -33,7 +33,7 @@
 
 import java.io.IOException;
 
-public class DeleteTest
+public class DeleteTest extends SchemaLoader
 {
     private static EmbeddedCassandraService cassandra;
 
@@ -51,6 +51,8 @@ public class DeleteTest
     @BeforeClass()
     public static void setup() throws ConfigurationException, IOException
     {
+        Schema.instance.clear();
+
         cassandra = new EmbeddedCassandraService();
         cassandra.start();
 

File: src/java/org/apache/cassandra/cql3/ColumnIdentifier.java
Patch:
@@ -89,7 +89,7 @@ public long unsharedHeapSize()
              + ObjectSizes.sizeOf(text);
     }
 
-    public long excessHeapSizeExcludingData()
+    public long unsharedHeapSizeExcludingData()
     {
         return EMPTY_SIZE
              + ObjectSizes.sizeOnHeapExcludingData(bytes)

File: src/java/org/apache/cassandra/db/AtomicBTreeColumns.java
Patch:
@@ -344,7 +344,7 @@ public Cell apply(Cell insert)
             indexer.insert(insert);
             insert = insert.localCopy(metadata, allocator, writeOp);
             this.dataSize += insert.cellDataSize();
-            this.heapSize += insert.excessHeapSizeExcludingData();
+            this.heapSize += insert.unsharedHeapSizeExcludingData();
             if (inserted == null)
                 inserted = new ArrayList<>();
             inserted.add(insert);
@@ -359,7 +359,7 @@ public Cell apply(Cell existing, Cell update)
             {
                 reconciled = reconciled.localCopy(metadata, allocator, writeOp);
                 dataSize += reconciled.cellDataSize() - existing.cellDataSize();
-                heapSize += reconciled.excessHeapSizeExcludingData() - existing.excessHeapSizeExcludingData();
+                heapSize += reconciled.unsharedHeapSizeExcludingData() - existing.unsharedHeapSizeExcludingData();
                 if (inserted == null)
                     inserted = new ArrayList<>();
                 inserted.add(reconciled);

File: src/java/org/apache/cassandra/db/BufferCell.java
Patch:
@@ -84,9 +84,9 @@ public long timestamp() {
     }
 
     @Override
-    public long excessHeapSizeExcludingData()
+    public long unsharedHeapSizeExcludingData()
     {
-        return EMPTY_SIZE + name.excessHeapSizeExcludingData() + ObjectSizes.sizeOnHeapExcludingData(value);
+        return EMPTY_SIZE + name.unsharedHeapSizeExcludingData() + ObjectSizes.sizeOnHeapExcludingData(value);
     }
 
     @Override

File: src/java/org/apache/cassandra/db/Cell.java
Patch:
@@ -51,7 +51,7 @@ public interface Cell extends OnDiskAtom
 
     // returns the size of the Cell and all references on the heap, excluding any costs associated with byte arrays
     // that would be allocated by a localCopy, as these will be accounted for by the allocator
-    public long excessHeapSizeExcludingData();
+    public long unsharedHeapSizeExcludingData();
 
     public int serializedSize(CellNameType type, TypeSizes typeSizes);
 

File: src/java/org/apache/cassandra/db/NativeCell.java
Patch:
@@ -75,7 +75,7 @@ public void updateDigest(MessageDigest digest)
     }
 
     @Override
-    public long excessHeapSizeExcludingData()
+    public long unsharedHeapSizeExcludingData()
     {
         return SIZE;
     }

File: src/java/org/apache/cassandra/db/NativeCounterCell.java
Patch:
@@ -167,7 +167,7 @@ public CounterCell localCopy(CFMetaData metadata, MemtableAllocator allocator, O
     }
 
     @Override
-    public long excessHeapSizeExcludingData()
+    public long unsharedHeapSizeExcludingData()
     {
         return SIZE;
     }

File: src/java/org/apache/cassandra/db/NativeDeletedCell.java
Patch:
@@ -112,7 +112,7 @@ public boolean equals(Cell cell)
     }
 
     @Override
-    public long excessHeapSizeExcludingData()
+    public long unsharedHeapSizeExcludingData()
     {
         return SIZE;
     }

File: src/java/org/apache/cassandra/db/NativeExpiringCell.java
Patch:
@@ -160,7 +160,7 @@ public ExpiringCell localCopy(CFMetaData metadata, MemtableAllocator allocator,
     }
 
     @Override
-    public long excessHeapSizeExcludingData()
+    public long unsharedHeapSizeExcludingData()
     {
         return SIZE;
     }

File: src/java/org/apache/cassandra/db/RowIndexEntry.java
Patch:
@@ -207,7 +207,7 @@ public long unsharedHeapSize()
         {
             long entrySize = 0;
             for (IndexHelper.IndexInfo idx : columnsIndex)
-                entrySize += idx.excessHeapSize();
+                entrySize += idx.unsharedHeapSize();
 
             return BASE_SIZE
                    + entrySize

File: src/java/org/apache/cassandra/db/composites/CellName.java
Patch:
@@ -74,5 +74,5 @@ public interface CellName extends Composite
     @Override
     public CellName copy(CFMetaData cfm, AbstractAllocator allocator);
 
-    public long excessHeapSizeExcludingData();
+    public long unsharedHeapSizeExcludingData();
 }

File: src/java/org/apache/cassandra/db/composites/CompoundDenseCellName.java
Patch:
@@ -73,7 +73,7 @@ public long unsharedHeapSize()
     }
 
     @Override
-    public long excessHeapSizeExcludingData()
+    public long unsharedHeapSizeExcludingData()
     {
         return HEAP_SIZE + ObjectSizes.sizeOnHeapExcludingData(elements);
     }

File: src/java/org/apache/cassandra/db/composites/SimpleDenseCellName.java
Patch:
@@ -67,7 +67,7 @@ public long unsharedHeapSize()
     }
 
     @Override
-    public long excessHeapSizeExcludingData()
+    public long unsharedHeapSizeExcludingData()
     {
         return EMPTY_SIZE + ObjectSizes.sizeOnHeapExcludingData(element);
     }

File: src/java/org/apache/cassandra/db/composites/SimpleSparseCellName.java
Patch:
@@ -87,9 +87,9 @@ public boolean isSameCQL3RowAs(CellNameType type, CellName other)
         return true;
     }
 
-    public long excessHeapSizeExcludingData()
+    public long unsharedHeapSizeExcludingData()
     {
-        return EMPTY_SIZE + columnName.excessHeapSizeExcludingData();
+        return EMPTY_SIZE + columnName.unsharedHeapSizeExcludingData();
     }
 
     public long unsharedHeapSize()

File: src/java/org/apache/cassandra/db/composites/SimpleSparseInternedCellName.java
Patch:
@@ -31,7 +31,7 @@ public class SimpleSparseInternedCellName extends SimpleSparseCellName
     }
 
     @Override
-    public long excessHeapSizeExcludingData()
+    public long unsharedHeapSizeExcludingData()
     {
         return 0;
     }

File: src/java/org/apache/cassandra/io/sstable/IndexHelper.java
Patch:
@@ -205,7 +205,7 @@ public long serializedSize(IndexInfo info, TypeSizes typeSizes)
             }
         }
 
-        public long excessHeapSize()
+        public long unsharedHeapSize()
         {
             return EMPTY_SIZE + firstName.unsharedHeapSize() + lastName.unsharedHeapSize();
         }

File: src/java/org/apache/cassandra/cql3/ColumnIdentifier.java
Patch:
@@ -89,7 +89,7 @@ public long unsharedHeapSize()
              + ObjectSizes.sizeOf(text);
     }
 
-    public long excessHeapSizeExcludingData()
+    public long unsharedHeapSizeExcludingData()
     {
         return EMPTY_SIZE
              + ObjectSizes.sizeOnHeapExcludingData(bytes)

File: src/java/org/apache/cassandra/db/AtomicBTreeColumns.java
Patch:
@@ -344,7 +344,7 @@ public Cell apply(Cell insert)
             indexer.insert(insert);
             insert = insert.localCopy(metadata, allocator, writeOp);
             this.dataSize += insert.cellDataSize();
-            this.heapSize += insert.excessHeapSizeExcludingData();
+            this.heapSize += insert.unsharedHeapSizeExcludingData();
             if (inserted == null)
                 inserted = new ArrayList<>();
             inserted.add(insert);
@@ -359,7 +359,7 @@ public Cell apply(Cell existing, Cell update)
             {
                 reconciled = reconciled.localCopy(metadata, allocator, writeOp);
                 dataSize += reconciled.cellDataSize() - existing.cellDataSize();
-                heapSize += reconciled.excessHeapSizeExcludingData() - existing.excessHeapSizeExcludingData();
+                heapSize += reconciled.unsharedHeapSizeExcludingData() - existing.unsharedHeapSizeExcludingData();
                 if (inserted == null)
                     inserted = new ArrayList<>();
                 inserted.add(reconciled);

File: src/java/org/apache/cassandra/db/BufferCell.java
Patch:
@@ -84,9 +84,9 @@ public long timestamp() {
     }
 
     @Override
-    public long excessHeapSizeExcludingData()
+    public long unsharedHeapSizeExcludingData()
     {
-        return EMPTY_SIZE + name.excessHeapSizeExcludingData() + ObjectSizes.sizeOnHeapExcludingData(value);
+        return EMPTY_SIZE + name.unsharedHeapSizeExcludingData() + ObjectSizes.sizeOnHeapExcludingData(value);
     }
 
     @Override

File: src/java/org/apache/cassandra/db/Cell.java
Patch:
@@ -51,7 +51,7 @@ public interface Cell extends OnDiskAtom
 
     // returns the size of the Cell and all references on the heap, excluding any costs associated with byte arrays
     // that would be allocated by a localCopy, as these will be accounted for by the allocator
-    public long excessHeapSizeExcludingData();
+    public long unsharedHeapSizeExcludingData();
 
     public int serializedSize(CellNameType type, TypeSizes typeSizes);
 

File: src/java/org/apache/cassandra/db/NativeCell.java
Patch:
@@ -75,7 +75,7 @@ public void updateDigest(MessageDigest digest)
     }
 
     @Override
-    public long excessHeapSizeExcludingData()
+    public long unsharedHeapSizeExcludingData()
     {
         return SIZE;
     }

File: src/java/org/apache/cassandra/db/NativeCounterCell.java
Patch:
@@ -167,7 +167,7 @@ public CounterCell localCopy(CFMetaData metadata, MemtableAllocator allocator, O
     }
 
     @Override
-    public long excessHeapSizeExcludingData()
+    public long unsharedHeapSizeExcludingData()
     {
         return SIZE;
     }

File: src/java/org/apache/cassandra/db/NativeDeletedCell.java
Patch:
@@ -112,7 +112,7 @@ public boolean equals(Cell cell)
     }
 
     @Override
-    public long excessHeapSizeExcludingData()
+    public long unsharedHeapSizeExcludingData()
     {
         return SIZE;
     }

File: src/java/org/apache/cassandra/db/NativeExpiringCell.java
Patch:
@@ -160,7 +160,7 @@ public ExpiringCell localCopy(CFMetaData metadata, MemtableAllocator allocator,
     }
 
     @Override
-    public long excessHeapSizeExcludingData()
+    public long unsharedHeapSizeExcludingData()
     {
         return SIZE;
     }

File: src/java/org/apache/cassandra/db/RowIndexEntry.java
Patch:
@@ -207,7 +207,7 @@ public long unsharedHeapSize()
         {
             long entrySize = 0;
             for (IndexHelper.IndexInfo idx : columnsIndex)
-                entrySize += idx.excessHeapSize();
+                entrySize += idx.unsharedHeapSize();
 
             return BASE_SIZE
                    + entrySize

File: src/java/org/apache/cassandra/db/composites/CellName.java
Patch:
@@ -74,5 +74,5 @@ public interface CellName extends Composite
     @Override
     public CellName copy(CFMetaData cfm, AbstractAllocator allocator);
 
-    public long excessHeapSizeExcludingData();
+    public long unsharedHeapSizeExcludingData();
 }

File: src/java/org/apache/cassandra/db/composites/CompoundDenseCellName.java
Patch:
@@ -73,7 +73,7 @@ public long unsharedHeapSize()
     }
 
     @Override
-    public long excessHeapSizeExcludingData()
+    public long unsharedHeapSizeExcludingData()
     {
         return HEAP_SIZE + ObjectSizes.sizeOnHeapExcludingData(elements);
     }

File: src/java/org/apache/cassandra/db/composites/SimpleDenseCellName.java
Patch:
@@ -67,7 +67,7 @@ public long unsharedHeapSize()
     }
 
     @Override
-    public long excessHeapSizeExcludingData()
+    public long unsharedHeapSizeExcludingData()
     {
         return EMPTY_SIZE + ObjectSizes.sizeOnHeapExcludingData(element);
     }

File: src/java/org/apache/cassandra/db/composites/SimpleSparseCellName.java
Patch:
@@ -87,9 +87,9 @@ public boolean isSameCQL3RowAs(CellNameType type, CellName other)
         return true;
     }
 
-    public long excessHeapSizeExcludingData()
+    public long unsharedHeapSizeExcludingData()
     {
-        return EMPTY_SIZE + columnName.excessHeapSizeExcludingData();
+        return EMPTY_SIZE + columnName.unsharedHeapSizeExcludingData();
     }
 
     public long unsharedHeapSize()

File: src/java/org/apache/cassandra/db/composites/SimpleSparseInternedCellName.java
Patch:
@@ -31,7 +31,7 @@ public class SimpleSparseInternedCellName extends SimpleSparseCellName
     }
 
     @Override
-    public long excessHeapSizeExcludingData()
+    public long unsharedHeapSizeExcludingData()
     {
         return 0;
     }

File: src/java/org/apache/cassandra/io/sstable/IndexHelper.java
Patch:
@@ -205,7 +205,7 @@ public long serializedSize(IndexInfo info, TypeSizes typeSizes)
             }
         }
 
-        public long excessHeapSize()
+        public long unsharedHeapSize()
         {
             return EMPTY_SIZE + firstName.unsharedHeapSize() + lastName.unsharedHeapSize();
         }

File: src/java/org/apache/cassandra/cql3/TypeCast.java
Patch:
@@ -50,7 +50,7 @@ public boolean isAssignableTo(String keyspace, ColumnSpecification receiver) thr
     {
         try
         {
-            return receiver.type.asCQL3Type().equals(type.prepare(keyspace));
+            return receiver.type.isValueCompatibleWith(type.prepare(keyspace).getType());
         }
         catch (InvalidRequestException e)
         {

File: src/java/org/apache/cassandra/cql3/functions/FunctionCall.java
Patch:
@@ -142,7 +142,7 @@ public boolean isAssignableTo(String keyspace, ColumnSpecification receiver)
             // is used as argument of another, existing, function. In that case, we return true here because we'll catch
             // the fact that the method is undefined latter anyway and with a more helpful error message that if we were
             // to return false here.
-            return returnType == null || receiver.type.asCQL3Type().equals(returnType.asCQL3Type());
+            return returnType == null || receiver.type.isValueCompatibleWith(returnType);
         }
 
         @Override

File: src/java/org/apache/cassandra/cql3/functions/Functions.java
Patch:
@@ -111,7 +111,7 @@ public static Function get(String keyspace, String name, List<? extends Assignem
 
     private static void validateTypes(String keyspace, Function fun, List<? extends AssignementTestable> providedArgs, ColumnSpecification receiver) throws InvalidRequestException
     {
-        if (!receiver.type.asCQL3Type().equals(fun.returnType().asCQL3Type()))
+        if (!receiver.type.isValueCompatibleWith(fun.returnType()))
             throw new InvalidRequestException(String.format("Type error: cannot assign result of function %s (type %s) to %s (type %s)", fun.name(), fun.returnType().asCQL3Type(), receiver, receiver.type.asCQL3Type()));
 
         if (providedArgs.size() != fun.argsType().size())
@@ -134,7 +134,7 @@ private static void validateTypes(String keyspace, Function fun, List<? extends
 
     private static boolean isValidType(String keyspace, Function fun, List<? extends AssignementTestable> providedArgs, ColumnSpecification receiver) throws InvalidRequestException
     {
-        if (!receiver.type.asCQL3Type().equals(fun.returnType().asCQL3Type()))
+        if (!receiver.type.isValueCompatibleWith(fun.returnType()))
             return false;
 
         if (providedArgs.size() != fun.argsType().size())

File: src/java/org/apache/cassandra/cql3/statements/Selection.java
Patch:
@@ -377,7 +377,7 @@ private static abstract class Selector implements AssignementTestable
 
         public boolean isAssignableTo(String keyspace, ColumnSpecification receiver)
         {
-            return getType().asCQL3Type().equals(receiver.type.asCQL3Type());
+            return receiver.type.isValueCompatibleWith(getType());
         }
     }
 

File: src/java/org/apache/cassandra/db/marshal/BytesType.java
Patch:
@@ -58,7 +58,7 @@ public boolean isCompatibleWith(AbstractType<?> previous)
     }
 
     @Override
-    public boolean isValueCompatibleWith(AbstractType<?> previous)
+    public boolean isValueCompatibleWithInternal(AbstractType<?> otherType)
     {
         // BytesType can read anything
         return true;

File: src/java/org/apache/cassandra/db/marshal/TupleType.java
Patch:
@@ -251,13 +251,13 @@ public boolean isCompatibleWith(AbstractType<?> previous)
     }
 
     @Override
-    public boolean isValueCompatibleWith(AbstractType<?> previous)
+    public boolean isValueCompatibleWithInternal(AbstractType<?> otherType)
     {
-        if (!(previous instanceof TupleType))
+        if (!(otherType instanceof TupleType))
             return false;
 
         // Extending with new components is fine, removing is not
-        TupleType tt = (TupleType)previous;
+        TupleType tt = (TupleType) otherType;
         if (size() < tt.size())
             return false;
 

File: src/java/org/apache/cassandra/cql3/TypeCast.java
Patch:
@@ -48,7 +48,7 @@ private ColumnSpecification castedSpecOf(ColumnSpecification receiver)
 
     public boolean isAssignableTo(ColumnSpecification receiver)
     {
-        return receiver.type.asCQL3Type().equals(type);
+        return receiver.type.isValueCompatibleWith(type.getType());
     }
 
     @Override

File: src/java/org/apache/cassandra/cql3/functions/FunctionCall.java
Patch:
@@ -142,7 +142,7 @@ public boolean isAssignableTo(ColumnSpecification receiver)
             // is used as argument of another, existing, function. In that case, we return true here because we'll catch
             // the fact that the method is undefined latter anyway and with a more helpful error message that if we were
             // to return false here.
-            return returnType == null || receiver.type.asCQL3Type().equals(returnType.asCQL3Type());
+            return returnType == null || receiver.type.isValueCompatibleWith(returnType);
         }
 
         @Override

File: src/java/org/apache/cassandra/cql3/functions/Functions.java
Patch:
@@ -111,7 +111,7 @@ public static Function get(String name, List<? extends AssignementTestable> prov
 
     private static void validateTypes(Function fun, List<? extends AssignementTestable> providedArgs, ColumnSpecification receiver) throws InvalidRequestException
     {
-        if (!receiver.type.asCQL3Type().equals(fun.returnType().asCQL3Type()))
+        if (!receiver.type.isValueCompatibleWith(fun.returnType()))
             throw new InvalidRequestException(String.format("Type error: cannot assign result of function %s (type %s) to %s (type %s)", fun.name(), fun.returnType().asCQL3Type(), receiver, receiver.type.asCQL3Type()));
 
         if (providedArgs.size() != fun.argsType().size())
@@ -134,7 +134,7 @@ private static void validateTypes(Function fun, List<? extends AssignementTestab
 
     private static boolean isValidType(Function fun, List<? extends AssignementTestable> providedArgs, ColumnSpecification receiver)
     {
-        if (!receiver.type.asCQL3Type().equals(fun.returnType().asCQL3Type()))
+        if (!receiver.type.isValueCompatibleWith(fun.returnType()))
             return false;
 
         if (providedArgs.size() != fun.argsType().size())

File: src/java/org/apache/cassandra/cql3/statements/Selection.java
Patch:
@@ -369,7 +369,7 @@ public ByteBuffer compute(ResultSetBuilder rs)
 
         public boolean isAssignableTo(ColumnSpecification receiver)
         {
-            return type.asCQL3Type().equals(receiver.type.asCQL3Type());
+            return receiver.type.isValueCompatibleWith(type);
         }
 
         @Override
@@ -401,7 +401,7 @@ public ByteBuffer compute(ResultSetBuilder rs) throws InvalidRequestException
 
         public boolean isAssignableTo(ColumnSpecification receiver)
         {
-            return fun.returnType().asCQL3Type().equals(receiver.type.asCQL3Type());
+            return receiver.type.isValueCompatibleWith(fun.returnType());
         }
 
         @Override
@@ -446,7 +446,7 @@ public ByteBuffer compute(ResultSetBuilder rs)
 
         public boolean isAssignableTo(ColumnSpecification receiver)
         {
-            return receiver.type.asCQL3Type().equals(isWritetime ? CQL3Type.Native.BIGINT : CQL3Type.Native.INT);
+            return receiver.type.isValueCompatibleWith(isWritetime ? LongType.instance : Int32Type.instance);
         }
 
         @Override

File: src/java/org/apache/cassandra/db/marshal/BytesType.java
Patch:
@@ -66,7 +66,7 @@ public boolean isCompatibleWith(AbstractType<?> previous)
     }
 
     @Override
-    public boolean isValueCompatibleWith(AbstractType<?> previous)
+    public boolean isValueCompatibleWithInternal(AbstractType<?> otherType)
     {
         // BytesType can read anything
         return true;

File: src/java/org/apache/cassandra/db/marshal/TupleType.java
Patch:
@@ -234,13 +234,13 @@ public boolean isCompatibleWith(AbstractType<?> previous)
     }
 
     @Override
-    public boolean isValueCompatibleWith(AbstractType<?> previous)
+    public boolean isValueCompatibleWithInternal(AbstractType<?> otherType)
     {
-        if (!(previous instanceof TupleType))
+        if (!(otherType instanceof TupleType))
             return false;
 
         // Extending with new components is fine, removing is not
-        TupleType tt = (TupleType)previous;
+        TupleType tt = (TupleType) otherType;
         if (size() < tt.size())
             return false;
 

File: src/java/org/apache/cassandra/tools/NodeTool.java
Patch:
@@ -192,7 +192,7 @@ private static void printHistory(String... args)
             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss,SSS");
             writer.append(sdf.format(new Date())).append(": ").append(cmdLine).append(System.lineSeparator());
         }
-        catch (IOException ioe)
+        catch (IOException | IOError ioe)
         {
             //quietly ignore any errors about not being able to write out history
         }

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -1531,7 +1531,7 @@ private static void printHistory(String[] args, ToolCommandLine cmd)
             SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss,SSS");
             writer.append(sdf.format(new Date()) + ": " + cmdLine + "\n");
         }
-        catch (IOException ioe)
+        catch (IOException | IOError ioe)
         {
             //quietly ignore any errors about not being able to write out history
         }

File: src/java/org/apache/cassandra/metrics/KeyspaceMetrics.java
Patch:
@@ -106,7 +106,7 @@ public Long value()
                 return total;
             }
         });
-        memtableOffHeapDataSize = Metrics.newGauge(factory.createMetricName("MemtableiOffHeapDataSize"), new Gauge<Long>()
+        memtableOffHeapDataSize = Metrics.newGauge(factory.createMetricName("MemtableOffHeapDataSize"), new Gauge<Long>()
         {
             public Long value()
             {
@@ -229,12 +229,13 @@ public Long value()
      */
     public void release()
     {
-        Metrics.defaultRegistry().removeMetric(factory.createMetricName("AllMemtablesLiveDateSize"));
+        Metrics.defaultRegistry().removeMetric(factory.createMetricName("AllMemtablesLiveDataSize"));
         Metrics.defaultRegistry().removeMetric(factory.createMetricName("AllMemtablesOnHeapDataSize"));
         Metrics.defaultRegistry().removeMetric(factory.createMetricName("AllMemtablesOffHeapDataSize"));
         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableLiveDataSize"));
         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableOnHeapDataSize"));
         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableOffHeapDataSize"));
+        Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableColumnsCount"));
         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableSwitchCount"));
         Metrics.defaultRegistry().removeMetric(factory.createMetricName("PendingFlushes"));
         Metrics.defaultRegistry().removeMetric(factory.createMetricName("PendingCompactions"));

File: src/java/org/apache/cassandra/db/Keyspace.java
Patch:
@@ -64,8 +64,6 @@ public class Keyspace
 
     public final KeyspaceMetrics metric;
 
-    public final KeyspaceMetrics metric;
-
     // It is possible to call Keyspace.open without a running daemon, so it makes sense to ensure
     // proper directories here as well as in CassandraDaemon.
     static

File: src/java/org/apache/cassandra/db/Keyspace.java
Patch:
@@ -27,7 +27,6 @@
 
 import com.google.common.base.Function;
 import com.google.common.collect.Iterables;
-import org.apache.cassandra.metrics.KeyspaceMetrics;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -79,7 +78,7 @@ public class Keyspace
     /* ColumnFamilyStore per column family */
     private final ConcurrentMap<UUID, ColumnFamilyStore> columnFamilyStores = new ConcurrentHashMap<UUID, ColumnFamilyStore>();
     private volatile AbstractReplicationStrategy replicationStrategy;
-    public final KeyspaceMetrics metric;
+
     public static final Function<String,Keyspace> keyspaceTransformer = new Function<String, Keyspace>()
     {
         public Keyspace apply(String keyspaceName)
@@ -265,7 +264,6 @@ private Keyspace(String keyspaceName, boolean loadSSTables)
         metadata = Schema.instance.getKSMetaData(keyspaceName);
         assert metadata != null : "Unknown keyspace " + keyspaceName;
         createReplicationStrategy(metadata);
-        metric = new KeyspaceMetrics(this);
 
         for (CFMetaData cfm : new ArrayList<CFMetaData>(metadata.cfMetaData().values()))
         {

File: src/java/org/apache/cassandra/cql3/QueryProcessor.java
Patch:
@@ -316,8 +316,7 @@ public ResultMessage processBatch(BatchStatement batch, QueryState queryState, B
         batch.checkAccess(clientState);
         batch.validate(clientState);
 
-        batch.executeWithPerStatementVariables(options.getConsistency(), queryState, options.getValues());
-        return new ResultMessage.Void();
+        return batch.executeWithPerStatementVariables(options.getConsistency(), queryState, options.getValues());
     }
 
     public static ParsedStatement.Prepared getStatement(String queryStr, ClientState clientState)

File: src/java/org/apache/cassandra/transport/messages/BatchMessage.java
Patch:
@@ -162,6 +162,7 @@ public Message.Response execute(QueryState state)
 
             QueryHandler handler = state.getClientState().getCQLQueryHandler();
             List<ModificationStatement> statements = new ArrayList<ModificationStatement>(queryOrIdList.size());
+            boolean hasConditions = false;
             for (int i = 0; i < queryOrIdList.size(); i++)
             {
                 Object query = queryOrIdList.get(i);
@@ -186,6 +187,7 @@ public Message.Response execute(QueryState state)
                     throw new InvalidRequestException("Invalid statement in batch: only UPDATE, INSERT and DELETE statements are allowed.");
 
                 ModificationStatement mst = (ModificationStatement)statement;
+                hasConditions |= mst.hasConditions();
                 if (mst.isCounter())
                 {
                     if (type != BatchStatement.Type.COUNTER)
@@ -201,7 +203,7 @@ public Message.Response execute(QueryState state)
 
             // Note: It's ok at this point to pass a bogus value for the number of bound terms in the BatchState ctor
             // (and no value would be really correct, so we prefer passing a clearly wrong one).
-            BatchStatement batch = new BatchStatement(-1, type, statements, Attributes.none());
+            BatchStatement batch = new BatchStatement(-1, type, statements, Attributes.none(), hasConditions);
             Message.Response response = handler.processBatch(batch, state, new BatchQueryOptions(consistency, values, queryOrIdList));
 
             if (tracingId != null)

File: src/java/org/apache/cassandra/cql3/statements/CreateColumnFamilyStatement.java
Patch:
@@ -252,7 +252,7 @@ public ParsedStatement.Prepared prepare() throws RequestValidationException
 
                         AbstractType<?> type = getTypeAndRemove(stmt.columns, t);
                         if (type instanceof CounterColumnType)
-                            throw new InvalidRequestException(String.format("counter type is not supported for PRIMARY KEY part %s", t.key));
+                            throw new InvalidRequestException(String.format("counter type is not supported for PRIMARY KEY part %s", t));
                         types.add(type);
                     }
 

File: src/java/org/apache/cassandra/streaming/compress/CompressedStreamReader.java
Patch:
@@ -32,7 +32,6 @@
 import org.apache.cassandra.db.Keyspace;
 import org.apache.cassandra.io.compress.CompressionMetadata;
 import org.apache.cassandra.io.sstable.SSTableWriter;
-import org.apache.cassandra.service.ActiveRepairService;
 import org.apache.cassandra.streaming.ProgressInfo;
 import org.apache.cassandra.streaming.StreamReader;
 import org.apache.cassandra.streaming.StreamSession;
@@ -45,7 +44,7 @@
  */
 public class CompressedStreamReader extends StreamReader
 {
-    private static final Logger logger = LoggerFactory.getLogger(StreamReader.class);
+    private static final Logger logger = LoggerFactory.getLogger(CompressedStreamReader.class);
 
     protected final CompressionInfo compressionInfo;
 

File: src/java/org/apache/cassandra/db/CounterMutation.java
Patch:
@@ -96,7 +96,8 @@ public RowMutation makeReplicationMutation()
                 cf.retainAll(rowMutation.getColumnFamily(cf.metadata().cfId));
             replicationMutation.add(cf);
         }
-        return replicationMutation;
+
+        return replicationMutation.isEmpty() ? null : replicationMutation;
     }
 
     private void addReadCommandFromColumnFamily(String table, ByteBuffer key, ColumnFamily columnFamily, List<ReadCommand> commands)

File: src/java/org/apache/cassandra/service/FileCacheService.java
Patch:
@@ -77,7 +77,7 @@ public void onRemoval(RemovalNotification<String, Queue<RandomAccessReader>> not
             }
         };
 
-        cache = CacheBuilder.<String, Queue<RandomAccessReader>>newBuilder()
+        cache = CacheBuilder.newBuilder()
                 .expireAfterAccess(AFTER_ACCESS_EXPIRATION, TimeUnit.MILLISECONDS)
                 .concurrencyLevel(DatabaseDescriptor.getConcurrentReaders())
                 .removalListener(onRemove)

File: src/java/org/apache/cassandra/concurrent/AbstractTracingAwareExecutorService.java
Patch:
@@ -105,7 +105,7 @@ protected <T> FutureTask<T> newTaskFor(Callable<T> callable)
                 return (TraceSessionFutureTask<T>) callable;
             return new TraceSessionFutureTask<T>(callable, null);
         }
-        if (callable instanceof java.util.concurrent.FutureTask)
+        if (callable instanceof FutureTask)
             return (FutureTask<T>) callable;
         return new FutureTask<>(callable);
     }

File: src/java/org/apache/cassandra/streaming/StreamTransferTask.java
Patch:
@@ -99,11 +99,12 @@ public Collection<OutgoingFileMessage> getFileMessages()
         return new ArrayList<>(files.values());
     }
 
-    public OutgoingFileMessage createMessageForRetry(int sequenceNumber)
+    public synchronized OutgoingFileMessage createMessageForRetry(int sequenceNumber)
     {
         // remove previous time out task to be rescheduled later
         ScheduledFuture future = timeoutTasks.get(sequenceNumber);
-        future.cancel(false);
+        if (future != null)
+            future.cancel(false);
         return files.get(sequenceNumber);
     }
 

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -2983,7 +2983,8 @@ private List<Pair<Range<Token>, Long>> getSplits(List<Token> tokens, int splitCo
             int index = (int) Math.round(i * step);
             Token token = tokens.get(index);
             Range<Token> range = new Range<>(prevToken, token);
-            splits.add(Pair.create(range, cfs.estimatedKeysForRange(range)));
+            // always return an estimate > 0 (see CASSANDRA-7322)
+            splits.add(Pair.create(range, Math.max(cfs.metadata.getMinIndexInterval(), cfs.estimatedKeysForRange(range))));
             prevToken = token;
         }
         return splits;

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -75,8 +75,8 @@ public final class CFMetaData
 
     private static final Logger logger = LoggerFactory.getLogger(CFMetaData.class);
 
-    public final static double DEFAULT_READ_REPAIR_CHANCE = 0.1;
-    public final static double DEFAULT_DCLOCAL_READ_REPAIR_CHANCE = 0.0;
+    public final static double DEFAULT_READ_REPAIR_CHANCE = 0.0;
+    public final static double DEFAULT_DCLOCAL_READ_REPAIR_CHANCE = 0.1;
     public final static boolean DEFAULT_REPLICATE_ON_WRITE = true;
     public final static int DEFAULT_GC_GRACE_SECONDS = 864000;
     public final static int DEFAULT_MIN_COMPACTION_THRESHOLD = 4;

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -626,7 +626,7 @@ private List<ByteBuffer> buildBound(Bound bound,
                             throw new InvalidRequestException(String.format("Invalid null clustering key part %s", name));
                         ColumnNameBuilder copy = builder.copy().add(val);
                         // See below for why this
-                        s.add((b == Bound.END && copy.remainingCount() > 0) ? copy.buildAsEndOfRange() : copy.build());
+                        s.add((eocBound == Bound.END && copy.remainingCount() > 0) ? copy.buildAsEndOfRange() : copy.build());
                     }
                     return new ArrayList<ByteBuffer>(s);
                 }
@@ -652,7 +652,7 @@ private List<ByteBuffer> buildBound(Bound bound,
         // with 2ndary index is done, and with the the partition provided with an EQ, we'll end up here, and in that
         // case using the eoc would be bad, since for the random partitioner we have no guarantee that
         // builder.buildAsEndOfRange() will sort after builder.build() (see #5240).
-        return Collections.singletonList((bound == Bound.END && builder.remainingCount() > 0) ? builder.buildAsEndOfRange() : builder.build());
+        return Collections.singletonList((eocBound == Bound.END && builder.remainingCount() > 0) ? builder.buildAsEndOfRange() : builder.build());
     }
 
     private List<ByteBuffer> getRequestedBound(Bound b, List<ByteBuffer> variables) throws InvalidRequestException

File: src/java/org/apache/cassandra/cql3/statements/DropTypeStatement.java
Patch:
@@ -97,7 +97,7 @@ private boolean isUsedBy(AbstractType<?> toCheck) throws RequestValidationExcept
             if (name.getKeyspace().equals(ut.keyspace) && name.getUserTypeName().equals(ut.name))
                 return true;
 
-            for (AbstractType<?> subtype : ut.fieldTypes)
+            for (AbstractType<?> subtype : ut.fieldTypes())
                 if (isUsedBy(subtype))
                     return true;
         }

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -739,7 +739,7 @@ private void joinTokenRing(int delay) throws ConfigurationException
                         if (existing != null)
                         {
                             if (Gossiper.instance.getEndpointStateForEndpoint(existing).getUpdateTimestamp() > (System.currentTimeMillis() - delay))
-                                throw new UnsupportedOperationException("Cannnot replace a live node... ");
+                                throw new UnsupportedOperationException("Cannot replace a live node... ");
                             current.add(existing);
                         }
                         else

File: src/java/org/apache/cassandra/db/BatchlogManager.java
Patch:
@@ -99,7 +99,8 @@ public void runMayThrow() throws ExecutionException, InterruptedException
 
     public int countAllBatches()
     {
-        return (int) executeInternal("SELECT count(*) FROM %s.%s", Keyspace.SYSTEM_KS, SystemKeyspace.BATCHLOG_CF).one().getLong("count");
+        String query = String.format("SELECT count(*) FROM %s.%s", Keyspace.SYSTEM_KS, SystemKeyspace.BATCHLOG_CF);
+        return (int) executeInternal(query).one().getLong("count");
     }
 
     public long getTotalBatchesReplayed()

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -1549,7 +1549,7 @@ private Restriction getExistingRestriction(SelectStatement stmt, ColumnDefinitio
                     return stmt.columnRestrictions[def.position()];
                 case REGULAR:
                 case STATIC:
-                    return stmt.metadataRestrictions.get(def);
+                    return stmt.metadataRestrictions.get(def.name);
                 default:
                     throw new AssertionError();
             }

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -223,9 +223,8 @@ public ResultMessage.Rows execute(QueryState state, QueryOptions options) throws
 
             List<Row> page = pager.fetchPage(pageSize);
             ResultMessage.Rows msg = processResults(page, options, limit, now);
-            if (!pager.isExhausted())
-                msg.result.metadata.setHasMorePages(pager.state());
-            return msg;
+
+            return pager.isExhausted() ? msg : msg.withPagingState(pager.state());
         }
     }
 

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -223,9 +223,8 @@ public ResultMessage.Rows execute(QueryState state, QueryOptions options) throws
 
             List<Row> page = pager.fetchPage(pageSize);
             ResultMessage.Rows msg = processResults(page, options, limit, now);
-            if (!pager.isExhausted())
-                msg.result.metadata.setHasMorePages(pager.state());
-            return msg;
+
+            return pager.isExhausted() ? msg : msg.withPagingState(pager.state());
         }
     }
 

File: src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
Patch:
@@ -459,11 +459,12 @@ public Pair<Descriptor, StatsMetadata> close()
 
     private Pair<Descriptor, StatsMetadata> close(long repairedAt)
     {
-        dataFile.writeFullChecksum(descriptor);
+
         // index and filter
         iwriter.close();
         // main data, close will truncate if necessary
         dataFile.close();
+        dataFile.writeFullChecksum(descriptor);
         // write sstable statistics
         Map<MetadataType, MetadataComponent> metadataComponents = sstableMetadataCollector.finalizeMetadata(
                                                                                     partitioner.getClass().getCanonicalName(),

File: src/java/org/apache/cassandra/db/HintedHandOffManager.java
Patch:
@@ -264,7 +264,7 @@ private static boolean pagingFinished(ColumnFamily hintColumnFamily, Composite s
     {
         // done if no hints found or the start column (same as last column processed in previous iteration) is the only one
         return hintColumnFamily == null
-               || (hintColumnFamily.getSortedColumns().size() == 1 && hintColumnFamily.getColumn((CellName)startColumn) != null);
+               || (!startColumn.isEmpty() && hintColumnFamily.getSortedColumns().size() == 1 && hintColumnFamily.getColumn((CellName)startColumn) != null);
     }
 
     private int waitForSchemaAgreement(InetAddress endpoint) throws TimeoutException

File: src/java/org/apache/cassandra/db/AbstractNativeCell.java
Patch:
@@ -18,6 +18,7 @@
 package org.apache.cassandra.db;
 
 import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
 import java.security.MessageDigest;
 
 import org.apache.cassandra.config.CFMetaData;
@@ -183,7 +184,7 @@ protected int postfixSize()
     public ByteBuffer value()
     {
         long offset = valueStartOffset();
-        return getByteBuffer(offset, (int) (internalSize() - (postfixSize() + offset)));
+        return getByteBuffer(offset, (int) (internalSize() - (postfixSize() + offset))).order(ByteOrder.BIG_ENDIAN);
     }
 
     private int clusteringSizeDelta()
@@ -291,7 +292,7 @@ public ByteBuffer get(int i)
         int cellNamesOffset = nameDeltaOffset(size);
         int startDelta = i == 0 ? 0 : getShort(nameDeltaOffset(i));
         int endDelta = i < size - 1 ? getShort(nameDeltaOffset(i + 1)) : valueStartOffset() - cellNamesOffset;
-        return getByteBuffer(cellNamesOffset + startDelta, endDelta - startDelta);
+        return getByteBuffer(cellNamesOffset + startDelta, endDelta - startDelta).order(ByteOrder.BIG_ENDIAN);
     }
 
     private static final ThreadLocal<byte[]> BUFFER = new ThreadLocal<byte[]>()

File: test/unit/org/apache/cassandra/cli/CliTest.java
Patch:
@@ -253,8 +253,8 @@ public void testCli() throws IOException, TException, TimedOutException, NotFoun
             // System.out.println("Result:\n" + result);
             if (statement.startsWith("show schema"))
                 assertEquals(errStream.toString() + "processing" + statement,
-                             "\nWARNING: CQL3 tables are intentionally omitted from 'show schema' output.\n"
-                             + "See https://issues.apache.org/jira/browse/CASSANDRA-4377 for details.\n\n",
+                             "\nWARNING: CQL3 tables are intentionally omitted from 'show schema' output." + String.format("%n")
+                             + "See https://issues.apache.org/jira/browse/CASSANDRA-4377 for details.\n" + String.format("%n"),
                              errStream.toString());
             else
                 assertEquals(errStream.toString() + " processing " + statement, "", errStream.toString());

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -132,7 +132,7 @@ public class Config
     public Integer column_index_size_in_kb = 64;
     public Integer batch_size_warn_threshold_in_kb = 5;
     public Integer in_memory_compaction_limit_in_mb = 64;
-    public Integer concurrent_compactors = FBUtilities.getAvailableProcessors();
+    public Integer concurrent_compactors;
     public volatile Integer compaction_throughput_mb_per_sec = 16;
 
     public Integer max_streaming_retries = 3;

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -453,7 +453,7 @@ public int compare(InetAddress endpoint1, InetAddress endpoint2)
         }
 
         if (conf.concurrent_compactors == null)
-            conf.concurrent_compactors = FBUtilities.getAvailableProcessors();
+            conf.concurrent_compactors = Math.min(8, Math.max(2, Math.min(FBUtilities.getAvailableProcessors(), conf.data_file_directories.length)));
 
         if (conf.concurrent_compactors <= 0)
             throw new ConfigurationException("concurrent_compactors should be strictly greater than 0");

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -373,6 +373,7 @@ public void invalidate()
         indexManager.invalidate();
 
         CacheService.instance.invalidateRowCacheForCf(metadata.cfId);
+        CacheService.instance.invalidateKeyCacheForCf(metadata.cfId);
     }
 
     /**

File: test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
Patch:
@@ -22,9 +22,11 @@
 import java.util.Date;
 import java.util.concurrent.TimeUnit;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.Util;
 import org.junit.Assert;
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.db.commitlog.CommitLog;
@@ -34,6 +36,7 @@
 import static org.apache.cassandra.db.KeyspaceTest.assertColumns;
 import static org.apache.cassandra.Util.cellname;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class RecoveryManagerTest extends SchemaLoader
 {
     @Test

File: test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
Patch:
@@ -23,9 +23,11 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.Util;
 import org.junit.Assert;
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.db.commitlog.CommitLog;
@@ -35,6 +37,7 @@
 import static org.apache.cassandra.Util.column;
 import static org.apache.cassandra.db.KeyspaceTest.assertColumns;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class RecoveryManagerTest extends SchemaLoader
 {
     @Test

File: test/unit/org/apache/cassandra/db/DirectoriesTest.java
Patch:
@@ -199,7 +199,8 @@ public void testDiskFailurePolicy_best_effort()
                 dd.location.setWritable(false);
             }
 
-            CFMetaData cfm = new CFMetaData(KS, "bad", ColumnFamilyType.Standard, null);
+            // nested folders in /tmp is enough to fail on *nix but we need to pass the 255 char limit to get a failure on Windows and blacklist
+            CFMetaData cfm = new CFMetaData(KS, "badbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbadbad", ColumnFamilyType.Standard, null);
             Directories dir = new Directories(cfm);
 
             for (File file : dir.getCFDirectories())

File: test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
Patch:
@@ -994,7 +994,7 @@ public void testSliceByNamesCommandOnUUIDTypeSCF() throws Throwable
     }
 
     @Test
-    public void testSliceByNamesCommandOldMetatada() throws Throwable
+    public void testSliceByNamesCommandOldMetadata() throws Throwable
     {
         String keyspaceName = "Keyspace1";
         String cfName= "Standard1";
@@ -1025,6 +1025,8 @@ public void testSliceByNamesCommandOldMetatada() throws Throwable
         ColumnFamily cf = cmd.getRow(keyspace).cf;
         Cell cell = cf.getColumn(cname);
         assert cell.value().equals(ByteBufferUtil.bytes("a")) : "expecting a, got " + ByteBufferUtil.string(cell.value());
+
+        Keyspace.clear("Keyspace1"); // CASSANDRA-7195
     }
 
     private static void assertTotalColCount(Collection<Row> rows, int expectedCount)

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -599,7 +599,9 @@ private static ResultSet buildCasFailureResultSet(ByteBuffer key, ColumnFamily c
         }
         else
         {
-            List<ColumnDefinition> defs = new ArrayList<>();
+            // We can have multiple conditions on the same columns (for collections) so use a set
+            // to avoid duplicate, but preserve the order just to it follows the order of IF in the query in general
+            Set<ColumnDefinition> defs = new LinkedHashSet<>();
             // Adding the partition key for batches to disambiguate if the conditions span multipe rows (we don't add them outside
             // of batches for compatibility sakes).
             if (isBatch)

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -649,7 +649,9 @@ private static ResultSet buildCasFailureResultSet(ByteBuffer key, ColumnFamily c
         }
         else
         {
-            List<CFDefinition.Name> names = new ArrayList<CFDefinition.Name>();
+            // We can have multiple conditions on the same columns (for collections) so use a set
+            // to avoid duplicate, but preserve the order just to it follows the order of IF in the query in general
+            Set<CFDefinition.Name> names = new LinkedHashSet<CFDefinition.Name>();
             // Adding the partition key for batches to disambiguate if the conditions span multipe rows (we don't add them outside
             // of batches for compatibility sakes).
             if (isBatch)

File: src/java/org/apache/cassandra/cql3/statements/CreateTypeStatement.java
Patch:
@@ -50,9 +50,6 @@ public void prepareKeyspace(ClientState state) throws InvalidRequestException
     {
         if (!name.hasKeyspace())
             name.setKeyspace(state.getKeyspace());
-
-        if (name.getKeyspace() == null)
-            throw new InvalidRequestException("You need to be logged in a keyspace or use a fully qualified user type name");
     }
 
     public void addDefinition(ColumnIdentifier name, CQL3Type.Raw type)

File: src/java/org/apache/cassandra/cql3/statements/DropTypeStatement.java
Patch:
@@ -43,9 +43,6 @@ public void prepareKeyspace(ClientState state) throws InvalidRequestException
     {
         if (!name.hasKeyspace())
             name.setKeyspace(state.getKeyspace());
-
-        if (name.getKeyspace() == null)
-            throw new InvalidRequestException("You need to be logged in a keyspace or use a fully qualified user type name");
     }
 
     public void checkAccess(ClientState state) throws UnauthorizedException, InvalidRequestException

File: examples/triggers/src/org/apache/cassandra/triggers/InvertedIndex.java
Patch:
@@ -42,7 +42,7 @@ public Collection<Mutation> augment(ByteBuffer key, ColumnFamily update)
         List<Mutation> mutations = new ArrayList<>(update.getColumnCount());
 
         String indexKeySpace = properties.getProperty("keyspace");
-        String indexColumnFamily = properties.getProperty("columnfamily")
+        String indexColumnFamily = properties.getProperty("columnfamily");
         for (Cell cell : update)
         {
             // Skip the row marker and other empty values, since they lead to an empty key.

File: src/java/org/apache/cassandra/db/composites/AbstractSimpleCellNameType.java
Patch:
@@ -64,7 +64,7 @@ public int compare(Composite c1, Composite c2)
         boolean c1isEmpty = c1.isEmpty();
         boolean c2isEmpty = c2.isEmpty();
         if (c1isEmpty || c2isEmpty)
-            return c1isEmpty ? 1 : (c2isEmpty ? -1 : 0);
+            return !c1isEmpty ? 1 : (!c2isEmpty ? -1 : 0);
 
         return type.compare(c1.get(0), c2.get(0));
     }

File: src/java/org/apache/cassandra/db/composites/SimpleCType.java
Patch:
@@ -58,14 +58,14 @@ public int compare(Composite c1, Composite c2)
             ByteBuffer b1 = c1.toByteBuffer();
             ByteBuffer b2 = c2.toByteBuffer();
             if (!b1.hasRemaining() || !b2.hasRemaining())
-
+                return b1.hasRemaining() ? 1 : (b2.hasRemaining() ? -1 : 0);
             return ByteBufferUtil.compareUnsigned(b1, b2);
         }
 
         boolean c1isEmpty = c1.isEmpty();
         boolean c2isEmpty = c2.isEmpty();
         if (c1isEmpty || c2isEmpty)
-            return c1isEmpty ? 1 : (c2isEmpty ? -1 : 0);
+            return !c1isEmpty ? 1 : (!c2isEmpty ? -1 : 0);
 
         return type.compare(c1.get(0), c2.get(0));
     }

File: src/java/org/apache/cassandra/transport/FrameCompressor.java
Patch:
@@ -109,9 +109,6 @@ public Frame decompress(Frame frame) throws IOException
             {
                 int size = Snappy.uncompress(input, 0, input.length, output.array(), output.arrayOffset());
                 output.writerIndex(size);
-
-                //release the old frame
-                frame.release();
             }
             catch (final Throwable e)
             {

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
Patch:
@@ -316,7 +316,7 @@ synchronized void sync()
             if (nextMarker < buffer.capacity())
             {
                 buffer.putInt(nextMarker, 0);
-                buffer.putLong(nextMarker + 4, 0);
+                buffer.putInt(nextMarker + 4, 0);
             }
 
             // actually perform the sync and signal those waiting for it

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
Patch:
@@ -74,7 +74,7 @@ public class CommitLogSegment
     }
 
     // The commit log entry overhead in bytes (int: length + int: head checksum + int: tail checksum)
-    static final int ENTRY_OVERHEAD_SIZE = 4 + 4 + 4;
+    public static final int ENTRY_OVERHEAD_SIZE = 4 + 4 + 4;
 
     // The commit log (chained) sync marker/header size in bytes (int: length + int: checksum [segmentId, position])
     static final int SYNC_MARKER_SIZE = 4 + 4;

File: test/unit/org/apache/cassandra/db/CommitLogTest.java
Patch:
@@ -34,6 +34,7 @@
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.commitlog.CommitLog;
 import org.apache.cassandra.db.commitlog.CommitLogDescriptor;
+import org.apache.cassandra.db.commitlog.CommitLogSegment;
 import org.apache.cassandra.db.composites.CellName;
 import org.apache.cassandra.net.MessagingService;
 
@@ -174,7 +175,7 @@ private static int getMaxRecordDataSize(String keyspace, ByteBuffer key, String
         rm.add("Standard1", Util.cellname("c1"), ByteBuffer.allocate(0), 0);
 
         int max = (DatabaseDescriptor.getCommitLogSegmentSize() / 2);
-        max -= (4 + 8 + 8); // log entry overhead
+        max -= CommitLogSegment.ENTRY_OVERHEAD_SIZE; // log entry overhead
         return max - (int) Mutation.serializer.serializedSize(rm, MessagingService.current_version);
     }
 

File: src/java/org/apache/cassandra/db/marshal/AbstractType.java
Patch:
@@ -153,8 +153,7 @@ public String getString(ByteBuffer bytes)
         TypeSerializer<T> serializer = getSerializer();
         serializer.validate(bytes);
 
-        T value = serializer.deserialize(bytes);
-        return value == null ? "null" : serializer.toString(value);
+        return serializer.toString(serializer.deserialize(bytes));
     }
 
     /** get a byte representation of the given string. */

File: src/java/org/apache/cassandra/serializers/InetAddressSerializer.java
Patch:
@@ -65,7 +65,7 @@ public void validate(ByteBuffer bytes) throws MarshalException
 
     public String toString(InetAddress value)
     {
-        return value.getHostAddress();
+        return value == null ? "" : value.getHostAddress();
     }
 
     public Class<InetAddress> getType()

File: src/java/org/apache/cassandra/serializers/IntegerSerializer.java
Patch:
@@ -29,12 +29,12 @@ public class IntegerSerializer implements TypeSerializer<BigInteger>
 
     public BigInteger deserialize(ByteBuffer bytes)
     {
-        return new BigInteger(ByteBufferUtil.getArray(bytes));
+        return bytes.hasRemaining() ? new BigInteger(ByteBufferUtil.getArray(bytes)) : null;
     }
 
     public ByteBuffer serialize(BigInteger value)
     {
-        return ByteBuffer.wrap(value.toByteArray());
+        return value == null ? ByteBufferUtil.EMPTY_BYTE_BUFFER : ByteBuffer.wrap(value.toByteArray());
     }
 
     public void validate(ByteBuffer bytes) throws MarshalException
@@ -44,7 +44,7 @@ public void validate(ByteBuffer bytes) throws MarshalException
 
     public String toString(BigInteger value)
     {
-        return value.toString(10);
+        return value == null ? "" : value.toString(10);
     }
 
     public Class<BigInteger> getType()

File: src/java/org/apache/cassandra/serializers/LongSerializer.java
Patch:
@@ -44,7 +44,7 @@ public void validate(ByteBuffer bytes) throws MarshalException
 
     public String toString(Long value)
     {
-        return String.valueOf(value);
+        return value == null ? "" : String.valueOf(value);
     }
 
     public Class<Long> getType()

File: src/java/org/apache/cassandra/serializers/TimestampSerializer.java
Patch:
@@ -72,7 +72,7 @@ public void validate(ByteBuffer bytes) throws MarshalException
 
     public String toString(Date value)
     {
-        return FORMATTER.get().format(value);
+        return value == null ? "" : FORMATTER.get().format(value);
     }
 
     public Class<Date> getType()

File: src/java/org/apache/cassandra/serializers/UUIDSerializer.java
Patch:
@@ -46,7 +46,7 @@ public void validate(ByteBuffer bytes) throws MarshalException
 
     public String toString(UUID value)
     {
-        return value.toString();
+        return value == null ? "" : value.toString();
     }
 
     public Class<UUID> getType()

File: src/java/org/apache/cassandra/serializers/CollectionSerializer.java
Patch:
@@ -73,7 +73,7 @@ protected static void writeCollectionSize(ByteBuffer output, int elements, int v
             output.putShort((short)elements);
     }
 
-    protected static int readCollectionSize(ByteBuffer input, int version)
+    public static int readCollectionSize(ByteBuffer input, int version)
     {
         return version >= 3 ? input.getInt() : ByteBufferUtil.readShortLength(input);
     }
@@ -104,7 +104,7 @@ protected static void writeValue(ByteBuffer output, ByteBuffer value, int versio
         }
     }
 
-    protected static ByteBuffer readValue(ByteBuffer input, int version)
+    public static ByteBuffer readValue(ByteBuffer input, int version)
     {
         if (version >= 3)
         {

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
Patch:
@@ -469,7 +469,7 @@ private void removeCleanFromDirty()
             UUID cfId = clean.getKey();
             AtomicInteger cleanPos = clean.getValue();
             AtomicInteger dirtyPos = cfDirty.get(cfId);
-            if (dirtyPos != null && dirtyPos.intValue() < cleanPos.intValue())
+            if (dirtyPos != null && dirtyPos.intValue() <= cleanPos.intValue())
             {
                 cfDirty.remove(cfId);
                 iter.remove();
@@ -482,9 +482,9 @@ private void removeCleanFromDirty()
      */
     public synchronized Collection<UUID> getDirtyCFIDs()
     {
-        removeCleanFromDirty();
         if (cfClean.isEmpty() || cfDirty.isEmpty())
             return cfDirty.keySet();
+
         List<UUID> r = new ArrayList<>(cfDirty.size());
         for (Map.Entry<UUID, AtomicInteger> dirty : cfDirty.entrySet())
         {

File: src/java/org/apache/cassandra/streaming/StreamCoordinator.java
Patch:
@@ -223,7 +223,7 @@ public StreamSession getOrCreateNextSession(InetAddress peer)
             // get
             else
             {
-                if (lastReturned == streamSessions.size() - 1)
+                if (lastReturned >= streamSessions.size() - 1)
                     lastReturned = 0;
 
                 return streamSessions.get(lastReturned++);

File: src/java/org/apache/cassandra/locator/SnitchProperties.java
Patch:
@@ -50,7 +50,7 @@ public class SnitchProperties
         catch (Exception e)
         {
             // do not throw exception here, just consider this an incomplete or an empty property file.
-            logger.warn("Unable to read " + RACKDC_PROPERTY_FILENAME);
+            logger.warn("Unable to read {}", ((configURL != null) ? configURL : RACKDC_PROPERTY_FILENAME));
         }
         finally
         {

File: test/unit/org/apache/cassandra/config/ColumnDefinitionTest.java
Patch:
@@ -45,7 +45,7 @@ public void testSerializeDeserialize() throws Exception
 
     protected void testSerializeDeserialize(CFMetaData cfm, ColumnDefinition cd) throws Exception
     {
-        ColumnDefinition newCd = ColumnDefinition.fromThrift(cfm, cd.toThrift());
+        ColumnDefinition newCd = ColumnDefinition.fromThrift(cfm.ksName, cfm.cfName, cfm.comparator.asAbstractType(), null, cd.toThrift());
         Assert.assertNotSame(cd, newCd);
         Assert.assertEquals(cd.hashCode(), newCd.hashCode());
         Assert.assertEquals(cd, newCd);

File: src/java/org/apache/cassandra/utils/SimpleCondition.java
Patch:
@@ -44,7 +44,7 @@ public synchronized boolean await(long time, TimeUnit unit) throws InterruptedEx
         // micro/nanoseconds not supported
         assert unit == TimeUnit.DAYS || unit == TimeUnit.HOURS || unit == TimeUnit.MINUTES || unit == TimeUnit.SECONDS || unit == TimeUnit.MILLISECONDS;
 
-        long end = System.currentTimeMillis() + unit.convert(time, TimeUnit.MILLISECONDS);
+        long end = System.currentTimeMillis() + TimeUnit.MILLISECONDS.convert(time, unit);
         while (!set && end > System.currentTimeMillis())
         {
             TimeUnit.MILLISECONDS.timedWait(this, end - System.currentTimeMillis());

File: src/java/org/apache/cassandra/locator/YamlFileNetworkTopologySnitch.java
Patch:
@@ -273,7 +273,7 @@ private synchronized void loadTopologyConfiguration()
 
                 for (final Node node : rack.nodes)
                 {
-                    if (rack.rack_name == null)
+                    if (node.broadcast_address == null)
                     {
                         throw new ConfigurationException(
                                 String.format(

File: src/java/org/apache/cassandra/cql3/Term.java
Patch:
@@ -44,7 +44,7 @@ public interface Term
      * Bind the values in this term to the values contained in {@code values}.
      * This is obviously a no-op if the term is Terminal.
      *
-     * @param values the values to bind markers to.
+     * @param options the values to bind markers to.
      * @return the result of binding all the variables of this NonTerminal (or
      * 'this' if the term is terminal).
      */

File: src/java/org/apache/cassandra/hadoop/cql3/CqlOutputFormat.java
Patch:
@@ -37,7 +37,7 @@
  * As is the case with the {@link org.apache.cassandra.hadoop.ColumnFamilyInputFormat}, 
  * you need to set the prepared statement in your
  * Hadoop job Configuration. The {@link CqlConfigHelper} class, through its
- * {@link ConfigHelper#setOutputPreparedStatement} method, is provided to make this
+ * {@link CqlConfigHelper#setOutputCql} method, is provided to make this
  * simple.
  * you need to set the Keyspace. The {@link ConfigHelper} class, through its
  * {@link ConfigHelper#setOutputColumnFamily} method, is provided to make this

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1537,7 +1537,7 @@ else if (endpoint.equals(currentOwner))
                 // set state back to normal, since the node may have tried to leave, but failed and is now back up
                 tokensToUpdateInMetadata.add(token);
                 if (!isClientMode)
-                    tokensToUpdateInSystemKeyspace.add(token);
+                    tokensToUpdateInSystemTable.add(token);
             }
             else if (tokenMetadata.isRelocating(token) && tokenMetadata.getRelocatingRanges().get(token).equals(endpoint))
             {

File: test/unit/org/apache/cassandra/locator/GoogleCloudSnitchTest.java
Patch:
@@ -52,7 +52,6 @@ public static void setup() throws Exception
     {
         SchemaLoader.mkdirs();
         SchemaLoader.cleanup();
-        Keyspace.setInitialized();
         StorageService.instance.initServer(0);
     }
 

File: src/java/org/apache/cassandra/cql3/QueryOptions.java
Patch:
@@ -58,7 +58,7 @@ public static QueryOptions fromProtocolV2(ConsistencyLevel consistency, List<Byt
 
     public static QueryOptions forInternalCalls(ConsistencyLevel consistency, List<ByteBuffer> values)
     {
-        return new DefaultQueryOptions(consistency, values, false, SpecificOptions.DEFAULT, 0);
+        return new DefaultQueryOptions(consistency, values, false, SpecificOptions.DEFAULT, 3);
     }
 
     public static QueryOptions fromPreV3Batch(ConsistencyLevel consistency)
@@ -123,8 +123,6 @@ static class DefaultQueryOptions extends QueryOptions
 
         private final SpecificOptions options;
 
-        // The protocol version of incoming queries. This is set during deserializaion and will be 0
-        // if the QueryOptions does not come from a user message (or come from thrift).
         private final transient int protocolVersion;
 
         DefaultQueryOptions(ConsistencyLevel consistency, List<ByteBuffer> values, boolean skipMetadata, SpecificOptions options, int protocolVersion)

File: tools/stress/src/org/apache/cassandra/stress/settings/GroupedOptions.java
Patch:
@@ -85,7 +85,7 @@ public static void printOptions(PrintStream out, String command, GroupedOptions.
             }
             firstRow = false;
 
-            StringBuilder sb = new StringBuilder("Usage: " + command);
+            StringBuilder sb = new StringBuilder("Usage: ").append(command);
             for (Option option : grouping.options())
             {
                 sb.append(" ");

File: tools/stress/src/org/apache/cassandra/stress/settings/Legacy.java
Patch:
@@ -216,12 +216,12 @@ else if (cmd.hasOption("r"))
             {
                 StringBuilder rep = new StringBuilder();
                 if (cmd.hasOption("R"))
-                    rep.append("strategy=" + cmd.getOptionValue("R"));
+                    rep.append("strategy=").append(cmd.getOptionValue("R"));
                 if (cmd.hasOption("l"))
                 {
                     if (rep.length() > 0)
                         rep.append(",");
-                    rep.append("factor=" + cmd.getOptionValue("l"));
+                    rep.append("factor=").append(cmd.getOptionValue("l"));
                 }
                 if (cmd.hasOption("O"))
                 {

File: src/java/org/apache/cassandra/utils/PureJavaCrc32.java
Patch:
@@ -122,6 +122,7 @@ else if (len < 16)
                 ByteBufferUtil.arrayCopy(b, off, buf, 0, l);
                 update(buf, 0, l);
                 len -= l;
+                off += l;
             }
         }
     }

File: src/java/org/apache/cassandra/cql3/Constants.java
Patch:
@@ -125,7 +125,7 @@ public static Literal hex(String text)
         public Value prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
         {
             if (!isAssignableTo(keyspace, receiver))
-                throw new InvalidRequestException(String.format("Invalid %s constant (%s) for %s of type %s", type, text, receiver, receiver.type.asCQL3Type()));
+                throw new InvalidRequestException(String.format("Invalid %s constant (%s) for \"%s\" of type %s", type, text, receiver.name, receiver.type.asCQL3Type()));
 
             return new Value(parsedValue(receiver.type));
         }

File: src/java/org/apache/cassandra/service/AbstractRowResolver.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.List;
 import java.util.concurrent.ConcurrentLinkedQueue;
 
 import org.slf4j.Logger;
@@ -37,7 +38,7 @@ public abstract class AbstractRowResolver implements IResponseResolver<ReadRespo
 
     protected final String keyspaceName;
     // synchronizedList gives us thread-safety without the overhead of guaranteeing uniqueness like a Set would
-    protected final Collection<MessageIn<ReadResponse>> replies = Collections.synchronizedList(new ArrayList<MessageIn<ReadResponse>>());
+    protected final List<MessageIn<ReadResponse>> replies = Collections.synchronizedList(new ArrayList<MessageIn<ReadResponse>>());
     protected final DecoratedKey key;
 
     public AbstractRowResolver(ByteBuffer key, String keyspaceName)

File: src/java/org/apache/cassandra/db/NativeCounterCell.java
Patch:
@@ -180,7 +180,7 @@ public long unsharedHeapSize()
 
     public boolean equals(Cell cell)
     {
-        return cell instanceof CounterCell && equals((CounterCell) this);
+        return cell instanceof CounterCell && equals((CounterCell) cell);
     }
 
     public boolean equals(CounterCell cell)

File: src/java/org/apache/cassandra/db/NativeExpiringCell.java
Patch:
@@ -130,7 +130,7 @@ public void updateDigest(MessageDigest digest)
 
     public boolean equals(Cell cell)
     {
-        return cell instanceof ExpiringCell && equals((ExpiringCell) this);
+        return cell instanceof ExpiringCell && equals((ExpiringCell) cell);
     }
 
     protected boolean equals(ExpiringCell cell)

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -619,14 +619,15 @@ private static void syncWriteToBatchlog(Collection<Mutation> mutations, Collecti
             }
             else if (targetVersion == MessagingService.current_version)
             {
-                MessagingService.instance().sendRR(message, target, handler);
+                MessagingService.instance().sendRR(message, target, handler, false);
             }
             else
             {
                 MessagingService.instance().sendRR(BatchlogManager.getBatchlogMutationFor(mutations, uuid, targetVersion)
                                                                   .createMessage(),
                                                    target,
-                                                   handler);
+                                                   handler,
+                                                   false);
             }
         }
 

File: test/unit/org/apache/cassandra/db/ScrubTest.java
Patch:
@@ -187,7 +187,7 @@ public void testScrubOutOfOrder() throws Exception
          * The test also assumes an ordered partitioner.
          *
         ColumnFamily cf = ArrayBackedSortedColumns.factory.create(cfs.metadata);
-        cf.addColumn(new Cell(ByteBufferUtil.bytes("someName"), ByteBufferUtil.bytes("someValue"), 0L));
+        cf.addColumn(new BufferCell(ByteBufferUtil.bytes("someName"), ByteBufferUtil.bytes("someValue"), 0L));
 
         SSTableWriter writer = new SSTableWriter(cfs.getTempSSTablePath(new File(System.getProperty("corrupt-sstable-root"))),
                                                  cfs.metadata.getIndexInterval(),

File: test/unit/org/apache/cassandra/db/ArrayBackedSortedColumnsTest.java
Patch:
@@ -223,7 +223,7 @@ public void testSearchIterator()
         int[] values = new int[]{ 1, 2, 3, 5, 9, 15, 21, 22 };
 
         for (int i = 0; i < values.length; ++i)
-            map.addColumn(new Cell(type.makeCellName(values[i])));
+            map.addColumn(new BufferCell(type.makeCellName(values[i])));
 
         SearchIterator<CellName, Cell> iter = map.searchIterator();
         for (int i = 0 ; i < values.length ; i++)

File: src/java/org/apache/cassandra/cql3/statements/CreateTriggerStatement.java
Patch:
@@ -49,7 +49,7 @@ public CreateTriggerStatement(CFName name, String triggerName, String clazz)
 
     public void checkAccess(ClientState state) throws UnauthorizedException
     {
-        state.ensureIsSuper("Only superusers are allowed to perfrom CREATE TRIGGER queries");
+        state.ensureIsSuper("Only superusers are allowed to perform CREATE TRIGGER queries");
     }
 
     public void validate(ClientState state) throws RequestValidationException

File: src/java/org/apache/cassandra/gms/FailureDetector.java
Patch:
@@ -43,12 +43,12 @@
  */
 public class FailureDetector implements IFailureDetector, FailureDetectorMBean
 {
+    private static final Logger logger = LoggerFactory.getLogger(FailureDetector.class);
     public static final String MBEAN_NAME = "org.apache.cassandra.net:type=FailureDetector";
     private static final int SAMPLE_SIZE = 1000;
     protected static final int INITIAL_VALUE = getInitialValue();
 
     public static final IFailureDetector instance = new FailureDetector();
-    private static final Logger logger = LoggerFactory.getLogger(FailureDetector.class);
 
     // this is useless except to provide backwards compatibility in phi_convict_threshold,
     // because everyone seems pretty accustomed to the default of 8, and users who have

File: src/java/org/apache/cassandra/cache/RefCountedMemory.java
Patch:
@@ -23,6 +23,7 @@
 
 public class RefCountedMemory extends Memory implements AutoCloseable
 {
+    private volatile int references = 1;
     private static final AtomicIntegerFieldUpdater<RefCountedMemory> UPDATER = AtomicIntegerFieldUpdater.newUpdater(RefCountedMemory.class, "references");
 
     public RefCountedMemory(long size)

File: test/unit/org/apache/cassandra/db/KeyCacheTest.java
Patch:
@@ -162,6 +162,8 @@ public void testKeyCache() throws ExecutionException, InterruptedException
         for (SSTableReader reader : readers)
             reader.releaseReference();
 
+        while (StorageService.tasks.getActiveCount() > 0);
+
         // after releasing the reference this should drop to 2
         assertKeyCacheSize(2, KEYSPACE1, COLUMN_FAMILY1);
 

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -134,7 +134,7 @@ public final class CFMetaData
     {
         public int compare(ColumnDefinition def1, ColumnDefinition def2)
         {
-            return def1.name.compareTo(def2.name);
+            return ByteBufferUtil.compareUnsigned(def1.name.bytes, def2.name.bytes);
         }
     };
 

File: src/java/org/apache/cassandra/db/composites/AbstractComposite.java
Patch:
@@ -97,14 +97,14 @@ public int dataSize()
         return size;
     }
 
-    public boolean isPrefixOf(Composite c)
+    public boolean isPrefixOf(CType type, Composite c)
     {
         if (size() > c.size() || isStatic() != c.isStatic())
             return false;
 
         for (int i = 0; i < size(); i++)
         {
-            if (!get(i).equals(c.get(i)))
+            if (type.subtype(i).compare(get(i), c.get(i)) != 0)
                 return false;
         }
         return true;

File: src/java/org/apache/cassandra/db/composites/Composite.java
Patch:
@@ -70,7 +70,7 @@ public byte toByte()
 
     public boolean isStatic();
 
-    public boolean isPrefixOf(Composite other);
+    public boolean isPrefixOf(CType type, Composite other);
 
     public ByteBuffer toByteBuffer();
 

File: src/java/org/apache/cassandra/db/composites/Composites.java
Patch:
@@ -103,7 +103,7 @@ public long unsharedHeapSize()
             return 0;
         }
 
-        public boolean isPrefixOf(Composite c)
+        public boolean isPrefixOf(CType type, Composite c)
         {
             return true;
         }

File: src/java/org/apache/cassandra/db/filter/IDiskAtomFilter.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.cassandra.db.columniterator.OnDiskAtomIterator;
 import org.apache.cassandra.db.composites.CellNameType;
 import org.apache.cassandra.db.composites.Composite;
+import org.apache.cassandra.db.composites.CType;
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.io.sstable.SSTableReader;
 import org.apache.cassandra.io.util.DataOutputPlus;
@@ -77,7 +78,7 @@ public interface IDiskAtomFilter
     public ColumnCounter columnCounter(CellNameType comparator, long now);
 
     public IDiskAtomFilter cloneShallow();
-    public boolean maySelectPrefix(Comparator<Composite> cmp, Composite prefix);
+    public boolean maySelectPrefix(CType type, Composite prefix);
 
     public boolean shouldInclude(SSTableReader sstable);
 

File: src/java/org/apache/cassandra/db/filter/NamesQueryFilter.java
Patch:
@@ -34,6 +34,7 @@
 import org.apache.cassandra.db.composites.CellName;
 import org.apache.cassandra.db.composites.CellNameType;
 import org.apache.cassandra.db.composites.Composite;
+import org.apache.cassandra.db.composites.CType;
 import org.apache.cassandra.io.ISerializer;
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.io.sstable.SSTableReader;
@@ -131,11 +132,11 @@ public int getLiveCount(ColumnFamily cf, long now)
         return count;
     }
 
-    public boolean maySelectPrefix(Comparator<Composite> cmp, Composite prefix)
+    public boolean maySelectPrefix(CType type, Composite prefix)
     {
         for (CellName column : columns)
         {
-            if (prefix.isPrefixOf(column))
+            if (prefix.isPrefixOf(type, column))
                 return true;
         }
         return false;

File: src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
Patch:
@@ -334,10 +334,10 @@ public void updateColumnsLimit(int newLimit)
         count = newLimit;
     }
 
-    public boolean maySelectPrefix(Comparator<Composite> cmp, Composite prefix)
+    public boolean maySelectPrefix(CType type, Composite prefix)
     {
         for (ColumnSlice slice : slices)
-            if (slice.includes(cmp, prefix))
+            if (slice.includes(type, prefix))
                 return true;
         return false;
     }

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -1219,7 +1219,7 @@ public ColumnDefinition getColumnDefinitionFromColumnName(ByteBuffer columnName)
                 else
                 {
                     if (def.componentIndex >= components.length)
-                        break;
+                        continue;
 
                     toCompare = components[def.componentIndex];
                 }

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -675,7 +675,6 @@ private void doCleanupCompaction(final ColumnFamilyStore cfs, Collection<SSTable
         {
             if (!hasIndexes && !new Bounds<>(sstable.first.token, sstable.last.token).intersects(ranges))
             {
-                cfs.getDataTracker().replaceReaders(Arrays.asList(sstable), Collections.<SSTableReader>emptyList());
                 cfs.getDataTracker().markCompactedSSTablesReplaced(Arrays.asList(sstable), Collections.<SSTableReader>emptyList(), OperationType.CLEANUP);
                 continue;
             }

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -187,7 +187,7 @@ else if (conf.commitlog_sync_batch_window_in_ms != null)
         }
 
         if (conf.commitlog_total_space_in_mb == null)
-            conf.commitlog_total_space_in_mb = hasLargeAddressSpace() ? 1024 : 32;
+            conf.commitlog_total_space_in_mb = hasLargeAddressSpace() ? 8192 : 32;
 
         /* evaluate the DiskAccessMode Config directive, which also affects indexAccessMode selection */
         if (conf.disk_access_mode == Config.DiskAccessMode.auto)

File: src/java/org/apache/cassandra/db/commitlog/CommitLogAllocator.java
Patch:
@@ -293,7 +293,7 @@ private void flushOldestTables()
     {
         CommitLogSegment oldestSegment = activeSegments.peek();
 
-        if (oldestSegment != null)
+        if (oldestSegment != null && oldestSegment != CommitLog.instance.activeSegment)
         {
             for (UUID dirtyCFId : oldestSegment.getDirtyCFIDs())
             {

File: src/java/org/apache/cassandra/cql3/QueryProcessor.java
Patch:
@@ -43,7 +43,7 @@
 
 public class QueryProcessor implements QueryHandler
 {
-    public static final SemanticVersion CQL_VERSION = new SemanticVersion("3.1.5");
+    public static final SemanticVersion CQL_VERSION = new SemanticVersion("3.1.6");
 
     public static final QueryProcessor instance = new QueryProcessor();
 

File: src/java/org/apache/cassandra/db/commitlog/CommitLogReplayer.java
Patch:
@@ -68,7 +68,6 @@ public CommitLogReplayer()
         // compute per-CF and global replay positions
         cfPositions = new HashMap<UUID, ReplayPosition>();
         Ordering<ReplayPosition> replayPositionOrdering = Ordering.from(ReplayPosition.comparator);
-        Map<UUID,Pair<ReplayPosition,Long>> truncationPositions = SystemTable.getTruncationRecords();
         for (ColumnFamilyStore cfs : ColumnFamilyStore.all())
         {
             // it's important to call RP.gRP per-cf, before aggregating all the positions w/ the Ordering.min call
@@ -77,8 +76,7 @@ public CommitLogReplayer()
             ReplayPosition rp = ReplayPosition.getReplayPosition(cfs.getSSTables());
 
             // but, if we've truncted the cf in question, then we need to need to start replay after the truncation
-            Pair<ReplayPosition, Long> truncateRecord = truncationPositions.get(cfs.metadata.cfId);
-            ReplayPosition truncatedAt = truncateRecord == null ? null : truncateRecord.left;
+            ReplayPosition truncatedAt = SystemTable.getTruncatedPosition(cfs.metadata.cfId);
             if (truncatedAt != null)
                 rp = replayPositionOrdering.max(Arrays.asList(rp, truncatedAt));
 

File: test/unit/org/apache/cassandra/db/HintedHandOffTest.java
Patch:
@@ -70,7 +70,7 @@ public void testCompactionOfHintsCF() throws Exception
                ByteBufferUtil.EMPTY_BYTE_BUFFER,
                System.currentTimeMillis());
 
-        rm.toHint(rm.calculateHintTTL(), UUID.randomUUID()).apply();
+        rm.toHint(System.currentTimeMillis(), rm.calculateHintTTL(), UUID.randomUUID()).apply();
 
         // flush data to disk
         hintStore.forceBlockingFlush();

File: src/java/org/apache/cassandra/repair/Differencer.java
Patch:
@@ -71,7 +71,7 @@ public void run()
         }
 
         // non-0 difference: perform streaming repair
-        logger.info(format, "have {} range(s) out of sync", differences.size());
+        logger.info(String.format(format, "have " + differences.size() + " range(s) out of sync"));
         performStreamingRepair();
     }
 

File: src/java/org/apache/cassandra/db/ArrayBackedSortedColumns.java
Patch:
@@ -465,8 +465,9 @@ public Cell next(CellName name)
 
                 // optimize for runs of sequential matches, as in CollationController
                 // checking to see if we've found the desired cells yet (CASSANDRA-6933)
-                if (metadata.comparator.compare(name, cells[i].name()) == 0)
-                    return cells[i++];
+                int c = metadata.comparator.compare(name, cells[i].name());
+                if (c <= 0)
+                    return c < 0 ? null : cells[i++];
 
                 // use range to manually force a better bsearch "pivot" by breaking it into two calls:
                 // first for i..i+range, then i+range..size if necessary.

File: src/java/org/apache/cassandra/streaming/StreamTransferTask.java
Patch:
@@ -58,7 +58,7 @@ public void addTransferFile(SSTableReader sstable, long estimatedKeys, List<Pair
      *
      * @param sequenceNumber sequence number of file
      */
-    public void complete(int sequenceNumber)
+    public synchronized void complete(int sequenceNumber)
     {
         OutgoingFileMessage file = files.remove(sequenceNumber);
         if (file != null)
@@ -117,7 +117,7 @@ public OutgoingFileMessage createMessageForRetry(int sequenceNumber)
      * @param unit unit of given time
      * @return scheduled future for timeout task
      */
-    public ScheduledFuture scheduleTimeout(final int sequenceNumber, long time, TimeUnit unit)
+    public synchronized ScheduledFuture scheduleTimeout(final int sequenceNumber, long time, TimeUnit unit)
     {
         if (timeoutExecutor.isShutdown())
             return null;

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1373,12 +1373,11 @@ else if (moveName.equals(VersionedValue.STATUS_RELOCATING))
                     break;
                 case SCHEMA:
                     SystemTable.updatePeerInfo(endpoint, "schema_version", value.value);
+                    MigrationManager.instance.scheduleSchemaPull(endpoint, epState);
                     break;
                 case HOST_ID:
                     SystemTable.updatePeerInfo(endpoint, "host_id", value.value);
                     break;
-                case SCHEMA:
-                    MigrationManager.instance.scheduleSchemaPull(endpoint, epState);
             }
         }
     }

File: src/java/org/apache/cassandra/streaming/ConnectionHandler.java
Patch:
@@ -366,7 +366,7 @@ public void run()
             {
                 throw new AssertionError(e);
             }
-            catch (IOException e)
+            catch (Throwable e)
             {
                 session.onError(e);
             }

File: test/unit/org/apache/cassandra/streaming/StreamTransferTaskTest.java
Patch:
@@ -59,7 +59,7 @@ public void testScheduleTimeout() throws Exception
         {
             List<Range<Token>> ranges = new ArrayList<>();
             ranges.add(new Range<>(sstable.first.getToken(), sstable.last.getToken()));
-            task.addTransferFile(sstable, 1, sstable.getPositionsForRanges(ranges));
+            task.addTransferFile(sstable, 1, sstable.getPositionsForRanges(ranges), 0);
         }
         assertEquals(2, task.getTotalNumberOfFiles());
 

File: src/java/org/apache/cassandra/streaming/StreamWriter.java
Patch:
@@ -115,9 +115,6 @@ public void write(WritableByteChannel channel) throws IOException
             FileUtils.closeQuietly(file);
             FileUtils.closeQuietly(validator);
         }
-
-        // release reference only when completed successfully
-        sstable.releaseReference();
     }
 
     protected long totalSize()

File: src/java/org/apache/cassandra/streaming/compress/CompressedStreamWriter.java
Patch:
@@ -83,8 +83,6 @@ public void write(WritableByteChannel channel) throws IOException
             // no matter what happens close file
             FileUtils.closeQuietly(file);
         }
-
-        sstable.releaseReference();
     }
 
     @Override

File: src/java/org/apache/cassandra/db/filter/ColumnSlice.java
Patch:
@@ -88,7 +88,8 @@ public boolean intersects(List<ByteBuffer> minCellNames, List<ByteBuffer> maxCel
             ByteBuffer f = i < sEnd.size() ? sEnd.get(i) : ByteBufferUtil.EMPTY_BYTE_BUFFER;
 
             // we already know the first component falls within its min/max range (otherwise we wouldn't get here)
-            if (i > 0 && (t.compare(f, minCellNames.get(i)) < 0 || t.compare(s, maxCellNames.get(i)) > 0))
+            if (i > 0 && (i < sEnd.size() && t.compare(f, minCellNames.get(i)) < 0 ||
+                          i < sStart.size() && t.compare(s, maxCellNames.get(i)) > 0))
                 return false;
 
             // if this component isn't equal in the start and finish, we don't need to check any more

File: src/java/org/apache/cassandra/utils/btree/BTree.java
Patch:
@@ -26,6 +26,8 @@
 
 import org.apache.cassandra.utils.ObjectSizes;
 
+import static org.apache.cassandra.utils.btree.UpdateFunction.NoOp;
+
 public class BTree
 {
     /**
@@ -141,7 +143,7 @@ public static <V> Object[] build(Iterable<V> source, int size, Comparator<V> com
      */
     public static <V> Object[] update(Object[] btree, Comparator<V> comparator, Collection<V> updateWith, boolean updateWithIsSorted)
     {
-        return update(btree, comparator, updateWith, updateWithIsSorted, UpdateFunction.NoOp.<V>instance());
+        return update(btree, comparator, updateWith, updateWithIsSorted, NoOp.<V>instance());
     }
 
     public static <V> Object[] update(Object[] btree,

File: src/java/org/apache/cassandra/cql3/statements/CQL3CasConditions.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.cassandra.db.filter.*;
 import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.service.CASConditions;
+import org.apache.cassandra.utils.Pair;
 
 /**
  * Processed CAS conditions on potentially multiple rows of the same partition.
@@ -166,7 +167,7 @@ public boolean appliesTo(ColumnFamily current)
 
     private static class ColumnsConditions extends RowCondition
     {
-        private final Map<ColumnIdentifier, ColumnCondition.WithVariables> conditions = new HashMap<>();
+        private final Map<Pair<ColumnIdentifier, ByteBuffer>, ColumnCondition.WithVariables> conditions = new HashMap<>();
 
         private ColumnsConditions(ColumnNameBuilder rowPrefix, long now)
         {
@@ -180,7 +181,7 @@ public void addConditions(Collection<ColumnCondition> conds, List<ByteBuffer> va
                 // We will need the variables in appliesTo but with protocol batches, each condition in this object can have a
                 // different list of variables.
                 ColumnCondition.WithVariables current = condition.with(variables);
-                ColumnCondition.WithVariables previous = conditions.put(condition.column.name, current);
+                ColumnCondition.WithVariables previous = conditions.put(Pair.create(condition.column.name, current.getCollectionElementValue()), current);
                 // If 2 conditions are actually equal, let it slide
                 if (previous != null && !previous.equalsTo(current))
                     throw new InvalidRequestException("Duplicate and incompatible conditions for column " + condition.column.name);

File: src/java/org/apache/cassandra/tools/SSTableImport.java
Patch:
@@ -162,7 +162,7 @@ else if (isRangeTombstone())
                 }
                 else
                 {
-                    value = stringAsType((String) fields.get(1), meta.getValueValidator(meta.comparator.cellFromByteBuffer(name)));
+                    value = stringAsType((String) fields.get(1), meta.getValueValidator(comparator.cellFromByteBuffer(name)));
                 }
             }
         }

File: test/unit/org/apache/cassandra/thrift/ThriftValidationTest.java
Patch:
@@ -101,7 +101,7 @@ public void testColumnNameEqualToDefaultKeyAlias() throws org.apache.cassandra.e
         CFMetaData metaData = Schema.instance.getCFMetaData("Keyspace1", "UUIDKeys");
         ColumnDefinition definition = metaData.getColumnDefinition(ByteBufferUtil.bytes(CFMetaData.DEFAULT_KEY_ALIAS));
         assertNotNull(definition);
-        assertEquals(ColumnDefinition.Kind.PARTITION_KEY, definition.type);
+        assertEquals(ColumnDefinition.Kind.PARTITION_KEY, definition.kind);
 
         // make sure the key alias does not affect validation of columns with the same name (CASSANDRA-6892)
         Column column = new Column(ByteBufferUtil.bytes(CFMetaData.DEFAULT_KEY_ALIAS));

File: src/java/org/apache/cassandra/cql/QueryProcessor.java
Patch:
@@ -190,7 +190,7 @@ private static List<org.apache.cassandra.db.Row> multiRangeSlice(CFMetaData meta
         {
             // Left and right side of relational expression encoded according to comparator/validator.
             ByteBuffer entity = columnRelation.getEntity().getByteBuffer(metadata.comparator, variables);
-            ByteBuffer value = columnRelation.getValue().getByteBuffer(select.getValueValidator(metadata.ksName, entity), variables);
+            ByteBuffer value = columnRelation.getValue().getByteBuffer(metadata.getValueValidatorFromColumnName(entity), variables);
 
             expressions.add(new IndexExpression(entity,
                                                 IndexOperator.valueOf(columnRelation.operator().toString()),
@@ -326,7 +326,7 @@ public static void validateColumn(CFMetaData metadata, ByteBuffer name, ByteBuff
     throws InvalidRequestException
     {
         validateColumnName(name);
-        AbstractType<?> validator = metadata.getValueValidator(name);
+        AbstractType<?> validator = metadata.getValueValidatorFromColumnName(name);
 
         try
         {

File: src/java/org/apache/cassandra/tools/SSTableExport.java
Patch:
@@ -187,7 +187,7 @@ private static List<Object> serializeColumn(Column column, AbstractType<?> compa
         }
         else
         {
-            AbstractType<?> validator = cfMetaData.getValueValidator(cfMetaData.getColumnDefinitionFromColumnName(name));
+            AbstractType<?> validator = cfMetaData.getValueValidatorFromColumnName(name);
             serializedColumn.add(validator.getString(value));
         }
         serializedColumn.add(column.timestamp());

File: src/java/org/apache/cassandra/tools/SSTableImport.java
Patch:
@@ -161,7 +161,7 @@ else if (isRangeTombstone())
                 }
                 else
                 {
-                    value = stringAsType((String) fields.get(1), meta.getValueValidator(meta.getColumnDefinitionFromColumnName(name)));
+                    value = stringAsType((String) fields.get(1), meta.getValueValidatorFromColumnName(name));
                 }
             }
         }

File: src/java/org/apache/cassandra/cql3/QueryProcessor.java
Patch:
@@ -35,6 +35,7 @@
 import org.apache.cassandra.exceptions.*;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.QueryState;
+import org.apache.cassandra.thrift.ThriftClientState;
 import org.apache.cassandra.tracing.Tracing;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.MD5Digest;
@@ -237,7 +238,8 @@ public static UntypedResultSet resultify(String query, Row row)
     public ResultMessage.Prepared prepare(String queryString, QueryState queryState)
     throws RequestValidationException
     {
-        return prepare(queryString, queryState.getClientState(), false);
+        ClientState cState = queryState.getClientState();
+        return prepare(queryString, cState, cState instanceof ThriftClientState);
     }
 
     public static ResultMessage.Prepared prepare(String queryString, ClientState clientState, boolean forThrift)

File: src/java/org/apache/cassandra/db/filter/ExtendedFilter.java
Patch:
@@ -255,7 +255,8 @@ public IDiskAtomFilter getExtraFilter(DecoratedKey rowKey, ColumnFamily data)
              * 2) We don't yet allow non-indexed range slice with filters in CQL3 (i.e. this will never be
              * called by CFS.filter() for composites).
              */
-            assert !(cfs.getComparator() instanceof CompositeType);
+            assert !(cfs.getComparator() instanceof CompositeType) : "Sequential scan with filters is not supported (if you just created an index, you "
+                                                                     + "need to wait for the creation to be propagated to all nodes before querying it)";
 
             if (!needsExtraQuery(rowKey.key, data))
                 return null;

File: src/java/org/apache/cassandra/db/BatchlogManager.java
Patch:
@@ -246,7 +246,7 @@ private void replayBatch(UUID id, ByteBuffer data, long writtenAt, RateLimiter r
     private void deleteBatch(UUID id)
     {
         RowMutation mutation = new RowMutation(Table.SYSTEM_KS, UUIDType.instance.decompose(id));
-        mutation.delete(new QueryPath(SystemTable.BATCHLOG_CF, null, null), System.currentTimeMillis());
+        mutation.delete(new QueryPath(SystemTable.BATCHLOG_CF, null, null), FBUtilities.timestampMicros());
         mutation.apply();
     }
 

File: test/unit/org/apache/cassandra/db/BatchlogManagerTest.java
Patch:
@@ -67,6 +67,9 @@ public void testReplay() throws Exception
             BatchlogManager.getBatchlogMutationFor(Collections.singleton(mutation), UUIDGen.getTimeUUID(), timestamp * 1000).apply();
         }
 
+        // Flush the batchlog to disk (see CASSANDRA-6822).
+        Table.open(Table.SYSTEM_KS).getColumnFamilyStore(SystemTable.BATCHLOG_CF).forceFlush();
+
         assertEquals(1000, BatchlogManager.instance.countAllBatches());
         assertEquals(0, BatchlogManager.instance.getTotalBatchesReplayed());
 

File: src/java/org/apache/cassandra/cache/AutoSavingCache.java
Patch:
@@ -170,6 +170,8 @@ protected Writer(int keysToSave)
                 type = OperationType.KEY_CACHE_SAVE;
             else if (cacheType == CacheService.CacheType.ROW_CACHE)
                 type = OperationType.ROW_CACHE_SAVE;
+            else if (cacheType == CacheService.CacheType.COUNTER_CACHE)
+                type = OperationType.COUNTER_CACHE_SAVE;
             else
                 type = OperationType.UNKNOWN;
 

File: src/java/org/apache/cassandra/db/compaction/OperationType.java
Patch:
@@ -23,6 +23,7 @@ public enum OperationType
     VALIDATION("Validation"),
     KEY_CACHE_SAVE("Key cache save"),
     ROW_CACHE_SAVE("Row cache save"),
+    COUNTER_CACHE_SAVE("Counter cache save"),
     CLEANUP("Cleanup"),
     SCRUB("Scrub"),
     UPGRADE_SSTABLES("Upgrade sstables"),

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1725,6 +1725,9 @@ public ColumnFamily getColumnFamily(QueryFilter filter)
      */
     ColumnFamily filterColumnFamily(ColumnFamily cached, QueryFilter filter)
     {
+        if (cached == null)
+            return null;
+
         ColumnFamily cf = cached.cloneMeShallow(ArrayBackedSortedColumns.factory, filter.filter.isReversed());
         OnDiskAtomIterator ci = filter.getColumnFamilyIterator(cached);
 

File: src/java/org/apache/cassandra/db/ArrayBackedSortedColumns.java
Patch:
@@ -94,7 +94,7 @@ public static ColumnFamily cloneToHeap(ColumnFamily value, ColumnFamilyStore cfs
         final Cell[] cells = new Cell[value.getColumnCount()];
         int i = 0;
         for (Cell cell : value)
-            cells[i++] = cell.localCopy(cfs, HeapAllocator.instance);
+            cells[i++] = cell.localCopy(HeapAllocator.instance);
         ColumnFamily r = new ArrayBackedSortedColumns(cfs.metadata, value.isInsertReversed(), cells, i, i);
         r.delete(value);
         return r;

File: src/java/org/apache/cassandra/db/CollationController.java
Patch:
@@ -86,7 +86,7 @@ private ColumnFamily collectTimeOrderedData(boolean copyOnHeap)
                     {
                         OnDiskAtom atom = iter.next();
                         if (copyOnHeap)
-                            atom = ((Cell) atom).localCopy(cfs, HeapAllocator.instance);
+                            atom = ((Cell) atom).localCopy(HeapAllocator.instance);
                         container.addAtom(atom);
                     }
                 }
@@ -205,7 +205,7 @@ private ColumnFamily collectAllData(boolean copyOnHeap)
                         ColumnFamily newCf = cf.cloneMeShallow(ArrayBackedSortedColumns.factory, false);
                         for (Cell cell : cf)
                         {
-                            newCf.addColumn(cell.localCopy(cfs, HeapAllocator.instance));
+                            newCf.addColumn(cell.localCopy(HeapAllocator.instance));
                         }
                         cf = newCf;
                         iter = filter.getColumnFamilyIterator(cf);

File: src/java/org/apache/cassandra/db/ConsistencyLevel.java
Patch:
@@ -115,10 +115,12 @@ public int blockFor(Keyspace keyspace)
             case THREE:
                 return 3;
             case QUORUM:
+            case SERIAL:
                 return quorumFor(keyspace);
             case ALL:
                 return keyspace.getReplicationStrategy().getReplicationFactor();
             case LOCAL_QUORUM:
+            case LOCAL_SERIAL:
                 return localQuorumFor(keyspace, DatabaseDescriptor.getLocalDataCenter());
             case EACH_QUORUM:
                 if (keyspace.getReplicationStrategy() instanceof NetworkTopologyStrategy)

File: src/java/org/apache/cassandra/db/DeletionInfo.java
Patch:
@@ -227,7 +227,7 @@ public int rangeCount()
     public boolean mayModify(DeletionInfo delInfo)
     {
         return topLevel.markedForDeleteAt > delInfo.topLevel.markedForDeleteAt
-            || ranges == null;
+            || ranges != null;
     }
 
     @Override

File: src/java/org/apache/cassandra/streaming/AbstractStreamSession.java
Patch:
@@ -44,8 +44,6 @@ protected AbstractStreamSession(String table, InetAddress host, UUID sessionId,
         this.sessionId = sessionId;
         this.table = table;
         this.callback = callback;
-        Gossiper.instance.register(this);
-        FailureDetector.instance.registerFailureDetectionEventListener(this);
     }
 
     public UUID getSessionId()

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -472,6 +472,7 @@ void print() throws UnknownHostException
             catch (IllegalStateException e)
             {
                 ownerships = probe.getOwnership();
+                outs.printf("Note: Ownership information does not include topology; for complete information, specify a keyspace%n");
             }
 
             // More tokens then nodes (aka vnodes)?

File: src/java/org/apache/cassandra/db/MeteredFlusher.java
Patch:
@@ -37,9 +37,8 @@ public void run()
         long totalMemtableBytesAllowed = DatabaseDescriptor.getTotalMemtableSpaceInMB() * 1048576L;
 
         // first, find how much memory non-active memtables are using
-        long flushingBytes = Memtable.activelyMeasuring == null
-                           ? 0
-                           : Memtable.activelyMeasuring.getMemtableThreadSafe().getLiveSize();
+        ColumnFamilyStore measuredCfs = Memtable.activelyMeasuring;
+        long flushingBytes = measuredCfs == null ? 0 : measuredCfs.getMemtableThreadSafe().getLiveSize();
         flushingBytes += countFlushingBytes();
         if (flushingBytes > 0)
             logger.debug("Currently flushing {} bytes of {} max", flushingBytes, totalMemtableBytesAllowed);

File: src/java/org/apache/cassandra/service/ReadCallback.java
Patch:
@@ -76,6 +76,8 @@ public ReadCallback(IResponseResolver<TMessage, TResolved> resolver, Consistency
         this.resolver = resolver;
         this.start = System.nanoTime();
         this.endpoints = endpoints;
+        // we don't support read repair (or rapid read protection) for range scans yet (CASSANDRA-6897)
+        assert !(resolver instanceof RangeSliceResponseResolver) || blockfor >= endpoints.size();
     }
 
     public boolean await(long timePastStart, TimeUnit unit)

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -1473,7 +1473,8 @@ public static List<Row> getRangeSlice(AbstractRangeCommand command, ConsistencyL
 
                 // collect replies and resolve according to consistency level
                 RangeSliceResponseResolver resolver = new RangeSliceResponseResolver(nodeCmd.keyspace, command.timestamp);
-                ReadCallback<RangeSliceReply, Iterable<Row>> handler = new ReadCallback(resolver, consistency_level, nodeCmd, filteredEndpoints);
+                List<InetAddress> minimalEndpoints = filteredEndpoints.subList(0, Math.min(filteredEndpoints.size(), consistency_level.blockFor(keyspace)));
+                ReadCallback<RangeSliceReply, Iterable<Row>> handler = new ReadCallback<>(resolver, consistency_level, nodeCmd, minimalEndpoints);
                 handler.assureSufficientLiveNodes();
                 resolver.setSources(filteredEndpoints);
                 if (filteredEndpoints.size() == 1

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1671,10 +1671,11 @@ public ExtendedFilter makeExtendedFilter(AbstractBounds<RowPosition> keyRange,
                                              ByteBuffer columnStop,
                                              List<IndexExpression> rowFilter,
                                              int maxResults,
+                                             boolean countCQL3Rows,
                                              long now)
     {
         DataRange dataRange = new DataRange.Paging(keyRange, columnRange, columnStart, columnStop, metadata.comparator);
-        return ExtendedFilter.create(this, dataRange, rowFilter, maxResults, true, now);
+        return ExtendedFilter.create(this, dataRange, rowFilter, maxResults, countCQL3Rows, now);
     }
 
     public List<Row> getRangeSlice(AbstractBounds<RowPosition> range,

File: test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
Patch:
@@ -1198,15 +1198,15 @@ public void testRangeSlicePaging() throws Throwable
                                                    ByteBufferUtil.bytes("c2"),
                                                    false,
                                                    0);
-        rows = cfs.getRangeSlice(cfs.makeExtendedFilter(new Bounds<RowPosition>(ka, kc), sf, ByteBufferUtil.bytes("c2"), ByteBufferUtil.bytes("c1"), null, 2, System.currentTimeMillis()));
+        rows = cfs.getRangeSlice(cfs.makeExtendedFilter(new Bounds<RowPosition>(ka, kc), sf, ByteBufferUtil.bytes("c2"), ByteBufferUtil.bytes("c1"), null, 2, true, System.currentTimeMillis()));
         assert rows.size() == 2 : "Expected 2 rows, got " + toString(rows);
         iter = rows.iterator();
         row1 = iter.next();
         row2 = iter.next();
         assertColumnNames(row1, "c2");
         assertColumnNames(row2, "c1");
 
-        rows = cfs.getRangeSlice(cfs.makeExtendedFilter(new Bounds<RowPosition>(kb, kc), sf, ByteBufferUtil.bytes("c1"), ByteBufferUtil.bytes("c1"), null, 10, System.currentTimeMillis()));
+        rows = cfs.getRangeSlice(cfs.makeExtendedFilter(new Bounds<RowPosition>(kb, kc), sf, ByteBufferUtil.bytes("c1"), ByteBufferUtil.bytes("c1"), null, 10, true, System.currentTimeMillis()));
         assert rows.size() == 2 : "Expected 2 rows, got " + toString(rows);
         iter = rows.iterator();
         row1 = iter.next();

File: tools/stress/src/org/apache/cassandra/stress/settings/OptionDistribution.java
Patch:
@@ -334,7 +334,7 @@ private UniformFactory(long min, long max)
         @Override
         public Distribution get()
         {
-            return new DistributionBoundApache(new UniformRealDistribution(min, max), min, max);
+            return new DistributionBoundApache(new UniformRealDistribution(min, max + 1), min, max);
         }
     }
 

File: src/java/org/apache/cassandra/db/commitlog/CommitLogReplayer.java
Patch:
@@ -239,7 +239,7 @@ public void recover(File file) throws IOException
         try
         {
             assert reader.length() <= Integer.MAX_VALUE;
-            int offset = getStartOffset(segmentId, desc.getMessagingVersion());
+            int offset = getStartOffset(segmentId, desc.getVersion());
             if (offset < 0)
             {
                 logger.debug("skipping replay of fully-flushed {}", file);

File: src/java/org/apache/cassandra/db/columniterator/IndexedSliceReader.java
Patch:
@@ -186,7 +186,7 @@ static int indexFor(SSTableReader sstable, Composite name, List<IndexHelper.Inde
         if (sstable.metadata.isSuper() && sstable.descriptor.version.hasSuperColumns)
         {
             CellNameType scComparator = SuperColumns.scNameType(comparator);
-            Composite scName = CellNames.compositeDense(SuperColumns.scName(name));
+            Composite scName = CellNames.simpleDense(SuperColumns.scName(name));
             return IndexHelper.indexFor(scName, indexes, scComparator, reversed, startIdx);
         }
         return IndexHelper.indexFor(name, indexes, comparator, reversed, startIdx);

File: src/java/org/apache/cassandra/db/columniterator/IndexedSliceReader.java
Patch:
@@ -196,7 +196,7 @@ static Composite forIndexComparison(SSTableReader sstable, Composite name)
     {
         // See indexFor above.
         return sstable.metadata.isSuper() && sstable.descriptor.version.hasSuperColumns
-             ? CellNames.compositeDense(SuperColumns.scName(name))
+             ? CellNames.simpleDense(SuperColumns.scName(name))
              : name;
     }
 

File: src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
Patch:
@@ -36,6 +36,7 @@
 import org.apache.cassandra.db.composites.CellName;
 import org.apache.cassandra.db.composites.CellNameType;
 import org.apache.cassandra.db.composites.Composite;
+import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.io.sstable.SSTableReader;
 import org.apache.cassandra.io.util.FileDataInput;
@@ -222,11 +223,10 @@ public void collectReducedColumns(ColumnFamily container, Iterator<Cell> reduced
         if (respectTombstoneThresholds() && columnCounter.ignored() > DatabaseDescriptor.getTombstoneWarnThreshold())
         {
             StringBuilder sb = new StringBuilder();
-            AbstractType<?> type = container.metadata().comparator;
+            CellNameType type = container.metadata().comparator;
             for (ColumnSlice sl : slices)
             {
-                if (sl == null)
-                    continue;
+                assert sl != null;
 
                 sb.append('[');
                 sb.append(type.getString(sl.start));

File: src/java/org/apache/cassandra/db/commitlog/CommitLogAllocator.java
Patch:
@@ -304,7 +304,7 @@ private void flushOldestKeyspaces()
     {
         CommitLogSegment oldestSegment = activeSegments.peek();
 
-        if (oldestSegment != null)
+        if (oldestSegment != null && oldestSegment != CommitLog.instance.activeSegment)
         {
             for (UUID dirtyCFId : oldestSegment.getDirtyCFIDs())
             {

File: src/java/org/apache/cassandra/db/commitlog/CommitLogAllocator.java
Patch:
@@ -304,7 +304,7 @@ private void flushOldestKeyspaces()
     {
         CommitLogSegment oldestSegment = activeSegments.peek();
 
-        if (oldestSegment != null)
+        if (oldestSegment != null && oldestSegment != CommitLog.instance.activeSegment)
         {
             for (UUID dirtyCFId : oldestSegment.getDirtyCFIDs())
             {

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsKey.java
Patch:
@@ -114,7 +114,7 @@ public static SettingsKey get(Map<String, String[]> clArgs, SettingsCommand comm
             switch(command.type)
             {
                 case WRITE:
-                case COUNTERWRITE:
+                case COUNTER_WRITE:
                     return new SettingsKey(new PopulateOptions(defaultLimit));
                 default:
                     return new SettingsKey(new DistributionOptions(defaultLimit));

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsMisc.java
Patch:
@@ -117,7 +117,8 @@ private static boolean maybePrintHelp(Map<String, String[]> clArgs)
 
     public static void printHelp()
     {
-        System.out.println("Usage: ./bin/cassandra-stress <command> [options]");
+        System.out.println("Usage:      cassandra-stress <command> [options]");
+        System.out.println("Help usage: cassandra-stress help <command>");
         System.out.println();
         System.out.println("---Commands---");
         for (Command cmd : Command.values())
@@ -160,7 +161,7 @@ public void run()
                 System.out.println("Usage: ./bin/cassandra-stress help <command|option>");
                 System.out.println("Commands:");
                 for (Command cmd : Command.values())
-                    System.out.println("    " + cmd.toString().toLowerCase() + (cmd.extraName != null ? ", " + cmd.extraName : ""));
+                    System.out.println("    " + cmd.names.toString().replaceAll("\\[|\\]", ""));
                 System.out.println("Options:");
                 for (CliOption op : CliOption.values())
                     System.out.println("    -" + op.toString().toLowerCase() + (op.extraName != null ? ", " + op.extraName : ""));

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsRate.java
Patch:
@@ -92,7 +92,7 @@ public static SettingsRate get(Map<String, String[]> clArgs, SettingsCommand com
             switch (command.type)
             {
                 case WRITE:
-                case COUNTERWRITE:
+                case COUNTER_WRITE:
                     if (command.count > 0)
                     {
                         ThreadOptions options = new ThreadOptions();

File: tools/stress/src/org/apache/cassandra/stress/settings/StressSettings.java
Patch:
@@ -165,7 +165,7 @@ public JavaDriverClient getJavaDriverClient()
 
     public void maybeCreateKeyspaces()
     {
-        if (command.type == Command.WRITE || command.type == Command.COUNTERWRITE)
+        if (command.type == Command.WRITE || command.type == Command.COUNTER_WRITE)
             schema.createKeySpaces(this);
 
     }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1370,7 +1370,7 @@ List<SSTableReader> findSSTables(DataTracker.View view)
 
     public List<String> getSSTablesForKey(String key)
     {
-        DecoratedKey dk = new DecoratedKey(partitioner.getToken(ByteBuffer.wrap(key.getBytes())), ByteBuffer.wrap(key.getBytes()));
+        DecoratedKey dk = partitioner.decorateKey(metadata.getKeyValidator().fromString(key));
         ViewFragment view = markReferenced(dk);
         try
         {

File: src/java/org/apache/cassandra/utils/FBUtilities.java
Patch:
@@ -370,7 +370,7 @@ public static String getReleaseVersionString()
             in = FBUtilities.class.getClassLoader().getResourceAsStream("org/apache/cassandra/config/version.properties");
             if (in == null)
             {
-                return "Unknown";
+                return System.getProperty("cassandra.releaseVersion", "Unknown");
             }
             Properties props = new Properties();
             props.load(in);

File: tools/stress/src/org/apache/cassandra/stress/StressAction.java
Patch:
@@ -87,7 +87,7 @@ private void warmup(Command type, SettingsCommand command)
                     warmup(subtype, command);
                 return;
             case MULTI:
-                int keysAtOnce = ((SettingsCommandMulti) command).keysAtOnce;
+                int keysAtOnce = command.keysAtOnce;
                 iterations = Math.min(50000, (int) Math.ceil(500000d / keysAtOnce));
                 break;
             default:
@@ -298,6 +298,8 @@ public void run()
                                 case SIMPLE_NATIVE:
                                     op.run(sclient);
                                     break;
+                                case THRIFT:
+                                case THRIFT_SMART:
                                 default:
                                     op.run(tclient);
                             }

File: tools/stress/src/org/apache/cassandra/stress/generatedata/RowGen.java
Patch:
@@ -46,6 +46,7 @@ public List<ByteBuffer> generate(long operationIndex, ByteBuffer key)
 
     // these byte[] may be re-used
     abstract List<ByteBuffer> getColumns(long operationIndex);
+    abstract public int count(long operationIndex);
 
     abstract public boolean isDeterministic();
 

File: tools/stress/src/org/apache/cassandra/stress/operations/ThriftIndexedRangeSlicer.java
Patch:
@@ -23,7 +23,6 @@
 import java.util.List;
 
 import org.apache.cassandra.stress.Operation;
-import org.apache.cassandra.stress.settings.SettingsCommandMulti;
 import org.apache.cassandra.stress.util.ThriftClient;
 import org.apache.cassandra.thrift.*;
 import org.apache.cassandra.utils.ByteBufferUtil;
@@ -52,7 +51,7 @@ public void run(final ThriftClient client) throws IOException
         final List<ByteBuffer> columns = generateColumnValues(getKey());
         final ColumnParent parent = state.columnParents.get(0);
 
-        final ByteBuffer columnName = getColumnNameBytes(1);
+        final ByteBuffer columnName = state.settings.columns.names.get(1);
         final ByteBuffer value = columns.get(1); // only C1 column is indexed
 
         IndexExpression expression = new IndexExpression(columnName, IndexOperator.EQ, value);
@@ -64,7 +63,7 @@ public void run(final ThriftClient client) throws IOException
             final boolean first = minKey.length == 0;
             final IndexClause clause = new IndexClause(Arrays.asList(expression),
                                                  ByteBuffer.wrap(minKey),
-                                                ((SettingsCommandMulti) state.settings.command).keysAtOnce);
+                                                state.settings.command.keysAtOnce);
 
             timeWithRetry(new RunOp()
             {

File: tools/stress/src/org/apache/cassandra/stress/operations/ThriftInserter.java
Patch:
@@ -53,7 +53,7 @@ public void run(final ThriftClient client) throws IOException
                 ColumnOrSuperColumn column = new ColumnOrSuperColumn().setColumn(c);
                 mutations.add(new Mutation().setColumn_or_supercolumn(column));
             }
-            row = Collections.singletonMap(state.settings.schema.columnFamily, mutations);
+            row = Collections.singletonMap(state.type.table, mutations);
         }
         else
         {
@@ -64,7 +64,7 @@ public void run(final ThriftClient client) throws IOException
                 final ColumnOrSuperColumn cosc = new ColumnOrSuperColumn().setSuper_column(s);
                 mutations.add(new Mutation().setColumn_or_supercolumn(cosc));
             }
-            row = Collections.singletonMap("Super1", mutations);
+            row = Collections.singletonMap(state.settings.command.type.supertable, mutations);
         }
 
         final Map<ByteBuffer, Map<String, List<Mutation>>> record = Collections.singletonMap(key, row);
@@ -104,7 +104,7 @@ protected List<Column> generateColumns(ByteBuffer key)
             // TODO : consider randomly allocating column names in case where have fewer than max columns
             // but need to think about implications for indexes / indexed range slicer / other knock on effects
             for (int i = 0 ; i < values.size() ; i++)
-                columns.add(new Column(getColumnNameBytes(i)));
+                columns.add(new Column(state.settings.columns.names.get(i)));
 
         for (int i = 0 ; i < values.size() ; i++)
             columns.get(i)

File: tools/stress/src/org/apache/cassandra/stress/operations/ThriftMultiGetter.java
Patch:
@@ -22,7 +22,6 @@
 import java.util.List;
 
 import org.apache.cassandra.stress.Operation;
-import org.apache.cassandra.stress.settings.SettingsCommandMulti;
 import org.apache.cassandra.stress.util.ThriftClient;
 import org.apache.cassandra.thrift.ColumnParent;
 import org.apache.cassandra.thrift.SlicePredicate;
@@ -50,7 +49,7 @@ public void run(final ThriftClient client) throws IOException
                 )
         );
 
-        final List<ByteBuffer> keys = getKeys(((SettingsCommandMulti) state.settings.command).keysAtOnce);
+        final List<ByteBuffer> keys = getKeys(state.settings.command.keysAtOnce);
 
         for (final ColumnParent parent : state.columnParents)
         {

File: tools/stress/src/org/apache/cassandra/stress/operations/ThriftRangeSlicer.java
Patch:
@@ -21,7 +21,6 @@
 import java.nio.ByteBuffer;
 
 import org.apache.cassandra.stress.Operation;
-import org.apache.cassandra.stress.settings.SettingsCommandMulti;
 import org.apache.cassandra.stress.util.ThriftClient;
 import org.apache.cassandra.thrift.ColumnParent;
 import org.apache.cassandra.thrift.KeyRange;
@@ -55,7 +54,7 @@ public void run(final ThriftClient client) throws IOException
                 new KeyRange(state.settings.columns.maxColumnsPerKey)
                         .setStart_key(start)
                         .setEnd_key(ByteBufferUtil.EMPTY_BYTE_BUFFER)
-                        .setCount(((SettingsCommandMulti)state.settings.command).keysAtOnce);
+                        .setCount(state.settings.command.keysAtOnce);
 
         for (final ColumnParent parent : state.columnParents)
         {

File: tools/stress/src/org/apache/cassandra/stress/settings/Option.java
Patch:
@@ -31,6 +31,7 @@ abstract class Option
     abstract String shortDisplay();
     abstract String longDisplay();
     abstract List<String> multiLineDisplay();
+    abstract boolean setByUser();
 
     public int hashCode()
     {

File: tools/stress/src/org/apache/cassandra/stress/settings/OptionReplication.java
Patch:
@@ -77,7 +77,7 @@ public String apply(String name)
                 {
                     Class<?> clazz = Class.forName(fullname);
                     if (!AbstractReplicationStrategy.class.isAssignableFrom(clazz))
-                        throw new RuntimeException();
+                        throw new IllegalArgumentException(clazz + " is not a replication strategy");
                     strategy = fullname;
                     break;
                 } catch (Exception _)

File: tools/stress/src/org/apache/cassandra/stress/settings/OptionSimple.java
Patch:
@@ -33,7 +33,7 @@
 class OptionSimple extends Option
 {
 
-    private final String displayPrefix;
+    final String displayPrefix;
     private final Pattern matchPrefix;
     private final String defaultValue;
     private final Function<String, String> valueAdapter;

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsKey.java
Patch:
@@ -63,7 +63,7 @@ private static final class DistributionOptions extends GroupedOptions
 
         public DistributionOptions(String defaultLimit)
         {
-            dist = new OptionDistribution("dist=", "GAUSSIAN(1.." + defaultLimit + ")");
+            dist = new OptionDistribution("dist=", "GAUSSIAN(1.." + defaultLimit + ")", "Keys are selected from this distribution");
         }
 
         @Override

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsMisc.java
Patch:
@@ -43,7 +43,7 @@ static boolean maybeDoSpecial(Map<String, String[]> clArgs)
 
     static final class PrintDistribution extends GroupedOptions
     {
-        final OptionDistribution dist = new OptionDistribution("dist=", null);
+        final OptionDistribution dist = new OptionDistribution("dist=", null, "A mathematical distribution");
 
         @Override
         public List<? extends Option> options()
@@ -180,7 +180,7 @@ public void run()
                     @Override
                     public List<? extends Option> options()
                     {
-                        return Arrays.asList(new OptionDistribution("dist=", null));
+                        return Arrays.asList(new OptionDistribution("dist=", null, "A mathematical distribution"));
                     }
                 });
             }

File: tools/stress/src/org/apache/cassandra/stress/settings/SettingsTransport.java
Patch:
@@ -47,7 +47,7 @@ public SettingsTransport(TOptions options)
         {
             Class<?> clazz = Class.forName(fqFactoryClass);
             if (!ITransportFactory.class.isAssignableFrom(clazz))
-                throw new ClassCastException();
+                throw new IllegalArgumentException(clazz + " is not a valid transport factory");
             // check we can instantiate it
             clazz.newInstance();
         }

File: tools/stress/src/org/apache/cassandra/stress/util/JavaDriverClient.java
Patch:
@@ -103,11 +103,11 @@ public ResultSet execute(String query, org.apache.cassandra.db.ConsistencyLevel
         return getSession().execute(stmt);
     }
 
-    public ResultSet executePrepared(PreparedStatement stmt, List<ByteBuffer> queryParams, org.apache.cassandra.db.ConsistencyLevel consistency)
+    public ResultSet executePrepared(PreparedStatement stmt, List<Object> queryParams, org.apache.cassandra.db.ConsistencyLevel consistency)
     {
 
         stmt.setConsistencyLevel(from(consistency));
-        BoundStatement bstmt = stmt.bind((Object[]) queryParams.toArray(new ByteBuffer[queryParams.size()]));
+        BoundStatement bstmt = stmt.bind((Object[]) queryParams.toArray(new Object[queryParams.size()]));
         return getSession().execute(bstmt);
     }
 

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -493,7 +493,7 @@ static boolean needsCleanup(SSTableReader sstable, Collection<Range<Token>> owne
                 return false;
             }
 
-            if (i == (ownedRanges.size() - 1))
+            if (i == (sortedRanges.size() - 1))
             {
                 // we're at the last range and we found a key beyond the end of the range
                 return true;

File: src/java/org/apache/cassandra/service/FileCacheService.java
Patch:
@@ -91,7 +91,10 @@ public RandomAccessReader get(String path)
         Queue<RandomAccessReader> instances = getCacheFor(path);
         RandomAccessReader result = instances.poll();
         if (result != null)
+        {
             metrics.hits.mark();
+            memoryUsage.addAndGet(-result.getTotalBufferSize());
+        }
 
         return result;
     }

File: test/unit/org/apache/cassandra/triggers/TriggersTest.java
Patch:
@@ -169,7 +169,7 @@ public static class TestTrigger implements ITrigger
         public Collection<Mutation> augment(ByteBuffer key, ColumnFamily update)
         {
             ColumnFamily extraUpdate = update.cloneMeShallow(ArrayBackedSortedColumns.factory, false);
-            extraUpdate.addColumn(new Cell(CellNames.compositeDense(bytes("v2")),
+            extraUpdate.addColumn(new Cell(update.metadata().comparator.makeCellName(bytes("v2")),
                                            bytes(999)));
             Mutation mutation = new Mutation(ksName, key);
             mutation.add(extraUpdate);

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -508,13 +508,13 @@ public static void mutate(Collection<? extends IMutation> mutations, Consistency
         }
     }
 
-    public static void mutateWithTriggers(Collection<? extends IMutation> mutations, ConsistencyLevel consistencyLevel, boolean mutateAtomically) throws WriteTimeoutException, UnavailableException,
-            OverloadedException, InvalidRequestException
+    public static void mutateWithTriggers(Collection<? extends IMutation> mutations, ConsistencyLevel consistencyLevel, boolean mutateAtomically)
+    throws WriteTimeoutException, UnavailableException, OverloadedException, InvalidRequestException
     {
         Collection<RowMutation> tmutations = TriggerExecutor.instance.execute(mutations);
         if (mutateAtomically || tmutations != null)
         {
-            Collection<RowMutation> allMutations = (Collection<RowMutation>) mutations;
+            Collection<RowMutation> allMutations = new ArrayList<>((Collection<RowMutation>) mutations);
             if (tmutations != null)
                 allMutations.addAll(tmutations);
             StorageProxy.mutateAtomically(allMutations, consistencyLevel);

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -1532,6 +1532,9 @@ public void toSchema(RowMutation rm, long timestamp)
     {
         toSchemaNoColumnsNoTriggers(rm, timestamp);
 
+        for (TriggerDefinition td : triggers.values())
+            td.toSchema(rm, cfName, timestamp);
+
         for (ColumnDefinition cd : column_metadata.values())
             cd.toSchema(rm, cfName, getColumnDefinitionComparator(cd), timestamp);
     }

File: src/java/org/apache/cassandra/tools/NodeProbe.java
Patch:
@@ -895,7 +895,7 @@ public int compare(Entry<String, ColumnFamilyStoreMBean> e1, Entry<String, Colum
 
                 // get CF name and split it for index name
                 String e1CF[] = e1.getValue().getColumnFamilyName().split("\\.");
-                String e2CF[] = e1.getValue().getColumnFamilyName().split("\\.");
+                String e2CF[] = e2.getValue().getColumnFamilyName().split("\\.");
                 assert e1CF.length <= 2 && e2CF.length <= 2 : "unexpected split count for column family name";
 
                 //if neither are indexes, just compare CF names

File: src/java/org/apache/cassandra/cql3/statements/CQL3CasConditions.java
Patch:
@@ -82,7 +82,8 @@ public IDiskAtomFilter readFilter()
         for (Map.Entry<ByteBuffer, RowCondition> entry : conditions.entrySet())
             slices[i++] = new ColumnSlice(entry.getKey(), entry.getValue().rowPrefix.buildAsEndOfRange());
 
-        return new SliceQueryFilter(slices, false, slices.length, cfm.clusteringKeyColumns().size());
+        int toGroup = cfm.getCfDef().isCompact ? -1 : cfm.clusteringKeyColumns().size();
+        return new SliceQueryFilter(slices, false, slices.length, toGroup);
     }
 
     public boolean appliesTo(ColumnFamily current) throws InvalidRequestException

File: src/java/org/apache/cassandra/thrift/THsHaDisruptorServer.java
Patch:
@@ -80,7 +80,8 @@ public TServer buildTServer(Args args)
 
             com.thinkaurelius.thrift.util.TBinaryProtocol.Factory protocolFactory = new com.thinkaurelius.thrift.util.TBinaryProtocol.Factory(true, true);
 
-            TDisruptorServer.Args serverArgs = new TDisruptorServer.Args(serverTransport).inputTransportFactory(args.inTransportFactory)
+            TDisruptorServer.Args serverArgs = new TDisruptorServer.Args(serverTransport).useHeapBasedAllocation(true)
+                                                                                         .inputTransportFactory(args.inTransportFactory)
                                                                                          .outputTransportFactory(args.outTransportFactory)
                                                                                          .inputProtocolFactory(protocolFactory)
                                                                                          .outputProtocolFactory(protocolFactory)

File: src/java/org/apache/cassandra/cql3/statements/CQL3CasConditions.java
Patch:
@@ -44,7 +44,7 @@ public class CQL3CasConditions implements CASConditions
     public CQL3CasConditions(CFMetaData cfm, long now)
     {
         this.cfm = cfm;
-        // We will use now for Column.isLive() which expects milliseconds but the argument is in microseconds.
+        // We will use now for Cell.isLive() which expects milliseconds but the argument is in microseconds.
         this.now = now / 1000;
         this.conditions = new TreeMap<>(cfm.comparator);
     }

File: src/java/org/apache/cassandra/cql3/statements/CQL3CasConditions.java
Patch:
@@ -43,7 +43,8 @@ public class CQL3CasConditions implements CASConditions
     public CQL3CasConditions(CFMetaData cfm, long now)
     {
         this.cfm = cfm;
-        this.now = now;
+        // We will use now for Column.isLive() which expects milliseconds but the argument is in microseconds.
+        this.now = now / 1000;
         this.conditions = new TreeMap<>(cfm.comparator);
     }
 

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -534,9 +534,7 @@ public ResultMessage executeWithCondition(QueryState queryState, QueryOptions op
 
         ByteBuffer key = keys.get(0);
 
-        // It's cleaner to use the query timestamp below, but it's in seconds while the conditions expects microseconds, so just
-        // put it back in millis (we don't really lose precision because the ultimate consumer, Column.isLive, re-divide it).
-        CQL3CasConditions conditions = new CQL3CasConditions(cfm, queryState.getTimestamp() * 1000);
+        CQL3CasConditions conditions = new CQL3CasConditions(cfm, queryState.getTimestamp());
         ColumnNameBuilder prefix = createClusteringPrefixBuilder(variables);
         ColumnFamily updates = UnsortedColumns.factory.create(cfm);
         addUpdatesAndConditions(key, prefix, updates, conditions, variables, getTimestamp(queryState.getTimestamp(), variables));

File: src/java/org/apache/cassandra/io/compress/CompressedSequentialWriter.java
Patch:
@@ -231,7 +231,7 @@ public synchronized void resetAndTruncate(FileMark mark)
 
         // truncate data and index file
         truncate(chunkOffset);
-        metadataWriter.resetAndTruncate(realMark.nextChunkIndex);
+        metadataWriter.resetAndTruncate(realMark.nextChunkIndex - 1);
     }
 
     /**

File: test/unit/org/apache/cassandra/io/compress/CompressedRandomAccessReaderTest.java
Patch:
@@ -29,6 +29,7 @@
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.io.sstable.CorruptSSTableException;
 import org.apache.cassandra.io.sstable.metadata.MetadataCollector;
+import org.apache.cassandra.io.sstable.metadata.StatsMetadata;
 import org.apache.cassandra.io.util.*;
 
 import static org.junit.Assert.assertEquals;
@@ -59,7 +60,7 @@ public void test6791() throws IOException, ConfigurationException
         try
         {
 
-            SSTableMetadata.Collector sstableMetadataCollector = SSTableMetadata.createCollector(BytesType.instance).replayPosition(null);
+            MetadataCollector sstableMetadataCollector = new MetadataCollector(new SimpleDenseCellNameType(BytesType.instance));
             CompressedSequentialWriter writer = new CompressedSequentialWriter(f, filename + ".metadata", false, new CompressionParameters(SnappyCompressor.instance, 32, Collections.<String, String>emptyMap()), sstableMetadataCollector);
 
             for (int i = 0; i < 20; i++)

File: src/java/org/apache/cassandra/io/compress/CompressedSequentialWriter.java
Patch:
@@ -231,7 +231,7 @@ public synchronized void resetAndTruncate(FileMark mark)
 
         // truncate data and index file
         truncate(chunkOffset);
-        metadataWriter.resetAndTruncate(realMark.nextChunkIndex);
+        metadataWriter.resetAndTruncate(realMark.nextChunkIndex - 1);
     }
 
     /**

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -508,7 +508,7 @@ else if (isColumnRange())
                     slices = new ColumnSlice[l.size()+1];
                     slices[0] = staticSlice;
                     for (int i = 0; i < l.size(); i++)
-                        slices[i] = l.get(i);
+                        slices[i+1] = l.get(i);
                 }
             }
             return sliceFilter(slices, limit, toGroup);

File: src/java/org/apache/cassandra/db/compaction/CompactionTask.java
Patch:
@@ -271,7 +271,7 @@ protected void runWith(File sstableDirectory) throws Exception
             mergedRows.put(rows, count);
         }
 
-        SystemKeyspace.updateCompactionHistory(cfs.keyspace.getName(), cfs.name, start, startsize, endsize, mergedRows);
+        SystemKeyspace.updateCompactionHistory(cfs.keyspace.getName(), cfs.name, System.currentTimeMillis(), startsize, endsize, mergedRows);
         logger.info(String.format("Compacted %d sstables to [%s].  %,d bytes to %,d (~%d%% of original) in %,dms = %fMB/s.  %,d total partitions merged to %,d.  Partition merge counts were {%s}",
                                   toCompact.size(), builder.toString(), startsize, endsize, (int) (ratio * 100), dTime, mbps, totalSourceRows, totalkeysWritten, mergeSummary.toString()));
         logger.debug(String.format("CF Total Bytes Compacted: %,d", CompactionTask.addToTotalBytesCompacted(endsize)));

File: src/java/org/apache/cassandra/db/composites/CompoundDenseCellNameType.java
Patch:
@@ -69,8 +69,7 @@ protected Composite makeWith(ByteBuffer[] components, int size, Composite.EOC eo
         if (size < fullSize || eoc != Composite.EOC.NONE)
             return new CompoundComposite(components, size, false).withEOC(eoc);
 
-        assert components.length == size;
-        return new CompoundDenseCellName(components);
+        return new CompoundDenseCellName(components, size);
     }
 
     protected Composite copyAndMakeWith(ByteBuffer[] components, int size, Composite.EOC eoc, boolean isStatic)

File: test/unit/org/apache/cassandra/service/QueryPagerTest.java
Patch:
@@ -169,7 +169,7 @@ private static void assertRow(Row r, String key, ByteBuffer... names)
                 continue;
 
             ByteBuffer expected = names[i++];
-            assertEquals("column " + i + " doesn't match: " + toString(r.cf), expected, c.name());
+            assertEquals("column " + i + " doesn't match: " + toString(r.cf), expected, c.name().toByteBuffer());
         }
     }
 
@@ -337,7 +337,7 @@ public void SliceQueryWithTombstoneTest() throws Exception
         String keyspace = "cql_keyspace";
         String table = "table2";
         ColumnFamilyStore cfs = Keyspace.open(keyspace).getColumnFamilyStore(table);
-        CompositeType ct = (CompositeType)cfs.metadata.comparator;
+        CompositeType ct = (CompositeType)cfs.metadata.comparator.asAbstractType();
 
         // Insert rows but with a tombstone as last cell
         for (int i = 0; i < 5; i++)

File: src/java/org/apache/cassandra/db/composites/AbstractCellNameType.java
Patch:
@@ -198,7 +198,7 @@ public ColumnToCollectionType collectionType()
         throw new UnsupportedOperationException();
     }
 
-    public CellNameType addCollection(ColumnIdentifier columnName, CollectionType newCollection)
+    public CellNameType addOrUpdateCollection(ColumnIdentifier columnName, CollectionType newCollection)
     {
         throw new UnsupportedOperationException();
     }

File: src/java/org/apache/cassandra/db/composites/CellNameType.java
Patch:
@@ -99,10 +99,10 @@ public interface CellNameType extends CType
     public ColumnToCollectionType collectionType();
 
     /**
-     * Return the new type obtained by adding the new collection type for the provided column name
+     * Return the new type obtained by adding/updating to the new collection type for the provided column name
      * to this type.
      */
-    public CellNameType addCollection(ColumnIdentifier columnName, CollectionType newCollection);
+    public CellNameType addOrUpdateCollection(ColumnIdentifier columnName, CollectionType newCollection);
 
     /**
      * Returns a new CellNameType that is equivalent to this one but with one

File: src/java/org/apache/cassandra/db/composites/CompoundSparseCellNameType.java
Patch:
@@ -122,7 +122,7 @@ public CellNameType setSubtype(int position, AbstractType<?> newType)
     }
 
     @Override
-    public CellNameType addCollection(ColumnIdentifier columnName, CollectionType newCollection)
+    public CellNameType addOrUpdateCollection(ColumnIdentifier columnName, CollectionType newCollection)
     {
         return new WithCollection(clusteringType, ColumnToCollectionType.getInstance(Collections.singletonMap(columnName.bytes, newCollection)), internedIds);
     }
@@ -244,7 +244,7 @@ public CellNameType setSubtype(int position, AbstractType<?> newType)
         }
 
         @Override
-        public CellNameType addCollection(ColumnIdentifier columnName, CollectionType newCollection)
+        public CellNameType addOrUpdateCollection(ColumnIdentifier columnName, CollectionType newCollection)
         {
             Map<ByteBuffer, CollectionType> newMap = new HashMap<>(collectionType.defined);
             newMap.put(columnName.bytes, newCollection);

File: src/java/org/apache/cassandra/db/marshal/ColumnToCollectionType.java
Patch:
@@ -121,7 +121,8 @@ public boolean isCompatibleWith(AbstractType<?> previous)
         // We are compatible if we have all the definitions previous have (but we can have more).
         for (Map.Entry<ByteBuffer, CollectionType> entry : prev.defined.entrySet())
         {
-            if (!entry.getValue().isCompatibleWith(defined.get(entry.getKey())))
+            CollectionType newType = defined.get(entry.getKey());
+            if (newType == null || !newType.isCompatibleWith(entry.getValue()))
                 return false;
         }
         return true;

File: src/java/org/apache/cassandra/db/marshal/AbstractCompositeType.java
Patch:
@@ -76,6 +76,8 @@ public int compare(ByteBuffer o1, ByteBuffer o2)
     {
         if (o1 == null || !o1.hasRemaining())
             return o2 == null || !o2.hasRemaining() ? 0 : -1;
+        if (o2 == null || !o2.hasRemaining())
+            return 1;
 
         ByteBuffer bb1 = o1.duplicate();
         ByteBuffer bb2 = o2.duplicate();

File: src/java/org/apache/cassandra/db/marshal/LongType.java
Patch:
@@ -47,7 +47,7 @@ public static int compareLongs(ByteBuffer o1, ByteBuffer o2)
             return 1;
         }
 
-        int diff = o1.get(o1.position() + o1.arrayOffset()) - o2.get(o2.position() + o2.arrayOffset());
+        int diff = o1.get(o1.position()) - o2.get(o2.position());
         if (diff != 0)
             return diff;
 

File: src/java/org/apache/cassandra/db/composites/AbstractCType.java
Patch:
@@ -90,6 +90,8 @@ public int compare(Composite c1, Composite c2)
     {
         if (c1 == null || c1.isEmpty())
             return c2 == null || c2.isEmpty() ? 0 : -1;
+        if (c2 == null || c2.isEmpty())
+            return 1;
 
         if (c1.isStatic() != c2.isStatic())
             return c1.isStatic() ? -1 : 1;

File: src/java/org/apache/cassandra/db/marshal/DateType.java
Patch:
@@ -92,7 +92,7 @@ public static long dateStringToTimestamp(String source) throws MarshalException
           millis = System.currentTimeMillis();
       }
       // Milliseconds since epoch?
-      else if (source.matches("^\\d+$"))
+      else if (source.matches("^-?\\d+$"))
       {
           try
           {

File: src/java/org/apache/cassandra/service/AntiEntropyService.java
Patch:
@@ -849,7 +849,7 @@ public void sendTreeRequests()
                 allEndpoints.add(FBUtilities.getBroadcastAddress());
 
                 if (isSequential)
-                    makeSnapshots(endpoints);
+                    makeSnapshots(allEndpoints);
 
                 for (InetAddress endpoint : allEndpoints)
                     treeRequests.add(new TreeRequest(getName(), endpoint, range, new CFPair(tablename, cfname)));

File: src/java/org/apache/cassandra/cql3/QueryProcessor.java
Patch:
@@ -45,7 +45,7 @@
 
 public class QueryProcessor
 {
-    public static final SemanticVersion CQL_VERSION = new SemanticVersion("3.1.4");
+    public static final SemanticVersion CQL_VERSION = new SemanticVersion("3.1.5");
 
     private static final Logger logger = LoggerFactory.getLogger(QueryProcessor.class);
     private static final MemoryMeter meter = new MemoryMeter().withGuessing(MemoryMeter.Guess.FALLBACK_BEST);

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -37,6 +37,7 @@
 import org.apache.cassandra.db.marshal.*;
 import org.apache.cassandra.dht.*;
 import org.apache.cassandra.exceptions.*;
+import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.QueryState;
 import org.apache.cassandra.service.StorageProxy;
@@ -165,7 +166,8 @@ public ResultMessage.Rows execute(QueryState state, QueryOptions options) throws
         int pageSize = options.getPageSize();
         // A count query will never be paged for the user, but we always page it internally to avoid OOM.
         // If we user provided a pageSize we'll use that to page internally (because why not), otherwise we use our default
-        if (parameters.isCount && pageSize <= 0)
+        // Note that if there are some nodes in the cluster with a version less than 2.0, we can't use paging (CASSANDRA-6707).
+        if (parameters.isCount && pageSize <= 0 && MessagingService.instance().allNodesAtLeast20)
             pageSize = DEFAULT_COUNT_PAGE_SIZE;
 
         if (pageSize <= 0 || command == null || !QueryPagers.mayNeedPaging(command, pageSize))

File: src/java/org/apache/cassandra/streaming/StreamManager.java
Patch:
@@ -59,7 +59,7 @@ public class StreamManager implements StreamManagerMBean
      */
     public static RateLimiter getRateLimiter()
     {
-        double currentThroughput = ((double) DatabaseDescriptor.getStreamThroughputOutboundMegabitsPerSec()) * 1024 * 1024 * 8;
+        double currentThroughput = (((double) DatabaseDescriptor.getStreamThroughputOutboundMegabitsPerSec()) * 1024 * 1024 ) / 8;
         // if throughput is set to 0, throttling is disabled
         if (currentThroughput == 0)
             currentThroughput = Double.MAX_VALUE;

File: src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java
Patch:
@@ -443,8 +443,8 @@ public void deleteFromIndexes(DecoratedKey key, List<Cell> indexedColumnsInRow,
         for (Cell cell : indexedColumnsInRow)
         {
             // TODO: this is probably incorrect, we should pull all indexes
-            baseCfs.metadata.getColumnDefinition(cell.name());
-            SecondaryIndex index = indexesByColumn.get(cDef.name);
+            ColumnDefinition cDef = baseCfs.metadata.getColumnDefinition(cell.name());
+            SecondaryIndex index = indexesByColumn.get(cDef.name.bytes);
             if (index == null)
                 continue;
 

File: src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java
Patch:
@@ -464,7 +464,8 @@ public void deleteFromIndexes(DecoratedKey key, List<IColumn> indexedColumnsInRo
 
         for (IColumn column : indexedColumnsInRow)
         {
-            SecondaryIndex index = indexesByColumn.get(column.name());
+            ColumnDefinition cDef = baseCfs.metadata.getColumnDefinitionFromColumnName(column.name());
+            SecondaryIndex index = indexesByColumn.get(cDef.name);
             if (index == null)
                 continue;
 

File: src/java/org/apache/cassandra/db/Mutation.java
Patch:
@@ -191,7 +191,7 @@ public void addAll(IMutation m)
             // not in the case where it wasn't there indeed.
             ColumnFamily cf = modifications.put(entry.getKey(), entry.getValue());
             if (cf != null)
-                entry.getValue().resolve(cf);
+                entry.getValue().addAll(cf);
         }
     }
 

File: src/java/org/apache/cassandra/db/SystemKeyspace.java
Patch:
@@ -810,7 +810,7 @@ public static PaxosState loadPaxosState(ByteBuffer key, CFMetaData metadata)
             return new PaxosState(key, metadata);
         UntypedResultSet.Row row = results.one();
         Commit promised = row.has("in_progress_ballot")
-                        ? new Commit(key, row.getUUID("in_progress_ballot"), EmptyColumns.factory.create(metadata))
+                        ? new Commit(key, row.getUUID("in_progress_ballot"), ArrayBackedSortedColumns.factory.create(metadata))
                         : Commit.emptyCommit(key, metadata);
         // either we have both a recently accepted ballot and update or we have neither
         Commit accepted = row.has("proposal")

File: src/java/org/apache/cassandra/db/columniterator/IndexedSliceReader.java
Patch:
@@ -77,7 +77,7 @@ public IndexedSliceReader(SSTableReader sstable, RowIndexEntry indexEntry, FileD
         try
         {
             this.indexes = indexEntry.columnsIndex();
-            emptyColumnFamily = EmptyColumns.factory.create(sstable.metadata);
+            emptyColumnFamily = ArrayBackedSortedColumns.factory.create(sstable.metadata);
             if (indexes.isEmpty())
             {
                 setToRowStart(indexEntry, input);

File: src/java/org/apache/cassandra/db/columniterator/SimpleSliceReader.java
Patch:
@@ -71,7 +71,7 @@ public SimpleSliceReader(SSTableReader sstable, RowIndexEntry indexEntry, FileDa
             if (version.hasRowSizeAndColumnCount)
                 file.readLong();
 
-            emptyColumnFamily = EmptyColumns.factory.create(sstable.metadata);
+            emptyColumnFamily = ArrayBackedSortedColumns.factory.create(sstable.metadata);
             emptyColumnFamily.delete(DeletionTime.serializer.deserialize(file));
             int columnCount = version.hasRowSizeAndColumnCount ? file.readInt() : Integer.MAX_VALUE;
             atomIterator = emptyColumnFamily.metadata().getOnDiskIterator(file, columnCount, sstable.descriptor.version);

File: src/java/org/apache/cassandra/db/compaction/LazilyCompactedRow.java
Patch:
@@ -81,7 +81,7 @@ public LazilyCompactedRow(CompactionController controller, List<? extends OnDisk
         // containing `key` outside of the set of sstables involved in this compaction.
         maxPurgeableTimestamp = controller.maxPurgeableTimestamp(key);
 
-        emptyColumnFamily = EmptyColumns.factory.create(controller.cfs.metadata);
+        emptyColumnFamily = ArrayBackedSortedColumns.factory.create(controller.cfs.metadata);
         emptyColumnFamily.delete(maxRowTombstone);
         if (maxRowTombstone.markedForDeleteAt < maxPurgeableTimestamp)
             emptyColumnFamily.purgeTombstones(controller.gcBefore);

File: src/java/org/apache/cassandra/db/index/composites/CompositesSearcher.java
Patch:
@@ -274,7 +274,7 @@ else if (!currentKey.equals(dk))
 
                         if (data == null)
                             data = ArrayBackedSortedColumns.factory.create(baseCfs.metadata);
-                        data.resolve(newData);
+                        data.addAll(newData);
                         columnsCount += dataFilter.lastCounted();
                     }
                  }

File: src/java/org/apache/cassandra/io/sstable/SSTableIdentityIterator.java
Patch:
@@ -99,7 +99,7 @@ private SSTableIdentityIterator(CFMetaData metadata,
 
         try
         {
-            columnFamily = EmptyColumns.factory.create(metadata);
+            columnFamily = ArrayBackedSortedColumns.factory.create(metadata);
             columnFamily.delete(DeletionTime.serializer.deserialize(in));
             columnCount = dataVersion.hasRowSizeAndColumnCount ? in.readInt() : Integer.MAX_VALUE;
             atomIterator = columnFamily.metadata().getOnDiskIterator(in, columnCount, dataVersion);

File: src/java/org/apache/cassandra/service/ReadCallback.java
Patch:
@@ -98,10 +98,8 @@ public TResolved get() throws ReadTimeoutException, DigestMismatchException
         if (!await(command.getTimeout(), TimeUnit.MILLISECONDS))
         {
             // Same as for writes, see AbstractWriteResponseHandler
-            int acks = received;
-            if (resolver.isDataPresent() && acks >= blockfor)
-                acks = blockfor - 1;
             ReadTimeoutException ex = new ReadTimeoutException(consistencyLevel, received, blockfor, resolver.isDataPresent());
+
             if (logger.isDebugEnabled())
                 logger.debug("Read timeout: {}", ex.toString());
             throw ex;

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -232,7 +232,7 @@ public static ColumnFamily cas(String keyspaceName,
             {
                 Tracing.trace("CAS precondition {} does not match current values {}", conditions, current);
                 // We should not return null as this means success
-                return current == null ? EmptyColumns.factory.create(metadata) : current;
+                return current == null ? ArrayBackedSortedColumns.factory.create(metadata) : current;
             }
 
             // finish the paxos round w/ the desired updates
@@ -603,7 +603,7 @@ private static void syncWriteToBatchlog(Collection<Mutation> mutations, Collecti
 
     private static void asyncRemoveFromBatchlog(Collection<InetAddress> endpoints, UUID uuid)
     {
-        ColumnFamily cf = EmptyColumns.factory.create(Schema.instance.getCFMetaData(Keyspace.SYSTEM_KS, SystemKeyspace.BATCHLOG_CF));
+        ColumnFamily cf = ArrayBackedSortedColumns.factory.create(Schema.instance.getCFMetaData(Keyspace.SYSTEM_KS, SystemKeyspace.BATCHLOG_CF));
         cf.delete(new DeletionInfo(FBUtilities.timestampMicros(), (int) (System.currentTimeMillis() / 1000)));
         AbstractWriteResponseHandler handler = new WriteResponseHandler(endpoints,
                                                                         Collections.<InetAddress>emptyList(),

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -843,7 +843,6 @@ else if (frac > 1.0)
             if (!current.isEmpty())
                 for (InetAddress existing : current)
                     Gossiper.instance.replacedEndpoint(existing);
-            logger.info("Startup completed! Now serving reads.");
             assert tokenMetadata.sortedTokens().size() > 0;
 
             Auth.setup();

File: src/java/org/apache/cassandra/service/pager/QueryPagers.java
Patch:
@@ -147,7 +147,7 @@ public ColumnFamily next()
                 {
                     List<Row> rows = pager.fetchPage(pageSize);
                     ColumnFamily cf = rows.isEmpty() ? null : rows.get(0).cf;
-                    return cf == null ? EmptyColumns.factory.create(cfs.metadata) : cf;
+                    return cf == null ? ArrayBackedSortedColumns.factory.create(cfs.metadata) : cf;
                 }
                 catch (Exception e)
                 {

File: src/java/org/apache/cassandra/service/paxos/Commit.java
Patch:
@@ -57,7 +57,7 @@ public Commit(ByteBuffer key, UUID ballot, ColumnFamily update)
 
     public static Commit newPrepare(ByteBuffer key, CFMetaData metadata, UUID ballot)
     {
-        return new Commit(key, ballot, EmptyColumns.factory.create(metadata));
+        return new Commit(key, ballot, ArrayBackedSortedColumns.factory.create(metadata));
     }
 
     public static Commit newProposal(ByteBuffer key, UUID ballot, ColumnFamily update)
@@ -67,7 +67,7 @@ public static Commit newProposal(ByteBuffer key, UUID ballot, ColumnFamily updat
 
     public static Commit emptyCommit(ByteBuffer key, CFMetaData metadata)
     {
-        return new Commit(key, UUIDGen.minTimeUUID(0), EmptyColumns.factory.create(metadata));
+        return new Commit(key, UUIDGen.minTimeUUID(0), ArrayBackedSortedColumns.factory.create(metadata));
     }
 
     public boolean isAfter(Commit other)

File: test/unit/org/apache/cassandra/db/RowTest.java
Patch:
@@ -59,7 +59,7 @@ public void testResolve()
         cf2.addColumn(column("one", "B", 1));
         cf2.addColumn(column("two", "C", 1));
 
-        cf1.resolve(cf2);
+        cf1.addAll(cf2);
         assert Arrays.equals(cf1.getColumn(CellNames.simpleDense(ByteBufferUtil.bytes("one"))).value().array(), "B".getBytes());
         assert Arrays.equals(cf1.getColumn(CellNames.simpleDense(ByteBufferUtil.bytes("two"))).value().array(), "C".getBytes());
     }

File: tools/stress/src/org/apache/cassandra/stress/generatedata/DataGenStringDictionary.java
Patch:
@@ -27,17 +27,17 @@ public DataGenStringDictionary(EnumeratedDistribution<byte[]> wordDistribution)
     @Override
     public void generate(ByteBuffer fill, long index, ByteBuffer seed)
     {
-        fill(fill, 0);
+        fill(fill);
     }
 
     @Override
     public void generate(List<ByteBuffer> fills, long index, ByteBuffer seed)
     {
         for (int i = 0 ; i < fills.size() ; i++)
-            fill(fills.get(0), i);
+            fill(fills.get(0));
     }
 
-    private void fill(ByteBuffer fill, int column)
+    private void fill(ByteBuffer fill)
     {
         fill.clear();
         byte[] trg = fill.array();

File: tools/stress/src/org/apache/cassandra/stress/generatedata/DataGenStringRepeats.java
Patch:
@@ -50,7 +50,7 @@ private void fill(ByteBuffer fill, long index, int column, ByteBuffer seed)
 
     private byte[] getData(long index, int column, ByteBuffer seed)
     {
-        final long key = (column * repeatFrequency) + ((seed == null ? index : Math.abs(seed.hashCode())) % repeatFrequency);
+        final long key = ((long)column * repeatFrequency) + ((seed == null ? index : Math.abs(seed.hashCode())) % repeatFrequency);
         byte[] r = cache.get(key);
         if (r != null)
             return r;

File: tools/stress/src/org/apache/cassandra/stress/generatedata/DataGen.java
Patch:
@@ -6,13 +6,13 @@
 public abstract class DataGen
 {
 
-    public abstract void generate(ByteBuffer fill, long offset);
+    public abstract void generate(ByteBuffer fill, long index, ByteBuffer seed);
     public abstract boolean isDeterministic();
 
-    public void generate(List<ByteBuffer> fills, long offset)
+    public void generate(List<ByteBuffer> fills, long index, ByteBuffer seed)
     {
         for (ByteBuffer fill : fills)
-            generate(fill, offset++);
+            generate(fill, index++, seed);
     }
 
 }

File: tools/stress/src/org/apache/cassandra/stress/generatedata/DataGenBytesRandom.java
Patch:
@@ -9,7 +9,7 @@ public class DataGenBytesRandom extends DataGen
     private final Random rnd = new Random();
 
     @Override
-    public void generate(ByteBuffer fill, long offset)
+    public void generate(ByteBuffer fill, long index, ByteBuffer seed)
     {
         fill.clear();
         rnd.nextBytes(fill.array());

File: tools/stress/src/org/apache/cassandra/stress/generatedata/DataGenHex.java
Patch:
@@ -8,7 +8,7 @@ public abstract class DataGenHex extends DataGen
     abstract long next(long operationIndex);
 
     @Override
-    public final void generate(ByteBuffer fill, long operationIndex)
+    public final void generate(ByteBuffer fill, long operationIndex, ByteBuffer seed)
     {
         fill.clear();
         fillKeyStringBytes(next(operationIndex), fill.array());

File: tools/stress/src/org/apache/cassandra/stress/generatedata/DataGenStringDictionary.java
Patch:
@@ -25,13 +25,13 @@ public DataGenStringDictionary(EnumeratedDistribution<byte[]> wordDistribution)
     }
 
     @Override
-    public void generate(ByteBuffer fill, long index)
+    public void generate(ByteBuffer fill, long index, ByteBuffer seed)
     {
         fill(fill, 0);
     }
 
     @Override
-    public void generate(List<ByteBuffer> fills, long index)
+    public void generate(List<ByteBuffer> fills, long index, ByteBuffer seed)
     {
         for (int i = 0 ; i < fills.size() ; i++)
             fill(fills.get(0), i);
@@ -55,7 +55,7 @@ private void fill(ByteBuffer fill, int column)
     @Override
     public boolean isDeterministic()
     {
-        return true;
+        return false;
     }
 
     public static DataGenFactory getFactory(File file) throws IOException

File: tools/stress/src/org/apache/cassandra/stress/generatedata/KeyGen.java
Patch:
@@ -21,7 +21,7 @@ public List<ByteBuffer> getKeys(int n, long index)
     {
         while (keyBuffers.size() < n)
             keyBuffers.add(ByteBuffer.wrap(new byte[keySize]));
-        dataGen.generate(keyBuffers, index);
+        dataGen.generate(keyBuffers, index, null);
         return keyBuffers;
     }
 

File: tools/stress/src/org/apache/cassandra/stress/generatedata/RowGen.java
Patch:
@@ -16,10 +16,10 @@ protected RowGen(DataGen dataGenerator)
         this.dataGen = dataGenerator;
     }
 
-    public List<ByteBuffer> generate(long operationIndex)
+    public List<ByteBuffer> generate(long operationIndex, ByteBuffer key)
     {
         List<ByteBuffer> fill = getColumns(operationIndex);
-        dataGen.generate(fill, operationIndex);
+        dataGen.generate(fill, operationIndex, key);
         return fill;
     }
 

File: tools/stress/src/org/apache/cassandra/stress/operations/CqlIndexedRangeSlicer.java
Patch:
@@ -70,7 +70,7 @@ protected String buildQuery()
     protected void run(CqlOperation.ClientWrapper client) throws IOException
     {
         acceptNoResults = false;
-        final List<ByteBuffer> columns = generateColumnValues();
+        final List<ByteBuffer> columns = generateColumnValues(getKey());
         final ByteBuffer value = columns.get(1); // only C1 column is indexed
         byte[] minKey = new byte[0];
         int rowCount;

File: tools/stress/src/org/apache/cassandra/stress/operations/CqlInserter.java
Patch:
@@ -72,7 +72,7 @@ protected String buildQuery()
     protected List<ByteBuffer> getQueryParameters(byte[] key)
     {
         final ArrayList<ByteBuffer> queryParams = new ArrayList<>();
-        final List<ByteBuffer> values = generateColumnValues();
+        final List<ByteBuffer> values = generateColumnValues(ByteBuffer.wrap(key));
         queryParams.addAll(values);
         queryParams.add(ByteBuffer.wrap(key));
         return queryParams;

File: tools/stress/src/org/apache/cassandra/stress/operations/ThriftCounterAdder.java
Patch:
@@ -39,7 +39,7 @@ public ThriftCounterAdder(State state, long index)
 
     public void run(final ThriftClient client) throws IOException
     {
-        List<CounterColumn> columns = new ArrayList<CounterColumn>();
+        List<CounterColumn> columns = new ArrayList<>();
         for (int i = 0; i < state.settings.columns.maxColumnsPerKey; i++)
             columns.add(new CounterColumn(getColumnNameBytes(i), 1L));
 

File: tools/stress/src/org/apache/cassandra/stress/operations/ThriftIndexedRangeSlicer.java
Patch:
@@ -49,7 +49,7 @@ public void run(final ThriftClient client) throws IOException
                 .setSlice_range(new SliceRange(ByteBufferUtil.EMPTY_BYTE_BUFFER,
                         ByteBufferUtil.EMPTY_BYTE_BUFFER,
                         false, state.settings.columns.maxColumnsPerKey));
-        final List<ByteBuffer> columns = generateColumnValues();
+        final List<ByteBuffer> columns = generateColumnValues(getKey());
         final ColumnParent parent = state.columnParents.get(0);
 
         final ByteBuffer columnName = getColumnNameBytes(1);

File: tools/stress/src/org/apache/cassandra/stress/operations/ThriftInserter.java
Patch:
@@ -42,7 +42,7 @@ public ThriftInserter(State state, long index)
     public void run(final ThriftClient client) throws IOException
     {
         final ByteBuffer key = getKey();
-        final List<Column> columns = generateColumns();
+        final List<Column> columns = generateColumns(key);
 
         Map<String, List<Mutation>> row;
         if (!state.settings.columns.useSuperColumns)
@@ -92,9 +92,9 @@ public int keyCount()
         });
     }
 
-    protected List<Column> generateColumns()
+    protected List<Column> generateColumns(ByteBuffer key)
     {
-        final List<ByteBuffer> values = generateColumnValues();
+        final List<ByteBuffer> values = generateColumnValues(key);
         final List<Column> columns = new ArrayList<>(values.size());
 
         if (state.settings.columns.useTimeUUIDComparator)

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -302,7 +302,7 @@ public void runMayThrow() throws Exception
      *
      * @param cfs
      * @param ranges Ranges that the repair was carried out on
-     * @param validatedForRepair SSTables containing the repaired ranges
+     * @param validatedForRepair SSTables containing the repaired ranges. Should be referenced before passing them.
      * @throws InterruptedException, ExecutionException, IOException
      */
     public void performAnticompaction(ColumnFamilyStore cfs,

File: test/unit/org/apache/cassandra/db/compaction/AntiCompactionTest.java
Patch:
@@ -70,6 +70,7 @@ public void antiCompactOne() throws InterruptedException, ExecutionException, IO
         Range<Token> range = new Range<Token>(new BytesToken("0".getBytes()), new BytesToken("4".getBytes()));
         List<Range<Token>> ranges = Arrays.asList(range);
 
+        SSTableReader.acquireReferences(sstables);
         long repairedAt = 1000;
         CompactionManager.instance.performAnticompaction(store, ranges, sstables, repairedAt);
 

File: test/unit/org/apache/cassandra/db/CleanupTest.java
Patch:
@@ -64,8 +64,7 @@ public class CleanupTest extends SchemaLoader
     @Test
     public void testCleanup() throws IOException, ExecutionException, InterruptedException, ConfigurationException
     {
-        StorageService.instance.initServer(0);
-
+        StorageService.instance.getTokenMetadata().clearUnsafe();
         Table table = Table.open(TABLE1);
         ColumnFamilyStore cfs = table.getColumnFamilyStore(CF2);
 

File: test/unit/org/apache/cassandra/db/CleanupTest.java
Patch:
@@ -64,8 +64,7 @@ public class CleanupTest extends SchemaLoader
     @Test
     public void testCleanup() throws IOException, ExecutionException, InterruptedException, ConfigurationException
     {
-        StorageService.instance.initServer(0);
-
+        StorageService.instance.getTokenMetadata().clearUnsafe();
         Table table = Table.open(TABLE1);
         ColumnFamilyStore cfs = table.getColumnFamilyStore(CF2);
 

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -926,8 +926,8 @@ else if (obj == null || obj.getClass() != getClass())
         if (indexInterval != rhs.indexInterval) return false;
         if (!Objects.equal(speculativeRetry, rhs.speculativeRetry)) return false;
         if (populateIoCacheOnFlush != rhs.populateIoCacheOnFlush) return false;
-        if (Objects.equal(droppedColumns, rhs.droppedColumns)) return false;
-        if (Objects.equal(triggers, rhs.triggers)) return false;
+        if (!Objects.equal(droppedColumns, rhs.droppedColumns)) return false;
+        if (!Objects.equal(triggers, rhs.triggers)) return false;
         if (!Objects.equal(rowsPerPartitionToCache, rhs.rowsPerPartitionToCache)) return false;
         return true;
     }

File: test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest.java
Patch:
@@ -108,6 +108,7 @@ public void newTestWriteEndpointsDuringLeave() throws Exception
                 valueFactory.leaving(Collections.singleton(endpointTokens.get(LEAVING_NODE))));
         assertTrue(tmd.isLeaving(hosts.get(LEAVING_NODE)));
 
+        Thread.sleep(100); // because there is a tight race between submit and blockUntilFinished
         PendingRangeCalculatorService.instance.blockUntilFinished();
 
         AbstractReplicationStrategy strategy;

File: src/java/org/apache/cassandra/db/ColumnFamilyStoreMBean.java
Patch:
@@ -194,7 +194,7 @@ public interface ColumnFamilyStoreMBean
 
     /**
      * @see org.apache.cassandra.metrics.ColumnFamilyMetrics#meanRowSize
-     * @return the size of the smallest compacted row
+     * @return the average row size across all the sstables
      */
     @Deprecated
     public long getMeanRowSize();

File: src/java/org/apache/cassandra/metrics/ColumnFamilyMetrics.java
Patch:
@@ -213,8 +213,9 @@ public Long value()
                 long count = 0;
                 for (SSTableReader sstable : cfs.getSSTables())
                 {
-                    sum += sstable.getEstimatedRowSize().mean();
-                    count++;
+                    long n = sstable.getEstimatedRowSize().count();
+                    sum += sstable.getEstimatedRowSize().mean() * n;
+                    count += n;
                 }
                 return count > 0 ? sum / count : 0;
             }

File: src/java/org/apache/cassandra/service/MigrationManager.java
Patch:
@@ -137,8 +137,9 @@ private static boolean shouldPullSchemaFrom(InetAddress endpoint)
          * Don't request schema from nodes with a higher major (may have incompatible schema)
          * Don't request schema from fat clients
          */
-        return MessagingService.instance().getVersion(endpoint) <= MessagingService.current_version
-            && !Gossiper.instance.isFatClient(endpoint);
+        return MessagingService.instance().knowsVersion(endpoint)
+                && MessagingService.instance().getVersion(endpoint) <= MessagingService.current_version
+                && !Gossiper.instance.isFatClient(endpoint);
     }
 
     public static boolean isReadyForBootstrap()

File: src/java/org/apache/cassandra/utils/concurrent/WaitQueue.java
Patch:
@@ -111,15 +111,15 @@ public boolean signal()
      */
     public void signalAll()
     {
-        if (!hasWaiters())
+        RegisteredSignal last = queue.peekLast();
+        if (last == null)
             return;
         List<Thread> woke = null;
         if (logger.isTraceEnabled())
             woke = new ArrayList<>();
         long start = System.nanoTime();
         // we wake up only a snapshot of the queue, to avoid a race where the condition is not met and the woken thread
         // immediately waits on the queue again
-        RegisteredSignal last = queue.getLast();
         Iterator<RegisteredSignal> iter = queue.iterator();
         while (iter.hasNext())
         {

File: src/java/org/apache/cassandra/db/index/composites/CompositesSearcher.java
Patch:
@@ -65,7 +65,7 @@ private IndexExpression highestSelectivityPredicate(List<IndexExpression> clause
                 continue;
 
             SecondaryIndex index = indexManager.getIndexForColumn(expression.column_name);
-            if (index == null || (expression.op != IndexOperator.EQ))
+            if (index == null || index.getIndexCfs() == null || (expression.op != IndexOperator.EQ))
                 continue;
             int columns = index.getIndexCfs().getMeanColumns();
             candidates.put(index, columns);
@@ -106,6 +106,7 @@ public ColumnFamilyStore.AbstractScanIterator getIndexedIterator(final AbstractB
         final IndexExpression primary = highestSelectivityPredicate(filter.getClause());
         final SecondaryIndex index = indexManager.getIndexForColumn(primary.column_name);
         assert index != null;
+        assert index.getIndexCfs() != null;
         final DecoratedKey indexKey = index.getIndexKeyFor(primary.value);
 
         if (logger.isDebugEnabled())

File: src/java/org/apache/cassandra/db/index/keys/KeysSearcher.java
Patch:
@@ -61,7 +61,7 @@ private IndexExpression highestSelectivityPredicate(List<IndexExpression> clause
                 continue;
 
             SecondaryIndex index = indexManager.getIndexForColumn(expression.column_name);
-            if (index == null || (expression.op != IndexOperator.EQ))
+            if (index == null || index.getIndexCfs() == null || (expression.op != IndexOperator.EQ))
                 continue;
             int columns = index.getIndexCfs().getMeanColumns();
             candidates.put(index, columns);
@@ -102,6 +102,7 @@ public ColumnFamilyStore.AbstractScanIterator getIndexedIterator(final AbstractB
         final IndexExpression primary = highestSelectivityPredicate(filter.getClause());
         final SecondaryIndex index = indexManager.getIndexForColumn(primary.column_name);
         assert index != null;
+        assert index.getIndexCfs() != null;
         final DecoratedKey indexKey = index.getIndexKeyFor(primary.value);
 
         if (logger.isDebugEnabled())

File: src/java/org/apache/cassandra/db/index/SecondaryIndexSearcher.java
Patch:
@@ -63,7 +63,7 @@ protected IndexExpression highestSelectivityPredicate(List<IndexExpression> clau
                 continue;
 
             SecondaryIndex index = indexManager.getIndexForColumn(expression.column_name);
-            if (index == null || (expression.op != IndexOperator.EQ))
+            if (index == null || index.getIndexCfs() == null || expression.op != IndexOperator.EQ)
                 continue;
             int columns = index.getIndexCfs().getMeanColumns();
             candidates.put(index, columns);

File: src/java/org/apache/cassandra/db/index/composites/CompositesSearcher.java
Patch:
@@ -80,6 +80,7 @@ private ColumnFamilyStore.AbstractScanIterator getIndexedIterator(final Extended
         final IndexExpression primary = highestSelectivityPredicate(filter.getClause());
         final CompositesIndex index = (CompositesIndex)indexManager.getIndexForColumn(primary.column_name);
         assert index != null;
+        assert index.getIndexCfs() != null;
         final DecoratedKey indexKey = index.getIndexKeyFor(primary.value);
 
         if (logger.isDebugEnabled())

File: src/java/org/apache/cassandra/db/index/keys/KeysSearcher.java
Patch:
@@ -63,6 +63,7 @@ private ColumnFamilyStore.AbstractScanIterator getIndexedIterator(final Extended
         final IndexExpression primary = highestSelectivityPredicate(filter.getClause());
         final SecondaryIndex index = indexManager.getIndexForColumn(primary.column_name);
         assert index != null;
+        assert index.getIndexCfs() != null;
         final DecoratedKey indexKey = index.getIndexKeyFor(primary.value);
 
         if (logger.isDebugEnabled())

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -346,7 +346,8 @@ public void stopNativeTransport()
         {
             throw new IllegalStateException("No configured daemon");
         }
-        daemon.nativeServer.stop();
+        if (daemon.nativeServer != null)
+            daemon.nativeServer.stop();
     }
 
     public boolean isNativeTransportRunning()

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -148,7 +148,7 @@ public static void initLog4j()
     protected void setup()
     {
         // log warnings for different kinds of sub-optimal JVMs.  tldr use 64-bit Oracle >= 1.6u32
-        if (!System.getProperty("os.arch").contains("64"))
+        if (!DatabaseDescriptor.hasLargeAddressSpace())
             logger.info("32bit JVM detected.  It is recommended to run Cassandra on a 64bit JVM for better performance.");
         String javaVersion = System.getProperty("java.version");
         String javaVmName = System.getProperty("java.vm.name");

File: src/java/org/apache/cassandra/db/context/CounterContext.java
Patch:
@@ -763,7 +763,7 @@ public void copyTo(ContextState other)
             if (currentIsGlobal)
                 other.context.putShort(other.context.position() + other.headerOffset, (short) (other.getElementIndex() + Short.MIN_VALUE));
             else if (currentIsLocal)
-                context.putShort(other.context.position() + other.headerOffset, (short) other.getElementIndex());
+                other.context.putShort(other.context.position() + other.headerOffset, (short) other.getElementIndex());
 
             other.currentIsGlobal = currentIsGlobal;
             other.currentIsLocal = currentIsLocal;

File: src/java/org/apache/cassandra/db/compaction/PrecompactedRow.java
Patch:
@@ -126,7 +126,7 @@ public void reduce(Column column)
                 // notify the index that the column has been overwritten if the value being reduced has been
                 // superceded by another directly, or indirectly by a range tombstone
                 if ((!column.isMarkedForDelete(System.currentTimeMillis()) && !container.getColumn(column.name()).equals(column))
-                    || returnCF.deletionInfo().isDeleted(column.name(), CompactionManager.NO_GC))
+                    || returnCF.deletionInfo().isDeleted(column))
                 {
                     indexer.remove(column);
                 }

File: test/unit/org/apache/cassandra/locator/DynamicEndpointSnitchTest.java
Patch:
@@ -35,7 +35,7 @@ public class DynamicEndpointSnitchTest
     public void testSnitch() throws InterruptedException, IOException, ConfigurationException
     {
         // do this because SS needs to be initialized before DES can work properly.
-        StorageService.instance.initClient();
+        StorageService.instance.initClient(0);
         int sleeptime = 150;
         SimpleSnitch ss = new SimpleSnitch();
         DynamicEndpointSnitch dsnitch = new DynamicEndpointSnitch(ss, String.valueOf(ss.hashCode()));

File: test/unit/org/apache/cassandra/service/InitClientTest.java
Patch:
@@ -30,6 +30,6 @@ public class InitClientTest // extends CleanupHelper
     @Test
     public void testInitClientStartup() throws IOException, ConfigurationException
     {
-        StorageService.instance.initClient();
+        StorageService.instance.initClient(0);
     }
 }

File: test/unit/org/apache/cassandra/service/StorageServiceClientTest.java
Patch:
@@ -35,7 +35,7 @@ public void testClientOnlyMode() throws IOException, ConfigurationException
     {
         SchemaLoader.mkdirs();
         SchemaLoader.cleanup();
-        StorageService.instance.initClient();
+        StorageService.instance.initClient(0);
 
         // verify that no storage directories were created.
         for (String path : DatabaseDescriptor.getAllDataFileLocations())

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -119,7 +119,7 @@ public long measureForPreparedCache(MemoryMeter meter)
              + meter.measureDeep(keyRestrictions)
              + meter.measureDeep(columnRestrictions)
              + meter.measureDeep(metadataRestrictions)
-             + meter.measureDeep(restrictedNames)
+             + meter.measureDeep(restrictedColumns)
              + (sliceRestriction == null ? 0 : meter.measureDeep(sliceRestriction))
              + (orderingIndexes == null ? 0 : meter.measureDeep(orderingIndexes));
     }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -77,7 +77,6 @@
 import org.apache.cassandra.service.StorageService;
 
 import org.apache.cassandra.streaming.StreamLockfile;
-import org.apache.cassandra.thrift.IndexExpression;
 import org.apache.cassandra.tracing.Tracing;
 import org.apache.cassandra.utils.*;
 

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -491,7 +491,7 @@ public boolean accept(File pathname)
             }
         }
 
-        logger.debug("Removing compacted SSTable files from {} (see http://wiki.apache.org/cassandra/MemtableSSTable)", columnFamily);
+        logger.debug("Removing compacted SSTable files from {} (see http://wiki.apache.org/cassandra/MemtableSSTable)", metadata.cfName);
 
         for (Map.Entry<Descriptor,Set<Component>> sstableFiles : directories.sstableLister().list().entrySet())
         {

File: src/java/org/apache/cassandra/streaming/messages/StreamMessage.java
Patch:
@@ -40,7 +40,8 @@ public static void serialize(StreamMessage message, WritableByteChannel out, int
         // message type
         buff.put(message.type.type);
         buff.flip();
-        out.write(buff);
+        while (buff.hasRemaining())
+            out.write(buff);
         message.type.serializer.serialize(message, out, version, session);
     }
 

File: src/java/org/apache/cassandra/utils/CLibrary.java
Patch:
@@ -60,11 +60,11 @@ public final class CLibrary
         }
         catch (NoClassDefFoundError e)
         {
-            logger.warn("JNA not found. Native methods will be disabled.");
+            logger.info("JNA not found. Native methods will be disabled.");
         }
         catch (UnsatisfiedLinkError e)
         {
-            logger.warn("JNA link failure, one or more native method will be unavailable.");
+            logger.info("JNA link failure, one or more native method will be unavailable.");
             logger.debug("JNA link failure details: {}", e.getMessage());
         }
         catch (NoSuchMethodError e)

File: src/java/org/apache/cassandra/cql3/statements/BatchStatement.java
Patch:
@@ -139,7 +139,7 @@ public ParsedStatement.Prepared prepare(ColumnSpecification[] boundNames) throws
 
     public ParsedStatement.Prepared prepare() throws InvalidRequestException
     {
-        CFDefinition.Name[] boundNames = new CFDefinition.Name[getBoundTerms()];
+        ColumnSpecification[] boundNames = new ColumnSpecification[getBoundTerms()];
         return prepare(boundNames);
     }
 

File: src/java/org/apache/cassandra/io/util/FileUtils.java
Patch:
@@ -450,7 +450,7 @@ public static void handleFSError(FSError e)
 
     /**
      * Get the size of a directory in bytes
-     * @param The directory for which we need size.
+     * @param directory The directory for which we need size.
      * @return The size of the directory
      */
     public static long folderSize(File directory)

File: src/java/org/apache/cassandra/utils/CLibrary.java
Patch:
@@ -60,11 +60,11 @@ public final class CLibrary
         }
         catch (NoClassDefFoundError e)
         {
-            logger.info("JNA not found. Native methods will be disabled.");
+            logger.warn("JNA not found. Native methods will be disabled.");
         }
         catch (UnsatisfiedLinkError e)
         {
-            logger.info("JNA link failure, one or more native method will be unavailable.");
+            logger.warn("JNA link failure, one or more native method will be unavailable.");
             logger.debug("JNA link failure details: {}", e.getMessage());
         }
         catch (NoSuchMethodError e)

File: src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java
Patch:
@@ -69,7 +69,7 @@ public void checkAccess(ClientState state) throws UnauthorizedException, Invalid
     public void validate(ClientState state) throws RequestValidationException
     {
         CFMetaData cfm = ThriftValidation.validateColumnFamily(keyspace(), columnFamily());
-        if (cfm.getDefaultValidator().isCommutative())
+        if (cfm.isCounter())
             throw new InvalidRequestException("Secondary indexes are not supported on counter tables");
 
         ColumnDefinition cd = cfm.getColumnDefinition(target.column);

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -91,7 +91,7 @@ public String columnFamily()
 
     public boolean isCounter()
     {
-        return cfm.getDefaultValidator().isCommutative();
+        return cfm.isCounter();
     }
 
     public long getTimestamp(long now, List<ByteBuffer> variables) throws InvalidRequestException

File: src/java/org/apache/cassandra/db/ColumnFamily.java
Patch:
@@ -125,7 +125,7 @@ public void addColumn(CellName name, ByteBuffer value, long timestamp)
 
     public void addColumn(CellName name, ByteBuffer value, long timestamp, int timeToLive)
     {
-        assert !metadata().getDefaultValidator().isCommutative();
+        assert !metadata().isCounter();
         Cell cell = Cell.create(name, value, timestamp, timeToLive, metadata());
         addColumn(cell);
     }

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -616,7 +616,7 @@ private static abstract class CleanupStrategy
     {
         public static CleanupStrategy get(ColumnFamilyStore cfs, Collection<Range<Token>> ranges, CounterId.OneShotRenewer renewer)
         {
-            if (cfs.indexManager.hasIndexes() || cfs.metadata.getDefaultValidator().isCommutative())
+            if (cfs.indexManager.hasIndexes() || cfs.metadata.isCounter())
                 return new Full(cfs, ranges, renewer);
 
             return new Bounded(cfs, ranges);

File: src/java/org/apache/cassandra/db/compaction/Scrubber.java
Patch:
@@ -84,7 +84,7 @@ public Scrubber(ColumnFamilyStore cfs, SSTableReader sstable, OutputHandler outp
         this.controller = isOffline
                         ? new ScrubController(cfs)
                         : new CompactionController(cfs, Collections.singleton(sstable), CompactionManager.getDefaultGcBefore(cfs));
-        this.isCommutative = cfs.metadata.getDefaultValidator().isCommutative();
+        this.isCommutative = cfs.metadata.isCounter();
         this.expectedBloomFilterSize = Math.max(cfs.metadata.getIndexInterval(), (int)(SSTableReader.getApproximateKeyCount(toScrub)));
 
         // loop through each row, deserializing to check for damage.

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -286,7 +286,7 @@ private List<ColumnOrSuperColumn> thriftifyColumnFamily(ColumnFamily cf, boolean
 
         if (cf.metadata().isSuper())
         {
-            boolean isCounterCF = cf.metadata().getDefaultValidator().isCommutative();
+            boolean isCounterCF = cf.metadata().isCounter();
             return thriftifySuperColumns(cf.getSortedColumns(), reverseOrder, now, subcolumnsOnly, isCounterCF);
         }
         else
@@ -829,7 +829,7 @@ private List<IMutation> createMutationList(ConsistencyLevel consistency_level,
                 ThriftValidation.validateKey(metadata, key);
 
                 org.apache.cassandra.db.Mutation mutation;
-                if (metadata.getDefaultValidator().isCommutative())
+                if (metadata.isCounter())
                 {
                     ThriftConversion.fromThrift(consistency_level).validateCounterForWrite(metadata);
                     counterMutation = counterMutation == null ? new org.apache.cassandra.db.Mutation(keyspace, key) : counterMutation;

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -1640,7 +1640,7 @@ static CFMetaData fromSchemaNoColumnsNoTriggers(UntypedResultSet.Row result)
             if (result.has("key_aliases"))
                 cfm.addColumnMetadataFromAliases(aliasesFromStrings(fromJsonList(result.getString("key_aliases"))), cfm.keyValidator, ColumnDefinition.Type.PARTITION_KEY);
             if (result.has("column_aliases"))
-            cfm.addColumnMetadataFromAliases(aliasesFromStrings(fromJsonList(result.getString("column_aliases"))), cfm.comparator, ColumnDefinition.Type.CLUSTERING_KEY);
+                cfm.addColumnMetadataFromAliases(aliasesFromStrings(fromJsonList(result.getString("column_aliases"))), cfm.comparator, ColumnDefinition.Type.CLUSTERING_KEY);
 
             if (result.has("value_alias"))
                 cfm.addColumnMetadataFromAliases(Collections.<ByteBuffer>singletonList(result.getBytes("value_alias")), cfm.defaultValidator, ColumnDefinition.Type.COMPACT_VALUE);

File: test/unit/org/apache/cassandra/config/CFMetaDataTest.java
Patch:
@@ -109,7 +109,7 @@ public void testConversionsInverses() throws Exception
                 checkInverses(cfm);
 
                 // Testing with compression to catch #3558
-                CFMetaData withCompression = CFMetaData.rename(cfm, cfm.cfName); // basically a clone
+                CFMetaData withCompression = cfm.clone();
                 withCompression.compressionParameters(new CompressionParameters(SnappyCompressor.instance, 32768, new HashMap<String, String>()));
                 checkInverses(withCompression);
             }

File: src/java/org/apache/cassandra/utils/btree/NodeBuilder.java
Patch:
@@ -231,7 +231,7 @@ <V> void addNewKey(Object key, ReplaceFunction<V> replaceF)
     {
         ensureRoom(buildKeyPosition + 1);
         if (replaceF != null)
-            key = replaceF.apply(null, (V) key);
+            key = replaceF.apply((V) key);
         buildKeys[buildKeyPosition++] = key;
     }
 

File: src/java/org/apache/cassandra/db/commitlog/AbstractCommitLogService.java
Patch:
@@ -108,7 +108,7 @@ public void run()
                         }
 
                         // if we have lagged this round, we probably have work to do already so we don't sleep
-                        if (sleep < 0)
+                        if (sleep < 0 || !run)
                             continue;
 
                         try

File: src/java/org/apache/cassandra/metrics/ColumnFamilyMetrics.java
Patch:
@@ -333,6 +333,7 @@ public void release()
     {
         readLatency.release();
         writeLatency.release();
+        Metrics.defaultRegistry().removeMetric(factory.createMetricName("AllMemtablesDataSize"));
         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableColumnsCount"));
         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableDataSize"));
         Metrics.defaultRegistry().removeMetric(factory.createMetricName("MemtableSwitchCount"));
@@ -353,7 +354,7 @@ public void release()
         Metrics.defaultRegistry().removeMetric(factory.createMetricName("RecentBloomFilterFalseRatio"));
         Metrics.defaultRegistry().removeMetric(factory.createMetricName("BloomFilterDiskSpaceUsed"));
         Metrics.defaultRegistry().removeMetric(factory.createMetricName("KeyCacheHitRate"));
-        Metrics.defaultRegistry().removeMetric(factory.createMetricName("SpeculativeRetry"));
+        Metrics.defaultRegistry().removeMetric(factory.createMetricName("SpeculativeRetries"));
         Metrics.defaultRegistry().removeMetric(factory.createMetricName("TombstoneScannedHistogram"));
         Metrics.defaultRegistry().removeMetric(factory.createMetricName("LiveScannedHistogram"));
         Metrics.defaultRegistry().removeMetric(factory.createMetricName("CoordinatorReadLatency"));

File: src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java
Patch:
@@ -71,7 +71,7 @@ public void announceMigration() throws RequestValidationException
         CFMetaData meta = validateColumnFamily(keyspace(), columnFamily());
         CFMetaData cfm = meta.clone();
 
-        CQL3Type validator = this.validator.prepare(keyspace());
+        CQL3Type validator = this.validator == null ? null : this.validator.prepare(keyspace());
 
         ColumnDefinition def = columnName == null ? null : cfm.getColumnDefinition(columnName);
         switch (oType)

File: src/java/org/apache/cassandra/db/CFRowAdder.java
Patch:
@@ -103,7 +103,7 @@ private CFRowAdder add(CellName name, ColumnDefinition def, Object value)
             AbstractType valueType = def.type.isCollection()
                                    ? ((CollectionType) def.type).valueComparator()
                                    : def.type;
-            cf.addColumn(new Cell(name, valueType.decompose(value), timestamp));
+            cf.addColumn(new Cell(name, value instanceof ByteBuffer ? (ByteBuffer)value : valueType.decompose(value), timestamp));
         }
         return this;
     }

File: test/pig/org/apache/cassandra/pig/PigTestBase.java
Patch:
@@ -69,7 +69,7 @@ public class PigTestBase extends SchemaLoader
 
     static
     {
-        System.setProperty("log4j.configuration", "log4j-junit.properties");
+        System.setProperty("logback.configurationFile", "logback-test.xml");
     }
 
     @AfterClass

File: src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
Patch:
@@ -134,7 +134,7 @@ public AbstractWriteResponseHandler getWriteResponseHandler(Collection<InetAddre
             // block for in this context will be localnodes block.
             return new DatacenterWriteResponseHandler(naturalEndpoints, pendingEndpoints, consistency_level, getTable(), callback, writeType);
         }
-        else if (consistency_level == ConsistencyLevel.EACH_QUORUM)
+        else if (consistency_level == ConsistencyLevel.EACH_QUORUM && (this instanceof NetworkTopologyStrategy))
         {
             return new DatacenterSyncWriteResponseHandler(naturalEndpoints, pendingEndpoints, consistency_level, getTable(), callback, writeType);
         }

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -517,8 +517,6 @@ private static IEndpointSnitch createEndpointSnitch(String snitchClassName) thro
     /** load keyspace (keyspace) definitions, but do not initialize the keyspace instances. */
     public static void loadSchemas()
     {
-        Schema.instance.loadUserTypes();
-
         ColumnFamilyStore schemaCFS = SystemKeyspace.schemaCFS(SystemKeyspace.SCHEMA_KEYSPACES_CF);
 
         // if keyspace with definitions is empty try loading the old way

File: src/java/org/apache/cassandra/cql3/AbstractMarker.java
Patch:
@@ -58,7 +58,7 @@ public Raw(int bindIndex)
             this.bindIndex = bindIndex;
         }
 
-        public AbstractMarker prepare(ColumnSpecification receiver) throws InvalidRequestException
+        public AbstractMarker prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
         {
             if (!(receiver.type instanceof CollectionType))
                 return new Constants.Marker(bindIndex, receiver);
@@ -72,7 +72,7 @@ public AbstractMarker prepare(ColumnSpecification receiver) throws InvalidReques
             throw new AssertionError();
         }
 
-        public boolean isAssignableTo(ColumnSpecification receiver)
+        public boolean isAssignableTo(String keyspace, ColumnSpecification receiver)
         {
             return true;
         }
@@ -99,7 +99,7 @@ private static ColumnSpecification makeInReceiver(ColumnSpecification receiver)
         }
 
         @Override
-        public AbstractMarker prepare(ColumnSpecification receiver) throws InvalidRequestException
+        public AbstractMarker prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException
         {
             if (receiver.type instanceof CollectionType)
                 throw new InvalidRequestException("Invalid IN relation on collection column");

File: src/java/org/apache/cassandra/cql3/AssignementTestable.java
Patch:
@@ -17,10 +17,12 @@
  */
 package org.apache.cassandra.cql3;
 
+import org.apache.cassandra.exceptions.InvalidRequestException;
+
 public interface AssignementTestable
 {
     /**
      * @return whether this object can be assigned to the provided receiver
      */
-    public boolean isAssignableTo(ColumnSpecification receiver);
+    public boolean isAssignableTo(String keyspace, ColumnSpecification receiver) throws InvalidRequestException;
 }

File: src/java/org/apache/cassandra/cql3/Attributes.java
Patch:
@@ -120,8 +120,8 @@ public static class Raw
 
         public Attributes prepare(String ksName, String cfName) throws InvalidRequestException
         {
-            Term ts = timestamp == null ? null : timestamp.prepare(timestampReceiver(ksName, cfName));
-            Term ttl = timeToLive == null ? null : timeToLive.prepare(timeToLiveReceiver(ksName, cfName));
+            Term ts = timestamp == null ? null : timestamp.prepare(ksName, timestampReceiver(ksName, cfName));
+            Term ttl = timeToLive == null ? null : timeToLive.prepare(ksName, timeToLiveReceiver(ksName, cfName));
             return new Attributes(ts, ttl);
         }
 

File: src/java/org/apache/cassandra/cql3/Term.java
Patch:
@@ -88,7 +88,7 @@ public interface Raw extends AssignementTestable
          * case this RawTerm describe a list index or a map key, etc...
          * @return the prepared term.
          */
-        public Term prepare(ColumnSpecification receiver) throws InvalidRequestException;
+        public Term prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException;
     }
 
     /**

File: src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java
Patch:
@@ -112,7 +112,7 @@ protected ModificationStatement prepareInternal(CFMetaData cfm, VariableSpecific
                 if (def.kind != ColumnDefinition.Kind.REGULAR && def.kind != ColumnDefinition.Kind.COMPACT_VALUE)
                     throw new InvalidRequestException(String.format("Invalid identifier %s for deletion (should not be a PRIMARY KEY part)", def.name));
 
-                Operation op = deletion.prepare(def);
+                Operation op = deletion.prepare(cfm.ksName, def);
                 op.collectMarkerSpecification(boundNames);
                 stmt.addOperation(op);
             }

File: src/java/org/apache/cassandra/cql3/statements/Selection.java
Patch:
@@ -150,7 +150,7 @@ else if (raw.selectable instanceof Selectable.WithFieldSelection)
             if (returnType == null)
                 throw new InvalidRequestException(String.format("Unknown function '%s'", withFun.functionName));
             ColumnSpecification spec = makeFunctionSpec(cfm, withFun, returnType, raw.alias);
-            Function fun = Functions.get(withFun.functionName, args, spec);
+            Function fun = Functions.get(cfm.ksName, withFun.functionName, args, spec);
             if (metadata != null)
                 metadata.add(spec);
             return new FunctionSelector(fun, args);
@@ -352,7 +352,7 @@ private static abstract class Selector implements AssignementTestable
         public abstract ByteBuffer compute(ResultSetBuilder rs) throws InvalidRequestException;
         public abstract AbstractType<?> getType();
 
-        public boolean isAssignableTo(ColumnSpecification receiver)
+        public boolean isAssignableTo(String keyspace, ColumnSpecification receiver)
         {
             return getType().asCQL3Type().equals(receiver.type.asCQL3Type());
         }

File: src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java
Patch:
@@ -155,13 +155,13 @@ protected ModificationStatement prepareInternal(CFMetaData cfm, VariableSpecific
                 {
                     case PARTITION_KEY:
                     case CLUSTERING_COLUMN:
-                        Term t = value.prepare(def);
+                        Term t = value.prepare(keyspace(), def);
                         t.collectMarkerSpecification(boundNames);
                         stmt.addKeyValue(def.name, t);
                         break;
                     case COMPACT_VALUE:
                     case REGULAR:
-                        Operation operation = new Operation.SetValue(value).prepare(def);
+                        Operation operation = new Operation.SetValue(value).prepare(keyspace(), def);
                         operation.collectMarkerSpecification(boundNames);
                         stmt.addOperation(operation);
                         break;
@@ -207,7 +207,7 @@ protected ModificationStatement prepareInternal(CFMetaData cfm, VariableSpecific
                 if (def == null)
                     throw new InvalidRequestException(String.format("Unknown identifier %s", entry.left));
 
-                Operation operation = entry.right.prepare(def);
+                Operation operation = entry.right.prepare(keyspace(), def);
                 operation.collectMarkerSpecification(boundNames);
 
                 switch (def.kind)

File: src/java/org/apache/cassandra/service/MigrationManager.java
Patch:
@@ -266,7 +266,6 @@ public static void announceColumnFamilyUpdate(CFMetaData cfm, boolean fromThrift
 
     public static void announceTypeUpdate(UserType updatedType)
     {
-        // We don't make a difference with a new type. DefsTable.mergeType will make sure we keep the updated version.
         announceNewType(updatedType);
     }
 

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1178,6 +1178,9 @@ public List<TokenRange> describeLocalRing(String keyspace) throws InvalidRequest
 
     private List<TokenRange> describeRing(String keyspace, boolean includeOnlyLocalDC) throws InvalidRequestException
     {
+        if (!Schema.instance.getKeyspaces().contains(keyspace))
+            throw new InvalidRequestException("No such keyspace: " + keyspace);
+
         if (keyspace == null || Keyspace.open(keyspace).getReplicationStrategy() instanceof LocalStrategy)
             throw new InvalidRequestException("There is no ring for the keyspace: " + keyspace);
 

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -501,7 +501,7 @@ public static void removeUnfinishedCompactionLeftovers(String keyspace, String c
         // remove new sstables from compactions that didn't complete, and compute
         // set of ancestors that shouldn't exist anymore
         Set<Integer> completedAncestors = new HashSet<>();
-        for (Map.Entry<Descriptor, Set<Component>> sstableFiles : directories.sstableLister().list().entrySet())
+        for (Map.Entry<Descriptor, Set<Component>> sstableFiles : directories.sstableLister().skipTemporary(true).list().entrySet())
         {
             Descriptor desc = sstableFiles.getKey();
 

File: src/java/org/apache/cassandra/db/composites/CellNames.java
Patch:
@@ -50,13 +50,14 @@ public static CellNameType fromAbstractType(AbstractType<?> type, boolean isDens
                 List<AbstractType<?>> types = ((CompositeType)type).types;
                 if (types.get(types.size() - 1) instanceof ColumnToCollectionType)
                 {
+                    // We don't allow collection for super columns, so the "name" type *must* be UTF8
                     assert types.get(types.size() - 2) instanceof UTF8Type;
                     return new CompoundSparseCellNameType.WithCollection(types.subList(0, types.size() - 2), (ColumnToCollectionType)types.get(types.size() - 1));
                 }
                 else
                 {
-                    assert types.get(types.size() - 1) instanceof UTF8Type;
-                    return new CompoundSparseCellNameType(types.subList(0, types.size() - 1));
+                    AbstractType<?> nameType = types.get(types.size() - 1);
+                    return new CompoundSparseCellNameType(types.subList(0, types.size() - 1), nameType);
                 }
             }
             else

File: test/unit/org/apache/cassandra/db/HintedHandOffTest.java
Patch:
@@ -102,8 +102,8 @@ public void testTruncateHints() throws Exception
         hintStore.clearUnsafe();
 
         // insert 1 hint
-        RowMutation rm = new RowMutation(KEYSPACE4, ByteBufferUtil.bytes(1));
-        rm.add(STANDARD1_CF, ByteBufferUtil.bytes(String.valueOf(COLUMN1)), ByteBufferUtil.EMPTY_BYTE_BUFFER, System.currentTimeMillis());
+        Mutation rm = new Mutation(KEYSPACE4, ByteBufferUtil.bytes(1));
+        rm.add(STANDARD1_CF, Util.cellname(COLUMN1), ByteBufferUtil.EMPTY_BYTE_BUFFER, System.currentTimeMillis());
 
         HintedHandOffManager.instance.hintFor(rm, HintedHandOffManager.calculateHintTTL(rm), UUID.randomUUID()).apply();
 

File: tools/stress/src/org/apache/cassandra/stress/operations/CqlOperation.java
Patch:
@@ -334,7 +334,7 @@ public <V> V execute(String query, ByteBuffer key, List<ByteBuffer> queryParams,
         {
             String formattedQuery = formatCqlQuery(query, queryParams, true);
             return handler.simpleNativeHandler().apply(
-                    client.execute_cql3_query(query, key, Compression.NONE, state.settings.command.consistencyLevel)
+                    client.execute_cql3_query(formattedQuery, key, Compression.NONE, state.settings.command.consistencyLevel)
             );
         }
 

File: src/java/org/apache/cassandra/thrift/ThriftValidation.java
Patch:
@@ -268,7 +268,7 @@ public static void validateRange(CFMetaData metadata, ColumnParent column_parent
         if (range.count < 0)
             throw new org.apache.cassandra.exceptions.InvalidRequestException("get_slice requires non-negative count");
 
-        int maxNameLength = org.apache.cassandra.db.Column.MAX_NAME_LENGTH;
+        int maxNameLength = Cell.MAX_NAME_LENGTH;
         if (range.start.remaining() > maxNameLength)
             throw new org.apache.cassandra.exceptions.InvalidRequestException("range start length cannot be larger than " + maxNameLength);
         if (range.finish.remaining() > maxNameLength)

File: src/java/org/apache/cassandra/tools/NodeProbe.java
Patch:
@@ -972,7 +972,7 @@ public Object getColumnFamilyMetric(String ks, String cf, String metricName)
 
     /**
      * Retrieve Proxy metrics
-     * @param scope; RangeSlice, Read or Write
+     * @param scope RangeSlice, Read or Write
      */
     public JmxReporter.TimerMBean getProxyMetric(String scope)
     {
@@ -990,7 +990,7 @@ public JmxReporter.TimerMBean getProxyMetric(String scope)
 
     /**
      * Retrieve Proxy metrics
-     * @param metricName; CompletedTasks, PendingTasks, BytesCompacted or TotalCompactionsCompleted.
+     * @param metricName CompletedTasks, PendingTasks, BytesCompacted or TotalCompactionsCompleted.
      */
     public Object getCompactionMetric(String metricName)
     {
@@ -1023,7 +1023,7 @@ public Object getCompactionMetric(String metricName)
 
     /**
      * Retrieve Proxy metrics
-     * @param metricName; Exceptions, Load, TotalHints or TotalHintsInProgress.
+     * @param metricName Exceptions, Load, TotalHints or TotalHintsInProgress.
      */
     public long getStorageMetric(String metricName)
     {

File: src/java/org/apache/cassandra/triggers/ITrigger.java
Patch:
@@ -44,7 +44,7 @@ public interface ITrigger
     /**
      * Called exactly once per CF update, returned mutations are atomically updated.
      *
-     * @param key - parition Key for the update.
+     * @param partitionKey - partition Key for the update.
      * @param update - update received for the CF
      * @return modifications to be applied, null if no action to be performed.
      */

File: src/java/org/apache/cassandra/tracing/Tracing.java
Patch:
@@ -100,8 +100,8 @@ public void addParameterColumns(ColumnFamily cf, Map<String, String> rawPayload)
     {
         for (Map.Entry<String, String> entry : rawPayload.entrySet())
         {
-            cf.addColumn(new ExpiringCell(buildName(cf.metadata(), "parameters", entry.getKey()),
-                                            bytes(entry.getValue()), System.currentTimeMillis(), TTL));
+            cf.addColumn(new ExpiringCell(buildName(CFMetaData.TraceSessionsCf, "parameters", entry.getKey()),
+                                          bytes(entry.getValue()), System.currentTimeMillis(), TTL));
         }
     }
 

File: src/java/org/apache/cassandra/cql3/CQLStatement.java
Patch:
@@ -31,7 +31,7 @@ public interface CQLStatement
     /**
      * Returns the number of bound terms in this statement.
      */
-    public int getBoundsTerms();
+    public int getBoundTerms();
 
     /**
      * Perform any access verification necessary for the statement.

File: src/java/org/apache/cassandra/cql3/statements/AuthenticationStatement.java
Patch:
@@ -35,7 +35,7 @@ public Prepared prepare()
         return new Prepared(this);
     }
 
-    public int getBoundsTerms()
+    public int getBoundTerms()
     {
         return 0;
     }

File: src/java/org/apache/cassandra/cql3/statements/AuthorizationStatement.java
Patch:
@@ -36,7 +36,7 @@ public Prepared prepare()
         return new Prepared(this);
     }
 
-    public int getBoundsTerms()
+    public int getBoundTerms()
     {
         return 0;
     }

File: src/java/org/apache/cassandra/cql3/statements/BatchStatement.java
Patch:
@@ -31,7 +31,6 @@
 import org.apache.cassandra.exceptions.*;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.utils.Pair;
-import org.apache.cassandra.utils.ObjectSizes;
 
 /**
  * A <code>BATCH</code> statement parsed from a CQL query.
@@ -140,7 +139,7 @@ public ParsedStatement.Prepared prepare(ColumnSpecification[] boundNames) throws
 
     public ParsedStatement.Prepared prepare() throws InvalidRequestException
     {
-        CFDefinition.Name[] boundNames = new CFDefinition.Name[getBoundsTerms()];
+        CFDefinition.Name[] boundNames = new CFDefinition.Name[getBoundTerms()];
         return prepare(boundNames);
     }
 

File: src/java/org/apache/cassandra/cql3/statements/CreateColumnFamilyStatement.java
Patch:
@@ -175,7 +175,7 @@ public ParsedStatement.Prepared prepare() throws RequestValidationException
             properties.validate();
 
             CreateColumnFamilyStatement stmt = new CreateColumnFamilyStatement(cfName, properties);
-            stmt.setBoundTerms(getBoundsTerms());
+            stmt.setBoundTerms(getBoundTerms());
 
             Map<ByteBuffer, CollectionType> definedCollections = null;
             for (Map.Entry<ColumnIdentifier, CQL3Type> entry : definitions.entrySet())

File: src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java
Patch:
@@ -173,7 +173,7 @@ public ParsedStatement.Prepared prepare(ColumnSpecification[] boundNames) throws
 
     public ParsedStatement.Prepared prepare() throws InvalidRequestException
     {
-        ColumnSpecification[] boundNames = new ColumnSpecification[getBoundsTerms()];
+        ColumnSpecification[] boundNames = new ColumnSpecification[getBoundTerms()];
         return prepare(boundNames);
     }
 

File: src/java/org/apache/cassandra/cql3/statements/ParsedStatement.java
Patch:
@@ -27,7 +27,7 @@ public abstract class ParsedStatement
 {
     private int boundTerms;
 
-    public int getBoundsTerms()
+    public int getBoundTerms()
     {
         return boundTerms;
     }

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -105,7 +105,7 @@ public long measureForPreparedCache(MemoryMeter meter)
         return meter.measureDeep(this) - meter.measureDeep(cfDef);
     }
 
-    public int getBoundsTerms()
+    public int getBoundTerms()
     {
         return boundTerms;
     }
@@ -1002,7 +1002,7 @@ public ParsedStatement.Prepared prepare() throws InvalidRequestException
 
             CFDefinition cfDef = cfm.getCfDef();
 
-            ColumnSpecification[] names = new ColumnSpecification[getBoundsTerms()];
+            ColumnSpecification[] names = new ColumnSpecification[getBoundTerms()];
 
             // Select clause
             if (parameters.isCount && !selectClause.isEmpty())
@@ -1012,7 +1012,7 @@ public ParsedStatement.Prepared prepare() throws InvalidRequestException
                                 ? Selection.wildcard(cfDef)
                                 : Selection.fromSelectors(cfDef, selectClause);
 
-            SelectStatement stmt = new SelectStatement(cfDef, getBoundsTerms(), parameters, selection);
+            SelectStatement stmt = new SelectStatement(cfDef, getBoundTerms(), parameters, selection);
 
             /*
              * WHERE clause. For a given entity, rules are:

File: src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java
Patch:
@@ -348,7 +348,7 @@ public ParsedStatement.Prepared prepare(ColumnSpecification[] boundNames) throws
 
     public ParsedStatement.Prepared prepare() throws InvalidRequestException
     {
-        ColumnSpecification[] names = new ColumnSpecification[getBoundsTerms()];
+        ColumnSpecification[] names = new ColumnSpecification[getBoundTerms()];
         return prepare(names);
     }
 

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -1849,7 +1849,7 @@ public CqlResult execute_prepared_cql3_query(int itemId, List<ByteBuffer> bindVa
                                                                 " (either the query was not prepared on this host (maybe the host has been restarted?)" +
                                                                 " or you have prepared too many queries and it has been evicted from the internal cache)",
                                                                 itemId));
-            logger.trace("Retrieved prepared statement #{} with {} bind markers", itemId, statement.getBoundsTerms());
+            logger.trace("Retrieved prepared statement #{} with {} bind markers", itemId, statement.getBoundTerms());
 
             return org.apache.cassandra.cql3.QueryProcessor.processPrepared(statement, ThriftConversion.fromThrift(cLevel), cState.getQueryState(), bindVariables).toThriftResult();
         }

File: src/java/org/apache/cassandra/service/pager/AbstractQueryPager.java
Patch:
@@ -197,7 +197,7 @@ private List<Row> discardFirst(List<Row> rows, int toDiscard)
         }
 
         // If there is less live data than to discard, all is discarded
-        if (i >= rows.size())
+        if (toDiscard > 0 && i >= rows.size())
             return Collections.<Row>emptyList();
 
         int count = firstCf.getColumnCount();
@@ -234,7 +234,7 @@ private List<Row> discardLast(List<Row> rows, int toDiscard)
         }
 
         // If there is less live data than to discard, all is discarded
-        if (i < 0)
+        if (toDiscard > 0 && i < 0)
             return Collections.<Row>emptyList();
 
         int count = lastCf.getColumnCount();

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -388,13 +388,12 @@ private SliceQueryFilter toInternalFilter(CFMetaData metadata, ColumnParent pare
     private IDiskAtomFilter toInternalFilter(CFMetaData metadata, ColumnParent parent, SlicePredicate predicate)
     {
         IDiskAtomFilter filter;
-        CellNameType columnType = metadata.isSuper()
-                                ? new SimpleDenseCellNameType(metadata.comparator.subtype(parent.isSetSuper_column() ? 1 : 0))
-                                : metadata.comparator;
+
         if (predicate.column_names != null)
         {
             if (metadata.isSuper())
             {
+                CellNameType columnType = new SimpleDenseCellNameType(metadata.comparator.subtype(parent.isSetSuper_column() ? 1 : 0));
                 SortedSet<CellName> s = new TreeSet<CellName>(columnType);
                 for (ByteBuffer bb : predicate.column_names)
                     s.add(columnType.cellFromByteBuffer(bb));

File: src/java/org/apache/cassandra/db/composites/CompoundSparseCellNameType.java
Patch:
@@ -231,7 +231,7 @@ protected Composite copyAndMakeWith(ByteBuffer[] components, int size, Composite
                 return super.copyAndMakeWith(components, size, eoc);
 
             ByteBuffer[] clusteringColumns = Arrays.copyOfRange(components, 0, clusteringSize);
-            return new CompoundSparseCellName.WithCollection(clusteringColumns, idFor(components[clusteringSize]), components[fullSize + 1]);
+            return new CompoundSparseCellName.WithCollection(clusteringColumns, idFor(components[clusteringSize]), components[clusteringSize + 1]);
         }
     }
 }

File: src/java/org/apache/cassandra/service/pager/SliceQueryPager.java
Patch:
@@ -17,6 +17,7 @@
  */
 package org.apache.cassandra.service.pager;
 
+import java.nio.ByteBuffer;
 import java.util.Collections;
 import java.util.List;
 

File: src/java/org/apache/cassandra/service/pager/AbstractQueryPager.java
Patch:
@@ -40,9 +40,9 @@ abstract class AbstractQueryPager implements QueryPager
     protected final IDiskAtomFilter columnFilter;
     private final long timestamp;
 
-    private volatile int remaining;
-    private volatile boolean exhausted;
-    private volatile boolean lastWasRecorded;
+    private int remaining;
+    private boolean exhausted;
+    private boolean lastWasRecorded;
 
     protected AbstractQueryPager(ConsistencyLevel consistencyLevel,
                                  int toFetch,

File: src/java/org/apache/cassandra/service/pager/NamesQueryPager.java
Patch:
@@ -17,6 +17,7 @@
  */
 package org.apache.cassandra.service.pager;
 
+import java.nio.ByteBuffer;
 import java.util.Collections;
 import java.util.List;
 
@@ -55,9 +56,9 @@ public class NamesQueryPager implements SinglePartitionPager
         this.localQuery = localQuery;
     }
 
-    NamesQueryPager(SliceByNamesReadCommand command, ConsistencyLevel consistencyLevel, boolean localQuery, PagingState state)
+    public ByteBuffer key()
     {
-        this(command, consistencyLevel, localQuery);
+        return command.key;
     }
 
     public ColumnCounter columnCounter()

File: src/java/org/apache/cassandra/service/pager/QueryPagers.java
Patch:
@@ -57,7 +57,8 @@ public static boolean mayNeedPaging(Pageable command, int pageSize)
         {
             List<ReadCommand> commands = ((Pageable.ReadCommands)command).commands;
 
-            int maxQueried = 0;
+            // Using long on purpose, as we could overflow otherwise
+            long maxQueried = 0;
             for (ReadCommand readCmd : commands)
                 maxQueried += maxQueried(readCmd);
 
@@ -78,7 +79,7 @@ else if (command instanceof ReadCommand)
     private static QueryPager pager(ReadCommand command, ConsistencyLevel consistencyLevel, boolean local, PagingState state)
     {
         if (command instanceof SliceByNamesReadCommand)
-            return new NamesQueryPager((SliceByNamesReadCommand)command, consistencyLevel, local, state);
+            return new NamesQueryPager((SliceByNamesReadCommand)command, consistencyLevel, local);
         else
             return new SliceQueryPager((SliceFromReadCommand)command, consistencyLevel, local, state);
     }

File: src/java/org/apache/cassandra/service/pager/SinglePartitionPager.java
Patch:
@@ -17,6 +17,8 @@
  */
 package org.apache.cassandra.service.pager;
 
+import java.nio.ByteBuffer;
+
 import org.apache.cassandra.db.filter.ColumnCounter;
 
 /**
@@ -26,5 +28,6 @@
  */
 public interface SinglePartitionPager extends QueryPager
 {
+    public ByteBuffer key();
     public ColumnCounter columnCounter();
 }

File: src/java/org/apache/cassandra/db/compaction/AbstractCompactionStrategy.java
Patch:
@@ -167,7 +167,7 @@ public void shutdown()
     /**
      * @return size in bytes of the largest sstables for this strategy
      */
-    public abstract long getMaxSSTableSize();
+    public abstract long getMaxSSTableBytes();
 
     public boolean isEnabled()
     {

File: src/java/org/apache/cassandra/db/compaction/CompactionTask.java
Patch:
@@ -118,7 +118,7 @@ protected void runWith(File sstableDirectory) throws Exception
         long totalkeysWritten = 0;
 
         long estimatedTotalKeys = Math.max(cfs.metadata.getIndexInterval(), SSTableReader.getApproximateKeyCount(actuallyCompact, cfs.metadata));
-        long estimatedSSTables = Math.max(1, SSTable.getTotalBytes(actuallyCompact) / strategy.getMaxSSTableSize());
+        long estimatedSSTables = Math.max(1, SSTable.getTotalBytes(actuallyCompact) / strategy.getMaxSSTableBytes());
         long keysPerSSTable = (long) Math.ceil((double) estimatedTotalKeys / estimatedSSTables);
         if (logger.isDebugEnabled())
             logger.debug("Expected bloom filter size : " + keysPerSSTable);

File: src/java/org/apache/cassandra/db/compaction/SizeTieredCompactionStrategy.java
Patch:
@@ -346,7 +346,7 @@ private void updateEstimatedCompactionsByTasks(List<List<SSTableReader>> tasks)
         estimatedRemainingTasks = n;
     }
 
-    public long getMaxSSTableSize()
+    public long getMaxSSTableBytes()
     {
         return Long.MAX_VALUE;
     }

File: src/java/org/apache/cassandra/tools/StandaloneScrubber.java
Patch:
@@ -109,7 +109,7 @@ public static void main(String args[])
             // If leveled, load the manifest
             if (cfs.getCompactionStrategy() instanceof LeveledCompactionStrategy)
             {
-                int maxSizeInMB = (int)((cfs.getCompactionStrategy().getMaxSSTableSize()) / (1024L * 1024L));
+                int maxSizeInMB = (int)((cfs.getCompactionStrategy().getMaxSSTableBytes()) / (1024L * 1024L));
                 manifest = LeveledManifest.create(cfs, maxSizeInMB, sstables);
             }
 

File: src/java/org/apache/cassandra/tools/SSTableMetadataViewer.java
Patch:
@@ -64,8 +64,8 @@ public static void main(String[] args) throws IOException
                 out.printf("Estimated droppable tombstones: %s%n", stats.getEstimatedDroppableTombstoneRatio((int) (System.currentTimeMillis() / 1000)));
                 out.printf("SSTable Level: %d%n", stats.sstableLevel);
                 out.println(stats.replayPosition);
+                printHistograms(stats, out);
             }
-            printHistograms(stats, out);
         }
     }
 

File: src/java/org/apache/cassandra/db/ConsistencyLevel.java
Patch:
@@ -285,9 +285,7 @@ public void validateForWrite(String keyspaceName) throws InvalidRequestException
     {
         switch (this)
         {
-            case LOCAL_QUORUM:
             case EACH_QUORUM:
-            case LOCAL_ONE:
                 requireNetworkTopologyStrategy(keyspaceName);
                 break;
             case SERIAL:

File: src/java/org/apache/cassandra/hadoop/pig/CqlStorage.java
Patch:
@@ -22,8 +22,6 @@
 import java.nio.charset.CharacterCodingException;
 import java.util.*;
 
-
-import org.apache.cassandra.cql3.ColumnIdentifier;
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.ColumnDefinition;
 import org.apache.cassandra.db.Column;
@@ -57,7 +55,6 @@
 public class CqlStorage extends AbstractCassandraStorage
 {
     private static final Logger logger = LoggerFactory.getLogger(CqlStorage.class);
-
     private RecordReader<Map<String, ByteBuffer>, Map<String, ByteBuffer>> reader;
     private RecordWriter<Map<String, ByteBuffer>, List<ByteBuffer>> writer;
 

File: src/java/org/apache/cassandra/db/compaction/LazilyCompactedRow.java
Patch:
@@ -112,7 +112,7 @@ public RowIndexEntry write(long currentPosition, DataOutput out) throws IOExcept
         // (however, if there are zero columns, iterator() will not be called by ColumnIndexer and reducer will be null)
         columnStats = new ColumnStats(reducer == null ? 0 : reducer.columns,
                                       reducer == null ? Long.MAX_VALUE : reducer.minTimestampSeen,
-                                      reducer == null ? maxRowTombstone.markedForDeleteAt : Math.max(maxRowTombstone.markedForDeleteAt, reducer.maxTimestampSeen),
+                                      reducer == null ? emptyColumnFamily.maxTimestamp() : Math.max(emptyColumnFamily.maxTimestamp(), reducer.maxTimestampSeen),
                                       reducer == null ? Integer.MIN_VALUE : reducer.maxLocalDeletionTimeSeen,
                                       reducer == null ? new StreamingHistogram(SSTable.TOMBSTONE_HISTOGRAM_BIN_SIZE) : reducer.tombstones,
                                       reducer == null ? Collections.<ByteBuffer>emptyList() : reducer.minColumnNameSeen,

File: src/java/org/apache/cassandra/db/AtomicSortedColumns.java
Patch:
@@ -120,12 +120,12 @@ public void setDeletionInfo(DeletionInfo newInfo)
         ref.set(ref.get().with(newInfo));
     }
 
-    public void maybeResetDeletionTimes(int gcBefore)
+    public void purgeTombstones(int gcBefore)
     {
         while (true)
         {
             Holder current = ref.get();
-            if (!current.deletionInfo.hasIrrelevantData(gcBefore))
+            if (!current.deletionInfo.hasPurgeableTombstones(gcBefore))
                 break;
 
             DeletionInfo purgedInfo = current.deletionInfo.copy();

File: src/java/org/apache/cassandra/db/ColumnIndex.java
Patch:
@@ -67,7 +67,7 @@ public static class Builder
         private final RangeTombstone.Tracker tombstoneTracker;
         private int atomCount;
         private final ByteBuffer key;
-        private final DeletionInfo deletionInfo;
+        private final DeletionInfo deletionInfo; // only used for serializing and calculating row header size
 
         public Builder(ColumnFamily cf,
                        ByteBuffer key,

File: src/java/org/apache/cassandra/db/RangeTombstoneList.java
Patch:
@@ -305,7 +305,7 @@ public void purge(int gcBefore)
     /**
      * Returns whether {@code purge(gcBefore)} would remove something or not.
      */
-    public boolean hasIrrelevantData(int gcBefore)
+    public boolean hasPurgeableTombstones(int gcBefore)
     {
         for (int i = 0; i < size; i++)
         {

File: test/unit/org/apache/cassandra/Util.java
Patch:
@@ -245,12 +245,12 @@ public static void createInitialRing(StorageService ss, IPartitioner partitioner
             assertTrue(ss.getTokenMetadata().isMember(hosts.get(i)));
     }
 
-    public static Future<?> compactAll(ColumnFamilyStore cfs)
+    public static Future<?> compactAll(ColumnFamilyStore cfs, int gcBefore)
     {
-        List<Descriptor> descriptors = new ArrayList<Descriptor>();
+        List<Descriptor> descriptors = new ArrayList<>();
         for (SSTableReader sstable : cfs.getSSTables())
             descriptors.add(sstable.descriptor);
-        return CompactionManager.instance.submitUserDefined(cfs, descriptors, Integer.MAX_VALUE);
+        return CompactionManager.instance.submitUserDefined(cfs, descriptors, gcBefore);
     }
 
     public static void compact(ColumnFamilyStore cfs, Collection<SSTableReader> sstables)

File: test/unit/org/apache/cassandra/db/KeyCacheTest.java
Patch:
@@ -145,7 +145,7 @@ public void testKeyCache() throws ExecutionException, InterruptedException
 
         assertKeyCacheSize(2, KEYSPACE1, COLUMN_FAMILY1);
 
-        Util.compactAll(cfs).get();
+        Util.compactAll(cfs, Integer.MAX_VALUE).get();
         // after compaction cache should have entries for
         // new SSTables, if we had 2 keys in cache previously it should become 4
         assertKeyCacheSize(4, KEYSPACE1, COLUMN_FAMILY1);

File: test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java
Patch:
@@ -136,7 +136,7 @@ private List<String> createAndTransfer(ColumnFamilyStore cfs, Mutator mutator, b
         for (int i = 1; i <= 3; i++)
             mutator.mutate("key" + i, "col" + i, timestamp);
         cfs.forceBlockingFlush();
-        Util.compactAll(cfs).get();
+        Util.compactAll(cfs, Integer.MAX_VALUE).get();
         assertEquals(1, cfs.getSSTables().size());
 
         // transfer the first and last key
@@ -468,7 +468,7 @@ public void mutate(String key, String colName, long timestamp) throws Exception
         for (int i = 1; i <= 6000; i++)
             mutator.mutate("key" + i, "col" + i, System.currentTimeMillis());
         cfs.forceBlockingFlush();
-        Util.compactAll(cfs).get();
+        Util.compactAll(cfs, Integer.MAX_VALUE).get();
         SSTableReader sstable = cfs.getSSTables().iterator().next();
         cfs.clearUnsafe();
 

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -560,7 +560,7 @@ private void doCleanupCompaction(final ColumnFamilyStore cfs, Collection<SSTable
                 throw new IOException("disk full");
 
             ICompactionScanner scanner = cleanupStrategy.getScanner(sstable, getRateLimiter());
-            CleanupInfo ci = new CleanupInfo(sstable, (SSTableScanner)scanner);
+            CleanupInfo ci = new CleanupInfo(sstable, scanner);
 
             metrics.beginCompaction(ci);
             SSTableWriter writer = createWriter(cfs,
@@ -1052,9 +1052,9 @@ public long getCompletedTasks()
     private static class CleanupInfo extends CompactionInfo.Holder
     {
         private final SSTableReader sstable;
-        private final SSTableScanner scanner;
+        private final ICompactionScanner scanner;
 
-        public CleanupInfo(SSTableReader sstable, SSTableScanner scanner)
+        public CleanupInfo(SSTableReader sstable, ICompactionScanner scanner)
         {
             this.sstable = sstable;
             this.scanner = scanner;

File: test/unit/org/apache/cassandra/db/DirectoriesTest.java
Patch:
@@ -244,7 +244,7 @@ public void testMTSnapshots() throws Exception
         for (final String cf : CFS)
         {
             final Directories directories = Directories.create(KS, cf);
-            Assert.assertEquals(cfDir(cf), directories.getDirectoryForNewSSTables(0));
+            Assert.assertEquals(cfDir(cf), directories.getDirectoryForNewSSTables());
             final String n = Long.toString(System.nanoTime());
             Callable<File> directoryGetter = new Callable<File>() {
                 public File call() throws Exception {

File: src/java/org/apache/cassandra/db/Directories.java
Patch:
@@ -448,7 +448,7 @@ private static File getOrCreate(File base, String... subdirs)
             if (!dir.isDirectory())
                 throw new AssertionError(String.format("Invalid directory path %s: path exists but is not a directory", dir));
         }
-        else if (!dir.mkdirs())
+        else if (!dir.mkdirs() && !(dir.exists() && dir.isDirectory()))
         {
             throw new FSWriteError(new IOException("Unable to create directory " + dir), dir);
         }

File: src/java/org/apache/cassandra/db/ConsistencyLevel.java
Patch:
@@ -285,9 +285,7 @@ public void validateForWrite(String keyspaceName) throws InvalidRequestException
     {
         switch (this)
         {
-            case LOCAL_QUORUM:
             case EACH_QUORUM:
-            case LOCAL_ONE:
                 requireNetworkTopologyStrategy(keyspaceName);
                 break;
             case SERIAL:

File: test/unit/org/apache/cassandra/service/MoveTest.java
Patch:
@@ -109,6 +109,7 @@ public void newTestWriteEndpointsDuringMove() throws Exception
 
         // Third node leaves
         ss.onChange(hosts.get(MOVING_NODE), ApplicationState.STATUS, valueFactory.moving(newToken));
+        PendingRangeCalculatorService.instance.blockUntilFinished();
 
         assertTrue(tmd.isMoving(hosts.get(MOVING_NODE)));
 
@@ -197,6 +198,7 @@ public void testSimultaneousMove() throws UnknownHostException, ConfigurationExc
         ss.onChange(boot2,
                     ApplicationState.STATUS,
                     valueFactory.bootstrapping(Collections.<Token>singleton(keyTokens.get(7))));
+        PendingRangeCalculatorService.instance.blockUntilFinished();
 
         // don't require test update every time a new keyspace is added to test/conf/cassandra.yaml
         Map<String, AbstractReplicationStrategy> tableStrategyMap = new HashMap<String, AbstractReplicationStrategy>();

File: src/java/org/apache/cassandra/db/marshal/CollectionType.java
Patch:
@@ -113,7 +113,7 @@ protected static ByteBuffer pack(List<ByteBuffer> buffers, int elements, int siz
         return (ByteBuffer)result.flip();
     }
 
-    protected List<Pair<ByteBuffer, IColumn>> enforceLimit(List<Pair<ByteBuffer, IColumn>> columns)
+    protected List<Pair<ByteBuffer, Column>> enforceLimit(List<Pair<ByteBuffer, Column>> columns)
     {
         if (columns.size() <= MAX_ELEMENTS)
             return columns;

File: src/java/org/apache/cassandra/dht/BootStrapper.java
Patch:
@@ -102,7 +102,7 @@ public static Collection<Token> getBootstrapTokens(final TokenMetadata metadata,
             {
                 Token token = StorageService.getPartitioner().getTokenFactory().fromString(tokenString);
                 if (metadata.getEndpoint(token) != null)
-                    throw new ConfigurationException("Bootstraping to existing token " + tokenString + " is not allowed (decommission/removenode the old node first).");
+                    throw new ConfigurationException("Bootstrapping to existing token " + tokenString + " is not allowed (decommission/removenode the old node first).");
                 tokens.add(token);
             }
             return tokens;

File: test/unit/org/apache/cassandra/io/sstable/CQLSSTableWriterTest.java
Patch:
@@ -39,7 +39,7 @@
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.OutputHandler;
 
-public class CQLSSTableWriterTest extends SchemaLoader
+public class CQLSSTableWriterTest
 {
     @BeforeClass
     public static void setup() throws Exception
@@ -78,7 +78,7 @@ public void testUnsortedWriter() throws Exception
         {
             public void init(String keyspace)
             {
-                for (Range<Token> range : StorageService.instance.getLocalRanges("Keyspace1"))
+                for (Range<Token> range : StorageService.instance.getLocalRanges("cql_keyspace"))
                     addRangeForEndpoint(range, FBUtilities.getBroadcastAddress());
                 setPartitioner(StorageService.getPartitioner());
             }

File: src/java/org/apache/cassandra/locator/TokenMetadata.java
Patch:
@@ -976,7 +976,7 @@ public String printRelocatingRanges()
         return sb.toString();
     }
 
-    public Collection<InetAddress> pendingEndpointsFor(Token token, String table)
+    public Collection<InetAddress> pendingEndpointsFor(Token token, String keyspaceName)
     {
         Map<Range<Token>, Collection<InetAddress>> ranges = getPendingRanges(keyspaceName);
         if (ranges.isEmpty())

File: src/java/org/apache/cassandra/locator/PropertyFileSnitch.java
Patch:
@@ -188,7 +188,7 @@ public void reloadConfiguration() throws ConfigurationException
         logger.debug("loaded network topology {}", FBUtilities.toString(reloadedMap));
         endpointMap = reloadedMap;
         if (StorageService.instance != null) // null check tolerates circular dependency; see CASSANDRA-4145
-            StorageService.instance.getTokenMetadata().invalidateCaches();
+            StorageService.instance.getTokenMetadata().invalidateCachedRings();
 
         if (gossipStarted)
             StorageService.instance.gossipSnitchInfo();

File: src/java/org/apache/cassandra/locator/TokenMetadata.java
Patch:
@@ -1054,7 +1054,7 @@ public long getRingVersion()
         return ringVersion;
     }
 
-    private void invalidateCachedRings()
+    public void invalidateCachedRings()
     {
         ringVersion++;
     }

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -275,9 +275,6 @@ private Table(String table, boolean loadSSTables)
 
     public void createReplicationStrategy(KSMetaData ksm)
     {
-        if (replicationStrategy != null)
-            StorageService.instance.getTokenMetadata().unregister(replicationStrategy);
-
         replicationStrategy = AbstractReplicationStrategy.createReplicationStrategy(ksm.name,
                                                                                     ksm.strategyClass,
                                                                                     StorageService.instance.getTokenMetadata(),

File: src/java/org/apache/cassandra/db/compaction/CompactionController.java
Patch:
@@ -135,8 +135,8 @@ public static Set<SSTableReader> getFullyExpiredSSTables(ColumnFamilyStore cfSto
             }
             else
             {
-               logger.debug("Dropping expired SSTable {} (maxLocalDeletionTime={}, gcBefore={})",
-                        candidate, candidate.getSSTableMetadata().maxLocalDeletionTime, gcBefore);
+                logger.debug("Dropping expired SSTable {} (maxLocalDeletionTime={}, gcBefore={})",
+                             candidate, candidate.getSSTableMetadata().maxLocalDeletionTime, gcBefore);
             }
         }
         return new HashSet<SSTableReader>(candidates);

File: src/java/org/apache/cassandra/db/compaction/ParallelCompactionIterable.java
Patch:
@@ -56,7 +56,7 @@ public class ParallelCompactionIterable extends AbstractCompactionIterable
 
     public ParallelCompactionIterable(OperationType type, List<ICompactionScanner> scanners, CompactionController controller)
     {
-        this(type, scanners, controller, DatabaseDescriptor.getInMemoryCompactionLimit() / scanners.size());
+        this(type, scanners, controller, DatabaseDescriptor.getInMemoryCompactionLimit() / (scanners.isEmpty() ? 1 : scanners.size()));
     }
 
     public ParallelCompactionIterable(OperationType type, List<ICompactionScanner> scanners, CompactionController controller, int maxInMemorySize)

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -183,6 +183,9 @@ public class Config
     public volatile int tombstone_warn_threshold = 1000;
     public volatile int tombstone_failure_threshold = 100000;
 
+    public volatile Long index_summary_capacity_in_mb;
+    public volatile int index_summary_resize_interval_in_minutes = 60;
+
     public static boolean getOutboundBindAny()
     {
         return outboundBindAny;

File: src/java/org/apache/cassandra/db/compaction/AbstractCompactionStrategy.java
Patch:
@@ -283,7 +283,7 @@ else if (CompactionController.getFullyExpiredSSTables(cfs, Collections.singleton
         else
         {
             // what percentage of columns do we expect to compact outside of overlap?
-            if (sstable.getKeySampleSize() < 2)
+            if (sstable.getIndexSummarySize() < 2)
             {
                 // we have too few samples to estimate correct percentage
                 return false;

File: src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
Patch:
@@ -414,7 +414,7 @@ class IndexWriter implements Closeable
             indexFile = SequentialWriter.open(new File(descriptor.filenameFor(Component.PRIMARY_INDEX)),
                                               !metadata.populateIoCacheOnFlush());
             builder = SegmentedFile.getBuilder(DatabaseDescriptor.getIndexAccessMode());
-            summary = new IndexSummaryBuilder(keyCount, metadata.getIndexInterval());
+            summary = new IndexSummaryBuilder(keyCount, metadata.getIndexInterval(), Downsampling.BASE_SAMPLING_LEVEL);
             bf = FilterFactory.getFilter(keyCount, metadata.getBloomFilterFpChance(), true);
         }
 

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -487,10 +487,12 @@ public synchronized void initServer(int delay) throws ConfigurationException
         initialized = true;
         isClientMode = false;
 
-        // Ensure StorageProxy is initialized on start-up; see CASSANDRA-3797.
         try
         {
+            // Ensure StorageProxy is initialized on start-up; see CASSANDRA-3797.
             Class.forName("org.apache.cassandra.service.StorageProxy");
+            // also IndexSummaryManager, which is otherwise unreferenced
+            Class.forName("org.apache.cassandra.io.sstable.IndexSummaryManager");
         }
         catch (ClassNotFoundException e)
         {

File: test/unit/org/apache/cassandra/SchemaLoader.java
Patch:
@@ -202,7 +202,8 @@ public static Collection<KSMetaData> schemaDefinition(boolean withOldCfIds) thro
                                                                                .compactionStrategyOptions(leveledOptions),
                                            standardCFMD(ks1, "legacyleveled")
                                                                                .compactionStrategyClass(LeveledCompactionStrategy.class)
-                                                                               .compactionStrategyOptions(leveledOptions)));
+                                                                               .compactionStrategyOptions(leveledOptions),
+                                           standardCFMD(ks1, "StandardLowIndexInterval").indexInterval(8).caching(CFMetaData.Caching.NONE)));
 
         // Keyspace 2
         schema.add(KSMetaData.testMetadata(ks2,

File: src/java/org/apache/cassandra/db/Memtable.java
Patch:
@@ -362,7 +362,9 @@ private SSTableReader writeSortedContents(Future<ReplayPosition> context, File s
                         if (!cfs.indexManager.hasIndexes())
                             currentSize.addAndGet(-ColumnFamilyStore.removeDeletedColumnsOnly(cf, Integer.MIN_VALUE));
                     }
-                    writer.append((DecoratedKey)entry.getKey(), cf);
+
+                    if (cf.getColumnCount() > 0 || cf.isMarkedForDelete())
+                        writer.append((DecoratedKey)entry.getKey(), cf);
                 }
 
                 if (writer.getFilePointer() > 0)

File: src/java/org/apache/cassandra/db/Memtable.java
Patch:
@@ -497,7 +497,7 @@ public void run()
 
                 if (newRatio < MIN_SANE_LIVE_RATIO)
                 {
-                    logger.warn("setting live ratio to minimum of {} instead of {}", MIN_SANE_LIVE_RATIO, newRatio);
+                    logger.debug("setting live ratio to minimum of {} instead of {}", MIN_SANE_LIVE_RATIO, newRatio);
                     newRatio = MIN_SANE_LIVE_RATIO;
                 }
                 if (newRatio > MAX_SANE_LIVE_RATIO)

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -1407,7 +1407,7 @@ public String system_update_column_family(CfDef cf_def)
             if (oldCfm == null)
                 throw new InvalidRequestException("Could not find column family definition to modify.");
 
-            if (!oldCfm.isThriftIncompatible())
+            if (oldCfm.isThriftIncompatible())
                 throw new InvalidRequestException("Cannot modify CQL3 table " + oldCfm.cfName + " as it may break the schema. You should use cqlsh to modify CQL3 tables instead.");
 
             state().hasColumnFamilyAccess(cf_def.keyspace, cf_def.name, Permission.ALTER);

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -38,7 +38,7 @@
 /**
  * Abstract class for statements that apply on a given column family.
  */
-public abstract class ModificationStatement extends CFStatement implements CQLStatement
+public abstract class ModificationStatement extends CFStatement implements CQLStatement, MeasurableForPreparedCache
 {
     public static enum Type
     {

File: src/java/org/apache/cassandra/cql3/Operation.java
Patch:
@@ -400,7 +400,7 @@ public Operation prepare(ColumnSpecification receiver) throws InvalidRequestExce
                     return new Lists.DiscarderByIndex(id, idx);
                 case SET:
                     Term elt = element.prepare(Sets.valueSpecOf(receiver));
-                    return new Lists.Discarder(id, elt);
+                    return new Sets.Discarder(id, elt);
                 case MAP:
                     Term key = element.prepare(Maps.keySpecOf(receiver));
                     return new Maps.DiscarderByKey(id, key);

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -468,7 +468,6 @@ public int compare(InetAddress endpoint1, InetAddress endpoint2)
         assert systemKeyspaces.size() == Schema.systemKeyspaceNames.size();
         for (KSMetaData ksmd : systemKeyspaces)
             Schema.instance.load(ksmd);
-        Schema.instance.loadUserTypes();
 
         /* Load the seeds for node contact points */
         if (conf.seed_provider == null)
@@ -502,6 +501,8 @@ private static IEndpointSnitch createEndpointSnitch(String snitchClassName) thro
     /** load keyspace (keyspace) definitions, but do not initialize the keyspace instances. */
     public static void loadSchemas()
     {
+        Schema.instance.loadUserTypes();
+
         ColumnFamilyStore schemaCFS = SystemKeyspace.schemaCFS(SystemKeyspace.SCHEMA_KEYSPACES_CF);
 
         // if keyspace with definitions is empty try loading the old way

File: src/java/org/apache/cassandra/tools/SSTableImport.java
Patch:
@@ -44,9 +44,9 @@
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.BytesType;
 import org.apache.cassandra.db.marshal.CompositeType;
-import org.apache.cassandra.db.marshal.MarshalException;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.io.sstable.SSTableWriter;
+import org.apache.cassandra.serializers.MarshalException;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.codehaus.jackson.JsonFactory;
 import org.codehaus.jackson.JsonParser;
@@ -158,8 +158,7 @@ else if (isRangeTombstone())
                 }
                 else if (isRangeTombstone())
                 {
-                    AbstractType<?> type = CompositeType.getInstance(Arrays.asList(new AbstractType<?>[]{meta.getColumnDefinitionComparator(0)}));
-                    value = type.fromString((String)fields.get(1));
+                    value = comparator.fromString((String)fields.get(1));
                 }
                 else
                 {

File: src/java/org/apache/cassandra/db/marshal/CompositeType.java
Patch:
@@ -229,11 +229,11 @@ public boolean intersects(List<ByteBuffer> minColumnNames, List<ByteBuffer> maxC
                 AbstractType<?> t = types.get(i);
                 ByteBuffer s = i < start.length ? start[i] : ByteBufferUtil.EMPTY_BYTE_BUFFER;
                 ByteBuffer f = i < finish.length ? finish[i] : ByteBufferUtil.EMPTY_BYTE_BUFFER;
-                if (!t.intersects(minColumnNames.get(i), maxColumnNames.get(i), s, f))
-                    return false;
+                if (t.intersects(minColumnNames.get(i), maxColumnNames.get(i), s, f))
+                    return true;
             }
         }
-        return true;
+        return false;
     }
 
     private static class StaticParsedComparator implements ParsedComparator

File: src/java/org/apache/cassandra/net/WriteCallbackInfo.java
Patch:
@@ -39,6 +39,8 @@ public WriteCallbackInfo(InetAddress target, IAsyncCallback callback, MessageOut
 
     public boolean shouldHint()
     {
-        return consistencyLevel != ConsistencyLevel.ANY && StorageProxy.shouldHint(target);
+        return sentMessage.verb != MessagingService.Verb.COUNTER_MUTATION
+               && consistencyLevel != ConsistencyLevel.ANY
+               && StorageProxy.shouldHint(target);
     }
 }

File: src/java/org/apache/cassandra/db/compaction/Scrubber.java
Patch:
@@ -120,7 +120,7 @@ public void scrub()
                 if (scrubInfo.isStopRequested())
                     throw new CompactionInterruptedException(scrubInfo.getCompactionInfo());
                 long rowStart = dataFile.getFilePointer();
-                outputHandler.debug("Reading row at {}" + rowStart);
+                outputHandler.debug("Reading row at " + rowStart);
 
                 DecoratedKey key = null;
                 long dataSize = -1;

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -3106,8 +3106,7 @@ public void confirmReplication(InetAddress node)
         }
         else
         {
-            logger.info("Received unexpected REPLICATION_FINISHED message from " + node
-                         + ". Was this node recently a removal coordinator?");
+            logger.info("Received unexpected REPLICATION_FINISHED message from {}. Was this node recently a removal coordinator?", node);
         }
     }
 

File: src/java/org/apache/cassandra/db/commitlog/CommitLogReplayer.java
Patch:
@@ -127,7 +127,7 @@ public static ReplayFilter create()
             Multimap<String, String> toReplay = HashMultimap.create();
             for (String rawPair : System.getProperty("cassandra.replayList").split(","))
             {
-                String[] pair = rawPair.trim().split(".");
+                String[] pair = rawPair.trim().split("\\.");
                 if (pair.length != 2)
                     throw new IllegalArgumentException("Each table to be replayed must be fully qualified with keyspace name, e.g., 'system.peers'");
 

File: src/java/org/apache/cassandra/thrift/ThriftValidation.java
Patch:
@@ -212,7 +212,7 @@ private static void validateColumnNames(CFMetaData metadata, ByteBuffer superCol
         }
         AbstractType<?> comparator = SuperColumns.getComparatorFor(metadata, superColumnName);
         CFDefinition cfDef = metadata.getCfDef();
-        boolean isCQL3Table = cfDef.isComposite && !cfDef.isCompact && !metadata.isSuper();
+        boolean isCQL3Table = !metadata.isThriftCompatible();
         for (ByteBuffer name : column_names)
         {
             if (name.remaining() > maxNameLength)

File: src/java/org/apache/cassandra/db/RangeSliceCommand.java
Patch:
@@ -310,7 +310,7 @@ public long serializedSize(RangeSliceCommand rsc, int version)
             {
                 size += TypeSizes.NATIVE.sizeofWithShortLength(expr.column_name);
                 size += TypeSizes.NATIVE.sizeof(expr.op.getValue());
-                size += TypeSizes.NATIVE.sizeofWithLength(expr.value);
+                size += TypeSizes.NATIVE.sizeofWithShortLength(expr.value);
             }
         }
         size += AbstractBounds.serializer.serializedSize(rsc.keyRange, version);

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -96,6 +96,7 @@ public class Config
     public Boolean start_native_transport = false;
     public Integer native_transport_port = 9042;
     public Integer native_transport_max_threads = 128;
+    public Integer native_transport_max_frame_size_in_mb = 256;
 
     @Deprecated
     public Integer thrift_max_message_length_in_mb = 16;

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -465,6 +465,7 @@ public int compare(InetAddress endpoint1, InetAddress endpoint2)
         assert systemKeyspaces.size() == Schema.systemKeyspaceNames.size();
         for (KSMetaData ksmd : systemKeyspaces)
             Schema.instance.load(ksmd);
+        Schema.instance.loadUserTypes();
 
         /* Load the seeds for node contact points */
         if (conf.seed_provider == null)

File: src/java/org/apache/cassandra/config/KSMetaData.java
Patch:
@@ -84,11 +84,12 @@ public static KSMetaData systemKeyspace()
                                                 CFMetaData.PeerEventsCf,
                                                 CFMetaData.HintsCf,
                                                 CFMetaData.IndexCf,
-                                                CFMetaData.SchemaTriggersCf,
                                                 CFMetaData.CounterIdCf,
                                                 CFMetaData.SchemaKeyspacesCf,
                                                 CFMetaData.SchemaColumnFamiliesCf,
                                                 CFMetaData.SchemaColumnsCf,
+                                                CFMetaData.SchemaTriggersCf,
+                                                CFMetaData.SchemaUserTypesCf,
                                                 CFMetaData.CompactionLogCf,
                                                 CFMetaData.CompactionHistoryCf,
                                                 CFMetaData.PaxosCf,

File: src/java/org/apache/cassandra/cql3/ResultSet.java
Patch:
@@ -310,7 +310,7 @@ public String toString()
             {
                 for (ColumnSpecification name : names)
                 {
-                    sb.append("[").append(name.toString());
+                    sb.append("[").append(name.name.toString());
                     sb.append("(").append(name.ksName).append(", ").append(name.cfName).append(")");
                     sb.append(", ").append(name.type).append("]");
                 }
@@ -389,7 +389,7 @@ public void encode(Metadata m, ChannelBuffer dest, int version)
                             CBUtil.writeString(name.ksName, dest);
                             CBUtil.writeString(name.cfName, dest);
                         }
-                        CBUtil.writeString(name.toString(), dest);
+                        CBUtil.writeString(name.name.toString(), dest);
                         DataType.codec.writeOne(DataType.fromType(name.type), dest);
                     }
                 }
@@ -420,7 +420,7 @@ public int encodedSize(Metadata m, int version)
                             size += CBUtil.sizeOfString(name.ksName);
                             size += CBUtil.sizeOfString(name.cfName);
                         }
-                        size += CBUtil.sizeOfString(name.toString());
+                        size += CBUtil.sizeOfString(name.name.toString());
                         size += DataType.codec.oneSerializedSize(DataType.fromType(name.type));
                     }
                 }

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -1270,7 +1270,7 @@ public ColumnDefinition getColumnDefinitionFromCellName(ByteBuffer cellName)
 
                     toCompare = components[def.position()];
                 }
-                if (def.name.equals(toCompare))
+                if (def.name.bytes.equals(toCompare))
                     return def;
             }
             return null;
@@ -1281,8 +1281,6 @@ public ColumnDefinition getColumnDefinitionFromCellName(ByteBuffer cellName)
         }
     }
 
-
-
     public ColumnDefinition getColumnDefinitionForIndex(String indexName)
     {
         for (ColumnDefinition def : allColumns())

File: src/java/org/apache/cassandra/cql/AlterTableStatement.java
Patch:
@@ -80,7 +80,7 @@ public CFMetaData getCFMetaData(String keyspace) throws ConfigurationException,
             case ALTER:
                 // We only look for the first key alias which is ok for CQL2
                 ColumnDefinition partionKeyDef = cfm.partitionKeyColumns().get(0);
-                if (partionKeyDef.name.equals(columnName))
+                if (partionKeyDef.name.bytes.equals(columnName))
                 {
                     cfm.keyValidator(TypeParser.parse(validator));
                 }
@@ -90,7 +90,7 @@ public CFMetaData getCFMetaData(String keyspace) throws ConfigurationException,
 
                     for (ColumnDefinition columnDef : cfm.regularColumns())
                     {
-                        if (columnDef.name.equals(columnName))
+                        if (columnDef.name.bytes.equals(columnName))
                         {
                             toUpdate = columnDef;
                             break;
@@ -111,7 +111,7 @@ public CFMetaData getCFMetaData(String keyspace) throws ConfigurationException,
 
                 for (ColumnDefinition columnDef : cfm.regularColumns())
                 {
-                    if (columnDef.name.equals(columnName))
+                    if (columnDef.name.bytes.equals(columnName))
                     {
                         toDelete = columnDef;
                     }

File: src/java/org/apache/cassandra/cql/QueryProcessor.java
Patch:
@@ -678,7 +678,7 @@ else if (oldKeyspace == null)
                 CFMetaData cfm = oldCfm.clone();
                 for (ColumnDefinition cd : cfm.regularColumns())
                 {
-                    if (cd.name.equals(columnName))
+                    if (cd.name.bytes.equals(columnName))
                     {
                         if (cd.getIndexType() != null)
                             throw new InvalidRequestException("Index already exists");

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -1122,7 +1122,7 @@ public ParsedStatement.Prepared prepare() throws InvalidRequestException
                         throw new InvalidRequestException(String.format("Predicates on the non-primary-key column (%s) of a COMPACT table are not yet supported", def.name));
                     case REGULAR:
                         // We only all IN on the row key and last clustering key so far, never on non-PK columns, and this even if there's an index
-                        Restriction r = updateRestriction(def, stmt.metadataRestrictions.get(def), rel, names);
+                        Restriction r = updateRestriction(def, stmt.metadataRestrictions.get(def.name), rel, names);
                         if (r.isIN() && !((Restriction.IN)r).canHaveOnlyOneValue())
                             // Note: for backward compatibility reason, we conside a IN of 1 value the same as a EQ, so we let that slide.
                             throw new InvalidRequestException(String.format("IN predicates on non-primary-key columns (%s) is not yet supported", def.name));

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -916,7 +916,8 @@ public static long removeDeletedColumnsOnly(ColumnFamily cf, int gcBefore)
     // 2. if it has been re-added since then, this particular column was inserted before the last drop
     private static boolean isDroppedColumn(Column c, CFMetaData meta)
     {
-        Long droppedAt = meta.getDroppedColumns().get(((CompositeType) meta.comparator).extractLastComponent(c.name()));
+        ByteBuffer cql3ColumnName = ((CompositeType) meta.comparator).extractLastComponent(c.name());
+        Long droppedAt = meta.getDroppedColumns().get(meta.getColumnDefinition(cql3ColumnName).name);
         return droppedAt != null && c.timestamp() <= droppedAt;
     }
 

File: src/java/org/apache/cassandra/db/index/SecondaryIndex.java
Patch:
@@ -255,7 +255,7 @@ void removeColumnDef(ByteBuffer name)
         Iterator<ColumnDefinition> it = columnDefs.iterator();
         while (it.hasNext())
         {
-            if (it.next().name.equals(name))
+            if (it.next().name.bytes.equals(name))
                 it.remove();
         }
     }

File: src/java/org/apache/cassandra/db/compaction/PrecompactedRow.java
Patch:
@@ -168,7 +168,9 @@ public RowIndexEntry write(long currentPosition, DataOutput out) throws IOExcept
 
     public void update(MessageDigest digest)
     {
-        assert compactedCf != null;
+        if (compactedCf == null)
+            return;
+
         DataOutputBuffer buffer = new DataOutputBuffer();
         try
         {

File: src/java/org/apache/cassandra/db/compaction/AbstractCompactedRow.java
Patch:
@@ -42,10 +42,10 @@ public AbstractCompactedRow(DecoratedKey key)
 
     /**
      * write the row (size + column index + filter + column data, but NOT row key) to @param out.
-     * It is an error to call this if isEmpty is false.  (Because the key is appended first,
-     * so we'd have an incomplete row written.)
      *
      * write() may change internal state; it is NOT valid to call write() or update() a second time.
+     *
+     * @return index information for the written row, or null if the compaction resulted in only expired tombstones.
      */
     public abstract RowIndexEntry write(long currentPosition, DataOutput out) throws IOException;
 

File: src/java/org/apache/cassandra/db/compaction/CompactionController.java
Patch:
@@ -154,7 +154,7 @@ public String getColumnFamily()
 
     /**
      * @return true if it's okay to drop tombstones for the given row, i.e., if we know all the verisons of the row
-     * are included in the compaction set
+     * older than @param maxDeletionTimestamp are included in the compaction set
      */
     public boolean shouldPurge(DecoratedKey key, long maxDeletionTimestamp)
     {

File: src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
Patch:
@@ -259,7 +259,7 @@ public long appendFromStream(DecoratedKey key, CFMetaData metadata, DataInput in
                 columnIndexer.add(atom); // This write the atom on disk too
             }
 
-            columnIndexer.finish();
+            columnIndexer.maybeWriteEmptyRowHeader();
             dataFile.stream.writeShort(END_OF_ROW);
         }
         catch (IOException e)

File: src/java/org/apache/cassandra/db/compaction/SizeTieredCompactionStrategyOptions.java
Patch:
@@ -26,7 +26,7 @@ public final class SizeTieredCompactionStrategyOptions
     protected static final long DEFAULT_MIN_SSTABLE_SIZE = 50L * 1024L * 1024L;
     protected static final double DEFAULT_BUCKET_LOW = 0.5;
     protected static final double DEFAULT_BUCKET_HIGH = 1.5;
-    protected static final double DEFAULT_COLD_READS_TO_OMIT = 0.0;
+    protected static final double DEFAULT_COLD_READS_TO_OMIT = 0.05;
     protected static final String MIN_SSTABLE_SIZE_KEY = "min_sstable_size";
     protected static final String BUCKET_LOW_KEY = "bucket_low";
     protected static final String BUCKET_HIGH_KEY = "bucket_high";

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -1461,7 +1461,7 @@ public RowMutation toSchemaUpdate(CFMetaData newState, long modificationTimestam
             if (fromThrift && cd.type != ColumnDefinition.Type.REGULAR)
                 continue;
 
-            cd.deleteFromSchema(rm, cfName, modificationTimestamp);
+            cd.deleteFromSchema(rm, cfName, getColumnDefinitionComparator(cd), modificationTimestamp);
         }
 
         // newly added columns
@@ -1506,7 +1506,7 @@ public RowMutation dropFromSchema(long timestamp)
         cf.addAtom(new RangeTombstone(builder.build(), builder.buildAsEndOfRange(), timestamp, ldt));
 
         for (ColumnDefinition cd : column_metadata.values())
-            cd.deleteFromSchema(rm, cfName, timestamp);
+            cd.deleteFromSchema(rm, cfName, getColumnDefinitionComparator(cd), timestamp);
 
         for (TriggerDefinition td : triggers.values())
             td.deleteFromSchema(rm, cfName, timestamp);

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -83,7 +83,7 @@ public final class CFMetaData
     public final static Class<? extends AbstractCompactionStrategy> DEFAULT_COMPACTION_STRATEGY_CLASS = SizeTieredCompactionStrategy.class;
     public final static Caching DEFAULT_CACHING_STRATEGY = Caching.KEYS_ONLY;
     public final static int DEFAULT_DEFAULT_TIME_TO_LIVE = 0;
-    public final static SpeculativeRetry DEFAULT_SPECULATIVE_RETRY = new SpeculativeRetry(SpeculativeRetry.RetryType.NONE, 0);
+    public final static SpeculativeRetry DEFAULT_SPECULATIVE_RETRY = new SpeculativeRetry(SpeculativeRetry.RetryType.PERCENTILE, 0.99);
     public final static int DEFAULT_INDEX_INTERVAL = 128;
     public final static boolean DEFAULT_POPULATE_IO_CACHE_ON_FLUSH = false;
 

File: src/java/org/apache/cassandra/service/IResponseResolver.java
Patch:
@@ -38,6 +38,6 @@ public interface IResponseResolver<TMessage, TResolved> {
      */
     public TResolved getData();
 
-    public boolean preprocess(MessageIn<TMessage> message);
+    public void preprocess(MessageIn<TMessage> message);
     public Iterable<MessageIn<TMessage>> getMessages();
 }

File: src/java/org/apache/cassandra/service/RangeSliceResponseResolver.java
Patch:
@@ -93,10 +93,9 @@ public Iterable<Row> resolve()
         return resolvedRows;
     }
 
-    public boolean preprocess(MessageIn message)
+    public void preprocess(MessageIn message)
     {
         responses.add(message);
-        return true;
     }
 
     public boolean isDataPresent()

File: src/java/org/apache/cassandra/hadoop/ConfigHelper.java
Patch:
@@ -382,7 +382,7 @@ public static boolean getInputIsWide(Configuration conf)
 
     public static String getReadConsistencyLevel(Configuration conf)
     {
-        return conf.get(READ_CONSISTENCY_LEVEL, "ONE");
+        return conf.get(READ_CONSISTENCY_LEVEL, "LOCAL_ONE");
     }
 
     public static void setReadConsistencyLevel(Configuration conf, String consistencyLevel)
@@ -392,7 +392,7 @@ public static void setReadConsistencyLevel(Configuration conf, String consistenc
 
     public static String getWriteConsistencyLevel(Configuration conf)
     {
-        return conf.get(WRITE_CONSISTENCY_LEVEL, "ONE");
+        return conf.get(WRITE_CONSISTENCY_LEVEL, "LOCAL_ONE");
     }
 
     public static void setWriteConsistencyLevel(Configuration conf, String consistencyLevel)

File: src/java/org/apache/cassandra/tracing/TraceState.java
Patch:
@@ -90,6 +90,7 @@ public void trace(String message)
     public static void trace(final ByteBuffer sessionIdBytes, final String message, final int elapsed)
     {
         final ByteBuffer eventId = ByteBuffer.wrap(UUIDGen.getTimeUUIDBytes());
+        final String threadName = Thread.currentThread().getName();
 
         StageManager.getStage(Stage.TRACING).execute(new WrappedRunnable()
         {
@@ -101,7 +102,7 @@ public void runMayThrow()
                 Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("source")), FBUtilities.getBroadcastAddress());
                 if (elapsed >= 0)
                     Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("source_elapsed")), elapsed);
-                Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("activity")), message);
+                Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("thread")), threadName);
                 Tracing.mutateWithCatch(new RowMutation(Tracing.TRACE_KS, sessionIdBytes, cf));
             }
         });

File: src/java/org/apache/cassandra/db/SystemKeyspace.java
Patch:
@@ -844,7 +844,9 @@ public static PaxosState loadPaxosState(ByteBuffer key, CFMetaData metadata)
         if (results.isEmpty())
             return new PaxosState(key, metadata);
         UntypedResultSet.Row row = results.one();
-        Commit promised = new Commit(key, row.getUUID("in_progress_ballot"), EmptyColumns.factory.create(metadata));
+        Commit promised = row.has("in_progress_ballot")
+                        ? new Commit(key, row.getUUID("in_progress_ballot"), EmptyColumns.factory.create(metadata))
+                        : Commit.emptyCommit(key, metadata);
         // either we have both a recently accepted ballot and update or we have neither
         Commit accepted = row.has("proposal")
                         ? new Commit(key, row.getUUID("proposal_ballot"), ColumnFamily.fromBytes(row.getBytes("proposal")))

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -83,7 +83,7 @@ public final class CFMetaData
     public final static Class<? extends AbstractCompactionStrategy> DEFAULT_COMPACTION_STRATEGY_CLASS = SizeTieredCompactionStrategy.class;
     public final static Caching DEFAULT_CACHING_STRATEGY = Caching.KEYS_ONLY;
     public final static int DEFAULT_DEFAULT_TIME_TO_LIVE = 0;
-    public final static SpeculativeRetry DEFAULT_SPECULATIVE_RETRY = new SpeculativeRetry(SpeculativeRetry.RetryType.PERCENTILE, 0.99);
+    public final static SpeculativeRetry DEFAULT_SPECULATIVE_RETRY = new SpeculativeRetry(SpeculativeRetry.RetryType.NONE, 0);
     public final static int DEFAULT_INDEX_INTERVAL = 128;
     public final static boolean DEFAULT_POPULATE_IO_CACHE_ON_FLUSH = false;
 

File: src/java/org/apache/cassandra/config/ColumnDefinition.java
Patch:
@@ -265,9 +265,9 @@ public void apply(ColumnDefinition def, AbstractType<?> comparator)  throws Conf
         if (getIndexType() != null && def.getIndexType() != null)
         {
             // If an index is set (and not drop by this update), the validator shouldn't be change to a non-compatible one
+            // (and we want true comparator compatibility, not just value one, since the validator is used by LocalPartitioner to order index rows)
             if (!def.getValidator().isCompatibleWith(getValidator()))
-                throw new ConfigurationException(String.format("Cannot modify validator to a non-compatible one for column %s since an index is set",
-                                                                comparator.getString(name)));
+                throw new ConfigurationException(String.format("Cannot modify validator to a non-order-compatible one for column %s since an index is set", comparator.getString(name)));
 
             assert getIndexName() != null;
             if (!getIndexName().equals(def.getIndexName()))

File: src/java/org/apache/cassandra/config/ColumnDefinition.java
Patch:
@@ -180,8 +180,9 @@ public void apply(ColumnDefinition def, AbstractType<?> comparator)  throws Conf
         if (getIndexType() != null && def.getIndexType() != null)
         {
             // If an index is set (and not drop by this update), the validator shouldn't be change to a non-compatible one
+            // (and we want true comparator compatibility, not just value one, since the validator is used by LocalPartitioner to order index rows)
             if (!def.getValidator().isCompatibleWith(getValidator()))
-                throw new ConfigurationException(String.format("Cannot modify validator to a non-compatible one for column %s since an index is set", comparator.getString(name)));
+                throw new ConfigurationException(String.format("Cannot modify validator to a non-order-compatible one for column %s since an index is set", comparator.getString(name)));
 
             assert getIndexName() != null;
             if (!getIndexName().equals(def.getIndexName()))

File: src/java/org/apache/cassandra/io/util/Memory.java
Patch:
@@ -156,6 +156,7 @@ public void free()
 
     public long size()
     {
+        assert peer != 0;
         return size;
     }
 

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -932,7 +932,7 @@ private void bootstrap(Collection<Token> tokens)
         {
             // Dont set any state for the node which is bootstrapping the existing token...
             tokenMetadata.updateNormalTokens(tokens, FBUtilities.getBroadcastAddress());
-            SystemTable.removeEndpoint(DatabaseDescriptor.getReplaceAddress());
+            SystemKeyspace.removeEndpoint(DatabaseDescriptor.getReplaceAddress());
         }
         if (!Gossiper.instance.seenAnySeed())
             throw new IllegalStateException("Unable to contact any seeds!");

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -585,7 +585,7 @@ private void joinTokenRing(int delay) throws ConfigurationException
         // for bootstrap to get the load info it needs.
         // (we won't be part of the storage ring though until we add a counterId to our state, below.)
         // Seed the host ID-to-endpoint map with our own ID.
-        getTokenMetadata().updateHostId(SystemTable.getLocalHostId(), FBUtilities.getBroadcastAddress());
+        getTokenMetadata().updateHostId(SystemKeyspace.getLocalHostId(), FBUtilities.getBroadcastAddress());
         appStates.put(ApplicationState.NET_VERSION, valueFactory.networkVersion());
         appStates.put(ApplicationState.HOST_ID, valueFactory.hostId(SystemKeyspace.getLocalHostId()));
         appStates.put(ApplicationState.RPC_ADDRESS, valueFactory.rpcaddress(DatabaseDescriptor.getRpcAddress()));

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -582,7 +582,7 @@ private void joinTokenRing(int delay) throws ConfigurationException
         // for bootstrap to get the load info it needs.
         // (we won't be part of the storage ring though until we add a counterId to our state, below.)
         // Seed the host ID-to-endpoint map with our own ID.
-        getTokenMetadata().updateHostId(SystemTable.getLocalHostId(), FBUtilities.getBroadcastAddress());
+        getTokenMetadata().updateHostId(SystemKeyspace.getLocalHostId(), FBUtilities.getBroadcastAddress());
         appStates.put(ApplicationState.NET_VERSION, valueFactory.networkVersion());
         appStates.put(ApplicationState.HOST_ID, valueFactory.hostId(SystemKeyspace.getLocalHostId()));
         appStates.put(ApplicationState.RPC_ADDRESS, valueFactory.rpcaddress(DatabaseDescriptor.getRpcAddress()));

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -402,7 +402,7 @@ public synchronized Collection<Token> prepareReplacementInfo() throws Configurat
         {
             throw new RuntimeException(e);
         }
-        SystemTable.setLocalHostId(hostId); // use the replacee's host Id as our own so we receive hints, etc
+        SystemKeyspace.setLocalHostId(hostId); // use the replacee's host Id as our own so we receive hints, etc
         MessagingService.instance().shutdown();
         Gossiper.instance.resetEndpointStateMap(); // clean up since we have what we need
         return tokens;

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -267,6 +267,8 @@ else if (conf.memtable_flush_writers == null)
         /* Local IP or hostname to bind services to */
         if (conf.listen_address != null)
         {
+            if (conf.listen_address.equals("0.0.0.0"))
+                throw new ConfigurationException("listen_address cannot be 0.0.0.0!");
             try
             {
                 listenAddress = InetAddress.getByName(conf.listen_address);
@@ -276,8 +278,6 @@ else if (conf.memtable_flush_writers == null)
                 throw new ConfigurationException("Unknown listen_address '" + conf.listen_address + "'");
             }
         }
-        if (conf.listen_address.equals("0.0.0.0"))
-            throw new ConfigurationException("listen_address cannot be 0.0.0.0!");
 
         try
         {

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -1174,7 +1174,8 @@ else if (inner instanceof UnknownHostException)
                     
 
                 case STATUS :
-                    nodeCmd.printClusterStatus(System.out, arguments[0]);
+                    if (arguments.length > 0) nodeCmd.printClusterStatus(System.out, arguments[0]);
+                    else                      nodeCmd.printClusterStatus(System.out, null);
                     break;
 
                 case DECOMMISSION :

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -548,7 +548,7 @@ public int addCallback(IAsyncCallback cb, MessageOut message, InetAddress to, lo
 
     public int addCallback(IAsyncCallback cb, MessageOut<? extends IMutation> message, InetAddress to, long timeout, ConsistencyLevel consistencyLevel)
     {
-        assert message.verb == Verb.MUTATION;
+        assert message.verb == Verb.MUTATION || message.verb == Verb.COUNTER_MUTATION;
         int messageId = nextId();
         CallbackInfo previous = callbacks.put(messageId, new WriteCallbackInfo(to, cb, message, callbackDeserializers.get(message.verb), consistencyLevel), timeout);
         assert previous == null;

File: src/java/org/apache/cassandra/tracing/TraceState.java
Patch:
@@ -99,7 +99,7 @@ public void runMayThrow()
                 Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("thread")), threadName);
                 if (elapsed >= 0)
                     Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("source_elapsed")), elapsed);
-                Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("thread")), threadName);
+                Tracing.addColumn(cf, Tracing.buildName(cfMeta, eventId, ByteBufferUtil.bytes("activity")), message);
                 Tracing.mutateWithCatch(new RowMutation(Tracing.TRACE_KS, sessionIdBytes, cf));
             }
         });

File: src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java
Patch:
@@ -67,6 +67,9 @@ public void checkAccess(ClientState state) throws UnauthorizedException, Invalid
     public void validate(ClientState state) throws RequestValidationException
     {
         CFMetaData cfm = ThriftValidation.validateColumnFamily(keyspace(), columnFamily());
+        if (cfm.getDefaultValidator().isCommutative())
+            throw new InvalidRequestException("Secondary indexes are not supported on counter tables");
+
         CFDefinition.Name name = cfm.getCfDef().get(columnName);
 
         if (name == null)

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -175,8 +175,8 @@ public Collection<Range<Token>> getLocalPrimaryRanges(String keyspace)
     /* the probability for tracing any particular request, 0 disables tracing and 1 enables for all */
     private double tracingProbability = 0.0;
 
-    private static enum Mode { NORMAL, CLIENT, JOINING, LEAVING, DECOMMISSIONED, MOVING, DRAINING, DRAINED, RELOCATING }
-    private Mode operationMode;
+    private static enum Mode { STARTING, NORMAL, CLIENT, JOINING, LEAVING, DECOMMISSIONED, MOVING, DRAINING, DRAINED, RELOCATING }
+    private Mode operationMode = Mode.STARTING;
 
     private final MigrationManager migrationManager = MigrationManager.instance;
 

File: src/java/org/apache/cassandra/service/AbstractWriteResponseHandler.java
Patch:
@@ -38,7 +38,7 @@ public abstract class AbstractWriteResponseHandler implements IAsyncCallback
     protected final Keyspace keyspace;
     protected final long start;
     protected final Collection<InetAddress> naturalEndpoints;
-    protected final ConsistencyLevel consistencyLevel;
+    public final ConsistencyLevel consistencyLevel;
     protected final Runnable callback;
     protected final Collection<InetAddress> pendingEndpoints;
     private final WriteType writeType;

File: src/java/org/apache/cassandra/db/index/composites/CompositesSearcher.java
Patch:
@@ -56,7 +56,7 @@ private IndexExpression highestSelectivityPredicate(List<IndexExpression> clause
     {
         IndexExpression best = null;
         int bestMeanCount = Integer.MAX_VALUE;
-        Map<SecondaryIndex, Integer> candidates = new HashMap<>();
+        Map<SecondaryIndex, Integer> candidates = new HashMap<SecondaryIndex, Integer>();
 
         for (IndexExpression expression : clause)
         {

File: src/java/org/apache/cassandra/db/index/keys/KeysSearcher.java
Patch:
@@ -52,7 +52,7 @@ private IndexExpression highestSelectivityPredicate(List<IndexExpression> clause
     {
         IndexExpression best = null;
         int bestMeanCount = Integer.MAX_VALUE;
-        Map<SecondaryIndex, Integer> candidates = new HashMap<>();
+        Map<SecondaryIndex, Integer> candidates = new HashMap<SecondaryIndex, Integer>();
 
         for (IndexExpression expression : clause)
         {

File: src/java/org/apache/cassandra/hadoop/pig/AbstractCassandraStorage.java
Patch:
@@ -127,6 +127,7 @@ protected Tuple columnToTuple(Column col, CfDef cfDef, AbstractType comparator)
             setTupleValue(pair, 0, cassandraToObj(comparator, col.name()));
 
         // value
+        Map<ByteBuffer,AbstractType> validators = getValidatorMap(cfDef);
         if (validators.get(col.name()) == null)
         {
             Map<MarshallerType, AbstractType> marshallers = getDefaultMarshallers(cfDef);

File: src/java/org/apache/cassandra/io/util/RandomAccessReader.java
Patch:
@@ -152,7 +152,7 @@ public String getPath()
         return filePath;
     }
 
-    public int getBufferSize()
+    public int getTotalBufferSize()
     {
         return buffer.length;
     }

File: src/java/org/apache/cassandra/io/util/SegmentedFile.java
Patch:
@@ -19,6 +19,7 @@
 
 import java.io.DataInput;
 import java.io.DataOutput;
+import java.io.File;
 import java.io.IOException;
 import java.nio.MappedByteBuffer;
 import java.util.Iterator;
@@ -57,7 +58,7 @@ public abstract class SegmentedFile
 
     protected SegmentedFile(String path, long length, long onDiskLength)
     {
-        this.path = path;
+        this.path = new File(path).getAbsolutePath();
         this.length = length;
         this.onDiskLength = onDiskLength;
     }

File: src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java
Patch:
@@ -725,7 +725,7 @@ private void addKeyToTuple(Tuple tuple, ByteBuffer key, CfDef cfDef, AbstractTyp
         }
         else
         {
-            setTupleValue(tuple, 0, getDefaultMarshallers(cfDef).get(MarshallerType.KEY_VALIDATOR).compose(key));
+            setTupleValue(tuple, 0, cassandraToObj(getDefaultMarshallers(cfDef).get(MarshallerType.KEY_VALIDATOR), key));
         }
 
     }

File: src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java
Patch:
@@ -731,7 +731,7 @@ private void addKeyToTuple(Tuple tuple, ByteBuffer key, CfDef cfDef, AbstractTyp
         }
         else
         {
-            setTupleValue(tuple, 0, getDefaultMarshallers(cfDef).get(MarshallerType.KEY_VALIDATOR).compose(key));
+            setTupleValue(tuple, 0, cassandraToObj(getDefaultMarshallers(cfDef).get(MarshallerType.KEY_VALIDATOR), key));
         }
 
     }

File: src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java
Patch:
@@ -731,7 +731,7 @@ private void addKeyToTuple(Tuple tuple, ByteBuffer key, CfDef cfDef, AbstractTyp
         }
         else
         {
-            setTupleValue(tuple, 0, getDefaultMarshallers(cfDef).get(MarshallerType.KEY_VALIDATOR).compose(key));
+            setTupleValue(tuple, 0, cassandraToObj(getDefaultMarshallers(cfDef).get(MarshallerType.KEY_VALIDATOR), key));
         }
 
     }

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -467,7 +467,7 @@ private static Collection<InetAddress> getBatchlogEndpoints(String localDataCent
      * | off            |       >=1      | --> DO NOT fire hints. And DO NOT wait for them to complete.
      * | off            |       ANY      | --> DO NOT fire hints. And DO NOT wait for them to complete.
      *
-     * @throws TimeoutException if the hints cannot be written/enqueued
+     * @throws OverloadedException if the hints cannot be written/enqueued
      */
     public static void sendToHintedEndpoints(final RowMutation rm,
                                              Iterable<InetAddress> targets,

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -2827,7 +2827,7 @@ public static AbstractType<?> getTypeByFunction(String functionName)
         }
         catch (IllegalArgumentException e)
         {
-            String message = String.format("Function '%s' not found. Available functions: %", functionName, Function.getFunctionNames());
+            String message = String.format("Function '%s' not found. Available functions: %s", functionName, Function.getFunctionNames());
             throw new RuntimeException(message, e);
         }
 

File: src/java/org/apache/cassandra/exceptions/PreparedQueryNotFoundException.java
Patch:
@@ -17,7 +17,6 @@
  */
 package org.apache.cassandra.exceptions;
 
-import org.apache.cassandra.cql3.QueryProcessor;
 import org.apache.cassandra.utils.MD5Digest;
 
 public class PreparedQueryNotFoundException extends RequestValidationException
@@ -34,7 +33,7 @@ private static String makeMsg(MD5Digest id)
     {
         return String.format("Prepared query with ID %s not found" +
                              " (either the query was not prepared on this host (maybe the host has been restarted?)" +
-                             " or you have prepared more than %d queries and query %s has been evicted from the internal cache)",
-                             id, QueryProcessor.MAX_CACHE_PREPARED, id);
+                             " or you have prepared too many queries and it has been evicted from the internal cache)",
+                             id);
     }
 }

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -1827,8 +1827,8 @@ public CqlResult execute_prepared_cql3_query(int itemId, List<ByteBuffer> bindVa
             if (statement == null)
                 throw new InvalidRequestException(String.format("Prepared query with ID %d not found" +
                                                                 " (either the query was not prepared on this host (maybe the host has been restarted?)" +
-                                                                " or you have prepared more than %d queries and queries %d has been evicted from the internal cache)",
-                                                                itemId, org.apache.cassandra.cql3.QueryProcessor.MAX_CACHE_PREPARED, itemId));
+                                                                " or you have prepared too many queries and it has been evicted from the internal cache)",
+                                                                itemId));
             logger.trace("Retrieved prepared statement #{} with {} bind markers", itemId, statement.getBoundsTerms());
 
             return org.apache.cassandra.cql3.QueryProcessor.processPrepared(statement, ThriftConversion.fromThrift(cLevel), cState.getQueryState(), bindVariables).toThriftResult();

File: src/java/org/apache/cassandra/streaming/StreamResultFuture.java
Patch:
@@ -21,6 +21,7 @@
 import java.net.InetAddress;
 import java.net.Socket;
 import java.util.*;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.AbstractFuture;
@@ -48,7 +49,7 @@ public final class StreamResultFuture extends AbstractFuture<StreamState>
 
     public final UUID planId;
     public final String description;
-    private final List<StreamEventHandler> eventListeners = Collections.synchronizedList(new ArrayList<StreamEventHandler>());
+    private final Collection<StreamEventHandler> eventListeners = new ConcurrentLinkedQueue<>();
 
     private final Map<InetAddress, StreamSession> ongoingSessions;
     private final Map<InetAddress, SessionInfo> sessionStates = new NonBlockingHashMap<>();

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -659,7 +659,7 @@ private static void sendMessagesToOneDCInternal(MessageOut message, Collection<I
         {
             InetAddress destination = iter.next();
             CompactEndpointSerializationHelper.serialize(destination, dos);
-            String id = MessagingService.instance().addCallback(handler, message, destination, message.getTimeout());
+            String id = MessagingService.instance().addCallback(handler, message, destination, message.getTimeout(), handler.consistencyLevel);
             dos.writeUTF(id);
         }
         message = message.withParameter(RowMutation.FORWARD_TO, bos.toByteArray());

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -38,6 +38,7 @@
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.DefsTable;
 import org.apache.cassandra.db.SystemTable;
+import org.apache.cassandra.dht.BootStrapper;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.io.FSWriteError;
@@ -839,6 +840,8 @@ public static long getTimeout(MessagingService.Verb verb)
             case READ_REPAIR:
             case MUTATION:
                 return getWriteRpcTimeout();
+            case BOOTSTRAP_TOKEN:
+                return BootStrapper.BOOTSTRAP_TIMEOUT;
             default:
                 return getRpcTimeout();
         }

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -642,7 +642,7 @@ private static void sendMessagesToOneDCInternal(MessageOut message, Collection<I
         {
             // yes, the loop and non-loop code here are the same; this is clunky but we want to avoid
             // creating a second iterator since we already have a perfectly good one
-            MessagingService.instance().sendRR(message, target, handler);
+            MessagingService.instance().sendRR(message, target, handler, message.getTimeout(), handler.consistencyLevel);
             while (iter.hasNext())
             {
                 target = iter.next();

File: test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
Patch:
@@ -595,7 +595,7 @@ public void testDeleteCompositeIndex() throws Exception
         // Read the index and we check we do get no value (and no NPE)
         // Note: the index will return the entry because it hasn't been deleted (we
         // haven't read yet nor compacted) but the data read itself will return null
-        IndexExpression expr = new IndexExpression(colName, IndexOperator.EQ, val1);
+        IndexExpression expr = new IndexExpression(colName, IndexExpression.Operator.EQ, val1);
         List<IndexExpression> clause = Arrays.asList(expr);
         IDiskAtomFilter filter = new IdentityQueryFilter();
         Range<RowPosition> range = Util.range("", "");

File: src/java/org/apache/cassandra/db/UnsortedColumns.java
Patch:
@@ -86,6 +86,7 @@ public void addColumn(Column column, Allocator allocator)
 
     public void addAll(ColumnFamily cm, Allocator allocator, Function<Column, Column> transformation)
     {
+        delete(cm.deletionInfo());
         for (Column column : cm)
             addColumn(column);
     }

File: src/java/org/apache/cassandra/db/index/composites/CompositesIndexOnClusteringKey.java
Patch:
@@ -110,7 +110,6 @@ public boolean indexes(ByteBuffer name)
 
     public boolean isStale(IndexedEntry entry, ColumnFamily data, long now)
     {
-        return data == null || data.hasOnlyTombstones(now);
+        return data.hasOnlyTombstones(now);
     }
 }
-

File: src/java/org/apache/cassandra/db/index/composites/CompositesIndexOnPartitionKey.java
Patch:
@@ -97,8 +97,6 @@ public boolean indexes(ByteBuffer name)
 
     public boolean isStale(IndexedEntry entry, ColumnFamily data, long now)
     {
-        return data == null || data.hasOnlyTombstones(now);
+        return data.hasOnlyTombstones(now);
     }
 }
-
-

File: src/java/org/apache/cassandra/db/index/composites/CompositesSearcher.java
Patch:
@@ -240,7 +240,7 @@ else if (!currentKey.equals(dk))
                                                                            Integer.MAX_VALUE,
                                                                            baseCfs.metadata.clusteringKeyColumns().size());
                         ColumnFamily newData = baseCfs.getColumnFamily(new QueryFilter(dk, baseCfs.name, dataFilter, filter.timestamp));
-                        if (index.isStale(entry, newData, filter.timestamp))
+                        if (newData == null || index.isStale(entry, newData, filter.timestamp))
                         {
                             index.delete(entry);
                             continue;

File: test/unit/org/apache/cassandra/SchemaLoader.java
Patch:
@@ -222,7 +222,8 @@ public static Collection<KSMetaData> schemaDefinition(boolean withOldCfIds) thro
                                            superCFMD(ks2, "Super3", bytes),
                                            superCFMD(ks2, "Super4", TimeUUIDType.instance),
                                            indexCFMD(ks2, "Indexed1", true),
-                                           compositeIndexCFMD(ks2, "Indexed2", true, withOldCfIds)));
+                                           compositeIndexCFMD(ks2, "Indexed2", true, withOldCfIds),
+                                           compositeIndexCFMD(ks2, "Indexed3", true, withOldCfIds).gcGraceSeconds(0)));
 
         // Keyspace 3
         schema.add(KSMetaData.testMetadata(ks3,

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -297,12 +297,12 @@ private ColumnFamilyStore(Keyspace keyspace,
             public void run()
             {
                 SpeculativeRetry retryPolicy = ColumnFamilyStore.this.metadata.getSpeculativeRetry();
+                logger.debug("retryPolicy is {}", retryPolicy.value);
                 switch (retryPolicy.type)
                 {
                     case PERCENTILE:
                         // get percentile in nanos
                         assert metric.coordinatorReadLatency.durationUnit() == TimeUnit.MICROSECONDS;
-                        logger.info("retryPolicy is {}", retryPolicy.value);
                         sampleLatencyNanos = (long) (metric.coordinatorReadLatency.getSnapshot().getValue(retryPolicy.value) * 1000d);
                         break;
                     case CUSTOM:

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -558,7 +558,7 @@ private void doCleanupCompaction(ColumnFamilyStore cfs, Collection<SSTableReader
         }
 
         boolean isCommutative = cfs.metadata.getDefaultValidator().isCommutative();
-        boolean hasIndexes = !cfs.indexManager.getIndexes().isEmpty();
+        boolean hasIndexes = cfs.indexManager.hasIndexes();
 
         for (SSTableReader sstable : sstables)
         {

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -525,7 +525,7 @@ private void doCleanupCompaction(final ColumnFamilyStore cfs, Collection<SSTable
             return;
         }
 
-        boolean hasIndexes = !cfs.indexManager.getIndexes().isEmpty();
+        boolean hasIndexes = cfs.indexManager.hasIndexes();
         CleanupStrategy cleanupStrategy = CleanupStrategy.get(cfs, ranges, renewer);
 
         for (SSTableReader sstable : sstables)
@@ -623,7 +623,7 @@ private static abstract class CleanupStrategy
     {
         public static CleanupStrategy get(ColumnFamilyStore cfs, Collection<Range<Token>> ranges, CounterId.OneShotRenewer renewer)
         {
-            if (!cfs.indexManager.getIndexes().isEmpty() || cfs.metadata.getDefaultValidator().isCommutative())
+            if (cfs.indexManager.hasIndexes() || cfs.metadata.getDefaultValidator().isCommutative())
                 return new Full(cfs, ranges, renewer);
 
             return new Bounded(cfs, ranges);

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -83,7 +83,7 @@ public final class CFMetaData
     public final static Class<? extends AbstractCompactionStrategy> DEFAULT_COMPACTION_STRATEGY_CLASS = SizeTieredCompactionStrategy.class;
     public final static Caching DEFAULT_CACHING_STRATEGY = Caching.KEYS_ONLY;
     public final static int DEFAULT_DEFAULT_TIME_TO_LIVE = 0;
-    public final static SpeculativeRetry DEFAULT_SPECULATIVE_RETRY = new SpeculativeRetry(SpeculativeRetry.RetryType.NONE, 0);
+    public final static SpeculativeRetry DEFAULT_SPECULATIVE_RETRY = new SpeculativeRetry(SpeculativeRetry.RetryType.PERCENTILE, 0.99);
     public final static int DEFAULT_INDEX_INTERVAL = 128;
     public final static boolean DEFAULT_POPULATE_IO_CACHE_ON_FLUSH = false;
 

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -345,7 +345,8 @@ public String toString()
             switch (type)
             {
             case PERCENTILE:
-                return value + "PERCENTILE";
+                // TODO switch to BigDecimal so round-tripping isn't lossy
+                return (value * 100) + "PERCENTILE";
             case CUSTOM:
                 return value + "ms";
             default:

File: test/unit/org/apache/cassandra/db/RangeTombstoneListTest.java
Patch:
@@ -109,10 +109,10 @@ private void overlappingAdditionTest(int initialCapacity)
         assert !iter.hasNext();
 
         RangeTombstoneList l2 = new RangeTombstoneList(cmp, initialCapacity);
-        l.add(rt(4, 10, 12L));
-        l.add(rt(0, 8, 25L));
+        l2.add(rt(4, 10, 12L));
+        l2.add(rt(0, 8, 25L));
 
-        assertEquals(25L, l.search(b(8)).markedForDeleteAt);
+        assertEquals(25L, l2.search(b(8)).markedForDeleteAt);
     }
 
     @Test

File: src/java/org/apache/cassandra/service/AbstractReadExecutor.java
Patch:
@@ -321,7 +321,7 @@ public Iterable<InetAddress> getContactedReplicas()
         @Override
         public void executeAsync()
         {
-            makeDataRequests(targetReplicas.subList(0, 2));
+            makeDataRequests(targetReplicas.subList(0, targetReplicas.size() > 1 ? 2 : 1));
             if (targetReplicas.size() > 2)
                 makeDigestRequests(targetReplicas.subList(2, targetReplicas.size()));
             cfs.metric.speculativeRetry.inc();

File: src/java/org/apache/cassandra/service/ReadCallback.java
Patch:
@@ -50,7 +50,7 @@ public class ReadCallback<TMessage, TResolved> implements IAsyncCallback<TMessag
     public final IResponseResolver<TMessage, TResolved> resolver;
     private final SimpleCondition condition = new SimpleCondition();
     final long start;
-    private final int blockfor;
+    final int blockfor;
     final List<InetAddress> endpoints;
     private final IReadCommand command;
     private final ConsistencyLevel consistencyLevel;

File: src/java/org/apache/cassandra/service/MigrationManager.java
Patch:
@@ -110,7 +110,7 @@ public void onRemove(InetAddress endpoint)
      */
     private static void maybeScheduleSchemaPull(final UUID theirVersion, final InetAddress endpoint)
     {
-        if (Schema.instance.getVersion().equals(theirVersion) || !shouldPullSchemaFrom(endpoint))
+        if ((Schema.instance.getVersion() != null && Schema.instance.getVersion().equals(theirVersion)) || !shouldPullSchemaFrom(endpoint))
             return;
 
         if (Schema.emptyVersion.equals(Schema.instance.getVersion()) || runtimeMXBean.getUptime() < MIGRATION_DELAY_IN_MS)

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -291,6 +291,9 @@ else if (conf.memtable_flush_writers == null)
             /* Local IP or hostname to bind services to */
             if (conf.listen_address != null)
             {
+                if (conf.listen_address.equals("0.0.0.0"))
+                    throw new ConfigurationException("listen_address cannot be 0.0.0.0!");
+
                 try
                 {
                     listenAddress = InetAddress.getByName(conf.listen_address);

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -176,6 +176,8 @@ public class Config
     private static boolean loadYaml = true;
     private static boolean outboundBindAny = false;
 
+    public volatile int tombstone_debug_threshold = 10000;
+
     public static boolean getOutboundBindAny()
     {
         return outboundBindAny;

File: src/java/org/apache/cassandra/thrift/ThriftValidation.java
Patch:
@@ -241,6 +241,9 @@ private static void validateColumnNames(CFMetaData metadata, ByteBuffer superCol
                 // Furthermore, the column name must be a declared one.
                 int columnIndex = composite.types.size() - (cfDef.hasCollections ? 2 : 1);
                 ByteBuffer CQL3ColumnName = components[columnIndex];
+                if (!CQL3ColumnName.hasRemaining())
+                    continue; // Row marker, ok
+
                 ColumnIdentifier columnId = new ColumnIdentifier(CQL3ColumnName, composite.types.get(columnIndex));
                 if (cfDef.metadata.get(columnId) == null)
                     throw new org.apache.cassandra.exceptions.InvalidRequestException(String.format("Invalid cell for CQL3 table %s. The CQL3 column component (%s) does not correspond to a defined CQL3 column",

File: test/unit/org/apache/cassandra/SchemaLoader.java
Patch:
@@ -149,6 +149,7 @@ public static Collection<KSMetaData> schemaDefinition(boolean withOldCfIds) thro
                                            standardCFMD(ks1, "Standard2"),
                                            standardCFMD(ks1, "Standard3"),
                                            standardCFMD(ks1, "Standard4"),
+                                           standardCFMD(ks1, "StandardGCGS0").gcGraceSeconds(0),
                                            standardCFMD(ks1, "StandardLong1"),
                                            standardCFMD(ks1, "StandardLong2"),
                                            new CFMetaData(ks1,

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -56,7 +56,7 @@ public class Config
 
     public Long range_request_timeout_in_ms = new Long(10000);
 
-    public Long write_request_timeout_in_ms = new Long(10000);
+    public Long write_request_timeout_in_ms = new Long(2000);
 
     public Long cas_contention_timeout_in_ms = new Long(1000);
 

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -249,7 +249,7 @@ else if (conf.disk_access_mode == Config.DiskAccessMode.mmap_index_only)
             conf.file_cache_size_in_mb = Math.min(512, (int) (Runtime.getRuntime().maxMemory() / (4 * 1048576)));
 
         if (conf.memtable_total_space_in_mb == null)
-            conf.memtable_total_space_in_mb = (int) (Runtime.getRuntime().maxMemory() / (3 * 1048576));
+            conf.memtable_total_space_in_mb = (int) (Runtime.getRuntime().maxMemory() / (4 * 1048576));
         if (conf.memtable_total_space_in_mb <= 0)
             throw new ConfigurationException("memtable_total_space_in_mb must be positive");
         logger.info("Global memtable threshold is enabled at {}MB", conf.memtable_total_space_in_mb);

File: src/java/org/apache/cassandra/thrift/ThriftServer.java
Patch:
@@ -81,7 +81,7 @@ public boolean isRunning()
     }
 
     /*
-     * These methods are intended to be overriden to provide DSE specific implementations
+     * These methods are intended to be overridden to provide custom implementations.
      */
     protected CassandraServer getCassandraServer()
     {

File: src/java/org/apache/cassandra/cql3/CQL3Type.java
Patch:
@@ -209,7 +209,7 @@ public String toString()
                     return "set<" + ((SetType)type).elements.asCQL3Type() + ">";
                 case MAP:
                     MapType mt = (MapType)type;
-                    return "set<" + mt.keys.asCQL3Type() + ", " + mt.values.asCQL3Type() + ">";
+                    return "map<" + mt.keys.asCQL3Type() + ", " + mt.values.asCQL3Type() + ">";
             }
             throw new AssertionError();
         }

File: src/java/org/apache/cassandra/tracing/Tracing.java
Patch:
@@ -205,7 +205,7 @@ public void begin(final String request, final Map<String, String> parameters)
             public void runMayThrow() throws Exception
             {
                 CFMetaData cfMeta = CFMetaData.TraceSessionsCf;
-                ColumnFamily cf = ArrayBackedSortedColumns.factory.create(cfMeta);
+                ColumnFamily cf = TreeMapBackedSortedColumns.factory.create(cfMeta);
                 addColumn(cf, buildName(cfMeta, bytes("coordinator")), FBUtilities.getBroadcastAddress());
                 addParameterColumns(cf, parameters);
                 addColumn(cf, buildName(cfMeta, bytes("request")), request);

File: src/java/org/apache/cassandra/transport/messages/ResultMessage.java
Patch:
@@ -271,7 +271,7 @@ public int encodedSize(ResultMessage msg, int version)
                 size += CBUtil.sizeOfBytes(prepared.statementId.bytes);
                 size += ResultSet.Metadata.codec.encodedSize(prepared.metadata, version);
                 if (version > 1)
-                    ResultSet.Metadata.codec.encodedSize(prepared.resultMetadata, version);
+                    size += ResultSet.Metadata.codec.encodedSize(prepared.resultMetadata, version);
                 return size;
             }
         };

File: src/java/org/apache/cassandra/io/sstable/SSTableDeletingTask.java
Patch:
@@ -67,7 +67,8 @@ public void schedule()
 
     public void run()
     {
-        tracker.notifyDeleting(referent);
+        if (tracker != null)
+            tracker.notifyDeleting(referent);
 
         // If we can't successfully delete the DATA component, set the task to be retried later: see above
         File datafile = new File(desc.filenameFor(Component.DATA));

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -191,7 +191,7 @@ public enum Verb
         put(Verb.READ_REPAIR, RowMutation.serializer);
         put(Verb.READ, ReadCommand.serializer);
         put(Verb.RANGE_SLICE, RangeSliceCommand.serializer);
-        put(Verb.PAGED_RANGE, RangeSliceCommand.serializer);
+        put(Verb.PAGED_RANGE, PagedRangeCommand.serializer);
         put(Verb.BOOTSTRAP_TOKEN, BootStrapper.StringSerializer.instance);
         put(Verb.REPAIR_MESSAGE, RepairMessage.serializer);
         put(Verb.GOSSIP_DIGEST_ACK, GossipDigestAck.serializer);

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -230,6 +230,7 @@ public StorageService()
         MessagingService.instance().registerVerbHandlers(MessagingService.Verb.READ_REPAIR, new ReadRepairVerbHandler());
         MessagingService.instance().registerVerbHandlers(MessagingService.Verb.READ, new ReadVerbHandler());
         MessagingService.instance().registerVerbHandlers(MessagingService.Verb.RANGE_SLICE, new RangeSliceVerbHandler());
+        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.PAGED_RANGE, new RangeSliceVerbHandler());
         MessagingService.instance().registerVerbHandlers(MessagingService.Verb.COUNTER_MUTATION, new CounterMutationVerbHandler());
         MessagingService.instance().registerVerbHandlers(MessagingService.Verb.TRUNCATE, new TruncateVerbHandler());
         MessagingService.instance().registerVerbHandlers(MessagingService.Verb.PAXOS_PREPARE, new PrepareVerbHandler());

File: src/java/org/apache/cassandra/db/commitlog/CommitLogArchiver.java
Patch:
@@ -73,7 +73,7 @@ public CommitLogArchiver()
                 restoreCommand = null;
                 restoreDirectories = null;
                 restorePointInTime = Long.MAX_VALUE;
-                precision = TimeUnit.MILLISECONDS;
+                precision = TimeUnit.MICROSECONDS;
             }
             else
             {
@@ -82,7 +82,7 @@ public CommitLogArchiver()
                 restoreCommand = commitlog_commands.getProperty("restore_command");
                 restoreDirectories = commitlog_commands.getProperty("restore_directories");
                 String targetTime = commitlog_commands.getProperty("restore_point_in_time");
-                precision = TimeUnit.valueOf(commitlog_commands.getProperty("precision", "MILLISECONDS"));
+                precision = TimeUnit.valueOf(commitlog_commands.getProperty("precision", "MICROSECONDS"));
                 try
                 {
                     restorePointInTime = Strings.isNullOrEmpty(targetTime) ? Long.MAX_VALUE : format.parse(targetTime).getTime();

File: src/java/org/apache/cassandra/db/commitlog/CommitLogReplayer.java
Patch:
@@ -281,7 +281,7 @@ protected boolean pointInTimeExceeded(RowMutation frm)
 
         for (ColumnFamily families : frm.getColumnFamilies())
         {
-            if (families.maxTimestamp() > restoreTarget)
+            if (CommitLog.instance.archiver.precision.toMillis(families.maxTimestamp()) > restoreTarget)
                 return true;
         }
         return false;

File: src/java/org/apache/cassandra/tools/StandaloneSplitter.java
Patch:
@@ -211,6 +211,7 @@ public static Options parseArgs(String cmdArgs[])
                 opts.debug = cmd.hasOption(DEBUG_OPTION);
                 opts.verbose = cmd.hasOption(VERBOSE_OPTION);
                 opts.snapshot = !cmd.hasOption(NO_SNAPSHOT_OPTION);
+                opts.sizeInMB = DEFAULT_SSTABLE_SIZE;
 
                 if (cmd.hasOption(SIZE_OPTION))
                     opts.sizeInMB = Integer.valueOf(cmd.getOptionValue(SIZE_OPTION));

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -323,7 +323,7 @@ public void stopRPCServer()
 
     public boolean isRPCServerRunning()
     {
-        if (daemon == null)
+        if ((daemon == null) || (daemon.thriftServer == null))
         {
             return false;
         }
@@ -358,7 +358,7 @@ public void stopNativeTransport()
 
     public boolean isNativeTransportRunning()
     {
-        if (daemon == null)
+        if ((daemon == null) || (daemon.nativeServer == null))
         {
             return false;
         }

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -770,8 +770,8 @@ private void doValidationCompaction(ColumnFamilyStore cfs, AntiEntropyService.Va
         {
             SSTableReader.releaseReferences(sstables);
             iter.close();
-            if (cfs.table.snapshotExists(validator.request.sessionid))
-                cfs.table.clearSnapshot(validator.request.sessionid);
+            if (cfs.snapshotExists(validator.request.sessionid))
+                cfs.clearSnapshot(validator.request.sessionid);
 
             metrics.finishCompaction(ci);
         }

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -357,7 +357,7 @@ private static UUID beginAndRepairPaxos(long start, ByteBuffer key, CFMetaData m
         {
             long ballotMillis = summary == null
                               ? System.currentTimeMillis()
-                              : Math.max(System.currentTimeMillis(), 1 + UUIDGen.unixTimestamp(summary.inProgressCommit.ballot));
+                              : Math.max(System.currentTimeMillis(), 1 + UUIDGen.unixTimestamp(summary.mostRecentInProgressCommit.ballot));
             UUID ballot = UUIDGen.getTimeUUID(ballotMillis);
 
             // prepare
@@ -372,7 +372,7 @@ private static UUID beginAndRepairPaxos(long start, ByteBuffer key, CFMetaData m
                 continue;
             }
 
-            Commit inProgress = summary.inProgressCommit;
+            Commit inProgress = summary.mostRecentInProgressCommitWithUpdate;
             Commit mostRecent = summary.mostRecentCommit;
 
             // If we have an in-progress ballot greater than the MRC we know, then it's an in-progress round that

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -936,7 +936,9 @@ public static CFMetaData fromThriftCqlRow(CqlRow row)
             for (org.apache.cassandra.thrift.Column column : row.getColumns())
                 columns.put(ByteBufferUtil.string(column.bufferForName()), column.value);
         }
-        catch (CharacterCodingException ignore) {}
+        catch (CharacterCodingException ignore)
+        {
+        }
         UntypedResultSet.Row cql3row = new UntypedResultSet.Row(columns);
         return fromSchemaNoColumnsNoTriggers(cql3row);
     }

File: src/java/org/apache/cassandra/db/HintedHandOffManager.java
Patch:
@@ -436,9 +436,10 @@ public void run()
     private int calculatePageSize()
     {
         // read less columns (mutations) per page if they are very large
-        if (hintStore.getMeanColumns() > 0)
+        int meanColumnCount = hintStore.getMeanColumns();
+        if (meanColumnCount > 0)
         {
-            int averageColumnSize = (int) (hintStore.getMeanRowSize() / hintStore.getMeanColumns());
+            int averageColumnSize = (int) (hintStore.getMeanRowSize() / meanColumnCount);
             // page size of 1 does not allow actual paging b/c of >= behavior on startColumn
             return Math.max(2, Math.min(PAGE_SIZE, DatabaseDescriptor.getInMemoryCompactionLimit() / averageColumnSize));
         }

File: src/java/org/apache/cassandra/db/index/composites/CompositesSearcher.java
Patch:
@@ -138,7 +138,7 @@ protected Row computeNext()
                 {
                     // Did we get more columns that needed to respect the user limit?
                     // (but we still need to return what has been fetched already)
-                    if (columnsCount > limit)
+                    if (columnsCount >= limit)
                         return makeReturn(currentKey, data);
 
                     if (indexColumns == null || indexColumns.isEmpty())

File: src/java/org/apache/cassandra/cql3/QueryOptions.java
Patch:
@@ -231,6 +231,8 @@ private EnumSet<Flag> gatherFlags(QueryOptions options)
                 flags.add(Flag.SKIP_METADATA);
             if (options.getPageSize() >= 0)
                 flags.add(Flag.PAGE_SIZE);
+            if (options.getPagingState() != null)
+                flags.add(Flag.PAGING_STATE);
             if (options.getSerialConsistency() != ConsistencyLevel.SERIAL)
                 flags.add(Flag.SERIAL_CONSISTENCY);
             return flags;

File: src/java/org/apache/cassandra/transport/messages/RegisterMessage.java
Patch:
@@ -50,7 +50,7 @@ public int encodedSize(RegisterMessage msg, int version)
         {
             int size = 2;
             for (Event.Type type : msg.eventTypes)
-                CBUtil.sizeOfEnumValue(type);
+                size += CBUtil.sizeOfEnumValue(type);
             return size;
         }
     };

File: src/java/org/apache/cassandra/io/sstable/IndexSummary.java
Patch:
@@ -121,7 +121,8 @@ public IndexSummary deserialize(DataInput in, IPartitioner partitioner) throws I
             for (int i = 0; i < size; i++)
             {
                 positions[i] = in.readLong();
-                keys[i] = ByteBufferUtil.readBytes(in, in.readInt());
+                int len = in.readInt();
+                keys[i] = len == 0 ? new byte[0] : ByteBufferUtil.readBytes(in, len);
             }
 
             return new IndexSummary(partitioner, keys, positions);

File: src/java/org/apache/cassandra/utils/ByteBufferUtil.java
Patch:
@@ -398,7 +398,7 @@ public static ByteBuffer read(DataInput in, int length) throws IOException
 
     public static byte[] readBytes(DataInput in, int length) throws IOException
     {
-        assert length > 0;
+        assert length > 0 : "length is not > 0: " + length;
         byte[] bytes = new byte[length];
         in.readFully(bytes);
         return bytes;

File: src/java/org/apache/cassandra/hadoop/cql3/CqlRecordWriter.java
Patch:
@@ -307,7 +307,7 @@ private ByteBuffer getPartitionKey(Map<String, ByteBuffer> keyColumns)
         {
             ByteBuffer[] keys = new ByteBuffer[partitionKeyColumns.length];
             for (int i = 0; i< keys.length; i++)
-                keys[i] = keyColumns.get(partitionKeyColumns[i]);
+                keys[i] = keyColumns.get(partitionKeyColumns[i]).duplicate();
 
             partitionKey = ((CompositeType) keyValidator).build(keys);
         }

File: src/java/org/apache/cassandra/db/SystemKeyspace.java
Patch:
@@ -806,10 +806,11 @@ public static void savePaxosPromise(Commit promise)
 
     public static void savePaxosProposal(Commit commit)
     {
-        processInternal(String.format("UPDATE %s USING TIMESTAMP %d AND TTL %d SET proposal = 0x%s WHERE row_key = 0x%s AND cf_id = %s",
+        processInternal(String.format("UPDATE %s USING TIMESTAMP %d AND TTL %d SET in_progress_ballot = %s, proposal = 0x%s WHERE row_key = 0x%s AND cf_id = %s",
                                       PAXOS_CF,
                                       UUIDGen.microsTimestamp(commit.ballot),
                                       paxosTtl(commit.update.metadata),
+                                      commit.ballot,
                                       ByteBufferUtil.bytesToHex(commit.update.toBytes()),
                                       ByteBufferUtil.bytesToHex(commit.key),
                                       commit.update.id()));

File: test/unit/org/apache/cassandra/service/QueryPagerTest.java
Patch:
@@ -119,7 +119,8 @@ private static ReadCommand namesQuery(String key, String... names)
     private static ReadCommand sliceQuery(String key, String start, String end, int count)
     {
         SliceQueryFilter filter = new SliceQueryFilter(bytes(start), bytes(end), false, count);
-        return new SliceFromReadCommand(KS, bytes(key), CF, System.currentTimeMillis(), filter);
+        // Note: for MultiQueryTest, we need the same timestamp/expireBefore for all queries, so we just use 0 as it doesn't matter here.
+        return new SliceFromReadCommand(KS, bytes(key), CF, 0, filter);
     }
 
     private static RangeSliceCommand rangeNamesQuery(AbstractBounds<RowPosition> range, int count, String... names)

File: src/java/org/apache/cassandra/metrics/MetricNameFactory.java
Patch:
@@ -20,10 +20,10 @@
 public interface MetricNameFactory
 {
     /**
-     * Create {@link MetricName} from given metric name.
+     * Create a qualified name from given metric name.
      *
-     * @param metricName Name part of {@link MetricName}.
-     * @return new MetricName with given metric name.
+     * @param metricName part of qualified name.
+     * @return new String with given metric name.
      */
     String createMetricName(String metricName);
 }

File: src/java/org/apache/cassandra/streaming/ConnectionHandler.java
Patch:
@@ -91,7 +91,7 @@ public void initiate() throws IOException
     /**
      * Set up outgoing message handler on receiving side.
      *
-     * @param socket socket to use for {@link OutgoingMessageHandler}.
+     * @param socket socket to use for {@link org.apache.cassandra.streaming.ConnectionHandler.OutgoingMessageHandler}.
      * @param version Streaming message version
      * @throws IOException
      */

File: test/unit/org/apache/cassandra/utils/BloomFilterTest.java
Patch:
@@ -38,7 +38,6 @@
 
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.io.util.FileUtils;
-import org.apache.cassandra.utils.FilterFactory.Type;
 
 public class BloomFilterTest
 {
@@ -170,7 +169,7 @@ public void testHugeBFSerialization() throws IOException
         out.close();
         
         DataInputStream in = new DataInputStream(new FileInputStream(file));
-        BloomFilter filter2 = (BloomFilter) FilterFactory.deserialize(in, Type.MURMUR3, true);
+        BloomFilter filter2 = (BloomFilter) FilterFactory.deserialize(in, true);
         Assert.assertTrue(filter2.isPresent(test));
         FileUtils.closeQuietly(in);
     }

File: src/java/org/apache/cassandra/thrift/ThriftValidation.java
Patch:
@@ -242,7 +242,7 @@ private static void validateColumnNames(CFMetaData metadata, ByteBuffer superCol
                 int columnIndex = composite.types.size() - (cfDef.hasCollections ? 2 : 1);
                 ByteBuffer CQL3ColumnName = components[columnIndex];
                 ColumnIdentifier columnId = new ColumnIdentifier(CQL3ColumnName, composite.types.get(columnIndex));
-                if (cfDef.columns.get(columnId) == null)
+                if (cfDef.metadata.get(columnId) == null)
                     throw new org.apache.cassandra.exceptions.InvalidRequestException(String.format("Invalid cell for CQL3 table %s. The CQL3 column component (%s) does not correspond to a defined CQL3 column",
                                                                                                     metadata.cfName, columnId));
 

File: src/java/org/apache/cassandra/io/sstable/SSTableReader.java
Patch:
@@ -593,6 +593,8 @@ public IFilter getBloomFilter()
 
     public long getBloomFilterSerializedSize()
     {
+        if (bf instanceof AlwaysPresentFilter)
+            return 0;
         return FilterFactory.serializedSize(bf, descriptor.version.filterType);
     }
 

File: src/java/org/apache/cassandra/triggers/TriggerExecutor.java
Patch:
@@ -128,7 +128,7 @@ private List<RowMutation> execute(ByteBuffer key, ColumnFamily columnFamily)
         }
         catch (Exception ex)
         {
-            throw new RuntimeException(String.format("Exception while creating trigger a trigger on CF with ID: %s", columnFamily.id()), ex);
+            throw new RuntimeException(String.format("Exception while creating trigger on CF with ID: %s", columnFamily.id()), ex);
         }
         finally
         {

File: tools/stress/src/org/apache/cassandra/stress/StressAction.java
Patch:
@@ -140,7 +140,9 @@ public void run()
                                              total,
                                              opDelta / interval,
                                              keyDelta / interval,
-                                             latency.getMedian(), latency.get95thPercentile(), latency.get999thPercentile(),
+                                             StressStatistics.nanosToMillis(latency.getMedian()), 
+                                             StressStatistics.nanosToMillis(latency.get95thPercentile()), 
+                                             StressStatistics.nanosToMillis(latency.get999thPercentile()),
                                              currentTimeInSeconds));
 
                 if (client.outputStatistics()) {

File: src/java/org/apache/cassandra/io/util/Memory.java
Patch:
@@ -96,7 +96,7 @@ else if (count == 0)
         long end = memoryOffset + count;
         checkPosition(end - 1);
 
-        unsafe.copyMemory(buffer, BYTE_ARRAY_BASE_OFFSET, null, peer + memoryOffset, count);
+        unsafe.copyMemory(buffer, BYTE_ARRAY_BASE_OFFSET + bufferOffset, null, peer + memoryOffset, count);
     }
 
     public byte getByte(long offset)
@@ -138,7 +138,7 @@ else if (count == 0)
         long end = memoryOffset + count;
         checkPosition(end - 1);
 
-        unsafe.copyMemory(null, peer + memoryOffset, buffer, BYTE_ARRAY_BASE_OFFSET, count);
+        unsafe.copyMemory(null, peer + memoryOffset, buffer, BYTE_ARRAY_BASE_OFFSET + bufferOffset, count);
     }
 
     private void checkPosition(long offset)

File: src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java
Patch:
@@ -90,7 +90,7 @@ public void validate(ClientState state) throws RequestValidationException
         if (cd.getValidator().isCollection() && !isCustom)
             throw new InvalidRequestException("Indexes on collections are no yet supported");
 
-        if (cd.type == ColumnDefinition.Type.PARTITION_KEY && (cd.componentIndex == null || cd.componentIndex == 0))
+        if (cd.type == ColumnDefinition.Type.PARTITION_KEY && cd.componentIndex == null)
             throw new InvalidRequestException(String.format("Cannot add secondary index to already primarily indexed column %s", columnName));
     }
 

File: src/java/org/apache/cassandra/db/index/composites/CompositesIndexOnClusteringKey.java
Patch:
@@ -76,9 +76,10 @@ protected ColumnNameBuilder makeIndexColumnNameBuilder(ByteBuffer rowKey, ByteBu
         ByteBuffer[] components = baseComparator.split(columnName);
         CompositeType.Builder builder = getIndexComparator().builder();
         builder.add(rowKey);
-        for (int i = 0; i < columnDef.componentIndex; i++)
+
+        for (int i = 0; i < Math.min(components.length, columnDef.componentIndex); i++)
             builder.add(components[i]);
-        for (int i = columnDef.componentIndex + 1; i < ckCount; i++)
+        for (int i = columnDef.componentIndex + 1; i < Math.min(components.length, ckCount); i++)
             builder.add(components[i]);
         return builder;
     }

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -136,8 +136,6 @@ public final class CFMetaData
                                                                        + "value_alias text,"
                                                                        + "column_aliases text,"
                                                                        + "compaction_strategy_options text,"
-                                                                       + "default_read_consistency text,"
-                                                                       + "default_write_consistency text,"
                                                                        + "PRIMARY KEY (keyspace_name, columnfamily_name)"
                                                                        + ") WITH COMMENT='ColumnFamily definitions' AND gc_grace_seconds=8640");
 

File: src/java/org/apache/cassandra/io/sstable/SSTableReader.java
Patch:
@@ -597,7 +597,7 @@ public long getBloomFilterSerializedSize()
      */
     public long estimatedKeys()
     {
-        return indexSummary.size() * DatabaseDescriptor.getIndexInterval();
+        return ((long) indexSummary.size()) * DatabaseDescriptor.getIndexInterval();
     }
 
     /**

File: src/java/org/apache/cassandra/thrift/THsHaDisruptorServer.java
Patch:
@@ -84,7 +84,8 @@ public TServer buildTServer(Args args)
                                                                                          .outputTransportFactory(args.outTransportFactory)
                                                                                          .inputProtocolFactory(protocolFactory)
                                                                                          .outputProtocolFactory(protocolFactory)
-                                                                                         .processor(args.processor);
+                                                                                         .processor(args.processor)
+                                                                                         .maxFrameSizeInBytes(DatabaseDescriptor.getThriftFramedTransportSize());
 
             return new THsHaDisruptorServer(serverArgs);
         }

File: src/java/org/apache/cassandra/utils/FBUtilities.java
Patch:
@@ -356,7 +356,7 @@ public static File cassandraTriggerDir()
         }
         if (triggerDir == null || !triggerDir.exists())
         {
-            logger.warn("Trigger Directory doesnt exist, please create it and try again.");
+            logger.warn("Trigger directory doesn't exist, please create it and try again.");
             return null;
         }
         return triggerDir;

File: src/java/org/apache/cassandra/utils/FBUtilities.java
Patch:
@@ -356,7 +356,7 @@ public static File cassandraTriggerDir()
         }
         if (triggerDir == null || !triggerDir.exists())
         {
-            logger.warn("Trigger Directory doesnt exist, please create it and try again.");
+            logger.warn("Trigger directory doesn't exist, please create it and try again.");
             return null;
         }
         return triggerDir;

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -355,7 +355,7 @@ private static UUID beginAndRepairPaxos(long start, ByteBuffer key, CFMetaData m
         long timeout = TimeUnit.MILLISECONDS.toNanos(DatabaseDescriptor.getCasContentionTimeout());
 
         PrepareCallback summary = null;
-        while (start - System.nanoTime() < timeout)
+        while (System.nanoTime() - start < timeout)
         {
             long ballotMillis = summary == null
                               ? System.currentTimeMillis()

File: src/java/org/apache/cassandra/triggers/TriggerExecutor.java
Patch:
@@ -42,7 +42,7 @@ public class TriggerExecutor
 
     private final Map<String, ITrigger> cachedTriggers = Maps.newConcurrentMap();
     private final ClassLoader parent = Thread.currentThread().getContextClassLoader();
-    private final File triggerDirectory = new File(FBUtilities.cassandraHomeDir(), "triggers");
+    private final File triggerDirectory = FBUtilities.cassandraTriggerDir();
     private volatile ClassLoader customClassLoader;
 
     private TriggerExecutor()

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -1519,7 +1519,7 @@ public static boolean shouldHint(InetAddress ep)
      */
     public static void truncateBlocking(String keyspace, String cfname) throws UnavailableException, TimeoutException, IOException
     {
-        logger.debug("Starting a blocking truncate operation on keyspace {}, CF ", keyspace, cfname);
+        logger.debug("Starting a blocking truncate operation on keyspace {}, CF {}", keyspace, cfname);
         if (isAnyHostDown())
         {
             logger.info("Cannot perform truncate, some hosts are down");

File: src/java/org/apache/cassandra/io/sstable/SSTableReader.java
Patch:
@@ -571,7 +571,7 @@ public CompressionMetadata getCompressionMetadata()
         if (!compression)
             throw new IllegalStateException(this + " is not compressed");
 
-        return ((CompressedPoolingSegmentedFile)dfile).metadata;
+        return ((ICompressedFile) dfile).getMetadata();
     }
 
     /**

File: src/java/org/apache/cassandra/db/columniterator/IndexedSliceReader.java
Patch:
@@ -106,7 +106,7 @@ public IndexedSliceReader(SSTableReader sstable, RowIndexEntry indexEntry, FileD
                 IndexHelper.skipBloomFilter(file);
                 this.indexes = IndexHelper.deserializeIndex(file);
                 this.emptyColumnFamily = ColumnFamily.create(sstable.metadata);
-                emptyColumnFamily.delete(indexEntry.deletionTime());
+                emptyColumnFamily.delete(DeletionTime.serializer.deserialize(file));
                 fetcher = indexes.isEmpty()
                         ? new SimpleBlockFetcher()
                         : new IndexedBlockFetcher(file.getFilePointer() + 4); // We still have the column count to

File: src/java/org/apache/cassandra/cql3/QueryOptions.java
Patch:
@@ -216,8 +216,8 @@ public ChannelBuffer encode(QueryOptions options, int version)
             }
 
             CBUtil.BufferBuilder builder = new CBUtil.BufferBuilder(nbBuff, 0, options.values.size() + (flags.contains(Flag.PAGING_STATE) ? 1 : 0));
-            builder.add(CBUtil.byteToCB((byte)Flag.serialize(flags)));
             builder.add(CBUtil.consistencyLevelToCB(options.getConsistency()));
+            builder.add(CBUtil.byteToCB((byte)Flag.serialize(flags)));
 
             if (flags.contains(Flag.VALUES))
             {

File: src/java/org/apache/cassandra/db/RangeTombstoneList.java
Patch:
@@ -742,7 +742,7 @@ else if (cmp < 0)
                 }
                 else
                 {
-                    if (comparator.compare(name, ends[idx]) < 0)
+                    if (comparator.compare(name, ends[idx]) <= 0)
                         return markedAts[idx] >= timestamp;
                     else
                         idx++;

File: src/java/org/apache/cassandra/hadoop/cql3/CqlRecordWriter.java
Patch:
@@ -306,7 +306,7 @@ private ByteBuffer getPartitionKey(Map<String, ByteBuffer> keyColumns)
             for (int i = 0; i< keys.length; i++)
                 keys[i] = keyColumns.get(partitionKeyColumns[i]);
 
-            partitionKey = ((CompositeType) keyValidator).build(keys);
+            partitionKey = CompositeType.build(keys);
         }
         else
         {

File: src/java/org/apache/cassandra/thrift/ThriftValidation.java
Patch:
@@ -235,8 +235,8 @@ private static void validateColumnNames(CFMetaData metadata, ByteBuffer superCol
                 ByteBuffer[] components = composite.split(name);
                 int minComponents = composite.types.size() - (cfDef.hasCollections ? 1 : 0);
                 if (components.length < minComponents)
-                    throw new org.apache.cassandra.exceptions.InvalidRequestException(String.format("Not enough component (found %d but %d expected) for column name since %s is a CQL3 table",
-                                                                                                    metadata.cfName, components.length, minComponents));
+                    throw new org.apache.cassandra.exceptions.InvalidRequestException(String.format("Not enough components (found %d but %d expected) for column name since %s is a CQL3 table",
+                                                                                                    components.length, minComponents, metadata.cfName));
 
                 // Furthermore, the column name must be a declared one.
                 int columnIndex = composite.types.size() - (cfDef.hasCollections ? 2 : 1);

File: src/java/org/apache/cassandra/db/DeletionTime.java
Patch:
@@ -85,7 +85,7 @@ public boolean isGcAble(int gcBefore)
 
     public boolean isDeleted(IColumn column)
     {
-        return column.isMarkedForDelete() && column.getMarkedForDeleteAt() <= markedForDeleteAt;
+        return column.mostRecentLiveChangeAt() <= markedForDeleteAt;
     }
 
     public long memorySize()

File: src/java/org/apache/cassandra/db/compaction/LazilyCompactedRow.java
Patch:
@@ -293,7 +293,6 @@ protected OnDiskAtom getReduced()
 
                 // PrecompactedRow.removeDeletedAndOldShards have only checked the top-level CF deletion times,
                 // not the range tombstone. For that we use the columnIndexer tombstone tracker.
-                // Note that this doesn't work for super columns.
                 if (indexBuilder.tombstoneTracker().isDeleted(reduced))
                     return null;
 

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -1157,7 +1157,7 @@ else if (restriction.isEquality())
 
                     // We don't support IN for indexed values (basically this would require supporting a form of OR)
                     if (restriction.eqValues.size() > 1)
-                        throw new InvalidRequestException("Cannot use IN operator on column not part of the PRIMARY KEY");
+                        throw new InvalidRequestException("Cannot use IN operator on column not part of the partition key");
 
                     if (indexedNames.contains(entry.getKey().name.key))
                     {

File: interface/thrift/gen-java/org/apache/cassandra/thrift/AuthenticationRequest.java
Patch:
@@ -383,7 +383,7 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, AuthenticationReque
                 struct.credentials = new HashMap<String,String>(2*_map80.size);
                 for (int _i81 = 0; _i81 < _map80.size; ++_i81)
                 {
-                  String _key82; // required
+                  String _key82; // optional
                   String _val83; // required
                   _key82 = iprot.readString();
                   _val83 = iprot.readString();
@@ -459,7 +459,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, AuthenticationReques
         struct.credentials = new HashMap<String,String>(2*_map86.size);
         for (int _i87 = 0; _i87 < _map86.size; ++_i87)
         {
-          String _key88; // required
+          String _key88; // optional
           String _val89; // required
           _key88 = iprot.readString();
           _val89 = iprot.readString();

File: interface/thrift/gen-java/org/apache/cassandra/thrift/ColumnDef.java
Patch:
@@ -771,7 +771,7 @@ public void read(org.apache.thrift.protocol.TProtocol iprot, ColumnDef struct) t
                 struct.index_options = new HashMap<String,String>(2*_map90.size);
                 for (int _i91 = 0; _i91 < _map90.size; ++_i91)
                 {
-                  String _key92; // required
+                  String _key92; // optional
                   String _val93; // required
                   _key92 = iprot.readString();
                   _val93 = iprot.readString();
@@ -908,7 +908,7 @@ public void read(org.apache.thrift.protocol.TProtocol prot, ColumnDef struct) th
           struct.index_options = new HashMap<String,String>(2*_map96.size);
           for (int _i97 = 0; _i97 < _map96.size; ++_i97)
           {
-            String _key98; // required
+            String _key98; // optional
             String _val99; // required
             _key98 = iprot.readString();
             _val99 = iprot.readString();

File: src/java/org/apache/cassandra/db/DefsTables.java
Patch:
@@ -463,6 +463,7 @@ private static void flushSchemaCFs()
         SystemKeyspace.forceBlockingFlush(SystemKeyspace.SCHEMA_KEYSPACES_CF);
         SystemKeyspace.forceBlockingFlush(SystemKeyspace.SCHEMA_COLUMNFAMILIES_CF);
         SystemKeyspace.forceBlockingFlush(SystemKeyspace.SCHEMA_COLUMNS_CF);
+        SystemKeyspace.forceBlockingFlush(SystemKeyspace.SCHEMA_TRIGGERS_CF);
     }
 }
 

File: src/java/org/apache/cassandra/service/MigrationManager.java
Patch:
@@ -335,6 +335,7 @@ public static void resetLocalSchema() throws IOException
         SystemKeyspace.schemaCFS(SystemKeyspace.SCHEMA_KEYSPACES_CF).truncateBlocking();
         SystemKeyspace.schemaCFS(SystemKeyspace.SCHEMA_COLUMNFAMILIES_CF).truncateBlocking();
         SystemKeyspace.schemaCFS(SystemKeyspace.SCHEMA_COLUMNS_CF).truncateBlocking();
+        SystemKeyspace.schemaCFS(SystemKeyspace.SCHEMA_TRIGGERS_CF).truncateBlocking();
 
         if (logger.isDebugEnabled())
             logger.debug("Clearing local schema keyspace definitions...");

File: test/unit/org/apache/cassandra/config/CFMetaDataTest.java
Patch:
@@ -145,7 +145,7 @@ private void checkInverses(CFMetaData cfm) throws Exception
         ColumnFamily serializedCf = rm.getColumnFamily(Schema.instance.getId(Keyspace.SYSTEM_KS, SystemKeyspace.SCHEMA_COLUMNFAMILIES_CF));
         ColumnFamily serializedCD = rm.getColumnFamily(Schema.instance.getId(Keyspace.SYSTEM_KS, SystemKeyspace.SCHEMA_COLUMNS_CF));
         UntypedResultSet.Row result = QueryProcessor.resultify("SELECT * FROM system.schema_columnfamilies", new Row(k, serializedCf)).one();
-        CFMetaData newCfm = CFMetaData.addColumnDefinitionSchema(CFMetaData.fromSchemaNoColumns(result), new Row(k, serializedCD));
+        CFMetaData newCfm = CFMetaData.addColumnDefinitionsFromSchema(CFMetaData.fromSchemaNoColumnsNoTriggers(result), new Row(k, serializedCD));
         assert cfm.equals(newCfm) : String.format("\n%s\n!=\n%s", cfm, newCfm);
     }
 }

File: src/java/org/apache/cassandra/streaming/StreamTransferTask.java
Patch:
@@ -49,9 +49,9 @@ public void addTransferFile(SSTableReader sstable, long estimatedKeys, List<Pair
     }
 
     /**
-     * Complete sending file.
+     * Received ACK for file at {@code sequenceNumber}.
      *
-     * @param sequenceNumber sequence number of completed file transfer
+     * @param sequenceNumber sequence number of file
      */
     public void complete(int sequenceNumber)
     {

File: src/java/org/apache/cassandra/streaming/StreamSession.java
Patch:
@@ -620,8 +620,9 @@ private void startStreamingFiles()
         state(State.STREAMING);
         for (StreamTransferTask task : transfers.values())
         {
-            if (task.getFileMessages().size() > 0)
-                handler.sendMessages(task.getFileMessages());
+            Collection<FileMessage> messages = task.getFileMessages();
+            if (messages.size() > 0)
+                handler.sendMessages(messages);
             else
                 taskCompleted(task); // there is no file to send
         }

File: src/java/org/apache/cassandra/streaming/StreamTransferTask.java
Patch:
@@ -73,7 +73,9 @@ public long getTotalSize()
 
     public Collection<FileMessage> getFileMessages()
     {
-        return files.values();
+        // We may race between queuing all those messages and the completion of the completion of
+        // the first ones. So copy the values to avoid a ConcurrentModificationException
+        return new ArrayList<>(files.values());
     }
 
     public FileMessage createMessageForRetry(int sequenceNumber)

File: src/java/org/apache/cassandra/hadoop/cql3/CqlPagingRecordReader.java
Patch:
@@ -706,7 +706,7 @@ private boolean reachEndRange()
             for (int i = 0; i < partitionBoundColumns.size(); i++)
                 keys[i] = partitionBoundColumns.get(i).value.duplicate();
 
-            rowKey = ((CompositeType) keyValidator).build(keys);
+            rowKey = CompositeType.build(keys);
         }
         else
         {

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -175,7 +175,8 @@ public ResultMessage.Rows execute(ConsistencyLevel cl, QueryState state, List<By
 
             List<Row> page = pager.fetchPage(pageSize);
             ResultMessage.Rows msg = processResults(page, variables, limit, now);
-            msg.result.metadata.setHasMorePages(pager.state());
+            if (!pager.isExhausted())
+                msg.result.metadata.setHasMorePages(pager.state());
             return msg;
         }
     }

File: src/java/org/apache/cassandra/service/pager/PagingState.java
Patch:
@@ -69,6 +69,7 @@ public ByteBuffer serialize()
             ByteBufferUtil.writeWithShortLength(partitionKey, out);
             ByteBufferUtil.writeWithShortLength(cellName, out);
             out.writeInt(remaining);
+            result.flip();
             return result;
         }
         catch (IOException e)

File: src/java/org/apache/cassandra/transport/messages/ExecuteMessage.java
Patch:
@@ -204,6 +204,8 @@ public Message.Response execute(QueryState state)
             }
 
             Message.Response response = QueryProcessor.processPrepared(statement, consistency, state, values, resultPageSize, pagingState);
+            if (skipMetadata && response instanceof ResultMessage.Rows)
+                ((ResultMessage.Rows)response).result.metadata.setSkipMetadata();
 
             if (tracingId != null)
                 response.setTracingId(tracingId);

File: src/java/org/apache/cassandra/transport/messages/QueryMessage.java
Patch:
@@ -216,6 +216,8 @@ public Message.Response execute(QueryState state)
             }
 
             Message.Response response = QueryProcessor.process(query, values, consistency, state, resultPageSize, pagingState);
+            if (skipMetadata && response instanceof ResultMessage.Rows)
+                ((ResultMessage.Rows)response).result.metadata.setSkipMetadata();
 
             if (tracingId != null)
                 response.setTracingId(tracingId);

File: src/java/org/apache/cassandra/transport/messages/ResultMessage.java
Patch:
@@ -324,7 +324,7 @@ public CqlPreparedResult toThriftPreparedResult()
         @Override
         public String toString()
         {
-            return "RESULT PREPARED " + statementId + " " + metadata;
+            return "RESULT PREPARED " + statementId + " " + metadata + " (resultMetadata=" + resultMetadata + ")";
         }
     }
 

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -944,7 +944,7 @@ private void bootstrap(Collection<Token> tokens)
         }
         Tracing.instance();
         if (!Gossiper.instance.seenAnySeed())
-            throw new IllegalStateException("Unable to contact any seeds!")
+            throw new IllegalStateException("Unable to contact any seeds!");
         setMode(Mode.JOINING, "Starting to bootstrap...", true);
         new BootStrapper(FBUtilities.getBroadcastAddress(), tokens, tokenMetadata).bootstrap(); // handles token update
         logger.info("Bootstrap completed! for the tokens {}", tokens);

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -3545,9 +3545,9 @@ public void init(String keyspace)
             }
 
             @Override
-            public boolean validateColumnFamily(String keyspace, String cfName)
+            public CFMetaData getCFMetaData(String keyspace, String cfName)
             {
-                return Schema.instance.getCFMetaData(keyspace, cfName) != null;
+                return Schema.instance.getCFMetaData(keyspace, cfName);
             }
         };
 

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -728,7 +728,7 @@ public static UUID getReplaceNode()
 
     public static boolean isReplacing()
     {
-        return 0 != getReplaceTokens().size() || getReplaceNode() != null
+        return 0 != getReplaceTokens().size() || getReplaceNode() != null;
     }
 
     public static String getClusterName()

File: src/java/org/apache/cassandra/serializers/TimeUUIDSerializer.java
Patch:
@@ -22,6 +22,8 @@
 
 public class TimeUUIDSerializer extends UUIDSerializer
 {
+    public static final TimeUUIDSerializer instance = new TimeUUIDSerializer();
+
     @Override
     public void validate(ByteBuffer bytes) throws MarshalException
     {

File: test/unit/org/apache/cassandra/db/marshal/CompositeTypeTest.java
Patch:
@@ -145,7 +145,7 @@ public void testValidate()
         }
         catch (MarshalException e)
         {
-            assert e.toString().contains("TimeUUID should be 16 or 0 bytes");
+            assert e.toString().contains("should be 16 or 0 bytes");
         }
 
         key = createCompositeKey("test1", UUID.randomUUID(), 42, false);

File: test/unit/org/apache/cassandra/db/marshal/DynamicCompositeTypeTest.java
Patch:
@@ -144,7 +144,7 @@ public void testValidate()
         }
         catch (MarshalException e)
         {
-            assert e.toString().contains("TimeUUID should be 16 or 0 bytes");
+            assert e.toString().contains("should be 16 or 0 bytes");
         }
 
         key = createDynamicCompositeKey("test1", UUID.randomUUID(), 42, false);

File: src/java/org/apache/cassandra/tools/Shuffle.java
Patch:
@@ -434,7 +434,7 @@ public void clear() throws ShuffleError
                 assert row.getColumns().size() == 2;
 
                 ByteBuffer tokenBytes = ByteBuffer.wrap(row.getColumns().get(0).getValue());
-                String query = String.format("DELETE FROM system.range_xfers WHERE token_bytes = '%s'",
+                String query = String.format("DELETE FROM system.range_xfers WHERE token_bytes = 0x%s",
                         ByteBufferUtil.bytesToHex(tokenBytes));
                 executeCqlQuery(host, thriftPort, thriftFramed, query);
             }

File: src/java/org/apache/cassandra/tools/Shuffle.java
Patch:
@@ -683,7 +683,7 @@ else if (subCommand.equals("ls"))
                 shuffler.ls();
             else if (subCommand.startsWith("en"))
                 shuffler.enable();
-            else if (subCommand.startsWith("in"))
+            else if (subCommand.startsWith("dis"))
                 shuffler.disable();
             else if (subCommand.equals("clear"))
                 shuffler.clear();

File: src/java/org/apache/cassandra/cql3/Lists.java
Patch:
@@ -138,7 +138,7 @@ public static Value fromSerialized(ByteBuffer value, ListType type) throws Inval
             {
                 // Collections have this small hack that validate cannot be called on a serialized object,
                 // but compose does the validation (so we're fine).
-                List<?> l = type.compose(value);
+                List<?> l = (List<?>)type.compose(value);
                 List<ByteBuffer> elements = new ArrayList<ByteBuffer>(l.size());
                 for (Object element : l)
                     elements.add(type.elements.decompose(element));

File: src/java/org/apache/cassandra/cql3/Maps.java
Patch:
@@ -155,7 +155,7 @@ public static Value fromSerialized(ByteBuffer value, MapType type) throws Invali
             {
                 // Collections have this small hack that validate cannot be called on a serialized object,
                 // but compose does the validation (so we're fine).
-                Map<?, ?> m = type.compose(value);
+                Map<?, ?> m = (Map<?, ?>)type.compose(value);
                 Map<ByteBuffer, ByteBuffer> map = new LinkedHashMap<ByteBuffer, ByteBuffer>(m.size());
                 for (Map.Entry<?, ?> entry : m.entrySet())
                     map.put(type.keys.decompose(entry.getKey()), type.values.decompose(entry.getValue()));

File: src/java/org/apache/cassandra/cql3/Sets.java
Patch:
@@ -148,7 +148,7 @@ public static Value fromSerialized(ByteBuffer value, SetType type) throws Invali
             {
                 // Collections have this small hack that validate cannot be called on a serialized object,
                 // but compose does the validation (so we're fine).
-                Set<?> s = type.compose(value);
+                Set<?> s = (Set<?>)type.compose(value);
                 Set<ByteBuffer> elements = new LinkedHashSet<ByteBuffer>(s.size());
                 for (Object element : s)
                     elements.add(type.elements.decompose(element));

File: src/java/org/apache/cassandra/db/marshal/AbstractCommutativeType.java
Patch:
@@ -29,11 +29,13 @@ public boolean isCommutative()
         return true;
     }
 
+    @Override
     public Long compose(ByteBuffer bytes)
     {
         return CounterContext.instance().total(bytes);
     }
 
+    @Override
     public ByteBuffer decompose(Long value)
     {
         return ByteBufferUtil.bytes(value);

File: src/java/org/apache/cassandra/db/marshal/DynamicCompositeType.java
Patch:
@@ -336,11 +336,13 @@ public int compare(ByteBuffer v1, ByteBuffer v2)
             return cmp;
         }
 
+        @Override
         public Void compose(ByteBuffer bytes)
         {
             throw new UnsupportedOperationException();
         }
 
+        @Override
         public ByteBuffer decompose(Void value)
         {
             throw new UnsupportedOperationException();
@@ -356,12 +358,12 @@ public ByteBuffer fromString(String str)
             throw new UnsupportedOperationException();
         }
 
+        @Override
         public void validate(ByteBuffer bytes)
         {
             throw new UnsupportedOperationException();
         }
 
-        @Override
         public TypeSerializer<Void> getSerializer()
         {
             throw new UnsupportedOperationException();

File: src/java/org/apache/cassandra/db/marshal/LocalByPartionerType.java
Patch:
@@ -39,11 +39,13 @@ public LocalByPartionerType(IPartitioner<T> partitioner)
         this.partitioner = partitioner;
     }
 
+    @Override
     public ByteBuffer compose(ByteBuffer bytes)
     {
         throw new UnsupportedOperationException("You can't do this with a local partitioner.");
     }
 
+    @Override
     public ByteBuffer decompose(ByteBuffer bytes)
     {
         throw new UnsupportedOperationException("You can't do this with a local partitioner.");
@@ -65,6 +67,7 @@ public int compare(ByteBuffer o1, ByteBuffer o2)
         return RowPosition.forKey(o1, partitioner).compareTo(RowPosition.forKey(o2, partitioner));
     }
 
+    @Override
     public void validate(ByteBuffer bytes) throws MarshalException
     {
         throw new IllegalStateException("You shouldn't be validating this.");

File: src/java/org/apache/cassandra/tools/Shuffle.java
Patch:
@@ -389,7 +389,7 @@ public void ls() throws ShuffleError
 
                 ByteBuffer tokenBytes = ByteBuffer.wrap(row.getColumns().get(0).getValue());
                 ByteBuffer requestedAt = ByteBuffer.wrap(row.getColumns().get(1).getValue());
-                Date time = TimestampSerializer.instance.serialize(requestedAt);
+                Date time = TimestampSerializer.instance.deserialize(requestedAt);
                 Token<?> token = partitioner.getTokenFactory().fromByteArray(tokenBytes);
 
                 writeln("%-42s %-15s %s", token.toString(), host, time.toString());

File: src/java/org/apache/cassandra/utils/BooleanSerializer.java
Patch:
@@ -41,4 +41,4 @@ public long serializedSize(Boolean aBoolean, int version)
     {
         return 1;
     }
-}
\ No newline at end of file
+}

File: test/unit/org/apache/cassandra/cql/jdbc/JdbcDecimalTest.java
Patch:
@@ -33,8 +33,8 @@ public void testComposeDecompose()
         BigDecimal expected = new BigDecimal("123456789123456789.987654321");
         DecimalSerializer decimal = new DecimalSerializer();
         
-        ByteBuffer buffer = decimal.deserialize(expected);
-        BigDecimal actual = decimal.serialize(buffer);
+        ByteBuffer buffer = decimal.serialize(expected);
+        BigDecimal actual = decimal.deserialize(buffer);
         Assert.assertEquals(expected, actual);
     }
 }

File: src/java/org/apache/cassandra/cql3/CQL3Type.java
Patch:
@@ -41,7 +41,7 @@ public enum Native implements CQL3Type
         INET     (InetAddressType.instance),
         INT      (Int32Type.instance),
         TEXT     (UTF8Type.instance),
-        TIMESTAMP(DateType.instance),
+        TIMESTAMP(TimestampType.instance),
         UUID     (UUIDType.instance),
         VARCHAR  (UTF8Type.instance),
         VARINT   (IntegerType.instance),

File: src/java/org/apache/cassandra/cql3/UntypedResultSet.java
Patch:
@@ -128,7 +128,7 @@ public UUID getUUID(String column)
 
         public Date getTimestamp(String column)
         {
-            return DateType.instance.compose(data.get(column));
+            return TimestampType.instance.compose(data.get(column));
         }
 
         public long getLong(String column)

File: src/java/org/apache/cassandra/db/marshal/AbstractType.java
Patch:
@@ -306,4 +306,3 @@ public boolean intersects(List<ByteBuffer> minColumnNames, List<ByteBuffer> maxC
         return false;
     }
 }
-

File: src/java/org/apache/cassandra/db/marshal/UUIDType.java
Patch:
@@ -30,7 +30,7 @@
 import org.apache.cassandra.utils.UUIDGen;
 import org.apache.commons.lang.time.DateUtils;
 
-import static org.apache.cassandra.type.DateSerializer.iso8601Patterns;
+import static org.apache.cassandra.type.TimestampSerializer.iso8601Patterns;
 
 /**
  * Compares UUIDs using the following criteria:<br>

File: src/java/org/apache/cassandra/hadoop/pig/AbstractCassandraStorage.java
Patch:
@@ -140,7 +140,7 @@ else if (value instanceof ByteBuffer)
        else if (value instanceof UUID)
            pair.set(position, new DataByteArray(UUIDGen.decompose((java.util.UUID) value)));
        else if (value instanceof Date)
-           pair.set(position, DateType.instance.decompose((Date) value).getLong());
+           pair.set(position, TimestampType.instance.decompose((Date) value).getLong());
        else
            pair.set(position, value);
     }
@@ -299,7 +299,7 @@ protected String getFullyQualifiedClassName(String classname)
     /** get pig type for the cassandra data type*/
     protected byte getPigType(AbstractType type)
     {
-        if (type instanceof LongType || type instanceof DateType) // DateType is bad and it should feel bad
+        if (type instanceof LongType || type instanceof DateType || type instanceof TimestampType) // DateType is bad and it should feel bad
             return DataType.LONG;
         else if (type instanceof IntegerType || type instanceof Int32Type) // IntegerType will overflow at 2**31, but is kept for compatibility until pig has a BigInteger
             return DataType.INTEGER;

File: src/java/org/apache/cassandra/tools/Shuffle.java
Patch:
@@ -43,7 +43,7 @@
 import javax.management.MalformedObjectNameException;
 import javax.management.ObjectName;
 
-import org.apache.cassandra.type.DateSerializer;
+import org.apache.cassandra.type.TimestampSerializer;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.locator.EndpointSnitchInfoMBean;
@@ -389,7 +389,7 @@ public void ls() throws ShuffleError
 
                 ByteBuffer tokenBytes = ByteBuffer.wrap(row.getColumns().get(0).getValue());
                 ByteBuffer requestedAt = ByteBuffer.wrap(row.getColumns().get(1).getValue());
-                Date time = DateSerializer.instance.serialize(requestedAt);
+                Date time = TimestampSerializer.instance.serialize(requestedAt);
                 Token<?> token = partitioner.getTokenFactory().fromByteArray(tokenBytes);
 
                 writeln("%-42s %-15s %s", token.toString(), host, time.toString());

File: src/java/org/apache/cassandra/type/TimestampSerializer.java
Patch:
@@ -24,7 +24,7 @@
 import java.text.SimpleDateFormat;
 import java.util.Date;
 
-public class DateSerializer extends AbstractSerializer<Date>
+public class TimestampSerializer extends AbstractSerializer<Date>
 {
     public static final String[] iso8601Patterns = new String[] {
             "yyyy-MM-dd HH:mm",
@@ -49,7 +49,7 @@ protected SimpleDateFormat initialValue()
         }
     };
 
-    public static final DateSerializer instance = new DateSerializer();
+    public static final TimestampSerializer instance = new TimestampSerializer();
 
     @Override
     public Date serialize(ByteBuffer bytes)

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -32,6 +32,7 @@
 import com.google.common.collect.Collections2;
 import com.google.common.collect.Iterables;
 
+import org.apache.cassandra.type.MarshalException;
 import org.apache.commons.lang.StringUtils;
 
 import org.antlr.runtime.tree.Tree;

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -31,6 +31,7 @@
 import com.google.common.collect.MapDifference;
 import com.google.common.collect.Maps;
 
+import org.apache.cassandra.type.MarshalException;
 import org.apache.commons.lang.ArrayUtils;
 import org.apache.commons.lang.StringUtils;
 import org.apache.commons.lang.builder.EqualsBuilder;

File: src/java/org/apache/cassandra/cql/QueryProcessor.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.*;
 import java.util.concurrent.TimeoutException;
 
+import org.apache.cassandra.type.MarshalException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -36,7 +37,6 @@
 import org.apache.cassandra.db.index.SecondaryIndexManager;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.AsciiType;
-import org.apache.cassandra.db.marshal.MarshalException;
 import org.apache.cassandra.db.marshal.TypeParser;
 import org.apache.cassandra.dht.*;
 import org.apache.cassandra.exceptions.*;

File: src/java/org/apache/cassandra/cql/Term.java
Patch:
@@ -25,8 +25,8 @@
 import org.apache.cassandra.db.marshal.FloatType;
 import org.apache.cassandra.db.marshal.IntegerType;
 import org.apache.cassandra.db.marshal.LexicalUUIDType;
-import org.apache.cassandra.db.marshal.MarshalException;
 import org.apache.cassandra.exceptions.InvalidRequestException;
+import org.apache.cassandra.type.MarshalException;
 
 /** A term parsed from a CQL statement. */
 public class Term

File: src/java/org/apache/cassandra/cql3/Attributes.java
Patch:
@@ -23,8 +23,8 @@
 import org.apache.cassandra.db.ExpiringColumn;
 import org.apache.cassandra.db.marshal.Int32Type;
 import org.apache.cassandra.db.marshal.LongType;
-import org.apache.cassandra.db.marshal.MarshalException;
 import org.apache.cassandra.exceptions.InvalidRequestException;
+import org.apache.cassandra.type.MarshalException;
 
 /**
  * Utility class for the Parser to gather attributes for modification

File: src/java/org/apache/cassandra/cql3/Lists.java
Patch:
@@ -27,8 +27,8 @@
 import org.apache.cassandra.db.marshal.CollectionType;
 import org.apache.cassandra.db.marshal.Int32Type;
 import org.apache.cassandra.db.marshal.ListType;
-import org.apache.cassandra.db.marshal.MarshalException;
 import org.apache.cassandra.exceptions.InvalidRequestException;
+import org.apache.cassandra.type.MarshalException;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.Pair;

File: src/java/org/apache/cassandra/cql3/Maps.java
Patch:
@@ -27,8 +27,8 @@
 import org.apache.cassandra.db.ColumnFamily;
 import org.apache.cassandra.db.marshal.CollectionType;
 import org.apache.cassandra.db.marshal.MapType;
-import org.apache.cassandra.db.marshal.MarshalException;
 import org.apache.cassandra.exceptions.InvalidRequestException;
+import org.apache.cassandra.type.MarshalException;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.Pair;
 

File: src/java/org/apache/cassandra/cql3/Sets.java
Patch:
@@ -29,10 +29,10 @@
 
 import org.apache.cassandra.db.ColumnFamily;
 import org.apache.cassandra.db.marshal.CollectionType;
-import org.apache.cassandra.db.marshal.MarshalException;
 import org.apache.cassandra.db.marshal.MapType;
 import org.apache.cassandra.db.marshal.SetType;
 import org.apache.cassandra.exceptions.InvalidRequestException;
+import org.apache.cassandra.type.MarshalException;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -44,6 +44,7 @@
 import org.apache.cassandra.thrift.IndexExpression;
 import org.apache.cassandra.thrift.IndexOperator;
 import org.apache.cassandra.thrift.ThriftValidation;
+import org.apache.cassandra.type.MarshalException;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.Pair;

File: src/java/org/apache/cassandra/db/Column.java
Patch:
@@ -33,6 +33,7 @@
 import org.apache.cassandra.db.marshal.*;
 import org.apache.cassandra.io.sstable.Descriptor;
 import org.apache.cassandra.io.util.DataOutputBuffer;
+import org.apache.cassandra.type.MarshalException;
 import org.apache.cassandra.utils.Allocator;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;

File: src/java/org/apache/cassandra/db/CounterColumn.java
Patch:
@@ -25,6 +25,7 @@
 
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
+import org.apache.cassandra.type.MarshalException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -33,7 +34,6 @@
 import org.apache.cassandra.db.context.CounterContext;
 import org.apache.cassandra.db.context.IContext.ContextRelationship;
 import org.apache.cassandra.db.marshal.AbstractType;
-import org.apache.cassandra.db.marshal.MarshalException;
 import org.apache.cassandra.exceptions.OverloadedException;
 import org.apache.cassandra.exceptions.RequestExecutionException;
 import org.apache.cassandra.io.util.DataOutputBuffer;

File: src/java/org/apache/cassandra/db/DeletedColumn.java
Patch:
@@ -22,8 +22,8 @@
 import java.security.MessageDigest;
 
 import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.db.marshal.MarshalException;
 import org.apache.cassandra.io.util.DataOutputBuffer;
+import org.apache.cassandra.type.MarshalException;
 import org.apache.cassandra.utils.Allocator;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.HeapAllocator;

File: src/java/org/apache/cassandra/db/ExpiringColumn.java
Patch:
@@ -23,8 +23,8 @@
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.db.marshal.AbstractType;
-import org.apache.cassandra.db.marshal.MarshalException;
 import org.apache.cassandra.io.util.DataOutputBuffer;
+import org.apache.cassandra.type.MarshalException;
 import org.apache.cassandra.utils.Allocator;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.HeapAllocator;

File: src/java/org/apache/cassandra/db/OnDiskAtom.java
Patch:
@@ -22,9 +22,9 @@
 import java.security.MessageDigest;
 
 import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.db.marshal.MarshalException;
 import org.apache.cassandra.io.ISSTableSerializer;
 import org.apache.cassandra.io.sstable.Descriptor;
+import org.apache.cassandra.type.MarshalException;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
 public interface OnDiskAtom

File: src/java/org/apache/cassandra/db/RangeTombstone.java
Patch:
@@ -25,10 +25,10 @@
 import java.util.*;
 
 import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.db.marshal.MarshalException;
 import org.apache.cassandra.io.ISSTableSerializer;
 import org.apache.cassandra.io.sstable.Descriptor;
 import org.apache.cassandra.io.util.DataOutputBuffer;
+import org.apache.cassandra.type.MarshalException;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.Interval;
 

File: src/java/org/apache/cassandra/db/context/CounterContext.java
Patch:
@@ -23,12 +23,12 @@
 import java.util.Iterator;
 import java.util.List;
 
+import org.apache.cassandra.type.MarshalException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.db.compaction.CompactionManager;
-import org.apache.cassandra.db.marshal.MarshalException;
 import org.apache.cassandra.utils.*;
 
 /**

File: src/java/org/apache/cassandra/db/marshal/CollectionType.java
Patch:
@@ -22,6 +22,7 @@
 
 import org.apache.cassandra.cql3.CQL3Type;
 import org.apache.cassandra.db.Column;
+import org.apache.cassandra.type.MarshalException;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.Pair;
 

File: src/java/org/apache/cassandra/db/marshal/CompositeType.java
Patch:
@@ -34,6 +34,7 @@
 import org.apache.cassandra.cql3.ColumnNameBuilder;
 import org.apache.cassandra.cql3.Relation;
 import org.apache.cassandra.io.util.DataOutputBuffer;
+import org.apache.cassandra.type.MarshalException;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
 /*

File: src/java/org/apache/cassandra/hadoop/cql3/CqlRecordWriter.java
Patch:
@@ -356,7 +356,7 @@ private AbstractType<?> parseType(String type) throws ConfigurationException
     {
         try
         {
-            // always treat counters like longs, specifically CCT.compose is not what we need
+            // always treat counters like longs, specifically CCT.serialize is not what we need
             if (type != null && type.equals("org.apache.cassandra.db.marshal.CounterColumnType"))
                 return LongType.instance;
             return TypeParser.parse(type);

File: src/java/org/apache/cassandra/io/sstable/SSTableIdentityIterator.java
Patch:
@@ -20,13 +20,13 @@
 import java.io.*;
 import java.util.Iterator;
 
+import org.apache.cassandra.type.MarshalException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.columniterator.OnDiskAtomIterator;
-import org.apache.cassandra.db.marshal.MarshalException;
 import org.apache.cassandra.io.util.RandomAccessReader;
 
 public class SSTableIdentityIterator implements Comparable<SSTableIdentityIterator>, OnDiskAtomIterator

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -50,7 +50,7 @@
 import org.apache.cassandra.db.filter.NamesQueryFilter;
 import org.apache.cassandra.db.filter.SliceQueryFilter;
 import org.apache.cassandra.db.marshal.CompositeType;
-import org.apache.cassandra.db.marshal.MarshalException;
+import org.apache.cassandra.type.MarshalException;
 import org.apache.cassandra.db.marshal.TimeUUIDType;
 import org.apache.cassandra.dht.*;
 import org.apache.cassandra.exceptions.*;

File: src/java/org/apache/cassandra/thrift/ThriftValidation.java
Patch:
@@ -20,6 +20,7 @@
 import java.nio.ByteBuffer;
 import java.util.*;
 
+import org.apache.cassandra.type.MarshalException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -31,7 +32,6 @@
 import org.apache.cassandra.db.index.SecondaryIndexManager;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.CompositeType;
-import org.apache.cassandra.db.marshal.MarshalException;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.service.StorageService;

File: src/java/org/apache/cassandra/tools/SSTableImport.java
Patch:
@@ -28,6 +28,7 @@
 import java.util.TreeMap;
 import java.util.concurrent.TimeUnit;
 
+import org.apache.cassandra.type.MarshalException;
 import org.apache.commons.cli.CommandLine;
 import org.apache.commons.cli.CommandLineParser;
 import org.apache.commons.cli.Option;
@@ -43,7 +44,6 @@
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.BytesType;
 import org.apache.cassandra.db.marshal.CompositeType;
-import org.apache.cassandra.db.marshal.MarshalException;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.io.sstable.SSTableWriter;
 import org.apache.cassandra.utils.ByteBufferUtil;

File: src/java/org/apache/cassandra/tools/Shuffle.java
Patch:
@@ -43,7 +43,7 @@
 import javax.management.MalformedObjectNameException;
 import javax.management.ObjectName;
 
-import org.apache.cassandra.cql.jdbc.JdbcDate;
+import org.apache.cassandra.type.DateSerializer;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.locator.EndpointSnitchInfoMBean;
@@ -389,7 +389,7 @@ public void ls() throws ShuffleError
 
                 ByteBuffer tokenBytes = ByteBuffer.wrap(row.getColumns().get(0).getValue());
                 ByteBuffer requestedAt = ByteBuffer.wrap(row.getColumns().get(1).getValue());
-                Date time = JdbcDate.instance.compose(requestedAt);
+                Date time = DateSerializer.instance.serialize(requestedAt);
                 Token<?> token = partitioner.getTokenFactory().fromByteArray(tokenBytes);
 
                 writeln("%-42s %-15s %s", token.toString(), host, time.toString());

File: src/java/org/apache/cassandra/type/MarshalException.java
Patch:
@@ -15,7 +15,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.cassandra.cql.jdbc;
+
+package org.apache.cassandra.type;
 
 public class MarshalException extends RuntimeException
 {

File: test/unit/org/apache/cassandra/db/marshal/BytesTypeTest.java
Patch:
@@ -19,6 +19,7 @@
  */
 package org.apache.cassandra.db.marshal;
 
+import org.apache.cassandra.type.MarshalException;
 import org.junit.Test;
 
 public class BytesTypeTest

File: test/unit/org/apache/cassandra/db/marshal/CompositeTypeTest.java
Patch:
@@ -26,6 +26,7 @@
 import java.util.List;
 import java.util.UUID;
 
+import org.apache.cassandra.type.MarshalException;
 import org.junit.Test;
 import static org.junit.Assert.fail;
 import static org.junit.Assert.assertEquals;

File: test/unit/org/apache/cassandra/db/marshal/DynamicCompositeTypeTest.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.Map;
 import java.util.UUID;
 
+import org.apache.cassandra.type.MarshalException;
 import org.junit.Test;
 import static org.junit.Assert.fail;
 

File: test/unit/org/apache/cassandra/db/marshal/TimeUUIDTypeTest.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.Random;
 import java.util.UUID;
 
+import org.apache.cassandra.type.MarshalException;
 import org.junit.Test;
 import static org.junit.Assert.assertEquals;
 

File: test/unit/org/apache/cassandra/db/marshal/TypeValidationTest.java
Patch:
@@ -1,6 +1,7 @@
 package org.apache.cassandra.db.marshal;
 
 import org.apache.cassandra.Util;
+import org.apache.cassandra.type.MarshalException;
 import org.apache.cassandra.utils.UUIDGen;
 import org.junit.Test;
 

File: src/java/org/apache/cassandra/cql/QueryProcessor.java
Patch:
@@ -270,7 +270,7 @@ public static void validateKey(ByteBuffer key) throws InvalidRequestException
     public static void validateKeyAlias(CFMetaData cfm, String key) throws InvalidRequestException
     {
         assert key.toUpperCase().equals(key); // should always be uppercased by caller
-        String realKeyAlias = cfm.getCQL2KeyName();
+        String realKeyAlias = cfm.getCQL2KeyName().toUpperCase();
         if (!realKeyAlias.equals(key))
             throw new InvalidRequestException(String.format("Expected key '%s' to be present in WHERE clause for '%s'", realKeyAlias, cfm.cfName));
     }

File: src/java/org/apache/cassandra/streaming/StreamPlan.java
Patch:
@@ -139,7 +139,7 @@ public boolean isEmpty()
      */
     public StreamResultFuture execute()
     {
-        return StreamResultFuture.startStreamingAsync(planId, description, sessions.values());
+        return StreamResultFuture.init(planId, description, sessions.values());
     }
 
     /**

File: src/java/org/apache/cassandra/streaming/StreamReceiveTask.java
Patch:
@@ -53,7 +53,7 @@ public StreamReceiveTask(StreamSession session, UUID cfId, int totalFiles, long
      *
      * @param sstable SSTable file received.
      */
-    public void receive(SSTableReader sstable)
+    public void received(SSTableReader sstable)
     {
         assert cfId.equals(sstable.metadata.cfId);
 

File: src/java/org/apache/cassandra/cql3/ResultSet.java
Patch:
@@ -218,7 +218,7 @@ public static class Metadata
     {
         public static final CBCodec<Metadata> codec = new Codec();
 
-        public static final Metadata empty = new Metadata(EnumSet.of(Flag.NO_METADATA), 0);
+        public static final Metadata EMPTY = new Metadata(EnumSet.of(Flag.NO_METADATA), 0);
 
         public final EnumSet<Flag> flags;
         public final List<ColumnSpecification> names;
@@ -345,7 +345,7 @@ public ChannelBuffer encode(Metadata m, int version)
 
                 ChannelBuffer header = ChannelBuffers.buffer(8);
 
-                assert version > 1 || (!m.flags.contains(Flag.HAS_MORE_PAGES) && !noMetadata);
+                assert version > 1 || (!m.flags.contains(Flag.HAS_MORE_PAGES) && !noMetadata): "version = " + version + ", flags = " + m.flags;
 
                 header.writeInt(Flag.serialize(m.flags));
                 header.writeInt(m.columnCount);

File: src/java/org/apache/cassandra/cql3/QueryProcessor.java
Patch:
@@ -224,7 +224,7 @@ private static ResultMessage.Prepared storePreparedStatement(String queryString,
                                        statementId,
                                        prepared.statement.getBoundsTerms()));
             preparedStatements.put(statementId, prepared.statement);
-            return new ResultMessage.Prepared(statementId, prepared.boundNames);
+            return new ResultMessage.Prepared(statementId, prepared);
         }
     }
 

File: src/java/org/apache/cassandra/transport/Client.java
Patch:
@@ -126,7 +126,7 @@ else if (msgType.equals("QUERY"))
                     return null;
                 }
             }
-            return new QueryMessage(query, Collections.<ByteBuffer>emptyList(), ConsistencyLevel.ONE, pageSize);
+            return new QueryMessage(query, ConsistencyLevel.ONE, Collections.<ByteBuffer>emptyList(), pageSize);
         }
         else if (msgType.equals("NEXT"))
         {

File: src/java/org/apache/cassandra/transport/SimpleClient.java
Patch:
@@ -156,7 +156,7 @@ public ResultMessage execute(String query, ConsistencyLevel consistency)
 
     public ResultMessage execute(String query, List<ByteBuffer> values, ConsistencyLevel consistencyLevel)
     {
-        Message.Response msg = execute(new QueryMessage(query, values, consistencyLevel, -1));
+        Message.Response msg = execute(new QueryMessage(query, consistencyLevel, values, -1));
         assert msg instanceof ResultMessage;
         return (ResultMessage)msg;
     }

File: src/java/org/apache/cassandra/hadoop/pig/CqlStorage.java
Patch:
@@ -62,7 +62,7 @@ public CqlStorage()
         this(1000);
     }
 
-    /** @param limit number of CQL rows to fetch in a thrift request */
+    /** @param pageSize limit number of CQL rows to fetch in a thrift request */
     public CqlStorage(int pageSize)
     {
         super();

File: src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java
Patch:
@@ -510,9 +510,7 @@ private List<SecondaryIndexSearcher> getIndexSearchersForQuery(List<IndexExpress
      * Performs a search across a number of column indexes
      * TODO: add support for querying across index types
      *
-     * @param range the row range to restrict to
-     * @param clause the index query clause
-     * @param columnFilter the column range to restrict to
+     * @param filter the column range to restrict to
      * @return found indexed rows
      */
     public List<Row> search(ExtendedFilter filter)

File: src/java/org/apache/cassandra/hadoop/cql3/CqlOutputFormat.java
Patch:
@@ -36,8 +36,8 @@
  * ColumnFamily.
  *
  * <p>
- * As is the case with the {@link ColumnFamilyInputFormat}, you need to set the
- * prepared statement in your
+ * As is the case with the {@link org.apache.cassandra.hadoop.ColumnFamilyInputFormat}, 
+ * you need to set the prepared statement in your
  * Hadoop job Configuration. The {@link CqlConfigHelper} class, through its
  * {@link ConfigHelper#setOutputPreparedStatement} method, is provided to make this
  * simple.

File: src/java/org/apache/cassandra/repair/Differencer.java
Patch:
@@ -30,8 +30,6 @@
 import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.repair.messages.SyncComplete;
 import org.apache.cassandra.repair.messages.SyncRequest;
-import org.apache.cassandra.service.ActiveRepairService;
-import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.MerkleTree;
 
@@ -40,7 +38,7 @@
  */
 public class Differencer implements Runnable
 {
-    private static Logger logger = LoggerFactory.getLogger(ActiveRepairService.class);
+    private static Logger logger = LoggerFactory.getLogger(Differencer.class);
 
     private final RepairJobDesc desc;
     public final TreeResponse r1;

File: src/java/org/apache/cassandra/repair/NodePair.java
Patch:
@@ -23,7 +23,6 @@
 import java.net.InetAddress;
 
 import com.google.common.base.Objects;
-import com.google.common.collect.Sets;
 
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.net.CompactEndpointSerializationHelper;

File: src/java/org/apache/cassandra/repair/RepairJob.java
Patch:
@@ -38,7 +38,6 @@
 import org.apache.cassandra.net.MessageIn;
 import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.repair.messages.ValidationRequest;
-import org.apache.cassandra.service.ActiveRepairService;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.MerkleTree;
 import org.apache.cassandra.utils.SimpleCondition;
@@ -48,7 +47,7 @@
  */
 public class RepairJob
 {
-    private static Logger logger = LoggerFactory.getLogger(ActiveRepairService.class);
+    private static Logger logger = LoggerFactory.getLogger(RepairJob.class);
 
     public final RepairJobDesc desc;
     private final boolean isSequential;

File: src/java/org/apache/cassandra/repair/RepairSession.java
Patch:
@@ -71,7 +71,7 @@
  */
 public class RepairSession extends WrappedRunnable implements IEndpointStateChangeSubscriber, IFailureDetectionEventListener
 {
-    private static Logger logger = LoggerFactory.getLogger(ActiveRepairService.class);
+    private static Logger logger = LoggerFactory.getLogger(RepairSession.class);
 
     /** Repair session ID */
     private final UUID id;

File: src/java/org/apache/cassandra/repair/messages/RepairMessage.java
Patch:
@@ -21,7 +21,6 @@
 import java.io.DataOutput;
 import java.io.IOException;
 
-import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.net.MessageOut;
 import org.apache.cassandra.net.MessagingService;

File: src/java/org/apache/cassandra/repair/messages/SyncRequest.java
Patch:
@@ -29,10 +29,8 @@
 import org.apache.cassandra.dht.AbstractBounds;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.Token;
-import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.net.CompactEndpointSerializationHelper;
 import org.apache.cassandra.repair.RepairJobDesc;
-import org.apache.cassandra.utils.FBUtilities;
 
 /**
  * Body part of SYNC_REQUEST repair message.

File: src/java/org/apache/cassandra/repair/messages/ValidationRequest.java
Patch:
@@ -22,7 +22,6 @@
 import java.io.IOException;
 
 import org.apache.cassandra.db.TypeSizes;
-import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.repair.RepairJobDesc;
 
 /**

File: src/java/org/apache/cassandra/gms/VersionedValue.java
Patch:
@@ -148,8 +148,8 @@ public VersionedValue leaving(Collection<Token> tokens)
         public VersionedValue left(Collection<Token> tokens, long expireTime)
         {
             return new VersionedValue(versionString(VersionedValue.STATUS_LEFT,
-                    Long.toString(expireTime),
-                    makeTokenString(tokens)));
+                    makeTokenString(tokens),
+                    Long.toString(expireTime)));
         }
 
         public VersionedValue moving(Token token)

File: src/java/org/apache/cassandra/config/KSMetaData.java
Patch:
@@ -315,6 +315,7 @@ public static Map<String, CFMetaData> deserializeColumnFamilies(Row row)
                 // value aliases. But that's what we want (see CFMetaData.fromSchemaNoColumns).
                 cfm.addOrReplaceColumnDefinition(cd);
             }
+            cfm.rebuild();
         }
 
         return cfms;

File: src/java/org/apache/cassandra/cql/AlterTableStatement.java
Patch:
@@ -80,7 +80,7 @@ public CFMetaData getCFMetaData(String keyspace) throws ConfigurationException,
             case ALTER:
                 // We only look for the first key alias which is ok for CQL2
                 ColumnDefinition partionKeyDef = cfm.partitionKeyColumns().get(0);
-                if (partionKeyDef != null && partionKeyDef.name.equals(columnName))
+                if (partionKeyDef.name.equals(columnName))
                 {
                     cfm.keyValidator(TypeParser.parse(validator));
                 }

File: test/unit/org/apache/cassandra/config/DefsTest.java
Patch:
@@ -515,7 +515,7 @@ public void testDropIndex() throws IOException, ExecutionException, InterruptedE
         CFMetaData meta = cfs.metadata.clone();
         ColumnDefinition cdOld = meta.regularColumns().iterator().next();
         ColumnDefinition cdNew = ColumnDefinition.regularDef(cdOld.name, cdOld.getValidator(), null);
-        meta.columnMetadata(Collections.singletonMap(cdOld.name, cdNew));
+        meta.addOrReplaceColumnDefinition(cdNew);
         MigrationManager.announceColumnFamilyUpdate(meta, false);
 
         // check

File: src/java/org/apache/cassandra/db/ReadResponse.java
Patch:
@@ -105,6 +105,7 @@ public long serializedSize(ReadResponse response, int version)
         TypeSizes typeSizes = TypeSizes.NATIVE;
         ByteBuffer buffer = response.isDigestQuery() ? response.digest() : ByteBufferUtil.EMPTY_BYTE_BUFFER;
         int size = typeSizes.sizeof(buffer.remaining());
+        size += buffer.remaining();
         size += typeSizes.sizeof(response.isDigestQuery());
         if (!response.isDigestQuery())
             size += Row.serializer.serializedSize(response.row(), version);

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -918,7 +918,6 @@ private Map<ApplicationState, VersionedValue> copyNewerApplicationStates(Endpoin
         {
             ApplicationState key = fromEntry.getKey();
             VersionedValue value = fromEntry.getValue();
-            assert fromState.getHeartBeatState().getGeneration() == toState.getHeartBeatState().getGeneration();
 
             if ( (toState.applicationState.containsKey(key) && toState.applicationState.get(key).compareTo(value) < 0)
                 || !toState.applicationState.containsKey(key) )

File: src/java/org/apache/cassandra/tools/StandaloneUpgrader.java
Patch:
@@ -107,7 +107,7 @@ public static void main(String args[]) throws IOException
                     Upgrader upgrader = new Upgrader(cfs, sstable, handler);
                     upgrader.upgrade();
 
-                    sstable.markCompacted();
+                    sstable.markObsolete();
                     sstable.releaseReference();
                 }
                 catch (Exception e)

File: src/java/org/apache/cassandra/db/compaction/Upgrader.java
Patch:
@@ -69,14 +69,14 @@ public Upgrader(ColumnFamilyStore cfs, SSTableReader sstable, OutputHandler outp
         this.controller = new UpgradeController(cfs);
 
         this.strategy = cfs.getCompactionStrategy();
-        long estimatedTotalKeys = Math.max(DatabaseDescriptor.getIndexInterval(), SSTableReader.getApproximateKeyCount(toUpgrade));
+        long estimatedTotalKeys = Math.max(cfs.metadata.getIndexInterval(), SSTableReader.getApproximateKeyCount(toUpgrade, cfs.metadata));
         long estimatedSSTables = Math.max(1, SSTable.getTotalBytes(this.toUpgrade) / strategy.getMaxSSTableSize());
         this.estimatedRows = (long) Math.ceil((double) estimatedTotalKeys / estimatedSSTables);
     }
 
     private SSTableWriter createCompactionWriter()
     {
-        SSTableMetadata.Collector sstableMetadataCollector = SSTableMetadata.createCollector();
+        SSTableMetadata.Collector sstableMetadataCollector = SSTableMetadata.createCollector(cfs.getComparator());
 
         // Get the max timestamp of the precompacted sstables
         // and adds generation of live ancestors
@@ -130,7 +130,7 @@ public void upgrade()
             // also remove already completed SSTables
             for (SSTableReader sstable : sstables)
             {
-                sstable.markCompacted();
+                sstable.markObsolete();
                 sstable.releaseReference();
             }
             throw Throwables.propagate(t);

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -363,10 +363,8 @@ public void apply(RowMutation mutation, boolean writeCommitLog)
      */
     public void apply(RowMutation mutation, boolean writeCommitLog, boolean updateIndexes)
     {
-        if (!mutation.getTable().equals(Tracing.TRACE_KS))
-            Tracing.trace("Acquiring switchLock read lock");
-
         // write the mutation to the commitlog and memtables
+        Tracing.trace("Acquiring switchLock read lock");
         switchLock.readLock().lock();
         try
         {

File: test/unit/org/apache/cassandra/db/compaction/LeveledCompactionStrategyTest.java
Patch:
@@ -18,6 +18,7 @@
 package org.apache.cassandra.db.compaction;
 
 import java.nio.ByteBuffer;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.List;
@@ -173,10 +174,11 @@ public void testMutateLevel() throws Exception
             cfs.forceBlockingFlush();
         }
         waitForLeveling(cfs);
+        cfs.forceBlockingFlush();
         LeveledCompactionStrategy strategy = (LeveledCompactionStrategy) cfs.getCompactionStrategy();
         cfs.disableAutoCompaction();
 
-        while(CompactionManager.instance.getActiveCompactions() > 0)
+        while(CompactionManager.instance.isCompacting(Arrays.asList(cfs)))
             Thread.sleep(100);
 
         for (SSTableReader s : cfs.getSSTables())

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -1208,7 +1208,7 @@ Restriction updateRestriction(CFDefinition.Name name, Restriction restriction, R
                     break;
                 case IN:
                     if (restriction != null)
-                        throw new InvalidRequestException(String.format("%s cannot be restricted by more than one reation if it includes a IN", name));
+                        throw new InvalidRequestException(String.format("%s cannot be restricted by more than one relation if it includes a IN", name));
                     restriction = new Restriction(newRel.getInValues());
                     break;
                 case GT:

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -406,7 +406,7 @@ private List<ServerSocket> getServerSocket(InetAddress localEp) throws Configura
             }
             catch (IOException e)
             {
-                throw new ConfigurationException("Unable to create ssl socket");
+                throw new ConfigurationException("Unable to create ssl socket", e);
             }
             // setReuseAddress happens in the factory.
             logger.info("Starting Encrypted Messaging Service on SSL port {}", DatabaseDescriptor.getSSLStoragePort());
@@ -428,7 +428,7 @@ private List<ServerSocket> getServerSocket(InetAddress localEp) throws Configura
         }
         catch (SocketException e)
         {
-            throw new ConfigurationException("Insufficient permissions to setReuseAddress");
+            throw new ConfigurationException("Insufficient permissions to setReuseAddress", e);
         }
         InetSocketAddress address = new InetSocketAddress(localEp, DatabaseDescriptor.getStoragePort());
         try

File: src/java/org/apache/cassandra/cli/CliOptions.java
Patch:
@@ -80,7 +80,7 @@ public class CliOptions
 
         // ssl connection-related options
         options.addOption("ts", SSL_TRUSTSTORE, "TRUSTSTORE", "SSL: full path to truststore");
-        options.addOption("tspw", SSL_TRUSTSTORE_PW, "TRUSTSTORE-PASSWORD", "SSL: full path to truststore");
+        options.addOption("tspw", SSL_TRUSTSTORE_PW, "TRUSTSTORE-PASSWORD", "SSL: password of the truststore");
         options.addOption("prtcl", SSL_PROTOCOL, "PROTOCOL", "SSL: connections protocol to use (default: TLS)");
         options.addOption("alg", SSL_ALGORITHM, "ALGORITHM", "SSL: algorithm (default: SunX509)");
         options.addOption("st", SSL_STORE_TYPE, "STORE-TYPE", "SSL: type of store");

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -665,6 +665,8 @@ public void printNetworkStats(final InetAddress addr, PrintStream outs)
                 outs.printf("   Error retrieving file data for %s%n", host);
             }
         }
+        
+        outs.printf("Read Repair Statistics:%nAttempted: %d%nMismatch (Blocking): %d%nMismatch (Background): %d%n", probe.getReadRepairAttempted(), probe.getReadRepairRepairedBlocking(), probe.getReadRepairRepairedBackground());
 
         MessagingServiceMBean ms = probe.msProxy;
         outs.printf("%-25s", "Pool Name");

File: src/java/org/apache/cassandra/locator/SnitchProperties.java
Patch:
@@ -26,7 +26,7 @@
 
 public class SnitchProperties
 {
-    private static final Logger logger = LoggerFactory.getLogger(GossipingPropertyFileSnitch.class);
+    private static final Logger logger = LoggerFactory.getLogger(SnitchProperties.class);
     public static final String RACKDC_PROPERTY_FILENAME = "cassandra-rackdc.properties";
     private static Properties properties = new Properties();
 

File: src/java/org/apache/cassandra/db/RangeSliceCommand.java
Patch:
@@ -172,7 +172,7 @@ public void serialize(RangeSliceCommand sliceCommand, DataOutput out, int versio
                 ByteBufferUtil.write(sc, out);
         }
 
-        IDiskAtomFilter.Serializer.instance.serialize(sliceCommand.predicate, out, version);
+        IDiskAtomFilter.Serializer.instance.serialize(filter, out, version);
 
         if (sliceCommand.row_filter == null)
         {

File: src/java/org/apache/cassandra/transport/Client.java
Patch:
@@ -41,7 +41,7 @@
 import org.apache.cassandra.transport.messages.PrepareMessage;
 import org.apache.cassandra.transport.messages.QueryMessage;
 import org.apache.cassandra.transport.messages.RegisterMessage;
-import org.apache.cassandra.transport.messages.SaslResponse;
+import org.apache.cassandra.transport.messages.AuthResponse;
 import org.apache.cassandra.transport.messages.StartupMessage;
 import org.apache.cassandra.utils.Hex;
 
@@ -171,7 +171,7 @@ else if (msgType.equals("AUTHENTICATE"))
                 System.err.println("[ERROR] Authentication requires both 'username' and 'password'");
                 return null;
             }
-            return new SaslResponse(encodeCredentialsForSasl(credentials));
+            return new AuthResponse(encodeCredentialsForSasl(credentials));
         }
         else if (msgType.equals("REGISTER"))
         {

File: src/java/org/apache/cassandra/transport/Message.java
Patch:
@@ -71,8 +71,8 @@ public enum Type
         REGISTER       (11, Direction.REQUEST,  RegisterMessage.codec),
         EVENT          (12, Direction.RESPONSE, EventMessage.codec),
         BATCH          (13, Direction.REQUEST,  BatchMessage.codec),
-        AUTH_CHALLENGE (14, Direction.RESPONSE, SaslChallenge.codec),
-        AUTH_RESPONSE  (15, Direction.REQUEST,  SaslResponse.codec),
+        AUTH_CHALLENGE (14, Direction.RESPONSE, AuthChallenge.codec),
+        AUTH_RESPONSE  (15, Direction.REQUEST,  AuthResponse.codec),
         AUTH_SUCCESS   (16, Direction.RESPONSE, AuthSuccess.codec);
 
         public final int opcode;

File: src/java/org/apache/cassandra/transport/ServerConnection.java
Patch:
@@ -76,7 +76,7 @@ public void validateNewMessage(Message.Type type, int version)
                 break;
             case AUTHENTICATION:
                 // Support both SASL auth from protocol v2 and the older style Credentials auth from v1
-                if (type != Message.Type.SASL_RESPONSE && type != Message.Type.CREDENTIALS)
+                if (type != Message.Type.AUTH_RESPONSE && type != Message.Type.CREDENTIALS)
                     throw new ProtocolException(String.format("Unexpected message %s, expecting %s", type, version == 1 ? "CREDENTIALS" : "SASL_RESPONSE"));
                 break;
             case READY:
@@ -103,7 +103,7 @@ else if (responseType == Message.Type.READY)
                 break;
             case AUTHENTICATION:
                 // Support both SASL auth from protocol v2 and the older style Credentials auth from v1
-                assert requestType == Message.Type.SASL_RESPONSE || requestType == Message.Type.CREDENTIALS;
+                assert requestType == Message.Type.AUTH_RESPONSE || requestType == Message.Type.CREDENTIALS;
 
                 if (responseType == Message.Type.READY || responseType == Message.Type.AUTH_SUCCESS)
                 {

File: src/java/org/apache/cassandra/exceptions/AlreadyExistsException.java
Patch:
@@ -31,7 +31,7 @@ private AlreadyExistsException(String ksName, String cfName, String msg)
 
     public AlreadyExistsException(String ksName, String cfName)
     {
-        this(ksName, cfName, String.format("Cannot add already existing column family \"%s\" to keyspace \"%s\"", ksName, cfName));
+        this(ksName, cfName, String.format("Cannot add already existing column family \"%s\" to keyspace \"%s\"", cfName, ksName));
     }
 
     public AlreadyExistsException(String ksName)

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -1344,7 +1344,7 @@ private static void complainNonzeroArgs(String[] args, NodeCommand cmd)
     private static void handleSnapshots(NodeCommand nc, String tag, String[] cmdArgs, String columnFamily, NodeProbe probe) throws InterruptedException, IOException
     {
         String[] keyspaces = Arrays.copyOfRange(cmdArgs, 0, cmdArgs.length);
-        System.out.print("Requested snapshot for: ");
+        System.out.print("Requested " + ((nc == NodeCommand.SNAPSHOT) ? "creating" : "clearing") + " snapshot for: ");
         if ( keyspaces.length > 0 )
         {
           for (int i = 0; i < keyspaces.length; i++)

File: src/java/org/apache/cassandra/service/ReadCallback.java
Patch:
@@ -97,7 +97,7 @@ public boolean await(long timePastStart, TimeUnit unit)
 
     public TResolved get() throws ReadTimeoutException, DigestMismatchException
     {
-        if (!await(command.getTimeout(), TimeUnit.MICROSECONDS))
+        if (!await(command.getTimeout(), TimeUnit.MILLISECONDS))
         {
             ReadTimeoutException ex = new ReadTimeoutException(consistencyLevel, received.get(), blockfor, resolver.isDataPresent());
             if (logger.isDebugEnabled())

File: src/java/org/apache/cassandra/db/BatchlogManager.java
Patch:
@@ -122,8 +122,8 @@ public static RowMutation getBatchlogMutationFor(Collection<RowMutation> mutatio
 
         ColumnFamily cf = ArrayBackedSortedColumns.factory.create(CFMetaData.BatchlogCf);
         cf.addColumn(new Column(columnName(""), ByteBufferUtil.EMPTY_BYTE_BUFFER, timestamp));
-        cf.addColumn(new Column(columnName("written_at"), writtenAt, timestamp));
         cf.addColumn(new Column(columnName("data"), data, timestamp));
+        cf.addColumn(new Column(columnName("written_at"), writtenAt, timestamp));
 
         return new RowMutation(Table.SYSTEM_KS, UUIDType.instance.decompose(uuid), cf);
     }

File: src/java/org/apache/cassandra/db/commitlog/CommitLogReplayer.java
Patch:
@@ -80,7 +80,8 @@ public CommitLogReplayer()
             ReplayPosition rp = ReplayPosition.getReplayPosition(cfs.getSSTables());
 
             // but, if we've truncted the cf in question, then we need to need to start replay after the truncation
-            ReplayPosition truncatedAt = truncationPositions.get(cfs.metadata.cfId).left;
+            Pair<ReplayPosition, Long> truncateRecord = truncationPositions.get(cfs.metadata.cfId);
+            ReplayPosition truncatedAt = truncateRecord == null ? null : truncateRecord.left;
             if (truncatedAt != null)
                 rp = replayPositionOrdering.max(Arrays.asList(rp, truncatedAt));
 

File: src/java/org/apache/cassandra/db/SystemTable.java
Patch:
@@ -193,7 +193,7 @@ public static void saveTruncationRecord(ColumnFamilyStore cfs, long truncatedAt,
      */
     public static void removeTruncationRecord(UUID cfId)
     {
-        String req = "DELETE truncation_time['%s'] from system.%s WHERE key = '%s'";
+        String req = "DELETE truncated_at['%s'] from system.%s WHERE key = '%s'";
         processInternal(String.format(req, cfId, LOCAL_CF, LOCAL_KEY));
         forceBlockingFlush(LOCAL_CF);
     }

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -40,8 +40,6 @@
  */
 public abstract class ModificationStatement extends CFStatement implements CQLStatement
 {
-    public static final ConsistencyLevel defaultConsistency = ConsistencyLevel.ONE;
-
     public static enum Type
     {
         LOGGED, UNLOGGED, COUNTER

File: src/java/org/apache/cassandra/db/commitlog/BatchCommitLogExecutorService.java
Patch:
@@ -76,15 +76,16 @@ private boolean processWithSyncBatch() throws Exception
         //  so we have to break it into firstTask / extra tasks)
         incompleteTasks.clear();
         taskValues.clear();
-        long end = System.nanoTime() + (long)(1000000 * DatabaseDescriptor.getCommitLogSyncBatchWindow());
+        long start = System.nanoTime();
+        long window = (long)(1000000 * DatabaseDescriptor.getCommitLogSyncBatchWindow());
 
         // it doesn't seem worth bothering future-izing the exception
         // since if a commitlog op throws, we're probably screwed anyway
         incompleteTasks.add(firstTask);
         taskValues.add(firstTask.getRawCallable().call());
         while (!queue.isEmpty()
                && queue.peek().getRawCallable() instanceof CommitLog.LogRecordAdder
-               && System.nanoTime() < end)
+               && System.nanoTime() - start < window)
         {
             CheaterFutureTask task = queue.remove();
             incompleteTasks.add(task);

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -77,7 +77,9 @@ public class Config
     public Integer rpc_send_buff_size_in_bytes;
     public Integer rpc_recv_buff_size_in_bytes;
 
+    @Deprecated
     public Integer thrift_max_message_length_in_mb = 16;
+
     public Integer thrift_framed_transport_size_in_mb = 15;
     public Boolean snapshot_before_compaction = false;
     public Boolean auto_snapshot = true;

File: src/java/org/apache/cassandra/hadoop/ColumnFamilyOutputFormat.java
Patch:
@@ -118,7 +118,7 @@ public void checkOutputSpecs(org.apache.hadoop.fs.FileSystem filesystem, org.apa
     }
 
     /** Fills the deprecated OutputFormat interface for streaming. */
-    @Deprecated @Override
+    @Deprecated
     public ColumnFamilyRecordWriter getRecordWriter(org.apache.hadoop.fs.FileSystem filesystem, org.apache.hadoop.mapred.JobConf job, String name, org.apache.hadoop.util.Progressable progress) throws IOException
     {
         return new ColumnFamilyRecordWriter(job, new Progressable(progress));
@@ -155,7 +155,7 @@ public static Cassandra.Client createAuthenticatedClient(TSocket socket, Configu
     {
         logger.debug("Creating authenticated client for CF output format");
         TTransport transport = ConfigHelper.getOutputTransportFactory(conf).openTransport(socket, conf);
-        TBinaryProtocol binaryProtocol = new TBinaryProtocol(transport, ConfigHelper.getThriftMaxMessageLength(conf));
+        TBinaryProtocol binaryProtocol = new TBinaryProtocol(transport, true, true);
         Cassandra.Client client = new Cassandra.Client(binaryProtocol);
         client.set_keyspace(ConfigHelper.getOutputKeyspace(conf));
         if (ConfigHelper.getOutputKeyspaceUserName(conf) != null)

File: src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
Patch:
@@ -162,7 +162,7 @@ public void initialize(InputSplit split, TaskAttemptContext context) throws IOEx
             String location = getLocation();
             socket = new TSocket(location, ConfigHelper.getInputRpcPort(conf));
             TTransport transport = ConfigHelper.getInputTransportFactory(conf).openTransport(socket, conf);
-            TBinaryProtocol binaryProtocol = new TBinaryProtocol(transport, ConfigHelper.getThriftMaxMessageLength(conf));
+            TBinaryProtocol binaryProtocol = new TBinaryProtocol(transport, true, true);
             client = new Cassandra.Client(binaryProtocol);
 
             // log in

File: src/java/org/apache/cassandra/thrift/CassandraDaemon.java
Patch:
@@ -125,7 +125,7 @@ public ThriftServer(InetAddress listenAddr, int listenPort)
             logger.info(String.format("Binding thrift service to %s:%s", listenAddr, listenPort));
 
             // Protocol factory
-            TProtocolFactory tProtocolFactory = new TBinaryProtocol.Factory(true, true, DatabaseDescriptor.getThriftMaxMessageLength());
+            TProtocolFactory tProtocolFactory = new TBinaryProtocol.Factory(true, true);
 
             // Transport factory
             int tFramedTransportSize = DatabaseDescriptor.getThriftFramedTransportSize();

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -77,7 +77,9 @@ public class Config
     public Integer rpc_send_buff_size_in_bytes;
     public Integer rpc_recv_buff_size_in_bytes;
 
+    @Deprecated
     public Integer thrift_max_message_length_in_mb = 16;
+
     public Integer thrift_framed_transport_size_in_mb = 15;
     public Boolean snapshot_before_compaction = false;
     public Boolean auto_snapshot = true;

File: src/java/org/apache/cassandra/hadoop/ColumnFamilyOutputFormat.java
Patch:
@@ -118,7 +118,7 @@ public void checkOutputSpecs(org.apache.hadoop.fs.FileSystem filesystem, org.apa
     }
 
     /** Fills the deprecated OutputFormat interface for streaming. */
-    @Deprecated @Override
+    @Deprecated
     public ColumnFamilyRecordWriter getRecordWriter(org.apache.hadoop.fs.FileSystem filesystem, org.apache.hadoop.mapred.JobConf job, String name, org.apache.hadoop.util.Progressable progress) throws IOException
     {
         return new ColumnFamilyRecordWriter(job, new Progressable(progress));
@@ -155,7 +155,7 @@ public static Cassandra.Client createAuthenticatedClient(TSocket socket, Configu
     {
         logger.debug("Creating authenticated client for CF output format");
         TTransport transport = ConfigHelper.getOutputTransportFactory(conf).openTransport(socket, conf);
-        TBinaryProtocol binaryProtocol = new TBinaryProtocol(transport, ConfigHelper.getThriftMaxMessageLength(conf));
+        TBinaryProtocol binaryProtocol = new TBinaryProtocol(transport, true, true);
         Cassandra.Client client = new Cassandra.Client(binaryProtocol);
         client.set_keyspace(ConfigHelper.getOutputKeyspace(conf));
         if (ConfigHelper.getOutputKeyspaceUserName(conf) != null)

File: src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
Patch:
@@ -162,7 +162,7 @@ public void initialize(InputSplit split, TaskAttemptContext context) throws IOEx
             String location = getLocation();
             socket = new TSocket(location, ConfigHelper.getInputRpcPort(conf));
             TTransport transport = ConfigHelper.getInputTransportFactory(conf).openTransport(socket, conf);
-            TBinaryProtocol binaryProtocol = new TBinaryProtocol(transport, ConfigHelper.getThriftMaxMessageLength(conf));
+            TBinaryProtocol binaryProtocol = new TBinaryProtocol(transport, true, true);
             client = new Cassandra.Client(binaryProtocol);
 
             // log in

File: src/java/org/apache/cassandra/thrift/CassandraDaemon.java
Patch:
@@ -125,7 +125,7 @@ public ThriftServer(InetAddress listenAddr, int listenPort)
             logger.info(String.format("Binding thrift service to %s:%s", listenAddr, listenPort));
 
             // Protocol factory
-            TProtocolFactory tProtocolFactory = new TBinaryProtocol.Factory(true, true, DatabaseDescriptor.getThriftMaxMessageLength());
+            TProtocolFactory tProtocolFactory = new TBinaryProtocol.Factory(true, true);
 
             // Transport factory
             int tFramedTransportSize = DatabaseDescriptor.getThriftFramedTransportSize();

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -476,7 +476,7 @@ public ModificationStatement prepare(ColumnSpecification[] boundNames) throws In
 
             ModificationStatement stmt = prepareInternal(cfDef, boundNames);
 
-            if (stmt.hasConditions())
+            if (ifNotExists || (conditions != null && !conditions.isEmpty()))
             {
                 if (stmt.isCounter())
                     throw new InvalidRequestException("Conditional updates are not supported on counter tables");

File: src/java/org/apache/cassandra/cache/RowCacheSentinel.java
Patch:
@@ -19,6 +19,7 @@
 
 import java.util.concurrent.atomic.AtomicLong;
 
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.utils.ObjectSizes;
 
 import com.google.common.base.Objects;
@@ -60,6 +61,6 @@ public int hashCode()
     public long memorySize()
     {
         // Only long reference.
-        return ObjectSizes.getFieldSize(8);
+        return ObjectSizes.getFieldSize(TypeSizes.NATIVE.sizeof(sentinelId));
     }
 }

File: src/java/org/apache/cassandra/dht/Range.java
Patch:
@@ -136,7 +136,7 @@ public boolean intersects(AbstractBounds<T> that)
      */
     public boolean intersects(Bounds<T> that)
     {
-        return intersects(new Range<T>(that.left, that.right)) || contains(that.right);
+        return intersects(new Range<T>(that.left, that.right)) || contains(that.left);
     }
 
     public static <T extends RingPosition> Set<Range<T>> rangeSet(Range<T> ... ranges)

File: src/java/org/apache/cassandra/db/compaction/LazilyCompactedRow.java
Patch:
@@ -256,7 +256,7 @@ public void reduce(OnDiskAtom current)
                 container.addColumn(column);
                 if (indexer != SecondaryIndexManager.nullUpdater
                     && !column.isMarkedForDelete()
-                    && container.getColumn(column.name()) != column)
+                    && !container.getColumn(column.name()).equals(column))
                 {
                     indexer.remove(column);
                 }

File: src/java/org/apache/cassandra/db/compaction/PrecompactedRow.java
Patch:
@@ -141,7 +141,7 @@ public void reduce(IColumn column)
                 container.addColumn(column);
                 if (indexer != SecondaryIndexManager.nullUpdater
                     && !column.isMarkedForDelete()
-                    && container.getColumn(column.name()) != column)
+                    && !container.getColumn(column.name()).equals(column))
                 {
                     indexer.remove(column);
                 }

File: src/java/org/apache/cassandra/net/OutboundTcpConnectionPool.java
Patch:
@@ -132,6 +132,8 @@ public Socket newSocket() throws IOException
 
     InetAddress endPoint()
     {
+        if (id.equals(FBUtilities.getBroadcastAddress()))
+            return FBUtilities.getLocalAddress();
         return resetedEndpoint == null ? id : resetedEndpoint;
     }
 

File: test/unit/org/apache/cassandra/locator/DynamicEndpointSnitchTest.java
Patch:
@@ -41,7 +41,7 @@ public void testSnitch() throws InterruptedException, IOException, Configuration
         DynamicEndpointSnitch dsnitch = new DynamicEndpointSnitch(ss, String.valueOf(ss.hashCode()));
         InetAddress self = FBUtilities.getBroadcastAddress();
         ArrayList<InetAddress> order = new ArrayList<InetAddress>();
-        InetAddress host1 = InetAddress.getByName("127.0.0.1");
+        InetAddress host1 = InetAddress.getByName("127.0.0.4");
         InetAddress host2 = InetAddress.getByName("127.0.0.2");
         InetAddress host3 = InetAddress.getByName("127.0.0.3");
 

File: test/unit/org/apache/cassandra/service/AntiEntropyServiceTestAbstract.java
Patch:
@@ -43,6 +43,8 @@
 import org.apache.cassandra.locator.AbstractReplicationStrategy;
 import org.apache.cassandra.locator.TokenMetadata;
 import static org.apache.cassandra.service.AntiEntropyService.*;
+
+import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.MerkleTree;
@@ -100,6 +102,7 @@ public void prepare() throws Exception
         tmd.updateNormalToken(StorageService.getPartitioner().getMinimumToken(), REMOTE);
         assert tmd.isMember(REMOTE);
 
+        MessagingService.instance().setVersion(REMOTE, MessagingService.current_version);
         Gossiper.instance.initializeNodeUnsafe(REMOTE, UUID.randomUUID(), 1);
 
         local_range = StorageService.instance.getPrimaryRangesForEndpoint(tablename, LOCAL).iterator().next();

File: src/java/org/apache/cassandra/cql3/ColumnNameBuilder.java
Patch:
@@ -34,7 +34,7 @@ public interface ColumnNameBuilder
 
     /**
      * Add a new ByteBuffer as the next component for this name.
-     * @param bb the ByteBuffer to add
+     * @param t the ByteBuffer to add
      * @param op the relationship this component should respect.
      * @throws IllegalStateException if the builder if full, i.e. if enough component has been added.
      * @return this builder

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1778,8 +1778,6 @@ public void clearUnsafe()
 
     /**
      * Truncate deletes the entire column family's data with no expensive tombstone creation
-     * @return a Future to the delete operation. Call the future's get() to make
-     * sure the column family has been deleted
      */
     public void truncateBlocking()
     {

File: src/java/org/apache/cassandra/hadoop/ConfigHelper.java
Patch:
@@ -496,7 +496,7 @@ public static void setThriftFramedTransportSizeInMb(Configuration conf, int fram
 
     /**
      * @param conf The configuration to use.
-     * @return Value (converts MBs to Bytes) set by {@link setThriftFramedTransportSizeInMb(Configuration, int)} or default of 15MB
+     * @return Value (converts MBs to Bytes) set by {@link #setThriftFramedTransportSizeInMb(Configuration, int)} or default of 15MB
      */
     public static int getThriftFramedTransportSize(Configuration conf)
     {
@@ -510,7 +510,7 @@ public static void setThriftMaxMessageLengthInMb(Configuration conf, int maxMess
 
     /**
      * @param conf The configuration to use.
-     * @return Value (converts MBs to Bytes) set by {@link setThriftMaxMessageLengthInMb(Configuration, int)} or default of 16MB
+     * @return Value (converts MBs to Bytes) set by {@link #setThriftMaxMessageLengthInMb(Configuration, int)} or default of 16MB
      */
     public static int getThriftMaxMessageLength(Configuration conf)
     {

File: src/java/org/apache/cassandra/db/compaction/AbstractCompactionStrategy.java
Patch:
@@ -19,6 +19,7 @@
 
 import java.util.*;
 
+import com.google.common.util.concurrent.RateLimiter;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -150,9 +151,10 @@ public static List<SSTableReader> filterSuspectSSTables(Collection<SSTableReader
      */
     public List<ICompactionScanner> getScanners(Collection<SSTableReader> sstables, Range<Token> range)
     {
+        RateLimiter limiter = CompactionManager.instance.getRateLimiter();
         ArrayList<ICompactionScanner> scanners = new ArrayList<ICompactionScanner>();
         for (SSTableReader sstable : sstables)
-            scanners.add(sstable.getDirectScanner(range));
+            scanners.add(sstable.getDirectScanner(range, limiter));
         return scanners;
     }
 

File: src/java/org/apache/cassandra/io/compress/CompressedRandomAccessReader.java
Patch:
@@ -70,7 +70,7 @@ public static CompressedRandomAccessReader open(String dataFilePath, Compression
     // raw checksum bytes
     private final ByteBuffer checksumBytes = ByteBuffer.wrap(new byte[4]);
 
-    private CompressedRandomAccessReader(String dataFilePath, CompressionMetadata metadata, boolean skipIOCache, PoolingSegmentedFile owner) throws FileNotFoundException
+    protected CompressedRandomAccessReader(String dataFilePath, CompressionMetadata metadata, boolean skipIOCache, PoolingSegmentedFile owner) throws FileNotFoundException
     {
         super(new File(dataFilePath), metadata.chunkLength(), skipIOCache, owner);
         this.metadata = metadata;

File: src/java/org/apache/cassandra/tools/SSTableExport.java
Patch:
@@ -32,6 +32,7 @@
 import java.util.List;
 import java.util.Set;
 
+import com.google.common.util.concurrent.RateLimiter;
 import org.apache.commons.cli.CommandLine;
 import org.apache.commons.cli.CommandLineParser;
 import org.apache.commons.cli.Option;
@@ -349,7 +350,7 @@ public static void enumeratekeys(Descriptor desc, PrintStream outs)
     public static void export(Descriptor desc, PrintStream outs, Collection<String> toExport, String[] excludes) throws IOException
     {
         SSTableReader reader = SSTableReader.open(desc);
-        SSTableScanner scanner = reader.getDirectScanner();
+        SSTableScanner scanner = reader.getDirectScanner(null);
 
         IPartitioner<?> partitioner = reader.partitioner;
 
@@ -406,7 +407,7 @@ static void export(SSTableReader reader, PrintStream outs, String[] excludes) th
 
 
         SSTableIdentityIterator row;
-        SSTableScanner scanner = reader.getDirectScanner();
+        SSTableScanner scanner = reader.getDirectScanner(null);
 
         outs.println("[");
 

File: test/unit/org/apache/cassandra/io/sstable/SSTableUtils.java
Patch:
@@ -72,8 +72,8 @@ public static File tempSSTableFile(String tablename, String cfname, int generati
 
     public static void assertContentEquals(SSTableReader lhs, SSTableReader rhs) throws IOException
     {
-        SSTableScanner slhs = lhs.getDirectScanner();
-        SSTableScanner srhs = rhs.getDirectScanner();
+        SSTableScanner slhs = lhs.getDirectScanner(null);
+        SSTableScanner srhs = rhs.getDirectScanner(null);
         while (slhs.hasNext())
         {
             OnDiskAtomIterator ilhs = slhs.next();

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -197,7 +197,7 @@ public void apply(IMutation mutation,
      * @return true if the operation succeeds in updating the row
      */
     public static boolean cas(String table, String cfName, ByteBuffer key, ColumnFamily expected, ColumnFamily updates)
-    throws UnavailableException, IOException, IsBootstrappingException, ReadTimeoutException, WriteTimeoutException, InvalidRequestException
+    throws UnavailableException, IsBootstrappingException, ReadTimeoutException, WriteTimeoutException, InvalidRequestException
     {
         CFMetaData metadata = Schema.instance.getCFMetaData(table, cfName);
 

File: src/java/org/apache/cassandra/io/sstable/SSTableReader.java
Patch:
@@ -400,14 +400,14 @@ private void load(boolean recreateBloomFilter) throws IOException
                 // if summary was already read from disk we don't want to re-populate it using primary index
                 if (!summaryLoaded)
                 {
-                    summaryBuilder.maybeAddEntry(decoratedKey, indexPosition);
+                    summaryBuilder.maybeAddEntry(decoratedKey, metadata.getIndexInterval(), indexPosition);
                     ibuilder.addPotentialBoundary(indexPosition);
                     dbuilder.addPotentialBoundary(indexEntry.position);
                 }
             }
 
             if (!summaryLoaded)
-                indexSummary = summaryBuilder.build(partitioner);
+                indexSummary = summaryBuilder.build(partitioner, metadata.getIndexInterval());
         }
         finally
         {

File: src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
Patch:
@@ -339,7 +339,7 @@ public SSTableReader closeAndOpenReader(long maxDataAge)
                                                            partitioner,
                                                            ifile,
                                                            dfile,
-                                                           iwriter.summary.build(partitioner),
+                                                           iwriter.summary.build(partitioner, metadata.getIndexInterval()),
                                                            iwriter.bf,
                                                            maxDataAge,
                                                            sstableMetadata);
@@ -434,7 +434,7 @@ public void append(DecoratedKey key, RowIndexEntry indexEntry)
             if (logger.isTraceEnabled())
                 logger.trace("wrote index entry: " + indexEntry + " at " + indexPosition);
 
-            summary.maybeAddEntry(key, indexPosition);
+            summary.maybeAddEntry(key, metadata.getIndexInterval(), indexPosition);
             builder.addPotentialBoundary(indexPosition);
         }
 

File: src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
Patch:
@@ -461,7 +461,7 @@ protected Pair<ByteBuffer, SortedMap<ByteBuffer, IColumn>> computeNext()
                 return endOfData();
 
             Pair<ByteBuffer, SortedMap<ByteBuffer, IColumn>> next = wideColumns.next();
-            lastColumn = next.right.values().iterator().next().name();
+            lastColumn = next.right.values().iterator().next().name().duplicate();
 
             maybeIncreaseRowCounter(next);
             return next;
@@ -534,7 +534,7 @@ public boolean next(ByteBuffer key, SortedMap<ByteBuffer, IColumn> value) throws
         if (this.nextKeyValue())
         {
             key.clear();
-            key.put(this.getCurrentKey());
+            key.put(this.getCurrentKey().duplicate());
             key.flip();
 
             value.clear();

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -191,6 +191,7 @@ public enum Verb
         put(Verb.INDEX_SCAN, IndexScanCommand.serializer);
         put(Verb.REPLICATION_FINISHED, null);
         put(Verb.COUNTER_MUTATION, CounterMutation.serializer);
+        put(Verb.SNAPSHOT, SnapshotCommand.serializer);
     }};
 
     /**

File: src/java/org/apache/cassandra/db/columniterator/SSTableNamesIterator.java
Patch:
@@ -188,7 +188,7 @@ private void readSimpleColumns(FileDataInput file, SortedSet<ByteBuffer> columnN
                 if (columnNames.contains(column.name()))
                 {
                     result.add(column);
-                    if (++n > columns.size())
+                    if (++n >= columns.size())
                         break;
                 }
             }

File: src/java/org/apache/cassandra/tracing/Tracing.java
Patch:
@@ -214,9 +214,9 @@ public void runMayThrow() throws Exception
                 CFMetaData cfMeta = CFMetaData.TraceSessionsCf;
                 ColumnFamily cf = ArrayBackedSortedColumns.factory.create(cfMeta);
                 addColumn(cf, buildName(cfMeta, bytes("coordinator")), FBUtilities.getBroadcastAddress());
+                addParameterColumns(cf, parameters);
                 addColumn(cf, buildName(cfMeta, bytes("request")), request);
                 addColumn(cf, buildName(cfMeta, bytes("started_at")), started_at);
-                addParameterColumns(cf, parameters);
                 RowMutation mutation = new RowMutation(TRACE_KS, sessionIdBytes, cf);
                 StorageProxy.mutate(Arrays.asList(mutation), ConsistencyLevel.ANY);
             }

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -3835,7 +3835,7 @@ public List<String> sampleKeyRange() // do not rename to getter - see CASSANDRA-
         List<DecoratedKey> keys = new ArrayList<DecoratedKey>();
         for (Table keyspace : Table.nonSystem())
         {
-            for (Range<Token> range : getPrimaryRangesForEndpoint(keyspace.name, FBUtilities.getBroadcastAddress()))
+            for (Range<Token> range : getPrimaryRangesForEndpoint(keyspace.getName(), FBUtilities.getBroadcastAddress()))
                 keys.addAll(keySamples(keyspace.getColumnFamilyStores(), range));
         }
 

File: src/java/org/apache/cassandra/locator/NetworkTopologyStrategy.java
Patch:
@@ -78,7 +78,8 @@ public NetworkTopologyStrategy(String table, TokenMetadata tokenMetadata, IEndpo
     @SuppressWarnings("serial")
     public List<InetAddress> calculateNaturalEndpoints(Token searchToken, TokenMetadata tokenMetadata)
     {
-        Set<InetAddress> replicas = new HashSet<InetAddress>();
+        // we want to preserve insertion order so that the first added endpoint becomes primary
+        Set<InetAddress> replicas = new LinkedHashSet<InetAddress>();
         // replicas we have found in each DC
         Map<String, Set<InetAddress>> dcReplicas = new HashMap<String, Set<InetAddress>>(datacenters.size())
         {{

File: test/unit/org/apache/cassandra/service/AntiEntropyServiceTestAbstract.java
Patch:
@@ -102,7 +102,7 @@ public void prepare() throws Exception
 
         Gossiper.instance.initializeNodeUnsafe(REMOTE, UUID.randomUUID(), 1);
 
-        local_range = StorageService.instance.getLocalPrimaryRange();
+        local_range = StorageService.instance.getPrimaryRangesForEndpoint(tablename, LOCAL).iterator().next();
 
         // (we use REMOTE instead of LOCAL so that the reponses for the validator.complete() get lost)
         request = new TreeRequest(UUID.randomUUID().toString(), REMOTE, local_range, new CFPair(tablename, cfname));

File: test/unit/org/apache/cassandra/cache/ObjectSizeTest.java
Patch:
@@ -6,6 +6,7 @@
 import org.junit.Test;
 
 import junit.framework.Assert;
+import org.apache.cassandra.db.ColumnIndex;
 import org.apache.cassandra.db.DeletionTime;
 import org.apache.cassandra.db.RowIndexEntry;
 import org.apache.cassandra.utils.ObjectSizes;
@@ -56,7 +57,7 @@ public void testKeyCacheValue()
     @Test
     public void testKeyCacheValueWithDelInfo()
     {
-        RowIndexEntry entry = RowIndexEntry.create(123, new DeletionTime(123, 123), null);
+        RowIndexEntry entry = RowIndexEntry.create(123, new DeletionTime(123, 123), ColumnIndex.nothing());
         long size = entry.memorySize();
         long size2 = meter.measureDeep(entry);
         Assert.assertEquals(size, size2);

File: src/java/org/apache/cassandra/db/DeletionTime.java
Patch:
@@ -35,7 +35,7 @@ public class DeletionTime implements Comparable<DeletionTime>
 
     public static final ISerializer<DeletionTime> serializer = new Serializer();
 
-    DeletionTime(long markedForDeleteAt, int localDeletionTime)
+    public DeletionTime(long markedForDeleteAt, int localDeletionTime)
     {
         this.markedForDeleteAt = markedForDeleteAt;
         this.localDeletionTime = localDeletionTime;

File: src/java/org/apache/cassandra/db/RowIndexEntry.java
Patch:
@@ -206,7 +206,7 @@ public long memorySize()
             for (IndexHelper.IndexInfo idx : columnsIndex)
                 internal += idx.memorySize();
             long listSize = ObjectSizes.getFieldSize(ObjectSizes.getArraySize(columnsIndex.size(), internal) + 4);
-            return ObjectSizes.getFieldSize(deletionInfo.memorySize() + listSize);
+            return ObjectSizes.getFieldSize(deletion.memorySize() + listSize);
         }
     }
 }

File: src/java/org/apache/cassandra/utils/SemanticVersion.java
Patch:
@@ -143,7 +143,7 @@ public SemanticVersion findSupportingVersion(SemanticVersion... versions)
 
     public boolean isSupportedBy(SemanticVersion version)
     {
-        return major == version.major && minor <= version.minor && patch <= version.patch;
+        return major == version.major && this.compareTo(version) <= 0;
     }
 
     private static int compareIdentifiers(String[] ids1, String[] ids2, int defaultPred)

File: src/java/org/apache/cassandra/cql3/statements/CreateColumnFamilyStatement.java
Patch:
@@ -258,7 +258,7 @@ private AbstractType<?> getTypeAndRemove(Map<ColumnIdentifier, AbstractType> col
         {
             AbstractType type = columns.get(t);
             if (type == null)
-                throw new InvalidRequestException(String.format("Unkown definition %s referenced in PRIMARY KEY", t));
+                throw new InvalidRequestException(String.format("Unknown definition %s referenced in PRIMARY KEY", t));
             columns.remove(t);
             Boolean isReversed = definedOrdering.get(t);
             return isReversed != null && isReversed ? ReversedType.getInstance(type) : type;

File: src/java/org/apache/cassandra/cql3/QueryProcessor.java
Patch:
@@ -205,7 +205,7 @@ public static ResultMessage.Prepared prepare(String queryString, ClientState cli
         logger.trace("CQL QUERY: {}", queryString);
 
         ParsedStatement.Prepared prepared = getStatement(queryString, clientState);
-        ResultMessage.Prepared msg = storePreparedStatement(queryString, clientState.getKeyspace(), prepared, forThrift);
+        ResultMessage.Prepared msg = storePreparedStatement(queryString, clientState.getRawKeyspace(), prepared, forThrift);
 
         assert prepared.statement.getBoundsTerms() == prepared.boundNames.size();
         return msg;

File: src/java/org/apache/cassandra/db/compaction/OperationType.java
Patch:
@@ -31,7 +31,7 @@ public enum OperationType
     SCRUB("Scrub"),
     UPGRADE_SSTABLES("Upgrade sstables"),
     INDEX_BUILD("Secondary index build"),
-    UNKNOWN("Unkown compaction type");
+    UNKNOWN("Unknown compaction type");
 
     private final String type;
 

File: src/java/org/apache/cassandra/db/compaction/LeveledCompactionStrategy.java
Patch:
@@ -44,8 +44,6 @@ public class LeveledCompactionStrategy extends AbstractCompactionStrategy implem
     private static final Logger logger = LoggerFactory.getLogger(LeveledCompactionStrategy.class);
     private static final String SSTABLE_SIZE_OPTION = "sstable_size_in_mb";
 
-    private static final String SSTABLE_SIZE_OPTION = "sstable_size_in_mb";
-
     @VisibleForTesting
     final LeveledManifest manifest;
     private final int maxSSTableSizeInMB;

File: test/unit/org/apache/cassandra/AbstractSerializationsTester.java
Patch:
@@ -44,7 +44,6 @@ public class AbstractSerializationsTester extends SchemaLoader
         put("2.0", MessagingService.VERSION_20);
     }};
 
-    // TODO ant doesn't pass this -D up to the test, so it's kind of useless
     protected static final boolean EXECUTE_WRITES = Boolean.getBoolean("cassandra.test-serialization-writes");
 
     protected final int getVersion()

File: src/java/org/apache/cassandra/db/ColumnIndex.java
Patch:
@@ -58,7 +58,6 @@ public static class Builder
 
         public Builder(ColumnFamily cf,
                        ByteBuffer key,
-                       DataOutput output)
                        DataOutput output,
                        boolean fromStream)
         {

File: test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java
Patch:
@@ -146,8 +146,8 @@ public void testTransferRangeTombstones() throws Exception
         String key = "key1";
         RowMutation rm = new RowMutation(ks, ByteBufferUtil.bytes(key));
         // add columns of size slightly less than column_index_size to force insert column index
-        rm.add(new QueryPath(cfname, null, ByteBufferUtil.bytes(1)), ByteBuffer.wrap(new byte[DatabaseDescriptor.getColumnIndexSize() - 64]), 2);
-        rm.add(new QueryPath(cfname, null, ByteBufferUtil.bytes(6)), ByteBuffer.wrap(new byte[DatabaseDescriptor.getColumnIndexSize()]), 2);
+        rm.add(cfname, ByteBufferUtil.bytes(1), ByteBuffer.wrap(new byte[DatabaseDescriptor.getColumnIndexSize() - 64]), 2);
+        rm.add(cfname, ByteBufferUtil.bytes(6), ByteBuffer.wrap(new byte[DatabaseDescriptor.getColumnIndexSize()]), 2);
         ColumnFamily cf = rm.addOrGet(cfname);
         // add RangeTombstones
         cf.delete(new DeletionInfo(ByteBufferUtil.bytes(2), ByteBufferUtil.bytes(3), cf.getComparator(), 1, (int) (System.currentTimeMillis() / 1000)));

File: src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
Patch:
@@ -240,7 +240,7 @@ public long appendFromStream(DecoratedKey key, CFMetaData metadata, long dataSiz
         ColumnFamily cf = ColumnFamily.create(metadata, ArrayBackedSortedColumns.factory());
         cf.delete(deletionInfo);
 
-        ColumnIndex.Builder columnIndexer = new ColumnIndex.Builder(cf, key.key, columnCount, dataFile.stream);
+        ColumnIndex.Builder columnIndexer = new ColumnIndex.Builder(cf, key.key, columnCount, dataFile.stream, true);
         OnDiskAtom.Serializer atomSerializer = cf.getOnDiskSerializer();
         for (int i = 0; i < columnCount; i++)
         {

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -256,6 +256,7 @@ public StorageService()
         MessagingService.instance().registerVerbHandlers(MessagingService.Verb.MIGRATION_REQUEST, new MigrationRequestVerbHandler());
 
         MessagingService.instance().registerVerbHandlers(MessagingService.Verb.SNAPSHOT, new SnapshotVerbHandler());
+        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.ECHO, new EchoVerbHandler());
 
         // spin up the streaming service so it is available for jmx tools.
         if (StreamingService.instance == null)

File: test/unit/org/apache/cassandra/io/CompactSerializerTest.java
Patch:
@@ -83,6 +83,7 @@ public static void scanClasspath()
         expectedClassNames.add("ColumnFamilySerializer");
         expectedClassNames.add("CompressionInfoSerializer");
         expectedClassNames.add("ChunkSerializer");
+        expectedClassNames.add("EchoMessageSerializer");
 
         discoveredClassNames = new ArrayList<String>();
         String cp = System.getProperty("java.class.path");

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -457,7 +457,8 @@ public void initRowCache()
             ColumnFamily data = getTopLevelColumns(QueryFilter.getIdentityFilter(key, new QueryPath(columnFamily)),
                                                    Integer.MIN_VALUE,
                                                    true);
-            CacheService.instance.rowCache.put(new RowCacheKey(metadata.cfId, key), data);
+            if (data != null)
+                CacheService.instance.rowCache.put(new RowCacheKey(metadata.cfId, key), data);
             cachedRowsRead++;
         }
 

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -44,6 +44,7 @@
 import org.apache.cassandra.io.FSError;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.thrift.ThriftServer;
+import org.apache.cassandra.tracing.Tracing;
 import org.apache.cassandra.utils.CLibrary;
 import org.apache.cassandra.utils.Mx4jTool;
 import org.apache.cassandra.utils.Pair;
@@ -176,6 +177,7 @@ public void uncaughtException(Thread t, Throwable e)
             {
                 exceptions.incrementAndGet();
                 logger.error("Exception in thread " + t, e);
+                Tracing.trace("Exception in thread " + t, e);
                 for (Throwable e2 = e; e2 != null; e2 = e2.getCause())
                 {
                     // some code, like FileChannel.map, will wrap an OutOfMemoryError in another exception

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -41,6 +41,7 @@
 import org.apache.cassandra.io.FSError;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.thrift.ThriftServer;
+import org.apache.cassandra.tracing.Tracing;
 import org.apache.cassandra.utils.CLibrary;
 import org.apache.cassandra.utils.Mx4jTool;
 
@@ -172,6 +173,7 @@ public void uncaughtException(Thread t, Throwable e)
             {
                 exceptions.incrementAndGet();
                 logger.error("Exception in thread " + t, e);
+                Tracing.trace("Exception in thread " + t, e);
                 for (Throwable e2 = e; e2 != null; e2 = e2.getCause())
                 {
                     // some code, like FileChannel.map, will wrap an OutOfMemoryError in another exception

File: src/java/org/apache/cassandra/db/compaction/CompactionTask.java
Patch:
@@ -41,11 +41,11 @@ public class CompactionTask extends AbstractCompactionTask
     private Set<SSTableReader> toCompact;
     private CompactionExecutorStatsCollector collector;
 
-    public CompactionTask(ColumnFamilyStore cfs, Collection<SSTableReader> sstables, final int gcBefore)
+    public CompactionTask(ColumnFamilyStore cfs, Iterable<SSTableReader> sstables, final int gcBefore)
     {
         super(cfs, sstables);
         this.gcBefore = gcBefore;
-        toCompact = new HashSet<SSTableReader>(sstables);
+        toCompact = Sets.newHashSet(sstables);
     }
 
     public static synchronized long addToTotalBytesCompacted(long bytesCompacted)

File: src/java/org/apache/cassandra/db/compaction/SizeTieredCompactionStrategy.java
Patch:
@@ -152,7 +152,7 @@ public synchronized AbstractCompactionTask getNextBackgroundTask(int gcBefore)
 
     public AbstractCompactionTask getMaximalTask(final int gcBefore)
     {
-        Collection<SSTableReader> sstables = cfs.markAllCompacting();
+        Iterable<SSTableReader> sstables = cfs.markAllCompacting();
         if (sstables == null)
             return null;
 

File: src/java/org/apache/cassandra/tools/Shuffle.java
Patch:
@@ -596,7 +596,7 @@ private static void printShuffleHelp()
         sb.append(" ls               List pending relocations").append(String.format("%n"));
         sb.append(" clear            Clear pending relocations").append(String.format("%n"));
         sb.append(" en[able]         Enable shuffling").append(String.format("%n"));
-        sb.append(" in[able]        Disable shuffling").append(String.format("%n%n"));
+        sb.append(" dis[able]        Disable shuffling").append(String.format("%n%n"));
 
         printHelp("shuffle [options] <sub-command>", sb.toString());
     }

File: src/java/org/apache/cassandra/config/ColumnDefinition.java
Patch:
@@ -20,6 +20,7 @@
 import java.nio.ByteBuffer;
 import java.util.*;
 
+import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Objects;
 import com.google.common.collect.Maps;
 
@@ -97,7 +98,8 @@ public ColumnDefinition(ByteBuffer name, AbstractType<?> validator, Integer comp
         this(name, validator, null, null, null, componentIndex, type);
     }
 
-    private ColumnDefinition(ByteBuffer name, AbstractType<?> validator, IndexType index_type, Map<String, String> index_options, String index_name, Integer componentIndex, Type type)
+    @VisibleForTesting
+    public ColumnDefinition(ByteBuffer name, AbstractType<?> validator, IndexType index_type, Map<String, String> index_options, String index_name, Integer componentIndex, Type type)
     {
         assert name != null && validator != null;
         this.name = name;

File: test/unit/org/apache/cassandra/SchemaLoader.java
Patch:
@@ -310,7 +310,7 @@ private static CFMetaData perRowIndexedCFMD(String ksName, String cfName, boolea
                                 IndexType.CUSTOM,
                                 indexOptions,
                                 ByteBufferUtil.bytesToHex(cName),
-                                null));
+                                null, ColumnDefinition.Type.REGULAR));
                     }});
     }
 

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -256,6 +256,7 @@ public StorageService()
         MessagingService.instance().registerVerbHandlers(MessagingService.Verb.MIGRATION_REQUEST, new MigrationRequestVerbHandler());
 
         MessagingService.instance().registerVerbHandlers(MessagingService.Verb.SNAPSHOT, new SnapshotVerbHandler());
+        MessagingService.instance().registerVerbHandlers(MessagingService.Verb.ECHO, new EchoVerbHandler());
 
         // spin up the streaming service so it is available for jmx tools.
         if (StreamingService.instance == null)

File: src/java/org/apache/cassandra/streaming/compress/CompressedFileStreamTask.java
Patch:
@@ -77,6 +77,9 @@ protected void stream() throws IOException
             // stream each of the required sections of the file
             for (Pair<Long, Long> section : sections)
             {
+                // seek to the beginning of the section when socket channel is not available
+                if (sc == null)
+                    file.seek(section.left);
                 // length of the section to stream
                 long length = section.right - section.left;
                 // tracks write progress
@@ -92,7 +95,6 @@ protected void stream() throws IOException
                     }
                     else
                     {
-                        file.seek(section.left);
                         // NIO is not available. Fall back to normal streaming.
                         // This happens when inter-node encryption is turned on.
                         if (transferBuffer == null)

File: src/java/org/apache/cassandra/io/sstable/SSTableBoundedScanner.java
Patch:
@@ -35,10 +35,11 @@ public class SSTableBoundedScanner extends SSTableScanner
     private final Iterator<Pair<Long, Long>> rangeIterator;
     private Pair<Long, Long> currentRange;
 
-    SSTableBoundedScanner(SSTableReader sstable, Range<Token> range)
+    SSTableBoundedScanner(SSTableReader sstable, Iterator<Pair<Long, Long>> rangeIterator)
     {
         super(sstable);
-        this.rangeIterator = sstable.getPositionsForRanges(Collections.singletonList(range)).iterator();
+        assert rangeIterator.hasNext(); // use EmptyCompactionScanner otherwise
+        this.rangeIterator = rangeIterator;
         currentRange = rangeIterator.next();
         dfile.seek(currentRange.left);
     }

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -236,7 +236,7 @@ public final class CFMetaData
                                                               + "requested_at timestamp"
                                                               + ") WITH COMMENT='ranges requested for transfer here'");
 
-    public static final CFMetaData CompactionLogCF = compile(18, "CREATE TABLE " + SystemTable.COMPACTION_LOG + " ("
+    public static final CFMetaData CompactionLogCf = compile(18, "CREATE TABLE " + SystemTable.COMPACTION_LOG + " ("
                                                                  + "id uuid PRIMARY KEY,"
                                                                  + "keyspace_name text,"
                                                                  + "columnfamily_name text,"

File: src/java/org/apache/cassandra/config/KSMetaData.java
Patch:
@@ -88,7 +88,7 @@ public static KSMetaData systemKeyspace()
                                                 CFMetaData.SchemaKeyspacesCf,
                                                 CFMetaData.SchemaColumnFamiliesCf,
                                                 CFMetaData.SchemaColumnsCf,
-                                                CFMetaData.CompactionLogCF,
+                                                CFMetaData.CompactionLogCf,
                                                 CFMetaData.OldStatusCf,
                                                 CFMetaData.OldHintsCf,
                                                 CFMetaData.OldMigrationsCf,

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -214,7 +214,7 @@ public final class CFMetaData
                                                                + "  PRIMARY KEY (session_id, event_id)"
                                                                + ");", Tracing.TRACE_KS);
 
-    public static final CFMetaData BatchlogCF = compile(16, "CREATE TABLE " + SystemTable.BATCHLOG_CF + " ("
+    public static final CFMetaData BatchlogCf = compile(16, "CREATE TABLE " + SystemTable.BATCHLOG_CF + " ("
                                                             + "id uuid PRIMARY KEY,"
                                                             + "written_at timestamp,"
                                                             + "data blob"

File: src/java/org/apache/cassandra/config/KSMetaData.java
Patch:
@@ -78,7 +78,7 @@ public static KSMetaData cloneWith(KSMetaData ksm, Iterable<CFMetaData> cfDefs)
 
     public static KSMetaData systemKeyspace()
     {
-        List<CFMetaData> cfDefs = Arrays.asList(CFMetaData.BatchlogCF,
+        List<CFMetaData> cfDefs = Arrays.asList(CFMetaData.BatchlogCf,
                                                 CFMetaData.RangeXfersCf,
                                                 CFMetaData.LocalCf,
                                                 CFMetaData.PeersCf,

File: src/java/org/apache/cassandra/db/BatchlogManager.java
Patch:
@@ -135,7 +135,7 @@ public static RowMutation getBatchlogMutationFor(Collection<RowMutation> mutatio
         ByteBuffer writtenAt = LongType.instance.decompose(timestamp / 1000);
         ByteBuffer data = serializeRowMutations(mutations);
 
-        ColumnFamily cf = ColumnFamily.create(CFMetaData.BatchlogCF);
+        ColumnFamily cf = ColumnFamily.create(CFMetaData.BatchlogCf);
         cf.addColumn(new Column(WRITTEN_AT, writtenAt, timestamp));
         cf.addColumn(new Column(DATA, data, timestamp));
         RowMutation rm = new RowMutation(Table.SYSTEM_KS, UUIDType.instance.decompose(uuid));
@@ -253,7 +253,7 @@ private static void deleteBatch(DecoratedKey key)
     private static ByteBuffer columnName(String name)
     {
         ByteBuffer raw = UTF8Type.instance.decompose(name);
-        return CFMetaData.BatchlogCF.getCfDef().getColumnNameBuilder().add(raw).build();
+        return CFMetaData.BatchlogCf.getCfDef().getColumnNameBuilder().add(raw).build();
     }
 
     private static List<Row> getRangeSlice(IDiskAtomFilter columnFilter)

File: src/java/org/apache/cassandra/cql3/statements/Selection.java
Patch:
@@ -117,6 +117,8 @@ else if (raw instanceof RawSelector.WritetimeOrTTL)
                 args.add(makeSelector(cfDef, rawArg, names, null));
 
             AbstractType<?> returnType = Functions.getReturnType(withFun.functionName, cfDef.cfm.ksName, cfDef.cfm.cfName);
+            if (returnType == null)
+                throw new InvalidRequestException(String.format("Unknown function '%s'", withFun.functionName));
             ColumnSpecification spec = makeFunctionSpec(cfDef, withFun, returnType);
             Function fun = Functions.get(withFun.functionName, args, spec);
             if (metadata != null)

File: src/java/org/apache/cassandra/cql3/statements/Selection.java
Patch:
@@ -262,7 +262,7 @@ public void add(Column c)
             }
         }
 
-        private boolean isDead(IColumn c)
+        private boolean isDead(Column c)
         {
             return c == null || c.isMarkedForDelete();
         }

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -422,7 +422,6 @@ public synchronized void initClient(int ringDelay) throws IOException, Configura
         Gossiper.instance.register(migrationManager);
         Gossiper.instance.start((int) (System.currentTimeMillis() / 1000)); // needed for node-ring gathering.
         Gossiper.instance.addLocalApplicationState(ApplicationState.NET_VERSION, valueFactory.networkVersion());
-        Schema.instance.updateVersion();
 
         MessagingService.instance().listen(FBUtilities.getLocalAddress());
         try

File: src/java/org/apache/cassandra/service/MigrationManager.java
Patch:
@@ -116,6 +116,9 @@ private static void maybeScheduleSchemaPull(final UUID theirVersion, final InetA
         if (MessagingService.instance().getVersion(endpoint) < MessagingService.VERSION_117)
             return;
 
+        if (Gossiper.instance.isFatClient(endpoint))
+            return;
+
         if (Schema.instance.getVersion().equals(theirVersion))
             return;
 

File: test/unit/org/apache/cassandra/locator/DynamicEndpointSnitchTest.java
Patch:
@@ -35,7 +35,7 @@ public class DynamicEndpointSnitchTest
     public void testSnitch() throws InterruptedException, IOException, ConfigurationException
     {
         // do this because SS needs to be initialized before DES can work properly.
-        StorageService.instance.initClient(0);
+        StorageService.instance.initClient();
         int sleeptime = 150;
         SimpleSnitch ss = new SimpleSnitch();
         DynamicEndpointSnitch dsnitch = new DynamicEndpointSnitch(ss, String.valueOf(ss.hashCode()));

File: test/unit/org/apache/cassandra/service/InitClientTest.java
Patch:
@@ -30,6 +30,6 @@ public class InitClientTest // extends CleanupHelper
     @Test
     public void testInitClientStartup() throws IOException, ConfigurationException
     {
-        StorageService.instance.initClient(0);
+        StorageService.instance.initClient();
     }
 }

File: test/unit/org/apache/cassandra/service/StorageServiceClientTest.java
Patch:
@@ -35,7 +35,7 @@ public void testClientOnlyMode() throws IOException, ConfigurationException
     {
         SchemaLoader.mkdirs();
         SchemaLoader.cleanup();
-        StorageService.instance.initClient(0);
+        StorageService.instance.initClient();
 
         // verify that no storage directories were created.
         for (String path : DatabaseDescriptor.getAllDataFileLocations())

File: src/java/org/apache/cassandra/service/MigrationManager.java
Patch:
@@ -117,6 +117,9 @@ private static void maybeScheduleSchemaPull(final UUID theirVersion, final InetA
         if (MessagingService.instance().getVersion(endpoint) < MessagingService.VERSION_117)
             return;
 
+        if (Gossiper.instance.isFatClient(endpoint))
+            return;
+
         if (Schema.instance.getVersion().equals(theirVersion))
             return;
 

File: test/unit/org/apache/cassandra/locator/DynamicEndpointSnitchTest.java
Patch:
@@ -35,7 +35,7 @@ public class DynamicEndpointSnitchTest
     public void testSnitch() throws InterruptedException, IOException, ConfigurationException
     {
         // do this because SS needs to be initialized before DES can work properly.
-        StorageService.instance.initClient(0);
+        StorageService.instance.initClient();
         int sleeptime = 150;
         SimpleSnitch ss = new SimpleSnitch();
         DynamicEndpointSnitch dsnitch = new DynamicEndpointSnitch(ss, String.valueOf(ss.hashCode()));

File: test/unit/org/apache/cassandra/service/InitClientTest.java
Patch:
@@ -30,6 +30,6 @@ public class InitClientTest // extends CleanupHelper
     @Test
     public void testInitClientStartup() throws IOException, ConfigurationException
     {
-        StorageService.instance.initClient(0);
+        StorageService.instance.initClient();
     }
 }

File: test/unit/org/apache/cassandra/service/StorageServiceClientTest.java
Patch:
@@ -35,7 +35,7 @@ public void testClientOnlyMode() throws IOException, ConfigurationException
     {
         SchemaLoader.mkdirs();
         SchemaLoader.cleanup();
-        StorageService.instance.initClient(0);
+        StorageService.instance.initClient();
 
         // verify that no storage directories were created.
         for (String path : DatabaseDescriptor.getAllDataFileLocations())

File: src/java/org/apache/cassandra/cql3/TypeCast.java
Patch:
@@ -48,7 +48,7 @@ private ColumnSpecification castedSpecOf(ColumnSpecification receiver)
 
     public boolean isAssignableTo(ColumnSpecification receiver)
     {
-        return receiver.type.equals(type.getType());
+        return receiver.type.asCQL3Type().equals(type);
     }
 
     @Override

File: src/java/org/apache/cassandra/cql3/functions/FunctionCall.java
Patch:
@@ -132,7 +132,7 @@ private static ByteBuffer execute(Function fun, List<Term> parameters) throws In
         public boolean isAssignableTo(ColumnSpecification receiver)
         {
             AbstractType<?> returnType = Functions.getReturnType(functionName, receiver.ksName, receiver.cfName);
-            return receiver.type.equals(returnType);
+            return receiver.type.asCQL3Type().equals(returnType.asCQL3Type());
         }
 
         @Override

File: src/java/org/apache/cassandra/cql3/functions/Functions.java
Patch:
@@ -112,7 +112,7 @@ public static Function get(String name, List<? extends AssignementTestable> prov
 
     private static void validateTypes(Function fun, List<? extends AssignementTestable> providedArgs, ColumnSpecification receiver) throws InvalidRequestException
     {
-        if (!receiver.type.equals(fun.returnType()))
+        if (!receiver.type.asCQL3Type().equals(fun.returnType().asCQL3Type()))
             throw new InvalidRequestException(String.format("Type error: cannot assign result of function %s (type %s) to %s (type %s)", fun.name(), fun.returnType().asCQL3Type(), receiver, receiver.type.asCQL3Type()));
 
         if (providedArgs.size() != fun.argsType().size())
@@ -135,7 +135,7 @@ private static void validateTypes(Function fun, List<? extends AssignementTestab
 
     private static boolean isValidType(Function fun, List<? extends AssignementTestable> providedArgs, ColumnSpecification receiver)
     {
-        if (!receiver.type.equals(fun.returnType()))
+        if (!receiver.type.asCQL3Type().equals(fun.returnType().asCQL3Type()))
             return false;
 
         if (providedArgs.size() != fun.argsType().size())

File: src/java/org/apache/cassandra/cql3/statements/Selection.java
Patch:
@@ -374,7 +374,7 @@ public ByteBuffer compute(ResultSetBuilder rs)
 
         public boolean isAssignableTo(ColumnSpecification receiver)
         {
-            return receiver.type.equals(isWritetime ? LongType.instance : Int32Type.instance);
+            return receiver.type.asCQL3Type().equals(isWritetime ? CQL3Type.Native.BIGINT : CQL3Type.Native.INT);
         }
     }
 

File: src/java/org/apache/cassandra/io/sstable/SSTableMetadata.java
Patch:
@@ -410,9 +410,7 @@ public SSTableMetadata deserialize(DataInputStream dis, Descriptor desc, boolean
                 replayPosition = ReplayPosition.NONE;
             }
             long minTimestamp = desc.version.tracksMinTimestamp ? dis.readLong() : Long.MIN_VALUE;
-            if (!desc.version.tracksMinTimestamp)
-                minTimestamp = Long.MAX_VALUE;
-            long maxTimestamp = desc.version.containsTimestamp() ? dis.readLong() : Long.MIN_VALUE;
+            long maxTimestamp = desc.version.containsTimestamp() ? dis.readLong() : Long.MAX_VALUE;
             if (!desc.version.tracksMaxTimestamp) // see javadoc to Descriptor.containsTimestamp
                 maxTimestamp = Long.MAX_VALUE;
             int maxLocalDeletionTime = desc.version.tracksMaxLocalDeletionTime ? dis.readInt() : Integer.MAX_VALUE;

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -975,9 +975,9 @@ public void scrub() throws ExecutionException, InterruptedException
         CompactionManager.instance.performScrub(ColumnFamilyStore.this);
     }
 
-    public void sstablesRewrite() throws ExecutionException, InterruptedException
+    public void sstablesRewrite(boolean excludeCurrentVersion) throws ExecutionException, InterruptedException
     {
-        CompactionManager.instance.performSSTableRewrite(ColumnFamilyStore.this);
+        CompactionManager.instance.performSSTableRewrite(ColumnFamilyStore.this, excludeCurrentVersion);
     }
 
     public void markCompacted(Collection<SSTableReader> sstables, OperationType compactionType)

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -2099,10 +2099,10 @@ public void scrub(String tableName, String... columnFamilies) throws IOException
             cfStore.scrub();
     }
 
-    public void upgradeSSTables(String tableName, String... columnFamilies) throws IOException, ExecutionException, InterruptedException
+    public void upgradeSSTables(String tableName, boolean excludeCurrentVersion, String... columnFamilies) throws IOException, ExecutionException, InterruptedException
     {
         for (ColumnFamilyStore cfStore : getValidColumnFamilies(true, true, tableName, columnFamilies))
-            cfStore.sstablesRewrite();
+            cfStore.sstablesRewrite(excludeCurrentVersion);
     }
 
     public void forceTableCompaction(String tableName, String... columnFamilies) throws IOException, ExecutionException, InterruptedException

File: src/java/org/apache/cassandra/service/StorageServiceMBean.java
Patch:
@@ -242,7 +242,7 @@ public interface StorageServiceMBean extends NotificationEmitter
      * Rewrite all sstables to the latest version.
      * Unlike scrub, it doesn't skip bad rows and do not snapshot sstables first.
      */
-    public void upgradeSSTables(String tableName, String... columnFamilies) throws IOException, ExecutionException, InterruptedException;
+    public void upgradeSSTables(String tableName, boolean excludeCurrentVersion, String... columnFamilies) throws IOException, ExecutionException, InterruptedException;
 
     /**
      * Flush all memtables for the given column families, or all columnfamilies for the given table

File: src/java/org/apache/cassandra/tools/NodeProbe.java
Patch:
@@ -192,9 +192,9 @@ public void scrub(String tableName, String... columnFamilies) throws IOException
         ssProxy.scrub(tableName, columnFamilies);
     }
 
-    public void upgradeSSTables(String tableName, String... columnFamilies) throws IOException, ExecutionException, InterruptedException
+    public void upgradeSSTables(String tableName, boolean excludeCurrentVersion, String... columnFamilies) throws IOException, ExecutionException, InterruptedException
     {
-        ssProxy.upgradeSSTables(tableName, columnFamilies);
+        ssProxy.upgradeSSTables(tableName, excludeCurrentVersion, columnFamilies);
     }
 
     public void forceTableCompaction(String tableName, String... columnFamilies) throws IOException, ExecutionException, InterruptedException

File: src/java/org/apache/cassandra/io/sstable/SSTableMetadata.java
Patch:
@@ -62,7 +62,7 @@ private SSTableMetadata()
         this(defaultRowSizeHistogram(),
              defaultColumnCountHistogram(),
              ReplayPosition.NONE,
-             Long.MIN_VALUE,
+             Long.MAX_VALUE,
              Double.MIN_VALUE,
              null,
              Collections.<Integer>emptySet());
@@ -223,7 +223,7 @@ public SSTableMetadata deserialize(DataInputStream dis, Descriptor desc) throws
                 // make sure we don't omit replaying something that we should.  see CASSANDRA-4782
                 replayPosition = ReplayPosition.NONE;
             }
-            long maxTimestamp = desc.containsTimestamp() ? dis.readLong() : Long.MIN_VALUE;
+            long maxTimestamp = desc.containsTimestamp() ? dis.readLong() : Long.MAX_VALUE;
             if (!desc.tracksMaxTimestamp) // see javadoc to Descriptor.containsTimestamp
                 maxTimestamp = Long.MAX_VALUE;
             double compressionRatio = desc.hasCompressionRatio

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -110,7 +110,7 @@ public class Config
 
     public Integer max_streaming_retries = 3;
 
-    public volatile Integer stream_throughput_outbound_megabits_per_sec;
+    public volatile Integer stream_throughput_outbound_megabits_per_sec = 200;
 
     public String[] data_file_directories;
 

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -410,9 +410,6 @@ public int compare(InetAddress endpoint1, InetAddress endpoint2)
             if (conf.compaction_throughput_mb_per_sec == null)
                 conf.compaction_throughput_mb_per_sec = 16;
 
-            if (conf.stream_throughput_outbound_megabits_per_sec == null)
-                conf.stream_throughput_outbound_megabits_per_sec = 400;
-
             if (conf.rpc_min_threads == null)
                 conf.rpc_min_threads = 16;
 

File: test/unit/org/apache/cassandra/db/compaction/LeveledCompactionStrategyTest.java
Patch:
@@ -183,7 +183,7 @@ public void testMutateLevel() throws Exception
 
         for(SSTableReader s : table.getColumnFamilyStore(cfname).getSSTables())
         {
-            assertTrue(changedSSTables.contains(s) && s.getSSTableLevel() == 6);
+            assertTrue(!changedSSTables.contains(s) || s.getSSTableLevel() == 6);
         }
 
         int [] levels = strat.manifest.getAllLevelSize();
@@ -192,8 +192,6 @@ public void testMutateLevel() throws Exception
         {
             if (i == 6)
                 assertEquals(table.getColumnFamilyStore(cfname).getSSTables().size(), levels[i]);
-            else
-                assertEquals(0, levels[i]);
         }
 
     }

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -167,6 +167,8 @@ public class Config
 
     public boolean inter_dc_tcp_nodelay = true;
 
+    public boolean preheat_kernel_page_cache = false;
+
     private static boolean loadYaml = true;
     private static boolean outboundBindAny = false;
 

File: src/java/org/apache/cassandra/db/commitlog/CommitLogReplayer.java
Patch:
@@ -121,7 +121,7 @@ public void recover(File file) throws IOException
         CommitLogDescriptor desc = CommitLogDescriptor.fromFileName(file.getName());
         final long segment = desc.id;
         int version = desc.getMessagingVersion();
-        RandomAccessReader reader = RandomAccessReader.open(new File(file.getAbsolutePath()), true);
+        RandomAccessReader reader = RandomAccessReader.open(new File(file.getAbsolutePath()));
         try
         {
             assert reader.length() <= Integer.MAX_VALUE;

File: src/java/org/apache/cassandra/db/compaction/AbstractCompactionStrategy.java
Patch:
@@ -152,7 +152,7 @@ public List<ICompactionScanner> getScanners(Collection<SSTableReader> sstables,
     {
         ArrayList<ICompactionScanner> scanners = new ArrayList<ICompactionScanner>();
         for (SSTableReader sstable : sstables)
-            scanners.add(sstable.getDirectScanner(range));
+            scanners.add(sstable.getScanner(range));
         return scanners;
     }
 

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -568,7 +568,7 @@ private void doCleanupCompaction(ColumnFamilyStore cfs, Collection<SSTableReader
             if (compactionFileLocation == null)
                 throw new IOException("disk full");
 
-            SSTableScanner scanner = sstable.getDirectScanner();
+            SSTableScanner scanner = sstable.getScanner();
             long rowsRead = 0;
             List<IColumn> indexedColumnsInRow = null;
 

File: src/java/org/apache/cassandra/db/compaction/LeveledCompactionStrategy.java
Patch:
@@ -179,7 +179,7 @@ public List<ICompactionScanner> getScanners(Collection<SSTableReader> sstables,
             {
                 // L0 makes no guarantees about overlapping-ness.  Just create a direct scanner for each
                 for (SSTableReader sstable : byLevel.get(level))
-                    scanners.add(sstable.getDirectScanner(range));
+                    scanners.add(sstable.getScanner(range));
             }
             else
             {
@@ -209,7 +209,7 @@ public LeveledScanner(Collection<SSTableReader> sstables, Range<Token> range)
             this.sstables = new ArrayList<SSTableReader>(sstables);
             Collections.sort(this.sstables, SSTable.sstableComparator);
             sstableIterator = this.sstables.iterator();
-            currentScanner = sstableIterator.next().getDirectScanner(range);
+            currentScanner = sstableIterator.next().getScanner(range);
 
             long length = 0;
             for (SSTableReader sstable : sstables)
@@ -234,7 +234,7 @@ protected OnDiskAtomIterator computeNext()
                         currentScanner = null;
                         return endOfData();
                     }
-                    currentScanner = sstableIterator.next().getDirectScanner(range);
+                    currentScanner = sstableIterator.next().getScanner(range);
                 }
             }
             catch (IOException e)

File: src/java/org/apache/cassandra/db/compaction/Scrubber.java
Patch:
@@ -94,8 +94,8 @@ public Scrubber(ColumnFamilyStore cfs, SSTableReader sstable, OutputHandler outp
         // we'll also loop through the index at the same time, using the position from the index to recover if the
         // row header (key or data size) is corrupt. (This means our position in the index file will be one row
         // "ahead" of the data file.)
-        this.dataFile = sstable.openDataReader(true);
-        this.indexFile = RandomAccessReader.open(new File(sstable.descriptor.filenameFor(Component.PRIMARY_INDEX)), true);
+        this.dataFile = sstable.openDataReader();
+        this.indexFile = RandomAccessReader.open(new File(sstable.descriptor.filenameFor(Component.PRIMARY_INDEX)));
         this.scrubInfo = new ScrubInfo(dataFile, sstable);
     }
 

File: src/java/org/apache/cassandra/io/sstable/KeyIterator.java
Patch:
@@ -38,7 +38,7 @@ public KeyIterator(Descriptor desc)
     {
         this.desc = desc;
         File path = new File(desc.filenameFor(SSTable.COMPONENT_INDEX));
-        in = RandomAccessReader.open(path, true);
+        in = RandomAccessReader.open(path);
     }
 
     protected DecoratedKey computeNext()

File: src/java/org/apache/cassandra/io/sstable/SSTableBoundedScanner.java
Patch:
@@ -35,9 +35,9 @@ public class SSTableBoundedScanner extends SSTableScanner
     private final Iterator<Pair<Long, Long>> rangeIterator;
     private Pair<Long, Long> currentRange;
 
-    SSTableBoundedScanner(SSTableReader sstable, boolean skipCache, Iterator<Pair<Long, Long>> rangeIterator)
+    SSTableBoundedScanner(SSTableReader sstable, Iterator<Pair<Long, Long>> rangeIterator)
     {
-        super(sstable, skipCache);
+        super(sstable);
         this.rangeIterator = rangeIterator;
         assert rangeIterator.hasNext(); // use EmptyCompactionScanner otherwise
         currentRange = rangeIterator.next();

File: src/java/org/apache/cassandra/streaming/FileStreamTask.java
Patch:
@@ -139,7 +139,7 @@ protected void stream() throws IOException
             return;
 
         // try to skip kernel page cache if possible
-        RandomAccessReader file = RandomAccessReader.open(new File(header.file.getFilename()), true);
+        RandomAccessReader file = RandomAccessReader.open(new File(header.file.getFilename()));
 
         // setting up data compression stream
         compressedoutput = new LZFOutputStream(output);

File: src/java/org/apache/cassandra/streaming/compress/CompressedFileStreamTask.java
Patch:
@@ -65,7 +65,7 @@ protected void stream() throws IOException
         ByteBuffer headerBuffer = MessagingService.instance().constructStreamHeader(header, false, MessagingService.instance().getVersion(to));
         socket.getOutputStream().write(ByteBufferUtil.getArray(headerBuffer));
 
-        RandomAccessReader file = RandomAccessReader.open(new File(header.file.getFilename()), true);
+        RandomAccessReader file = RandomAccessReader.open(new File(header.file.getFilename()));
         FileChannel fc = file.getChannel();
 
         StreamingMetrics.activeStreamsOutbound.inc();

File: src/java/org/apache/cassandra/tools/SSTableExport.java
Patch:
@@ -349,7 +349,7 @@ public static void enumeratekeys(Descriptor desc, PrintStream outs)
     public static void export(Descriptor desc, PrintStream outs, Collection<String> toExport, String[] excludes) throws IOException
     {
         SSTableReader reader = SSTableReader.open(desc);
-        SSTableScanner scanner = reader.getDirectScanner();
+        SSTableScanner scanner = reader.getScanner();
 
         IPartitioner<?> partitioner = reader.partitioner;
 
@@ -406,7 +406,7 @@ static void export(SSTableReader reader, PrintStream outs, String[] excludes) th
 
 
         SSTableIdentityIterator row;
-        SSTableScanner scanner = reader.getDirectScanner();
+        SSTableScanner scanner = reader.getScanner();
 
         outs.println("[");
 

File: test/unit/org/apache/cassandra/db/KeyCacheTest.java
Patch:
@@ -130,13 +130,13 @@ public void testKeyCache() throws IOException, ExecutionException, InterruptedEx
                                                        false,
                                                        10));
 
-        assert CacheService.instance.keyCache.size() == 2;
+        assertEquals(2, CacheService.instance.keyCache.size());
 
         Util.compactAll(cfs).get();
         keyCacheSize = CacheService.instance.keyCache.size();
         // after compaction cache should have entries for
         // new SSTables, if we had 2 keys in cache previously it should become 4
-        assert keyCacheSize == 4 : keyCacheSize;
+        assertEquals(4, keyCacheSize);
 
         // re-read same keys to verify that key cache didn't grow further
         cfs.getColumnFamily(QueryFilter.getSliceFilter(key1,

File: test/unit/org/apache/cassandra/io/sstable/SSTableTest.java
Patch:
@@ -56,7 +56,7 @@ public void testSingleWrite() throws IOException
 
     private void verifySingle(SSTableReader sstable, ByteBuffer bytes, ByteBuffer key) throws IOException
     {
-        RandomAccessReader file = sstable.openDataReader(false);
+        RandomAccessReader file = sstable.openDataReader();
         file.seek(sstable.getPosition(sstable.partitioner.decorateKey(key), SSTableReader.Operator.EQ).position);
         assert key.equals(ByteBufferUtil.readWithShortLength(file));
         int size = (int)SSTableReader.readRowSize(file, sstable.descriptor);
@@ -98,7 +98,7 @@ private void verifyMany(SSTableReader sstable, Map<ByteBuffer, ByteBuffer> map)
     {
         List<ByteBuffer> keys = new ArrayList<ByteBuffer>(map.keySet());
         //Collections.shuffle(keys);
-        RandomAccessReader file = sstable.openDataReader(false);
+        RandomAccessReader file = sstable.openDataReader();
         for (ByteBuffer key : keys)
         {
             file.seek(sstable.getPosition(sstable.partitioner.decorateKey(key), SSTableReader.Operator.EQ).position);

File: test/unit/org/apache/cassandra/io/sstable/SSTableUtils.java
Patch:
@@ -72,8 +72,8 @@ public static File tempSSTableFile(String tablename, String cfname, int generati
 
     public static void assertContentEquals(SSTableReader lhs, SSTableReader rhs) throws IOException
     {
-        SSTableScanner slhs = lhs.getDirectScanner();
-        SSTableScanner srhs = rhs.getDirectScanner();
+        SSTableScanner slhs = lhs.getScanner();
+        SSTableScanner srhs = rhs.getScanner();
         while (slhs.hasNext())
         {
             OnDiskAtomIterator ilhs = slhs.next();

File: test/unit/org/apache/cassandra/io/util/BufferedRandomAccessFileTest.java
Patch:
@@ -338,7 +338,7 @@ public void testIsEOF() throws IOException
             for (final int offset : Arrays.asList(0, 8))
             {
                 File file1 = writeTemporaryFile(new byte[16]);
-                final RandomAccessReader file = RandomAccessReader.open(file1, bufferSize, false, null);
+                final RandomAccessReader file = RandomAccessReader.open(file1, bufferSize, null);
                 expectEOF(new Callable<Object>()
                 {
                     public Object call() throws IOException
@@ -353,7 +353,7 @@ public Object call() throws IOException
             for (final int n : Arrays.asList(1, 2, 4, 8))
             {
                 File file1 = writeTemporaryFile(new byte[16]);
-                final RandomAccessReader file = RandomAccessReader.open(file1, bufferSize, false, null);
+                final RandomAccessReader file = RandomAccessReader.open(file1, bufferSize, null);
                 expectEOF(new Callable<Object>()
                 {
                     public Object call() throws IOException

File: src/java/org/apache/cassandra/service/MigrationManager.java
Patch:
@@ -220,7 +220,7 @@ public static void announceNewColumnFamily(CFMetaData cfm) throws ConfigurationE
         if (ksm == null)
             throw new ConfigurationException(String.format("Cannot add column family '%s' to non existing keyspace '%s'.", cfm.cfName, cfm.ksName));
         else if (ksm.cfMetaData().containsKey(cfm.cfName))
-            throw new AlreadyExistsException(cfm.cfName, cfm.ksName);
+            throw new AlreadyExistsException(cfm.ksName, cfm.cfName);
 
         logger.info(String.format("Create new ColumnFamily: %s", cfm));
         announce(cfm.toSchema(FBUtilities.timestampMicros()));

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
Patch:
@@ -29,6 +29,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.zip.Checksum;
 
+import org.apache.cassandra.utils.FBUtilities;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: src/java/org/apache/cassandra/service/WriteResponseHandler.java
Patch:
@@ -51,7 +51,7 @@ public WriteResponseHandler(Collection<InetAddress> writeEndpoints,
                                 WriteType writeType)
     {
         super(table, writeEndpoints, pendingEndpoints, consistencyLevel, callback, writeType);
-        responses = new AtomicInteger(consistencyLevel.blockFor(table));
+        responses = new AtomicInteger(totalBlockFor());
     }
 
     public WriteResponseHandler(InetAddress endpoint, WriteType writeType, Runnable callback)
@@ -72,7 +72,7 @@ public void response(MessageIn m)
 
     protected int ackCount()
     {
-        return consistencyLevel.blockFor(table) - responses.get();
+        return totalBlockFor() - responses.get();
     }
 
     public boolean isLatencyForSnitch()

File: src/java/org/apache/cassandra/service/WriteResponseHandler.java
Patch:
@@ -51,7 +51,7 @@ public WriteResponseHandler(Collection<InetAddress> writeEndpoints,
                                 WriteType writeType)
     {
         super(table, writeEndpoints, pendingEndpoints, consistencyLevel, callback, writeType);
-        responses = new AtomicInteger(consistencyLevel.blockFor(table));
+        responses = new AtomicInteger(totalBlockFor());
     }
 
     public WriteResponseHandler(InetAddress endpoint, WriteType writeType, Runnable callback)
@@ -72,7 +72,7 @@ public void response(MessageIn m)
 
     protected int ackCount()
     {
-        return consistencyLevel.blockFor(table) - responses.get();
+        return totalBlockFor() - responses.get();
     }
 
     public boolean isLatencyForSnitch()

File: src/java/org/apache/cassandra/db/compaction/LeveledManifest.java
Patch:
@@ -274,7 +274,7 @@ public synchronized Collection<SSTableReader> getCompactionCandidates()
 
     public synchronized int getLevelSize(int i)
     {
-        if (i > generations.length)
+        if (i >= generations.length)
             throw new ArrayIndexOutOfBoundsException("Maximum valid generation is " + (generations.length - 1));
         return generations[i].size();
     }

File: src/java/org/apache/cassandra/db/MeteredFlusher.java
Patch:
@@ -33,7 +33,7 @@
 
 import org.apache.cassandra.config.DatabaseDescriptor;
 
-class MeteredFlusher implements Runnable
+public class MeteredFlusher implements Runnable
 {
     private static Logger logger = LoggerFactory.getLogger(MeteredFlusher.class);
 

File: src/java/org/apache/cassandra/service/AntiEntropyService.java
Patch:
@@ -296,7 +296,7 @@ public Validator(TreeRequest request)
 
         public void prepare(ColumnFamilyStore cfs)
         {
-            if (tree.partitioner() instanceof RandomPartitioner)
+            if (!tree.partitioner().preservesOrder())
             {
                 // You can't beat an even tree distribution for md5
                 tree.init();

File: src/java/org/apache/cassandra/utils/MerkleTree.java
Patch:
@@ -241,6 +241,9 @@ else if (lhash == null || rhash == null)
      */
     static int differenceHelper(MerkleTree ltree, MerkleTree rtree, List<TreeRange> diff, TreeRange active)
     {
+        if (active.depth == Byte.MAX_VALUE)
+            return CONSISTENT;
+
         Token midpoint = ltree.partitioner().midpoint(active.left, active.right);
         TreeRange left = new TreeRange(null, active.left, midpoint, inc(active.depth), null);
         TreeRange right = new TreeRange(null, midpoint, active.right, inc(active.depth), null);

File: src/java/org/apache/cassandra/db/SliceFromReadCommand.java
Patch:
@@ -77,8 +77,9 @@ public ReadCommand maybeGenerateRetryCommand(RowDataResolver resolver, Row row)
 
         int count = filter.count;
         // We generate a retry if at least one node reply with count live columns but after merge we have less
-        // than the total number of column we are interested in (which may be < count on a retry)
-        if (maxLiveColumns >= count)
+        // than the total number of column we are interested in (which may be < count on a retry).
+        // So in particular, if no host returned count live columns, we know it's not a short read.
+        if (maxLiveColumns < count)
             return null;
 
         int liveCountInRow = row == null || row.cf == null ? 0 : filter.getLiveCount(row.cf);

File: src/java/org/apache/cassandra/auth/CassandraAuthorizer.java
Patch:
@@ -249,6 +249,6 @@ private static String escape(String name)
 
     private static UntypedResultSet process(String query) throws RequestExecutionException
     {
-        return QueryProcessor.process(query, ConsistencyLevel.QUORUM);
+        return QueryProcessor.process(query, ConsistencyLevel.ONE);
     }
 }

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -2308,7 +2308,7 @@ public void sendNotification(String type, String message, Object userObject)
     }
     public int forceRepairAsync(final String keyspace, final boolean isSequential, final boolean isLocal, final boolean primaryRange, final String... columnFamilies)
     {
-        final Collection<Range<Token>> ranges = primaryRange ? Collections.singletonList(getLocalPrimaryRange()) : getLocalRanges(keyspace);
+        final Collection<Range<Token>> ranges = primaryRange ? getLocalPrimaryRanges() : getLocalRanges(keyspace);
         return forceRepairAsync(keyspace, isSequential, isLocal, ranges, columnFamilies);
     }
 

File: src/java/org/apache/cassandra/hadoop/ConfigHelper.java
Patch:
@@ -493,7 +493,7 @@ public static void setThriftMaxMessageLengthInMb(Configuration conf, int maxMess
      */
     public static int getThriftMaxMessageLength(Configuration conf)
     {
-        return conf.getInt(THRIFT_FRAMED_TRANSPORT_SIZE_IN_MB, 16) * 1024 * 1024; // 16MB is default in Cassandra
+        return conf.getInt(THRIFT_MAX_MESSAGE_LENGTH_IN_MB, 16) * 1024 * 1024; // 16MB is default in Cassandra
     }
 
     public static CompressionParameters getOutputCompressionParamaters(Configuration conf)

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -37,6 +37,7 @@
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.DefsTable;
 import org.apache.cassandra.db.SystemTable;
+import org.apache.cassandra.db.Table;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.io.FSWriteError;

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -553,7 +553,7 @@ private static boolean hasExistingNoSystemTables()
                 {
                     public boolean accept(File pathname)
                     {
-                        return pathname.isDirectory();
+                        return (pathname.isDirectory() && !Table.SYSTEM_KS.equals(pathname.getName()));
                     }
                 }).length;
 

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -582,7 +582,7 @@ private static boolean hasExistingNoSystemTables()
                 {
                     public boolean accept(File pathname)
                     {
-                        return pathname.isDirectory();
+                        return (pathname.isDirectory() && !Table.SYSTEM_KS.equals(pathname.getName()));
                     }
                 }).length;
 

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -550,7 +550,7 @@ private static boolean hasExistingNoSystemTables()
                 {
                     public boolean accept(File pathname)
                     {
-                        return pathname.isDirectory();
+                        return (pathname.isDirectory() && !Table.SYSTEM_KS.equals(pathname.getName()));
                     }
                 }).length;
 

File: test/unit/org/apache/cassandra/db/ScrubTest.java
Patch:
@@ -27,7 +27,9 @@
 import java.util.concurrent.ExecutionException;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.exceptions.ConfigurationException;
@@ -43,6 +45,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class ScrubTest extends SchemaLoader
 {
     public String TABLE = "Keyspace1";

File: test/unit/org/apache/cassandra/locator/TokenMetadataTest.java
Patch:
@@ -24,14 +24,17 @@
 
 import org.junit.BeforeClass;
 import org.junit.Test;
+import org.junit.runner.RunWith;
 import static org.junit.Assert.assertEquals;
 
 import static org.apache.cassandra.Util.token;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.locator.TokenMetadata;
 import org.apache.cassandra.service.StorageService;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class TokenMetadataTest
 {
     public final static String ONE = "1";

File: test/unit/org/apache/cassandra/config/DefsTest.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.*;
 import java.util.concurrent.ExecutionException;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.db.*;
@@ -42,7 +43,9 @@
 import org.apache.cassandra.utils.ByteBufferUtil;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class DefsTest extends SchemaLoader
 {
 

File: test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
Patch:
@@ -32,7 +32,9 @@
 import org.apache.commons.lang.ArrayUtils;
 import org.apache.commons.lang.StringUtils;
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.config.CFMetaData;
@@ -58,6 +60,7 @@
 import static org.apache.commons.lang.ArrayUtils.EMPTY_BYTE_ARRAY;
 import static org.junit.Assert.assertNull;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class ColumnFamilyStoreTest extends SchemaLoader
 {
     static byte[] bytes1, bytes2;

File: test/unit/org/apache/cassandra/db/compaction/CompactionsTest.java
Patch:
@@ -29,7 +29,9 @@
 import com.google.common.collect.SetMultimap;
 import com.google.common.collect.Sets;
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.config.DatabaseDescriptor;
@@ -48,6 +50,7 @@
 
 import static junit.framework.Assert.*;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class CompactionsTest extends SchemaLoader
 {
     public static final String TABLE1 = "Keyspace1";

File: test/unit/org/apache/cassandra/db/compaction/LeveledCompactionStrategyTest.java
Patch:
@@ -23,7 +23,9 @@
 
 import com.google.common.collect.Iterables;
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.db.ColumnFamilyStore;
@@ -41,6 +43,7 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class LeveledCompactionStrategyTest extends SchemaLoader
 {
     /*

File: test/unit/org/apache/cassandra/dht/BootStrapperTest.java
Patch:
@@ -31,7 +31,9 @@
 import java.util.concurrent.CountDownLatch;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.db.Table;
@@ -46,6 +48,7 @@
 
 import static org.junit.Assert.*;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class BootStrapperTest extends SchemaLoader
 {
     @Test

File: test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java
Patch:
@@ -31,7 +31,9 @@
 import java.util.*;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.config.DatabaseDescriptor;
@@ -55,6 +57,7 @@
 import org.apache.cassandra.utils.CLibrary;
 import org.apache.cassandra.utils.Pair;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class SSTableReaderTest extends SchemaLoader
 {
     static Token t(int i)

File: test/unit/org/apache/cassandra/service/StorageServiceServerTest.java
Patch:
@@ -25,7 +25,9 @@
 import java.util.List;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.db.Table;
 import org.apache.cassandra.dht.Token;
@@ -35,6 +37,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class StorageServiceServerTest
 {
     @Test

File: test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java
Patch:
@@ -20,6 +20,7 @@
 */
 
 import static junit.framework.Assert.assertEquals;
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.Util;
 import static org.apache.cassandra.Util.column;
 import static org.apache.cassandra.Util.addMutation;
@@ -47,11 +48,13 @@
 
 import org.junit.BeforeClass;
 import org.junit.Test;
+import org.junit.runner.RunWith;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.utils.ByteBufferUtil;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class StreamingTransferTest extends SchemaLoader
 {
     private static final Logger logger = LoggerFactory.getLogger(StreamingTransferTest.class);

File: test/unit/org/apache/cassandra/config/DatabaseDescriptorTest.java
Patch:
@@ -18,6 +18,7 @@
 */
 package org.apache.cassandra.config;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.exceptions.InvalidRequestException;
@@ -26,9 +27,11 @@
 import org.apache.cassandra.service.MigrationManager;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
 import java.io.IOException;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class DatabaseDescriptorTest
 {
     @Test

File: test/unit/org/apache/cassandra/config/DefsTest.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.*;
 import java.util.concurrent.ExecutionException;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.db.*;
@@ -43,7 +44,9 @@
 import org.apache.cassandra.utils.ByteBufferUtil;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class DefsTest extends SchemaLoader
 {
 

File: test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
Patch:
@@ -32,6 +32,7 @@
 import org.apache.commons.lang.ArrayUtils;
 import org.apache.commons.lang.StringUtils;
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
 import static org.junit.Assert.assertNull;
 import static junit.framework.Assert.assertEquals;
@@ -45,6 +46,7 @@
 import static org.apache.cassandra.utils.ByteBufferUtil.bytes;
 import static org.apache.commons.lang.ArrayUtils.EMPTY_BYTE_ARRAY;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.config.CFMetaData;
@@ -68,6 +70,7 @@
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.WrappedRunnable;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class ColumnFamilyStoreTest extends SchemaLoader
 {
     static byte[] bytes1, bytes2;

File: test/unit/org/apache/cassandra/db/compaction/CompactionsTest.java
Patch:
@@ -25,7 +25,9 @@
 import java.util.concurrent.TimeUnit;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.config.DatabaseDescriptor;
@@ -43,6 +45,7 @@
 
 import static junit.framework.Assert.*;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class CompactionsTest extends SchemaLoader
 {
     public static final String TABLE1 = "Keyspace1";

File: test/unit/org/apache/cassandra/db/compaction/LeveledCompactionStrategyTest.java
Patch:
@@ -21,7 +21,9 @@
 import java.util.Collection;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.db.ColumnFamilyStore;
@@ -37,6 +39,7 @@
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class LeveledCompactionStrategyTest extends SchemaLoader
 {
     /*

File: test/unit/org/apache/cassandra/dht/BootStrapperTest.java
Patch:
@@ -31,7 +31,9 @@
 import java.util.concurrent.CountDownLatch;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.db.Table;
@@ -46,6 +48,7 @@
 
 import static org.junit.Assert.*;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class BootStrapperTest extends SchemaLoader
 {
     @Test

File: test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java
Patch:
@@ -31,7 +31,9 @@
 import java.util.*;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.config.DatabaseDescriptor;
@@ -56,6 +58,7 @@
 import org.apache.cassandra.utils.CLibrary;
 import org.apache.cassandra.utils.Pair;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class SSTableReaderTest extends SchemaLoader
 {
     static Token t(int i)

File: test/unit/org/apache/cassandra/service/StorageServiceServerTest.java
Patch:
@@ -25,7 +25,9 @@
 import java.util.List;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.db.Table;
 import org.apache.cassandra.dht.Token;
@@ -35,6 +37,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class StorageServiceServerTest
 {
     @Test

File: test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java
Patch:
@@ -20,6 +20,7 @@
 */
 
 import static junit.framework.Assert.assertEquals;
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.Util;
 import static org.apache.cassandra.Util.column;
 import static org.apache.cassandra.Util.addMutation;
@@ -47,11 +48,13 @@
 
 import org.junit.BeforeClass;
 import org.junit.Test;
+import org.junit.runner.RunWith;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.utils.ByteBufferUtil;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class StreamingTransferTest extends SchemaLoader
 {
     private static final Logger logger = LoggerFactory.getLogger(StreamingTransferTest.class);

File: test/unit/org/apache/cassandra/config/DatabaseDescriptorTest.java
Patch:
@@ -18,16 +18,19 @@
 */
 package org.apache.cassandra.config;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.gms.Gossiper;
 import org.apache.cassandra.locator.SimpleStrategy;
 import org.apache.cassandra.service.MigrationManager;
 import org.apache.cassandra.thrift.InvalidRequestException;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
 import java.io.IOException;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class DatabaseDescriptorTest
 {
     @Test

File: test/unit/org/apache/cassandra/config/DefsTest.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.*;
 import java.util.concurrent.ExecutionException;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.db.*;
@@ -44,7 +45,9 @@
 import org.apache.cassandra.utils.ByteBufferUtil;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class DefsTest extends SchemaLoader
 {
 

File: test/unit/org/apache/cassandra/db/CleanupTest.java
Patch:
@@ -27,6 +27,7 @@
 import java.util.List;
 import java.util.concurrent.ExecutionException;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.config.ConfigurationException;
@@ -46,7 +47,9 @@
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.NodeId;
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class CleanupTest extends SchemaLoader
 {
     public static final int LOOPS = 200;

File: test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
Patch:
@@ -26,6 +26,7 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.config.ColumnDefinition;
@@ -56,7 +57,9 @@
 import static org.junit.Assert.assertNull;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class ColumnFamilyStoreTest extends SchemaLoader
 {
     static byte[] bytes1, bytes2;

File: test/unit/org/apache/cassandra/db/ScrubTest.java
Patch:
@@ -27,7 +27,9 @@
 import java.util.concurrent.ExecutionException;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.config.DatabaseDescriptor;
@@ -46,6 +48,7 @@
 
 import java.util.*;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class ScrubTest extends SchemaLoader
 {
     public String TABLE = "Keyspace1";

File: test/unit/org/apache/cassandra/dht/BootStrapperTest.java
Patch:
@@ -28,7 +28,9 @@
 import java.util.Map;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.db.Table;
@@ -42,6 +44,7 @@
 
 import static org.junit.Assert.assertEquals;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class BootStrapperTest extends SchemaLoader
 {
     @Test

File: test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java
Patch:
@@ -32,7 +32,9 @@
 import java.util.concurrent.ExecutionException;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.cache.KeyCacheKey;
@@ -58,6 +60,7 @@
 import org.apache.cassandra.utils.CLibrary;
 import org.apache.cassandra.utils.Pair;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class SSTableReaderTest extends SchemaLoader
 {
     static Token t(int i)

File: test/unit/org/apache/cassandra/service/StorageServiceServerTest.java
Patch:
@@ -25,7 +25,9 @@
 import java.util.List;
 
 import org.junit.Test;
+import org.junit.runner.RunWith;
 
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.SchemaLoader;
@@ -34,6 +36,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class StorageServiceServerTest
 {
     @Test

File: test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java
Patch:
@@ -20,6 +20,7 @@
 */
 
 import static junit.framework.Assert.assertEquals;
+import org.apache.cassandra.OrderedJUnit4ClassRunner;
 import org.apache.cassandra.Util;
 import static org.apache.cassandra.Util.column;
 import static org.apache.cassandra.Util.addMutation;
@@ -47,11 +48,13 @@
 
 import org.junit.BeforeClass;
 import org.junit.Test;
+import org.junit.runner.RunWith;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.utils.ByteBufferUtil;
 
+@RunWith(OrderedJUnit4ClassRunner.class)
 public class StreamingTransferTest extends SchemaLoader
 {
     private static final Logger logger = LoggerFactory.getLogger(StreamingTransferTest.class);

File: src/java/org/apache/cassandra/db/SliceFromReadCommand.java
Patch:
@@ -77,8 +77,9 @@ public ReadCommand maybeGenerateRetryCommand(RowDataResolver resolver, Row row)
 
         int count = filter.count;
         // We generate a retry if at least one node reply with count live columns but after merge we have less
-        // than the total number of column we are interested in (which may be < count on a retry)
-        if (maxLiveColumns >= count)
+        // than the total number of column we are interested in (which may be < count on a retry).
+        // So in particular, if no host returned count live columns, we know it's not a short read.
+        if (maxLiveColumns < count)
             return null;
 
         int liveCountInRow = row == null || row.cf == null ? 0 : filter.getLiveCount(row.cf);

File: src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java
Patch:
@@ -180,7 +180,7 @@ static List<ByteBuffer> buildKeyNames(CFDefinition cfDef, Map<ColumnIdentifier,
             {
                 for (Term t : values)
                 {
-                    ByteBuffer val = values.get(0).bindAndGet(variables);
+                    ByteBuffer val = t.bindAndGet(variables);
                     if (val == null)
                         throw new InvalidRequestException(String.format("Invalid null value for partition key part %s", name));
                     keys.add(keyBuilder.copy().add(val).build());

File: src/java/org/apache/cassandra/transport/messages/ResultMessage.java
Patch:
@@ -294,7 +294,7 @@ public CqlPreparedResult toThriftPreparedResult()
             for (ColumnSpecification name : metadata.names)
             {
                 namesString.add(name.toString());
-                typesString.add(TypeParser.getShortName(name.type));
+                typesString.add(name.type.toString());
             }
             return new CqlPreparedResult(thriftStatementId, metadata.names.size()).setVariable_types(typesString).setVariable_names(namesString);
         }

File: src/java/org/apache/cassandra/locator/PropertyFileSnitch.java
Patch:
@@ -181,8 +181,8 @@ public void reloadConfiguration() throws ConfigurationException
                 reloadedMap.put(host, token);
             }
         }
-        if (!reloadedMap.containsKey(FBUtilities.getBroadcastAddress()))
-            throw new ConfigurationException(String.format("Snitch definitions at %s do not define a location for this node's broadcast address %s",
+        if (defaultDCRack == null && !reloadedMap.containsKey(FBUtilities.getBroadcastAddress()))
+            throw new ConfigurationException(String.format("Snitch definitions at %s do not define a location for this node's broadcast address %s, nor does it provides a default",
                                                            SNITCH_PROPERTIES_FILENAME, FBUtilities.getBroadcastAddress()));
 
         logger.debug("loaded network topology {}", FBUtilities.toString(reloadedMap));

File: src/java/org/apache/cassandra/cql3/Operation.java
Patch:
@@ -159,6 +159,9 @@ public Operation prepare(CFDefinition.Name receiver) throws InvalidRequestExcept
         {
             Term v = value.prepare(receiver);
 
+            if (receiver.type instanceof CounterColumnType)
+                throw new InvalidRequestException(String.format("Cannot set the value of counter column %s (counters can only be incremented/decremented, not set)", receiver));
+
             if (!(receiver.type instanceof CollectionType))
                 return new Constants.Setter(receiver.kind == CFDefinition.Name.Kind.VALUE_ALIAS ? null : receiver.name, v);
 

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -977,7 +977,7 @@ public ColumnDefinition getColumnDefinition(ByteBuffer name)
      */
     public ColumnDefinition getColumnDefinitionFromColumnName(ByteBuffer columnName)
     {
-        if (comparator instanceof CompositeType)
+        if (cfType == ColumnFamilyType.Standard && comparator instanceof CompositeType)
         {
             CompositeType composite = (CompositeType)comparator;
             ByteBuffer[] components = composite.split(columnName);

File: src/java/org/apache/cassandra/config/EncryptionOptions.java
Patch:
@@ -27,7 +27,7 @@ public abstract class EncryptionOptions
     public String protocol = "TLS";
     public String algorithm = "SunX509";
     public String store_type = "JKS";
-    public Boolean require_client_auth = false;
+    public boolean require_client_auth = false;
 
     public static class ClientEncryptionOptions extends EncryptionOptions
     {

File: src/java/org/apache/cassandra/db/SliceFromReadCommand.java
Patch:
@@ -75,10 +75,9 @@ public ReadCommand maybeGenerateRetryCommand(RepairCallback handler, Row row)
         int maxLiveColumns = handler.getMaxLiveColumns();
         int liveColumnsInRow = row != null ? row.getLiveColumnCount() : 0;
 
-        assert maxLiveColumns <= count;
         // We generate a retry if at least one node reply with count live columns but after merge we have less
         // than the total number of column we are interested in (which may be < count on a retry)
-        if ((maxLiveColumns == count) && (liveColumnsInRow < getOriginalRequestedCount()))
+        if ((maxLiveColumns >= count) && (liveColumnsInRow < getOriginalRequestedCount()))
         {
             // We asked t (= count) live columns and got l (=liveColumnsInRow) ones.
             // From that, we can estimate that on this row, for x requested

File: src/java/org/apache/cassandra/cql3/statements/DropUserStatement.java
Patch:
@@ -42,7 +42,7 @@ public void validate(ClientState state) throws RequestValidationException
         state.ensureNotAnonymous();
 
         if (!Auth.isExistingUser(username))
-            throw new InvalidRequestException(String.format("User %s doesn't exists", username));
+            throw new InvalidRequestException(String.format("User %s doesn't exist", username));
 
         AuthenticatedUser user = state.getUser();
         if (user != null && user.getName().equals(username))

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -879,7 +879,6 @@ public Set<SSTableReader> getOverlappingSSTables(Collection<SSTableReader> sstab
         for (SSTableReader sstable : sstables)
         {
             Set<SSTableReader> overlaps = ImmutableSet.copyOf(tree.search(Interval.<RowPosition, SSTableReader>create(sstable.first, sstable.last)));
-            assert overlaps.contains(sstable);
             results = results == null ? overlaps : Sets.union(results, overlaps).immutableCopy();
         }
         results = Sets.difference(results, ImmutableSet.copyOf(sstables));

File: test/unit/org/apache/cassandra/Util.java
Patch:
@@ -34,6 +34,7 @@
 import java.util.concurrent.Future;
 
 import org.apache.cassandra.db.*;
+import org.apache.cassandra.db.compaction.AbstractCompactionTask;
 import org.apache.cassandra.db.compaction.CompactionManager;
 import org.apache.cassandra.db.compaction.CompactionTask;
 import org.apache.cassandra.db.columniterator.IdentityQueryFilter;
@@ -258,7 +259,8 @@ public static Future<?> compactAll(ColumnFamilyStore cfs)
 
     public static void compact(ColumnFamilyStore cfs, Collection<SSTableReader> sstables)
     {
-        CompactionTask task = new CompactionTask(cfs, sstables, (int) (System.currentTimeMillis() / 1000) - cfs.metadata.getGcGraceSeconds());
+        int gcBefore = (int) (System.currentTimeMillis() / 1000) - cfs.metadata.getGcGraceSeconds();
+        AbstractCompactionTask task = cfs.getCompactionStrategy().getUserDefinedTask(sstables, gcBefore);
         task.execute(null);
     }
 

File: test/unit/org/apache/cassandra/db/compaction/CompactionsPurgeTest.java
Patch:
@@ -137,7 +137,7 @@ public void testMinorCompactionPurge() throws IOException, ExecutionException, I
         rm.add(new QueryPath(cfName, null, ByteBufferUtil.bytes(String.valueOf(5))), ByteBufferUtil.EMPTY_BYTE_BUFFER, 2);
         rm.apply();
         cfs.forceBlockingFlush();
-        new CompactionTask(cfs, sstablesIncomplete, Integer.MAX_VALUE).execute(null);
+        cfs.getCompactionStrategy().getUserDefinedTask(sstablesIncomplete, Integer.MAX_VALUE).execute(null);
 
         // verify that minor compaction does not GC when key is present
         // in a non-compacted sstable
@@ -178,7 +178,7 @@ public void testMinTimestampPurge() throws IOException, ExecutionException, Inte
         rm.delete(new QueryPath(cfName, null, ByteBufferUtil.bytes("c2")), 9);
         rm.apply();
         cfs.forceBlockingFlush();
-        new CompactionTask(cfs, sstablesIncomplete, Integer.MAX_VALUE).execute(null);
+        cfs.getCompactionStrategy().getUserDefinedTask(sstablesIncomplete, Integer.MAX_VALUE).execute(null);
 
         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key3, new QueryPath(cfName)));
         Assert.assertTrue(!cf.getColumn(ByteBufferUtil.bytes("c2")).isLive());

File: tools/stress/src/org/apache/cassandra/stress/operations/CqlCounterAdder.java
Patch:
@@ -88,14 +88,14 @@ public void run(CassandraClient client) throws IOException
                 {
                     Integer stmntId = getPreparedStatement(client, cqlQuery);
                     if (session.cqlVersion.startsWith("3"))
-                        client.execute_prepared_cql3_query(stmntId, Collections.singletonList(ByteBufferUtil.bytes(getUnQuotedCqlBlob(key))), session.getConsistencyLevel());
+                        client.execute_prepared_cql3_query(stmntId, Collections.singletonList(ByteBuffer.wrap(key.getBytes())), session.getConsistencyLevel());
                     else
-                        client.execute_prepared_cql_query(stmntId, Collections.singletonList(ByteBufferUtil.bytes(getUnQuotedCqlBlob(key))));
+                        client.execute_prepared_cql_query(stmntId, Collections.singletonList(ByteBuffer.wrap(key.getBytes())));
                 }
                 else
                 {
                     if (formattedQuery == null)
-                        formattedQuery = formatCqlQuery(cqlQuery, Collections.singletonList(getUnQuotedCqlBlob(key)));
+                        formattedQuery = formatCqlQuery(cqlQuery, Collections.singletonList(getUnQuotedCqlBlob(key, session.cqlVersion.startsWith("3"))));
                     if (session.cqlVersion.startsWith("3"))
                         client.execute_cql3_query(ByteBuffer.wrap(formattedQuery.getBytes()), Compression.NONE, session.getConsistencyLevel());
                     else

File: tools/stress/src/org/apache/cassandra/stress/operations/CqlCounterGetter.java
Patch:
@@ -89,14 +89,14 @@ public void run(CassandraClient client) throws IOException
                 {
                     Integer stmntId = getPreparedStatement(client, cqlQuery);
                     if (session.cqlVersion.startsWith("3"))
-                        result = client.execute_prepared_cql3_query(stmntId, Collections.singletonList(ByteBufferUtil.bytes(getUnQuotedCqlBlob(key))), session.getConsistencyLevel());
+                        result = client.execute_prepared_cql3_query(stmntId, Collections.singletonList(ByteBuffer.wrap(key)), session.getConsistencyLevel());
                     else
-                        result = client.execute_prepared_cql_query(stmntId, Collections.singletonList(ByteBufferUtil.bytes(getUnQuotedCqlBlob(key))));
+                        result = client.execute_prepared_cql_query(stmntId, Collections.singletonList(ByteBuffer.wrap(key)));
                 }
                 else
                 {
                     if (formattedQuery == null)
-                        formattedQuery = formatCqlQuery(cqlQuery, Collections.singletonList(getUnQuotedCqlBlob(key)));
+                        formattedQuery = formatCqlQuery(cqlQuery, Collections.singletonList(getUnQuotedCqlBlob(key, session.cqlVersion.startsWith("3"))));
 
                     if (session.cqlVersion.startsWith("3"))
                         result = client.execute_cql3_query(ByteBuffer.wrap(formattedQuery.getBytes()), Compression.NONE, session.getConsistencyLevel());

File: tools/stress/src/org/apache/cassandra/stress/operations/CqlIndexedRangeSlicer.java
Patch:
@@ -62,7 +62,7 @@ public void run(CassandraClient client) throws IOException
             if (session.cqlVersion.startsWith("2"))
                 query.append(" USING CONSISTENCY ").append(session.getConsistencyLevel());
 
-            query.append(" WHERE C1=").append(getUnQuotedCqlBlob(values.get(1).array()))
+            query.append(" WHERE C1=").append(getUnQuotedCqlBlob(values.get(1).array(), session.cqlVersion.startsWith("3")))
                  .append(" AND KEY > ? LIMIT ").append(session.getKeysPerCall());
 
             cqlQuery = query.toString();
@@ -81,7 +81,7 @@ public void run(CassandraClient client) throws IOException
             String exceptionMessage = null;
             CqlResult results = null;
             String formattedQuery = null;
-            List<String> queryParms = Collections.singletonList(getUnQuotedCqlBlob(startOffset));
+            List<String> queryParms = Collections.singletonList(getUnQuotedCqlBlob(startOffset, session.cqlVersion.startsWith("3")));
 
             for (int t = 0; t < session.getRetryTimes(); t++)
             {

File: tools/stress/src/org/apache/cassandra/stress/operations/CqlInserter.java
Patch:
@@ -89,11 +89,11 @@ public void run(CassandraClient client) throws IOException
         for (int i = 0; i < session.getColumnsPerKey(); i++)
         {
             // Column value
-            queryParms.add(getUnQuotedCqlBlob(values.get(i % values.size()).array()));
+            queryParms.add(getUnQuotedCqlBlob(values.get(i % values.size()).array(), session.cqlVersion.startsWith("3")));
         }
 
         String key = String.format("%0" + session.getTotalKeysLength() + "d", index);
-        queryParms.add(getUnQuotedCqlBlob(key));
+        queryParms.add(getUnQuotedCqlBlob(key, session.cqlVersion.startsWith("3")));
 
         String formattedQuery = null;
 

File: tools/stress/src/org/apache/cassandra/stress/operations/CqlRangeSlicer.java
Patch:
@@ -82,14 +82,14 @@ public void run(CassandraClient client) throws IOException
                 {
                     Integer stmntId = getPreparedStatement(client, cqlQuery);
                     if (session.cqlVersion.startsWith("3"))
-                        result = client.execute_prepared_cql3_query(stmntId, Collections.singletonList(ByteBufferUtil.bytes(getUnQuotedCqlBlob(key))), session.getConsistencyLevel());
+                        result = client.execute_prepared_cql3_query(stmntId, Collections.singletonList(ByteBuffer.wrap(key.getBytes())), session.getConsistencyLevel());
                     else
-                        result = client.execute_prepared_cql_query(stmntId, Collections.singletonList(ByteBufferUtil.bytes(getUnQuotedCqlBlob(key))));
+                        result = client.execute_prepared_cql_query(stmntId, Collections.singletonList(ByteBuffer.wrap(key.getBytes())));
                 }
                 else
                 {
                     if (formattedQuery == null)
-                        formattedQuery = formatCqlQuery(cqlQuery, Collections.singletonList(getUnQuotedCqlBlob(key)));
+                        formattedQuery = formatCqlQuery(cqlQuery, Collections.singletonList(getUnQuotedCqlBlob(key, session.cqlVersion.startsWith("3"))));
                     if (session.cqlVersion.startsWith("3"))
                         result = client.execute_cql3_query(ByteBuffer.wrap(formattedQuery.getBytes()), Compression.NONE, session.getConsistencyLevel());
                     else

File: tools/stress/src/org/apache/cassandra/stress/operations/CqlReader.java
Patch:
@@ -80,10 +80,10 @@ public void run(CassandraClient client) throws IOException
         List<String> queryParams = new ArrayList<String>();
         if (session.columnNames != null)
             for (int i = 0; i < session.columnNames.size(); i++)
-                queryParams.add(getUnQuotedCqlBlob(session.columnNames.get(i).array()));
+                queryParams.add(getUnQuotedCqlBlob(session.columnNames.get(i).array(), session.cqlVersion.startsWith("3")));
 
         byte[] key = generateKey();
-        queryParams.add(getUnQuotedCqlBlob(key));
+        queryParams.add(getUnQuotedCqlBlob(key, session.cqlVersion.startsWith("3")));
 
         String formattedQuery = null;
 

File: src/java/org/apache/cassandra/db/compaction/CompactionController.java
Patch:
@@ -114,7 +114,7 @@ public boolean shouldPurge(DecoratedKey key, long maxDeletionTimestamp)
         List<SSTableReader> filteredSSTables = overlappingTree.search(key);
         for (SSTableReader sstable : filteredSSTables)
         {
-            if (sstable.getBloomFilter().isPresent(key.key) && sstable.getMinTimestamp() >= maxDeletionTimestamp)
+            if (sstable.getBloomFilter().isPresent(key.key) && sstable.getMinTimestamp() <= maxDeletionTimestamp)
                 return false;
         }
         return true;

File: src/java/org/apache/cassandra/io/compress/CompressionMetadata.java
Patch:
@@ -199,6 +199,7 @@ public int compare(Chunk o1, Chunk o2)
         {
             int startIndex = (int) (section.left / parameters.chunkLength());
             int endIndex = (int) (section.right / parameters.chunkLength());
+            endIndex = section.right % parameters.chunkLength() == 0 ? endIndex - 1 : endIndex;
             for (int i = startIndex; i <= endIndex; i++)
             {
                 long offset = i * 8;

File: src/java/org/apache/cassandra/cql3/functions/Functions.java
Patch:
@@ -116,7 +116,7 @@ private static void validateTypes(Function fun, List<? extends AssignementTestab
             throw new InvalidRequestException(String.format("Type error: cannot assign result of function %s (type %s) to %s (type %s)", fun.name(), fun.returnType().asCQL3Type(), receiver, receiver.type.asCQL3Type()));
 
         if (providedArgs.size() != fun.argsType().size())
-            throw new InvalidRequestException(String.format("Invalid number of arguments in call to function %s: %d required but % provided", fun.name(), fun.argsType().size(), providedArgs.size()));
+            throw new InvalidRequestException(String.format("Invalid number of arguments in call to function %s: %d required but %d provided", fun.name(), fun.argsType().size(), providedArgs.size()));
 
         for (int i = 0; i < providedArgs.size(); i++)
         {

File: src/java/org/apache/cassandra/io/sstable/IndexHelper.java
Patch:
@@ -178,12 +178,12 @@ first slot where firstName > start ([20..25] here), so we subtract an extra one
         {
             if (reversed)
             {
-                startIdx = lastIndex;
-                toSearch = indexList.subList(lastIndex, indexList.size());
+                toSearch = indexList.subList(0, lastIndex + 1);
             }
             else
             {
-                toSearch = indexList.subList(0, lastIndex + 1);
+                startIdx = lastIndex;
+                toSearch = indexList.subList(lastIndex, indexList.size());
             }
         }
         int index = Collections.binarySearch(toSearch, target, getComparator(comparator, reversed));

File: src/java/org/apache/cassandra/auth/MigrationListener.java
Patch:
@@ -30,7 +30,7 @@ public void onDropKeyspace(String ksName)
         DatabaseDescriptor.getAuthorizer().revokeAll(DataResource.keyspace(ksName));
     }
 
-    public void onDropColumnFamly(String ksName, String cfName)
+    public void onDropColumnFamily(String ksName, String cfName)
     {
         DatabaseDescriptor.getAuthorizer().revokeAll(DataResource.columnFamily(ksName, cfName));
     }
@@ -39,15 +39,15 @@ public void onCreateKeyspace(String ksName)
     {
     }
 
-    public void onCreateColumnFamly(String ksName, String cfName)
+    public void onCreateColumnFamily(String ksName, String cfName)
     {
     }
 
     public void onUpdateKeyspace(String ksName)
     {
     }
 
-    public void onUpdateColumnFamly(String ksName, String cfName)
+    public void onUpdateColumnFamily(String ksName, String cfName)
     {
     }
 }

File: src/java/org/apache/cassandra/service/IMigrationListener.java
Patch:
@@ -20,11 +20,11 @@
 public interface IMigrationListener
 {
     public void onCreateKeyspace(String ksName);
-    public void onCreateColumnFamly(String ksName, String cfName);
+    public void onCreateColumnFamily(String ksName, String cfName);
 
     public void onUpdateKeyspace(String ksName);
-    public void onUpdateColumnFamly(String ksName, String cfName);
+    public void onUpdateColumnFamily(String ksName, String cfName);
 
     public void onDropKeyspace(String ksName);
-    public void onDropColumnFamly(String ksName, String cfName);
+    public void onDropColumnFamily(String ksName, String cfName);
 }

File: src/java/org/apache/cassandra/service/MigrationManager.java
Patch:
@@ -169,7 +169,7 @@ public void notifyCreateKeyspace(KSMetaData ksm)
     public void notifyCreateColumnFamily(CFMetaData cfm)
     {
         for (IMigrationListener listener : listeners)
-            listener.onCreateColumnFamly(cfm.ksName, cfm.cfName);
+            listener.onCreateColumnFamily(cfm.ksName, cfm.cfName);
     }
 
     public void notifyUpdateKeyspace(KSMetaData ksm)
@@ -181,7 +181,7 @@ public void notifyUpdateKeyspace(KSMetaData ksm)
     public void notifyUpdateColumnFamily(CFMetaData cfm)
     {
         for (IMigrationListener listener : listeners)
-            listener.onUpdateColumnFamly(cfm.ksName, cfm.cfName);
+            listener.onUpdateColumnFamily(cfm.ksName, cfm.cfName);
     }
 
     public void notifyDropKeyspace(KSMetaData ksm)
@@ -193,7 +193,7 @@ public void notifyDropKeyspace(KSMetaData ksm)
     public void notifyDropColumnFamily(CFMetaData cfm)
     {
         for (IMigrationListener listener : listeners)
-            listener.onDropColumnFamly(cfm.ksName, cfm.cfName);
+            listener.onDropColumnFamily(cfm.ksName, cfm.cfName);
     }
 
     public static void announceNewKeyspace(KSMetaData ksm) throws ConfigurationException

File: src/java/org/apache/cassandra/transport/Server.java
Patch:
@@ -327,7 +327,7 @@ public void onCreateKeyspace(String ksName)
             server.connectionTracker.send(new Event.SchemaChange(Event.SchemaChange.Change.CREATED, ksName));
         }
 
-        public void onCreateColumnFamly(String ksName, String cfName)
+        public void onCreateColumnFamily(String ksName, String cfName)
         {
             server.connectionTracker.send(new Event.SchemaChange(Event.SchemaChange.Change.CREATED, ksName, cfName));
         }
@@ -337,7 +337,7 @@ public void onUpdateKeyspace(String ksName)
             server.connectionTracker.send(new Event.SchemaChange(Event.SchemaChange.Change.UPDATED, ksName));
         }
 
-        public void onUpdateColumnFamly(String ksName, String cfName)
+        public void onUpdateColumnFamily(String ksName, String cfName)
         {
             server.connectionTracker.send(new Event.SchemaChange(Event.SchemaChange.Change.UPDATED, ksName, cfName));
         }
@@ -347,7 +347,7 @@ public void onDropKeyspace(String ksName)
             server.connectionTracker.send(new Event.SchemaChange(Event.SchemaChange.Change.DROPPED, ksName));
         }
 
-        public void onDropColumnFamly(String ksName, String cfName)
+        public void onDropColumnFamily(String ksName, String cfName)
         {
             server.connectionTracker.send(new Event.SchemaChange(Event.SchemaChange.Change.DROPPED, ksName, cfName));
         }

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -52,6 +52,7 @@
 import org.apache.cassandra.exceptions.RequestValidationException;
 import org.apache.cassandra.exceptions.SyntaxException;
 import org.apache.cassandra.io.compress.CompressionParameters;
+import org.apache.cassandra.io.compress.LZ4Compressor;
 import org.apache.cassandra.io.compress.SnappyCompressor;
 import org.apache.cassandra.io.sstable.Descriptor;
 import org.apache.cassandra.thrift.IndexType;
@@ -86,7 +87,7 @@ public final class CFMetaData
     public final static boolean DEFAULT_POPULATE_IO_CACHE_ON_FLUSH = false;
 
     // Note that this is the default only for user created tables
-    public final static String DEFAULT_COMPRESSOR = SnappyCompressor.isAvailable() ? SnappyCompressor.class.getCanonicalName() : null;
+    public final static String DEFAULT_COMPRESSOR = LZ4Compressor.class.getCanonicalName();
 
     @Deprecated
     public static final CFMetaData OldStatusCf = newSystemMetadata(Table.SYSTEM_KS, SystemTable.OLD_STATUS_CF, 0, "unused", BytesType.instance, null);

File: src/java/org/apache/cassandra/db/DataTracker.java
Patch:
@@ -506,7 +506,7 @@ public View replaceFlushed(Memtable flushedMemtable, SSTableReader newSSTable)
         {
             Set<Memtable> newPending = ImmutableSet.copyOf(Sets.difference(memtablesPendingFlush, Collections.singleton(flushedMemtable)));
             Set<SSTableReader> newSSTables = newSSTable == null
-                                            ? Collections.<SSTableReader>emptySet()
+                                            ? sstables
                                             : newSSTables(newSSTable);
             SSTableIntervalTree intervalTree = buildIntervalTree(newSSTables);
             return new View(memtable, newPending, newSSTables, compacting, intervalTree);

File: src/java/org/apache/cassandra/service/AntiEntropyService.java
Patch:
@@ -687,9 +687,10 @@ public void runMayThrow() throws Exception
             {
                 if (!FailureDetector.instance.isAlive(endpoint))
                 {
+                    String message = String.format("Cannot proceed on repair because a neighbor (%s) is dead: session failed", endpoint);
                     differencingDone.signalAll();
-                    logger.info(String.format("[repair #%s] Cannot proceed on repair because a neighbor (%s) is dead: session failed", getName(), endpoint));
-                    return;
+                    logger.error(String.format("[repair #%s] ", getName()) + message);
+                    throw new IOException(message);
                 }
 
                 if (Gossiper.instance.getVersion(endpoint) < MessagingService.VERSION_11 && isSequential)

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -922,7 +922,7 @@ else if (inner instanceof UnknownHostException)
                 }
             }
         }
-        System.exit(0);
+        System.exit(probe.isFailed() ? 1 : 0);
     }
 
     private static Throwable findInnermostThrowable(Throwable ex)

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -141,7 +141,7 @@ protected enum ColumnFamilyArgument
         MEMTABLE_FLUSH_PERIOD_IN_MS,
         CACHING,
         DEFAULT_TIME_TO_LIVE,
-        SPECULATIVE_RETRY
+        SPECULATIVE_RETRY,
         POPULATE_IO_CACHE_ON_FLUSH
     }
 

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -117,7 +117,6 @@ public final class CFMetaData
                                                                   + "strategy_options text"
                                                                   + ") WITH COMPACT STORAGE AND COMMENT='keyspace definitions' AND gc_grace_seconds=8640");
     public static final CFMetaData SchemaColumnFamiliesCf = compile(9, "CREATE TABLE " + SystemTable.SCHEMA_COLUMNFAMILIES_CF + "("
-<<<<<<< HEAD
                                                                        + "keyspace_name text,"
                                                                        + "columnfamily_name text,"
                                                                        + "id int,"

File: src/java/org/apache/cassandra/cql3/operations/Operation.java
Patch:
@@ -41,7 +41,7 @@ public void execute(ColumnFamily cf,
                         UpdateParameters params,
                         List<Pair<ByteBuffer, Column>> list) throws InvalidRequestException;
 
-    public void addBoundNames(ColumnSpecification column, ColumnSpecification[] boundNames) throws InvalidRequestException;
+    public Operation validateAndAddBoundNames(ColumnSpecification column, ColumnSpecification[] boundNames) throws InvalidRequestException;
 
     public List<Term> getValues();
 

File: src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java
Patch:
@@ -43,12 +43,12 @@ public static enum Type
     }
 
     public final Type oType;
-    public final ParsedType validator;
+    public final CQL3Type validator;
     public final ColumnIdentifier columnName;
     private final CFPropDefs cfProps;
     private final Map<ColumnIdentifier, ColumnIdentifier> renames;
 
-    public AlterTableStatement(CFName name, Type type, ColumnIdentifier columnName, ParsedType validator, CFPropDefs cfProps, Map<ColumnIdentifier, ColumnIdentifier> renames)
+    public AlterTableStatement(CFName name, Type type, ColumnIdentifier columnName, CQL3Type validator, CFPropDefs cfProps, Map<ColumnIdentifier, ColumnIdentifier> renames)
     {
         super(name);
         this.oType = type;

File: src/java/org/apache/cassandra/db/SystemTable.java
Patch:
@@ -204,7 +204,7 @@ private static String positionAsMapEntry(ColumnFamilyStore cfs, ReplayPosition p
         {
             throw new RuntimeException(e);
         }
-        return String.format("{'%s': '%s'}",
+        return String.format("{%s: 0x%s}",
                              cfs.metadata.cfId,
                              ByteBufferUtil.bytesToHex(ByteBuffer.wrap(out.getData(), 0, out.getLength())));
     }
@@ -262,7 +262,7 @@ public static synchronized void updatePeerInfo(InetAddress ep, String columnName
         if (ep.equals(FBUtilities.getBroadcastAddress()))
             return;
 
-        String req = "INSERT INTO system.%s (peer, %s) VALUES ('%s', '%s')";
+        String req = "INSERT INTO system.%s (peer, %s) VALUES ('%s', %s)";
         processInternal(String.format(req, PEERS_CF, columnName, ep.getHostAddress(), value));
     }
 
@@ -570,7 +570,7 @@ public static UUID getLocalHostId()
         hostId = UUID.randomUUID();
         logger.warn("No host ID found, created {} (Note: This should happen exactly once per node).", hostId);
 
-        req = "INSERT INTO system.%s (key, host_id) VALUES ('%s', '%s')";
+        req = "INSERT INTO system.%s (key, host_id) VALUES ('%s', %s)";
         processInternal(String.format(req, LOCAL_CF, LOCAL_KEY, hostId));
         return hostId;
     }

File: src/java/org/apache/cassandra/dht/IPartitioner.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.Map;
 
 import org.apache.cassandra.db.DecoratedKey;
+import org.apache.cassandra.db.marshal.AbstractType;
 
 public interface IPartitioner<T extends Token>
 {
@@ -84,5 +85,7 @@ public interface IPartitioner<T extends Token>
      */
     public Map<Token, Float> describeOwnership(List<Token> sortedTokens);
 
+    public AbstractType<?> getTokenValidator();
+
     public <R extends RingPosition> R minValue(Class<R> klass);
 }

File: src/java/org/apache/cassandra/cql3/operations/Operation.java
Patch:
@@ -41,7 +41,7 @@ public void execute(ColumnFamily cf,
                         UpdateParameters params,
                         List<Pair<ByteBuffer, IColumn>> list) throws InvalidRequestException;
 
-    public void addBoundNames(ColumnSpecification column, ColumnSpecification[] boundNames) throws InvalidRequestException;
+    public Operation validateAndAddBoundNames(ColumnSpecification column, ColumnSpecification[] boundNames) throws InvalidRequestException;
 
     public List<Term> getValues();
 

File: src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java
Patch:
@@ -43,12 +43,12 @@ public static enum Type
     }
 
     public final Type oType;
-    public final ParsedType validator;
+    public final CQL3Type validator;
     public final ColumnIdentifier columnName;
     private final CFPropDefs cfProps;
     private final Map<ColumnIdentifier, ColumnIdentifier> renames;
 
-    public AlterTableStatement(CFName name, Type type, ColumnIdentifier columnName, ParsedType validator, CFPropDefs cfProps, Map<ColumnIdentifier, ColumnIdentifier> renames)
+    public AlterTableStatement(CFName name, Type type, ColumnIdentifier columnName, CQL3Type validator, CFPropDefs cfProps, Map<ColumnIdentifier, ColumnIdentifier> renames)
     {
         super(name);
         this.oType = type;

File: src/java/org/apache/cassandra/db/SystemTable.java
Patch:
@@ -205,7 +205,7 @@ private static String positionAsMapEntry(ColumnFamilyStore cfs, ReplayPosition p
         {
             throw new RuntimeException(e);
         }
-        return String.format("{'%s': '%s'}",
+        return String.format("{%s: 0x%s}",
                              cfs.metadata.cfId,
                              ByteBufferUtil.bytesToHex(ByteBuffer.wrap(out.getData(), 0, out.getLength())));
     }
@@ -263,7 +263,7 @@ public static synchronized void updatePeerInfo(InetAddress ep, String columnName
         if (ep.equals(FBUtilities.getBroadcastAddress()))
             return;
 
-        String req = "INSERT INTO system.%s (peer, %s) VALUES ('%s', '%s')";
+        String req = "INSERT INTO system.%s (peer, %s) VALUES ('%s', %s)";
         processInternal(String.format(req, PEERS_CF, columnName, ep.getHostAddress(), value));
     }
 
@@ -571,7 +571,7 @@ public static UUID getLocalHostId()
         hostId = UUID.randomUUID();
         logger.warn("No host ID found, created {} (Note: This should happen exactly once per node).", hostId);
 
-        req = "INSERT INTO system.%s (key, host_id) VALUES ('%s', '%s')";
+        req = "INSERT INTO system.%s (key, host_id) VALUES ('%s', %s)";
         processInternal(String.format(req, LOCAL_CF, LOCAL_KEY, hostId));
         return hostId;
     }

File: src/java/org/apache/cassandra/dht/IPartitioner.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.Map;
 
 import org.apache.cassandra.db.DecoratedKey;
+import org.apache.cassandra.db.marshal.AbstractType;
 
 public interface IPartitioner<T extends Token>
 {
@@ -84,5 +85,7 @@ public interface IPartitioner<T extends Token>
      */
     public Map<Token, Float> describeOwnership(List<Token> sortedTokens);
 
+    public AbstractType<?> getTokenValidator();
+
     public <R extends RingPosition> R minValue(Class<R> klass);
 }

File: src/java/org/apache/cassandra/db/Directories.java
Patch:
@@ -126,7 +126,7 @@ public File getLocationForDisk(File dataDirectory)
     {
         for (File dir : sstableDirectories)
         {
-            if (FileUtils.getCanonicalPath(dir).startsWith(FileUtils.getCanonicalPath(dataDirectory)))
+            if (dir.getAbsolutePath().startsWith(dataDirectory.getAbsolutePath()))
                 return dir;
         }
         return null;

File: src/java/org/apache/cassandra/thrift/ThriftValidation.java
Patch:
@@ -511,7 +511,7 @@ else if (range.start_key != null && range.end_token != null)
         {
             // start_token/end_token can wrap, but key/token should not
             RowPosition stop = p.getTokenFactory().fromString(range.end_token).maxKeyBound(p);
-            if (RowPosition.forKey(range.start_key, p).compareTo(stop) > 0)
+            if (RowPosition.forKey(range.start_key, p).compareTo(stop) > 0 && !stop.isMinimum())
                 throw new InvalidRequestException("Start key's token sorts after end token");
         }
 

File: src/java/org/apache/cassandra/db/compaction/AbstractCompactionStrategy.java
Patch:
@@ -29,8 +29,6 @@
 import org.apache.cassandra.io.sstable.Component;
 import org.apache.cassandra.io.sstable.SSTableReader;
 
-import com.google.common.collect.Sets;
-
 /**
  * Pluggable compaction strategy determines how SSTables get merged.
  *
@@ -214,7 +212,7 @@ public static Map<String, String> validateOptions(Map<String, String> options) t
                 float thresholdValue = Float.parseFloat(threshold);
                 if (thresholdValue < 0)
                 {
-                    throw new ConfigurationException(String.format("%s must be greater than 0, but was %d", TOMBSTONE_THRESHOLD_OPTION, thresholdValue));
+                    throw new ConfigurationException(String.format("%s must be greater than 0, but was %f", TOMBSTONE_THRESHOLD_OPTION, thresholdValue));
                 }
             }
             catch (NumberFormatException e)

File: src/java/org/apache/cassandra/utils/SemanticVersion.java
Patch:
@@ -143,7 +143,7 @@ public SemanticVersion findSupportingVersion(SemanticVersion... versions)
 
     public boolean isSupportedBy(SemanticVersion version)
     {
-        return major == version.major && minor <= version.minor;
+        return major == version.major && minor <= version.minor && patch <= version.patch;
     }
 
     private static int compareIdentifiers(String[] ids1, String[] ids2, int defaultPred)

File: test/unit/org/apache/cassandra/utils/SemanticVersionTest.java
Patch:
@@ -71,7 +71,7 @@ public void testIsSupportedBy()
         v1 = new SemanticVersion("1.2.3");
         v2 = new SemanticVersion("1.2.4");
         assert v1.isSupportedBy(v2);
-        assert v2.isSupportedBy(v1);
+        assert !v2.isSupportedBy(v1);
 
         v1 = new SemanticVersion("1.2.3");
         v2 = new SemanticVersion("1.3.3");

File: src/java/org/apache/cassandra/db/compaction/LazilyCompactedRow.java
Patch:
@@ -91,7 +91,8 @@ public LazilyCompactedRow(CompactionController controller, List<? extends ICount
         // (however, if there are zero columns, iterator() will not be called by ColumnIndexer and reducer will be null)
         columnCount = reducer == null ? 0 : reducer.size;
         columnSerializedSize = reducer == null ? 0 : reducer.serializedSize;
-        maxTimestamp = reducer == null ? Long.MIN_VALUE : reducer.maxTimestampSeen;
+        long rowTombstone = emptyColumnFamily.getMarkedForDeleteAt();
+        maxTimestamp = reducer == null ? rowTombstone : Math.max(rowTombstone, reducer.maxTimestampSeen);
         reducer = null;
     }
 

File: src/java/org/apache/cassandra/io/sstable/SSTableMetadata.java
Patch:
@@ -225,7 +225,7 @@ public SSTableMetadata deserialize(DataInputStream dis, Descriptor desc) throws
             }
             long maxTimestamp = desc.containsTimestamp() ? dis.readLong() : Long.MIN_VALUE;
             if (!desc.tracksMaxTimestamp) // see javadoc to Descriptor.containsTimestamp
-                maxTimestamp = Long.MIN_VALUE;
+                maxTimestamp = Long.MAX_VALUE;
             double compressionRatio = desc.hasCompressionRatio
                                     ? dis.readDouble()
                                     : Double.MIN_VALUE;

File: src/java/org/apache/cassandra/net/OutboundTcpConnection.java
Patch:
@@ -133,7 +133,7 @@ public void run()
             if (m == CLOSE_SENTINEL)
             {
                 disconnect();
-                if (!isStopped)
+                if (isStopped)
                     break;
                 continue;
             }

File: src/java/org/apache/cassandra/net/OutboundTcpConnectionPool.java
Patch:
@@ -68,7 +68,7 @@ OutboundTcpConnection getConnection(MessageOut msg)
     void reset()
     {
         for (OutboundTcpConnection conn : new OutboundTcpConnection[] { cmdCon, ackCon })
-            conn.closeSocket();
+            conn.closeSocket(false);
     }
 
     public void resetToNewerVersion(int version)
@@ -161,9 +161,9 @@ public void close()
     {
         // these null guards are simply for tests
         if (ackCon != null)
-            ackCon.closeSocket();
+            ackCon.closeSocket(true);
         if (cmdCon != null)
-            cmdCon.closeSocket();
+            cmdCon.closeSocket(true);
         metrics.release();
     }
 }

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -305,9 +305,9 @@ public void destroyConnectionPool(InetAddress to)
             return;
         // these null guards are simply for tests
         if (cp.ackCon != null)
-            cp.ackCon.closeSocket();
+            cp.ackCon.closeSocket(true);
         if (cp.cmdCon != null)
-            cp.cmdCon.closeSocket();
+            cp.cmdCon.closeSocket(true);
         connectionManagers_.remove(to);
         recentTimeoutsPerHost.remove(to.getHostAddress());
         timeoutsPerHost.remove(to.getHostAddress());

File: src/java/org/apache/cassandra/net/OutboundTcpConnectionPool.java
Patch:
@@ -63,7 +63,7 @@ OutboundTcpConnection getConnection(Message msg)
     synchronized void reset()
     {
         for (OutboundTcpConnection con : new OutboundTcpConnection[] { cmdCon, ackCon })
-            con.closeSocket();
+            con.closeSocket(false);
     }
 
     /**

File: test/unit/org/apache/cassandra/service/RelocateTest.java
Patch:
@@ -32,6 +32,7 @@
 import java.util.UUID;
 
 import org.apache.cassandra.SchemaLoader;
+import org.apache.cassandra.db.SystemTable;
 import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.config.KSMetaData;
 import org.apache.cassandra.config.Schema;
@@ -186,6 +187,7 @@ public void testRelocationSuccess() throws UnknownHostException
 
         // Create a list of the endpoint's existing tokens, and add the relocatee to it.
         List<Token> tokens = new ArrayList<Token>(tmd.getTokens(relocator));
+        SystemTable.updateTokens(tokens);
         tokens.add(relocatee);
 
         // Send a normal status, then ensure all is copesetic.

File: src/java/org/apache/cassandra/io/sstable/SSTableReader.java
Patch:
@@ -353,7 +353,9 @@ void loadBloomFilter() throws IOException
      */
     private void load(boolean recreatebloom, Set<DecoratedKey> keysToLoadInCache) throws IOException
     {
-        boolean cacheLoading = keyCache != null && !keysToLoadInCache.isEmpty();
+        boolean cacheLoading = !keysToLoadInCache.isEmpty();
+        if (cacheLoading && keyCache == null)
+            keyCache = CacheService.instance.keyCache;
 
         SegmentedFile.Builder ibuilder = SegmentedFile.getBuilder(DatabaseDescriptor.getIndexAccessMode());
         SegmentedFile.Builder dbuilder = compression

File: src/java/org/apache/cassandra/cql/AlterTableStatement.java
Patch:
@@ -69,7 +69,7 @@ public CFMetaData getCFMetaData(String keyspace) throws ConfigurationException,
         CFMetaData cfm = meta.clone();
 
         ByteBuffer columnName = this.oType == OperationType.OPTS ? null
-                                                                 : meta.comparator.fromString(this.columnName);
+                                                                 : meta.comparator.fromStringCQL2(this.columnName);
 
         switch (oType)
         {

File: src/java/org/apache/cassandra/cql/CreateColumnFamilyStatement.java
Patch:
@@ -131,7 +131,7 @@ private Map<ByteBuffer, ColumnDefinition> getColumns(AbstractType<?> comparator)
         {
             try
             {
-                ByteBuffer columnName = comparator.fromString(col.getKey().getText());
+                ByteBuffer columnName = comparator.fromStringCQL2(col.getKey().getText());
                 String validatorClassName = CFPropDefs.comparators.containsKey(col.getValue())
                                           ? CFPropDefs.comparators.get(col.getValue())
                                           : col.getValue();

File: src/java/org/apache/cassandra/cql/Term.java
Patch:
@@ -90,7 +90,7 @@ public ByteBuffer getByteBuffer(AbstractType<?> validator, List<ByteBuffer> vari
     {
         try
         {
-            if (!isBindMarker()) return validator.fromString(text);
+            if (!isBindMarker()) return validator.fromStringCQL2(text);
 
             // must be a marker term so check for a CqlBindValue stored in the term
             if (bindIndex == null)

File: src/java/org/apache/cassandra/cql3/QueryProcessor.java
Patch:
@@ -41,7 +41,7 @@
 
 public class QueryProcessor
 {
-    public static final SemanticVersion CQL_VERSION = new SemanticVersion("3.0.0");
+    public static final SemanticVersion CQL_VERSION = new SemanticVersion("3.0.1");
 
     private static final Logger logger = LoggerFactory.getLogger(QueryProcessor.class);
 

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -1144,7 +1144,7 @@ public static List<Row> getRangeSlice(RangeSliceCommand command, ConsistencyLeve
                 {
                     nextRange = ranges.get(i);
                     nextEndpoints = getLiveSortedEndpoints(table, nextRange.right);
-                    nextFilteredEndpoints = consistency_level.filterForQuery(table, liveEndpoints);
+                    nextFilteredEndpoints = consistency_level.filterForQuery(table, nextEndpoints);
 
                     List<InetAddress> merged = intersection(liveEndpoints, nextEndpoints);
 

File: src/java/org/apache/cassandra/db/filter/IDiskAtomFilter.java
Patch:
@@ -75,6 +75,8 @@ public interface IDiskAtomFilter
 
     public int getLiveCount(ColumnFamily cf);
 
+    public IDiskAtomFilter cloneShallow();
+
     public static class Serializer implements IVersionedSerializer<IDiskAtomFilter>
     {
         public static Serializer instance = new Serializer();

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -434,7 +434,9 @@ private Map<ByteBuffer, List<ColumnOrSuperColumn>> multigetSliceInternal(String
         for (ByteBuffer key: keys)
         {
             ThriftValidation.validateKey(metadata, key);
-            commands.add(ReadCommand.create(keyspace, key, column_parent.getColumn_family(), filter));
+            // Note that we should not share a slice filter amongst the command, due to SliceQueryFilter not  being immutable
+            // due to its columnCounter used by the lastCounted() method (also see SelectStatement.getSliceCommands)
+            commands.add(ReadCommand.create(keyspace, key, column_parent.getColumn_family(), filter.cloneShallow()));
         }
 
         return getSlice(commands, column_parent.isSetSuper_column(), consistencyLevel);

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -92,7 +92,7 @@ public class Config
     public Integer rpc_recv_buff_size_in_bytes;
 
     public Boolean start_native_transport = false;
-    public Integer native_transport_port = 8000;
+    public Integer native_transport_port = 9042;
     public Integer native_transport_min_threads = 16;
     public Integer native_transport_max_threads = 128;
 

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -89,7 +89,7 @@ public class Config
     public Integer rpc_recv_buff_size_in_bytes;
 
     public Boolean start_native_transport = false;
-    public Integer native_transport_port = 8000;
+    public Integer native_transport_port = 9042;
     public Integer native_transport_min_threads = 16;
     public Integer native_transport_max_threads = 128;
 

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -164,7 +164,7 @@ public class Config
     public String memory_allocator = NativeAllocator.class.getSimpleName();
     public boolean populate_io_cache_on_flush = false;
 
-    public boolean inter_dc_tcp_nodelay = true;
+    public boolean inter_dc_tcp_nodelay = false;
 
     private static boolean loadYaml = true;
     private static boolean outboundBindAny = false;

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -450,8 +450,8 @@ public int get_count(ByteBuffer key, ColumnParent column_parent, SlicePredicate
             pages++;
             // We're done if either:
             //   - We've querying the number of columns requested by the user
-            //   - The last page wasn't full
-            if (remaining == 0 || columns.size() < predicate.slice_range.count)
+            //   - last fetched page only contains the column we already fetched
+            if (remaining == 0 || ((columns.size() == 1) && (firstName.equals(predicate.slice_range.start))))
                 break;
             else
                 predicate.slice_range.start = getName(columns.get(columns.size() - 1));

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -563,7 +563,7 @@ public void printColumnFamilyStats(PrintStream outs)
                 outs.println("\t\tWrite Count: " + cfstore.getWriteCount());
                 outs.println("\t\tWrite Latency: " + String.format("%01.3f", cfstore.getRecentWriteLatencyMicros() / 1000) + " ms.");
                 outs.println("\t\tPending Tasks: " + cfstore.getPendingTasks());
-                outs.println("\t\tBloom Filter False Postives: " + cfstore.getBloomFilterFalsePositives());
+                outs.println("\t\tBloom Filter False Positives: " + cfstore.getBloomFilterFalsePositives());
                 outs.println("\t\tBloom Filter False Ratio: " + String.format("%01.5f", cfstore.getRecentBloomFilterFalseRatio()));
                 outs.println("\t\tBloom Filter Space Used: " + cfstore.getBloomFilterDiskSpaceUsed());
                 outs.println("\t\tCompacted row minimum size: " + cfstore.getMinRowSize());

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -328,7 +328,7 @@ public Object apply(Pair<String, ExpiringMap.CacheableObject<CallbackInfo>> pair
                 {
                     assert expiredCallbackInfo.sentMessage != null;
                     RowMutation rm = (RowMutation) expiredCallbackInfo.sentMessage.payload;
-                    return StorageProxy.scheduleLocalHint(rm, expiredCallbackInfo.target, null, null);
+                    return StorageProxy.submitHint(rm, expiredCallbackInfo.target, null, null);
                 }
 
                 return null;

File: src/java/org/apache/cassandra/io/compress/CompressedRandomAccessReader.java
Patch:
@@ -90,7 +90,7 @@ private void decompressChunk(CompressionMetadata.Chunk chunk) throws IOException
 
         validBufferBytes = metadata.compressor().uncompress(compressed, 0, chunk.length, buffer, 0);
 
-        if (metadata.parameters.crcChance > FBUtilities.threadLocalRandom().nextDouble())
+        if (metadata.parameters.getCrcCheckChance() > FBUtilities.threadLocalRandom().nextDouble())
         {
             checksum.update(buffer, 0, validBufferBytes);
 

File: src/java/org/apache/cassandra/db/compaction/AbstractCompactedRow.java
Patch:
@@ -21,6 +21,7 @@
  */
 
 
+import java.io.Closeable;
 import java.io.DataOutput;
 import java.io.IOException;
 import java.security.MessageDigest;
@@ -32,7 +33,7 @@
  * and can write a compacted version of those rows to an output stream.  It does
  * NOT necessarily require creating a merged CF object in memory.
  */
-public abstract class AbstractCompactedRow
+public abstract class AbstractCompactedRow implements Closeable
 {
     public final DecoratedKey<?> key;
 

File: src/java/org/apache/cassandra/db/compaction/CompactionTask.java
Patch:
@@ -154,7 +154,10 @@ public int execute(CompactionExecutorStatsCollector collector) throws IOExceptio
 
                 AbstractCompactedRow row = nni.next();
                 if (row.isEmpty())
+                {
+                    row.close();
                     continue;
+                }
 
                 long position = writer.append(row);
                 totalkeysWritten++;

File: src/java/org/apache/cassandra/db/compaction/LazilyCompactedRow.java
Patch:
@@ -193,7 +193,7 @@ public long maxTimestamp()
         return maxTimestamp;
     }
 
-    private void close()
+    public void close()
     {
         for (IColumnIterator row : rows)
         {

File: src/java/org/apache/cassandra/db/compaction/PrecompactedRow.java
Patch:
@@ -185,4 +185,6 @@ public ColumnFamily getFullColumnFamily()  throws IOException
     {
         return compactedCf;
     }
+
+    public void close() { }
 }

File: src/java/org/apache/cassandra/cql/CreateColumnFamilyStatement.java
Patch:
@@ -169,6 +169,9 @@ public CFMetaData getCFMetaData(String keyspace, List<ByteBuffer> variables) thr
                                      comparator,
                                      null);
 
+            if (CFMetaData.DEFAULT_COMPRESSOR != null && cfProps.compressionParameters.isEmpty())
+                cfProps.compressionParameters.put(CompressionParameters.SSTABLE_COMPRESSION, CFMetaData.DEFAULT_COMPRESSOR);
+
             newCFMD.comment(cfProps.getProperty(CFPropDefs.KW_COMMENT))
                    .readRepairChance(getPropertyDouble(CFPropDefs.KW_READREPAIRCHANCE, CFMetaData.DEFAULT_READ_REPAIR_CHANCE))
                    .dcLocalReadRepairChance(getPropertyDouble(CFPropDefs.KW_DCLOCALREADREPAIRCHANCE, CFMetaData.DEFAULT_DCLOCAL_READ_REPAIR_CHANCE))

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -370,7 +370,7 @@ private Token getTokenBound(Bound b, List<ByteBuffer> variables, IPartitioner<?>
         if (t == null)
             return p.getMinimumToken();
 
-        if (t.getType() == Term.Type.STRING)
+        if (t.getType() == Term.Type.STRING && !t.isToken)
         {
             try
             {

File: src/java/org/apache/cassandra/db/compaction/LeveledManifest.java
Patch:
@@ -127,7 +127,7 @@ private static void load(ColumnFamilyStore cfs, LeveledManifest manifest, Iterab
                     logger.debug("Old manifest present but corrupt", old);
                 }
             }
-            logger.warn("Manifest present but corrupt. Cassandra will re-level {} from scratch", cfs.columnFamily);
+            logger.warn("Manifest present but corrupt. Cassandra will re-level {} from scratch", cfs.getColumnFamilyName());
         }
     }
 

File: src/java/org/apache/cassandra/db/columniterator/SSTableNamesIterator.java
Patch:
@@ -234,7 +234,7 @@ private void readIndexedColumns(CFMetaData metadata,
         for (ByteBuffer name : filteredColumnNames)
         {
             int index = IndexHelper.indexFor(name, indexList, comparator, false, lastIndexIdx);
-            if (index == indexList.size())
+            if (index < 0 || index == indexList.size())
                 continue;
             IndexHelper.IndexInfo indexInfo = indexList.get(index);
             // Check the index block does contain the column names and that we haven't inserted this block yet.

File: src/java/org/apache/cassandra/service/MigrationManager.java
Patch:
@@ -220,6 +220,8 @@ public static void announceColumnFamilyUpdate(CFMetaData cfm) throws Configurati
         if (oldCfm == null)
             throw new ConfigurationException(String.format("Cannot update non existing column family '%s' in keyspace '%s'.", cfm.cfName, cfm.ksName));
 
+        oldCfm.validateCompatility(cfm);
+
         logger.info(String.format("Update ColumnFamily '%s/%s' From %s To %s", cfm.ksName, cfm.cfName, oldCfm, cfm));
         announce(oldCfm.toSchemaUpdate(cfm, FBUtilities.timestampMicros()));
     }

File: src/java/org/apache/cassandra/cql3/operations/Operation.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.List;
 
 import org.apache.cassandra.cql3.ColumnNameBuilder;
+import org.apache.cassandra.cql3.ColumnSpecification;
 import org.apache.cassandra.cql3.Term;
 import org.apache.cassandra.cql3.UpdateParameters;
 import org.apache.cassandra.db.ColumnFamily;
@@ -40,6 +41,8 @@ public void execute(ColumnFamily cf,
                         UpdateParameters params,
                         List<Pair<ByteBuffer, IColumn>> list) throws InvalidRequestException;
 
+    public void addBoundNames(ColumnSpecification column, ColumnSpecification[] boundNames) throws InvalidRequestException;
+
     public List<Term> getValues();
 
     public boolean requiresRead(AbstractType<?> validator);

File: src/java/org/apache/cassandra/cql3/statements/BatchStatement.java
Patch:
@@ -128,7 +128,7 @@ public Collection<? extends IMutation> getMutations(List<ByteBuffer> variables,
         return mutations.values();
     }
 
-    public ParsedStatement.Prepared prepare(CFDefinition.Name[] boundNames) throws InvalidRequestException
+    public ParsedStatement.Prepared prepare(ColumnSpecification[] boundNames) throws InvalidRequestException
     {
         // XXX: we use our knowledge that Modification don't create new statement upon call to prepare()
         for (ModificationStatement statement : statements)

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -211,5 +211,5 @@ protected Map<ByteBuffer, ColumnGroupMap> readRows(List<ByteBuffer> keys, Column
     protected abstract Collection<? extends IMutation> getMutations(List<ByteBuffer> variables, boolean local, ConsistencyLevel cl, long now)
     throws RequestExecutionException, RequestValidationException;
 
-    public abstract ParsedStatement.Prepared prepare(CFDefinition.Name[] boundNames) throws InvalidRequestException;
+    public abstract ParsedStatement.Prepared prepare(ColumnSpecification[] boundNames) throws InvalidRequestException;
 }

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -106,7 +106,6 @@ public class Config
     public Integer in_memory_compaction_limit_in_mb = 64;
     public Integer concurrent_compactors = FBUtilities.getAvailableProcessors();
     public volatile Integer compaction_throughput_mb_per_sec = 16;
-    public Integer compaction_throughput_mb_per_sec = 16;
     public Boolean multithreaded_compaction = false;
 
     public Integer max_streaming_retries = 3;

File: src/java/org/apache/cassandra/utils/FBUtilities.java
Patch:
@@ -73,7 +73,7 @@ public static int getAvailableProcessors()
         if (System.getProperty("cassandra.available_processors") != null)
             return Integer.parseInt(System.getProperty("cassandra.available_processors"));
         else
-            return FBUtilities.getAvailableProcessors();
+            return Runtime.getRuntime().availableProcessors();
     }
 
     private static final ThreadLocal<MessageDigest> localMD5Digest = new ThreadLocal<MessageDigest>()

File: src/java/org/apache/cassandra/io/compress/CompressionParameters.java
Patch:
@@ -56,6 +56,7 @@ public static CompressionParameters create(Map<? extends CharSequence, ? extends
         String chunkLength = options.get(CHUNK_LENGTH_KB);
         options.remove(SSTABLE_COMPRESSION);
         options.remove(CHUNK_LENGTH_KB);
+        options.remove(CRC_CHECK_CHANCE);
         CompressionParameters cp = new CompressionParameters(sstableCompressionClass, parseChunkLength(chunkLength), options);
         cp.validate();
         return cp;

File: src/java/org/apache/cassandra/io/compress/CompressionParameters.java
Patch:
@@ -56,6 +56,7 @@ public static CompressionParameters create(Map<? extends CharSequence, ? extends
         String chunkLength = options.get(CHUNK_LENGTH_KB);
         options.remove(SSTABLE_COMPRESSION);
         options.remove(CHUNK_LENGTH_KB);
+        options.remove(CRC_CHECK_CHANCE);
         CompressionParameters cp = new CompressionParameters(sstableCompressionClass, parseChunkLength(chunkLength), options);
         cp.validate();
         return cp;

File: src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java
Patch:
@@ -340,7 +340,8 @@ else if (type == Type.COUNTER)
                     case COLUMN_ALIAS:
                         if (processedKeys.containsKey(name.name))
                             throw new InvalidRequestException(String.format("Multiple definitions found for PRIMARY KEY part %s", name));
-                        if (operation.getType() != Operation.Type.COLUMN)
+                        // We know collection are not accepted for key and column aliases
+                        if (operation.getType() != Operation.Type.COLUMN && operation.getType() != Operation.Type.PREPARED)
                             throw new InvalidRequestException(String.format("Invalid definition for %s, not a collection type", name));
                         processedKeys.put(name.name, operation.getValues());
                         break;

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -531,7 +531,7 @@ public AbstractType<?> getComparatorFor(ByteBuffer superColumnName)
     public double getBloomFilterFpChance()
     {
         return bloomFilterFpChance == null
-               ? compactionStrategyClass == LeveledCompactionStrategy.class ? 1.0 : 0.01
+               ? compactionStrategyClass == LeveledCompactionStrategy.class ? 0.1 : 0.01
                : bloomFilterFpChance;
     }
 

File: src/java/org/apache/cassandra/cql/AlterTableStatement.java
Patch:
@@ -186,6 +186,7 @@ public static void applyPropertiesToCFMetadata(CFMetaData cfm, CFPropDefs cfProp
         cfm.minCompactionThreshold(cfProps.getPropertyInt(CFPropDefs.KW_MINCOMPACTIONTHRESHOLD, cfm.getMinCompactionThreshold()));
         cfm.maxCompactionThreshold(cfProps.getPropertyInt(CFPropDefs.KW_MAXCOMPACTIONTHRESHOLD, cfm.getMaxCompactionThreshold()));
         cfm.caching(CFMetaData.Caching.fromString(cfProps.getPropertyString(CFPropDefs.KW_CACHING, cfm.getCaching().toString())));
+        cfm.defaultTimeToLive(cfProps.getPropertyInt(CFPropDefs.KW_DEFAULT_TIME_TO_LIVE, cfm.getDefaultTimeToLive()));
         cfm.bloomFilterFpChance(cfProps.getPropertyDouble(CFPropDefs.KW_BF_FP_CHANCE, cfm.getBloomFilterFpChance()));
         cfm.memtableFlushPeriod(cfProps.getPropertyInt(CFPropDefs.KW_MEMTABLE_FLUSH_PERIOD, cfm.getMemtableFlushPeriod()));
 

File: src/java/org/apache/cassandra/cql/CreateColumnFamilyStatement.java
Patch:
@@ -193,7 +193,8 @@ public CFMetaData getCFMetaData(String keyspace, List<ByteBuffer> variables) thr
                    .compressionParameters(CompressionParameters.create(cfProps.compressionParameters))
                    .caching(CFMetaData.Caching.fromString(getPropertyString(CFPropDefs.KW_CACHING, CFMetaData.DEFAULT_CACHING_STRATEGY.toString())))
                    .bloomFilterFpChance(getPropertyDouble(CFPropDefs.KW_BF_FP_CHANCE, null))
-                   .memtableFlushPeriod(getPropertyInt(CFPropDefs.KW_MEMTABLE_FLUSH_PERIOD, 0));
+                   .memtableFlushPeriod(getPropertyInt(CFPropDefs.KW_MEMTABLE_FLUSH_PERIOD, 0))
+                   .defaultTimeToLive(getPropertyInt(CFPropDefs.KW_DEFAULT_TIME_TO_LIVE, CFMetaData.DEFAULT_DEFAULT_TIME_TO_LIVE));
 
             // CQL2 can have null keyAliases
             if (keyAlias != null)

File: src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java
Patch:
@@ -99,7 +99,7 @@ public Collection<RowMutation> getMutations(List<ByteBuffer> variables, boolean
         Map<ByteBuffer, ColumnGroupMap> rows = toRead != null ? readRows(keys, builder, toRead, (CompositeType)cfDef.cfm.comparator, local, cl) : null;
 
         Collection<RowMutation> rowMutations = new ArrayList<RowMutation>(keys.size());
-        UpdateParameters params = new UpdateParameters(variables, getTimestamp(now), -1);
+        UpdateParameters params = new UpdateParameters(cfDef.cfm, variables, getTimestamp(now), -1);
 
         for (ByteBuffer key : keys)
             rowMutations.add(mutationForKey(cfDef, key, builder, isRange, params, rows == null ? null : rows.get(key)));

File: src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java
Patch:
@@ -133,7 +133,7 @@ public Collection<IMutation> getMutations(List<ByteBuffer> variables, boolean lo
         Map<ByteBuffer, ColumnGroupMap> rows = toRead != null ? readRows(keys, builder, toRead, (CompositeType)cfDef.cfm.comparator, local, cl) : null;
 
         Collection<IMutation> mutations = new LinkedList<IMutation>();
-        UpdateParameters params = new UpdateParameters(variables, getTimestamp(now), getTimeToLive());
+        UpdateParameters params = new UpdateParameters(cfDef.cfm, variables, getTimestamp(now), getTimeToLive());
 
         for (ByteBuffer key: keys)
             mutations.add(mutationForKey(cfDef, key, builder, params, rows == null ? null : rows.get(key), cl));

File: src/java/org/apache/cassandra/tools/NodeProbe.java
Patch:
@@ -590,7 +590,7 @@ public String getEndpoint()
             }
         }
 
-        throw new AssertionError("Could not find myself in the endpoint list, something is very wrong!");
+        throw new RuntimeException("Could not find myself in the endpoint list, something is very wrong!  Is the Cassandra node fully started?");
     }
 
     public String getDataCenter()

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -86,7 +86,8 @@ public class Config
 
     public Boolean start_native_transport = false;
     public Integer native_transport_port = 8000;
-    public Integer native_transport_max_threads = Integer.MAX_VALUE;
+    public Integer native_transport_min_threads = 16;
+    public Integer native_transport_max_threads = 128;
 
     public Integer thrift_max_message_length_in_mb = 16;
     public Integer thrift_framed_transport_size_in_mb = 15;

File: src/java/org/apache/cassandra/transport/Server.java
Patch:
@@ -106,6 +106,8 @@ public void run()
         factory = new NioServerSocketChannelFactory(Executors.newCachedThreadPool(), Executors.newCachedThreadPool());
         ServerBootstrap bootstrap = new ServerBootstrap(factory);
 
+        bootstrap.setOption("child.tcpNoDelay", true);
+
         // Set up the event pipeline factory.
         bootstrap.setPipelineFactory(new PipelineFactory(this));
 

File: src/java/org/apache/cassandra/transport/SimpleClient.java
Patch:
@@ -92,6 +92,8 @@ protected void establishConnection() throws IOException
                             Executors.newCachedThreadPool(),
                             Executors.newCachedThreadPool()));
 
+        bootstrap.setOption("tcpNoDelay", true);
+
         // Configure the pipeline factory.
         bootstrap.setPipelineFactory(new PipelineFactory());
         ChannelFuture future = bootstrap.connect(new InetSocketAddress(host, port));

File: src/java/org/apache/cassandra/io/sstable/SSTableReader.java
Patch:
@@ -173,7 +173,7 @@ private static SSTableReader open(Descriptor descriptor,
         String partitionerName = partitioner.getClass().getCanonicalName();
         if (sstableMetadata.partitioner != null && !partitionerName.equals(sstableMetadata.partitioner))
         {
-            logger.error(String.format("Cannot open %s because partitioner does not match %s != %s.  Please verify your partitioner in cassandra.yaml",
+            logger.error(String.format("Cannot open %s; partitioner %s does not match system partitioner %s.  Note that the default partitioner starting with Cassandra 1.2 is Murmur3Partitioner, so you will need to edit that to match your old partitioner if upgrading.",
                                        descriptor, sstableMetadata.partitioner, partitionerName));
             System.exit(1);
         }

File: src/java/org/apache/cassandra/cql3/statements/CreateColumnFamilyStatement.java
Patch:
@@ -209,6 +209,9 @@ public ParsedStatement.Prepared prepare() throws RequestValidationException
                     if (stmt.columns.isEmpty())
                         throw new InvalidRequestException("No definition found that is not part of the PRIMARY KEY");
 
+                    if (definedCollections != null)
+                        throw new InvalidRequestException("Collection types are not supported with COMPACT STORAGE");
+
                     stmt.comparator = CFDefinition.definitionType;
                 }
                 else

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -1115,6 +1115,9 @@ else if (restriction.eqValues.size() > 1 && i != stmt.columnRestrictions.length
 
             if (!stmt.parameters.orderings.isEmpty())
             {
+                if (!stmt.metadataRestrictions.isEmpty())
+                    throw new InvalidRequestException("ORDER BY with 2ndary indexes is not supported.");
+
                 if (stmt.isKeyRange())
                     throw new InvalidRequestException("ORDER BY is only supported when the partition key is restricted by an EQ or an IN.");
 

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -389,8 +389,6 @@ public synchronized void initClient(int delay) throws IOException, Configuration
         {
             throw new AssertionError(e);
         }
-
-        Schema.instance.updateVersionAndAnnounce();
     }
 
     public synchronized void initServer() throws ConfigurationException

File: tools/stress/src/org/apache/cassandra/stress/Session.java
Patch:
@@ -665,7 +665,7 @@ public void createKeySpaces()
             client.set_cql_version("3.0.0"); // just to create counter cf for cql3
 
             client.set_keyspace(KEYSPACE_NAME);
-            client.execute_cql_query(createCounterCFStatementForCQL3(), Compression.NONE);
+            client.execute_cql3_query(createCounterCFStatementForCQL3(), Compression.NONE, ConsistencyLevel.ONE);
 
             if (enable_cql)
                 client.set_cql_version(cqlVersion);

File: tools/stress/src/org/apache/cassandra/stress/StressAction.java
Patch:
@@ -235,7 +235,6 @@ public void run()
                         System.exit(-1);
                     }
 
-
                     output.println(e.getMessage());
                     returnCode = StressAction.FAILURE;
                     break;

File: src/java/org/apache/cassandra/db/CollationController.java
Patch:
@@ -99,8 +99,9 @@ private ColumnFamily collectTimeOrderedData()
 
             // avoid changing the filter columns of the original filter
             // (reduceNameFilter removes columns that are known to be irrelevant)
-            TreeSet<ByteBuffer> filterColumns = new TreeSet<ByteBuffer>(((NamesQueryFilter) filter.filter).columns);
-            QueryFilter reducedFilter = new QueryFilter(filter.key, filter.path, new NamesQueryFilter(filterColumns));
+            NamesQueryFilter namesFilter = (NamesQueryFilter) filter.filter;
+            TreeSet<ByteBuffer> filterColumns = new TreeSet<ByteBuffer>(namesFilter.columns);
+            QueryFilter reducedFilter = new QueryFilter(filter.key, filter.path, namesFilter.withUpdatedColumns(filterColumns));
 
             /* add the SSTables on disk */
             Collections.sort(view.sstables, SSTable.maxTimestampComparator);

File: src/java/org/apache/cassandra/db/SliceQueryPager.java
Patch:
@@ -52,9 +52,10 @@ public ColumnFamily next()
             return null;
 
         QueryPath path = new QueryPath(cfs.getColumnFamilyName());
-        QueryFilter filter = new QueryFilter(key, path, new SliceQueryFilter(slices, false, DEFAULT_PAGE_SIZE));
+        SliceQueryFilter sliceFilter = new SliceQueryFilter(slices, false, DEFAULT_PAGE_SIZE);
+        QueryFilter filter = new QueryFilter(key, path, sliceFilter);
         ColumnFamily cf = cfs.getColumnFamily(filter);
-        if (cf == null || cf.getLiveColumnCount() < DEFAULT_PAGE_SIZE)
+        if (cf == null || sliceFilter.getLiveCount(cf) < DEFAULT_PAGE_SIZE)
         {
             exhausted = true;
         }

File: src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java
Patch:
@@ -534,7 +534,7 @@ private List<SecondaryIndexSearcher> getIndexSearchersForQuery(List<IndexExpress
      * @param dataFilter the column range to restrict to
      * @return found indexed rows
      */
-    public List<Row> search(List<IndexExpression> clause, AbstractBounds<RowPosition> range, int maxResults, IDiskAtomFilter dataFilter, boolean maxIsColumns)
+    public List<Row> search(List<IndexExpression> clause, AbstractBounds<RowPosition> range, int maxResults, IDiskAtomFilter dataFilter, boolean countCQL3Rows)
     {
         List<SecondaryIndexSearcher> indexSearchers = getIndexSearchersForQuery(clause);
 
@@ -546,7 +546,7 @@ public List<Row> search(List<IndexExpression> clause, AbstractBounds<RowPosition
             throw new RuntimeException("Unable to search across multiple secondary index types");
 
 
-        return indexSearchers.get(0).search(clause, range, maxResults, dataFilter, maxIsColumns);
+        return indexSearchers.get(0).search(clause, range, maxResults, dataFilter, countCQL3Rows);
     }
 
     public Collection<SecondaryIndex> getIndexesByNames(Set<String> idxNames)

File: src/java/org/apache/cassandra/db/index/SecondaryIndexSearcher.java
Patch:
@@ -38,7 +38,7 @@ public SecondaryIndexSearcher(SecondaryIndexManager indexManager, Set<ByteBuffer
         this.baseCfs = indexManager.baseCfs;
     }
 
-    public abstract List<Row> search(List<IndexExpression> clause, AbstractBounds<RowPosition> range, int maxResults, IDiskAtomFilter dataFilter, boolean maxIsColumns);
+    public abstract List<Row> search(List<IndexExpression> clause, AbstractBounds<RowPosition> range, int maxResults, IDiskAtomFilter dataFilter, boolean countCQL3Rows);
 
     /**
      * @return true this index is able to handle given clauses.

File: src/java/org/apache/cassandra/db/index/keys/KeysSearcher.java
Patch:
@@ -75,10 +75,10 @@ public boolean isIndexing(List<IndexExpression> clause)
     }
 
     @Override
-    public List<Row> search(List<IndexExpression> clause, AbstractBounds<RowPosition> range, int maxResults, IDiskAtomFilter dataFilter, boolean maxIsColumns)
+    public List<Row> search(List<IndexExpression> clause, AbstractBounds<RowPosition> range, int maxResults, IDiskAtomFilter dataFilter, boolean countCQL3Rows)
     {
         assert clause != null && !clause.isEmpty();
-        ExtendedFilter filter = ExtendedFilter.create(baseCfs, dataFilter, clause, maxResults, maxIsColumns, false);
+        ExtendedFilter filter = ExtendedFilter.create(baseCfs, dataFilter, clause, maxResults, countCQL3Rows, false);
         return baseCfs.filter(getIndexedIterator(range, filter), filter);
     }
 

File: src/java/org/apache/cassandra/service/RangeSliceVerbHandler.java
Patch:
@@ -41,9 +41,9 @@ public static List<Row> executeLocally(RangeSliceCommand command) throws Executi
     {
         ColumnFamilyStore cfs = Table.open(command.keyspace).getColumnFamilyStore(command.column_family);
         if (cfs.indexManager.hasIndexFor(command.row_filter))
-            return cfs.search(command.row_filter, command.range, command.maxResults, command.predicate, command.maxIsColumns);
+            return cfs.search(command.row_filter, command.range, command.maxResults, command.predicate, command.countCQL3Rows);
         else
-            return cfs.getRangeSlice(command.super_column, command.range, command.maxResults, command.predicate, command.row_filter, command.maxIsColumns, command.isPaging);
+            return cfs.getRangeSlice(command.super_column, command.range, command.maxResults, command.predicate, command.row_filter, command.countCQL3Rows, command.isPaging);
     }
 
     public void doVerb(MessageIn<RangeSliceCommand> message, String id)

File: src/java/org/apache/cassandra/service/RowRepairResolver.java
Patch:
@@ -44,12 +44,12 @@ public class RowRepairResolver extends AbstractRowResolver
 {
     private int maxLiveCount = 0;
     public List<IAsyncResult> repairResults = Collections.emptyList();
-    private final SliceQueryFilter filter; // can be null if names query
+    private final IDiskAtomFilter filter;
 
     public RowRepairResolver(String table, ByteBuffer key, IDiskAtomFilter qFilter)
     {
         super(key, table);
-        this.filter = qFilter instanceof SliceQueryFilter ? (SliceQueryFilter)qFilter : null;
+        this.filter = qFilter;
     }
 
     /*
@@ -80,7 +80,7 @@ public Row resolve() throws DigestMismatchException, IOException
                 endpoints.add(message.from);
 
                 // compute maxLiveCount to prevent short reads -- see https://issues.apache.org/jira/browse/CASSANDRA-2643
-                int liveCount = cf == null ? 0 : (filter == null ? cf.getLiveColumnCount() : filter.getLiveCount(cf));
+                int liveCount = cf == null ? 0 : filter.getLiveCount(cf);
                 if (liveCount > maxLiveCount)
                     maxLiveCount = liveCount;
             }

File: test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
Patch:
@@ -948,7 +948,7 @@ private static void assertTotalColCount(Collection<Row> rows, int expectedCount)
         int columns = 0;
         for (Row row : rows)
         {
-            columns += row.getLiveColumnCount();
+            columns += row.getLiveCount(new SliceQueryFilter(ColumnSlice.ALL_COLUMNS_ARRAY, false, expectedCount));
         }
         assert columns == expectedCount : "Expected " + expectedCount + " live columns but got " + columns + ": " + rows;
     }

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -328,7 +328,9 @@ private int getLimit()
     {
         // Internally, we don't support exclusive bounds for slices. Instead,
         // we query one more element if necessary and exclude
-        return sliceRestriction != null && !sliceRestriction.isInclusive(Bound.START) ? parameters.limit + 1 : parameters.limit;
+        return sliceRestriction != null && !sliceRestriction.isInclusive(Bound.START) && parameters.limit != Integer.MAX_VALUE
+             ? parameters.limit + 1
+             : parameters.limit;
     }
 
     private Collection<ByteBuffer> getKeys(final List<ByteBuffer> variables) throws InvalidRequestException

File: src/java/org/apache/cassandra/db/CounterColumn.java
Patch:
@@ -113,7 +113,7 @@ public int serializedSize(TypeSizes typeSizes)
     @Override
     public IColumn diff(IColumn column)
     {
-        assert column instanceof CounterColumn : "Wrong class type.";
+        assert column instanceof CounterColumn : "Wrong class type. " + ((column == null) ? "null" : column.getClass().getSimpleName()) + " found.";
 
         if (timestamp() < column.timestamp())
             return column;

File: src/java/org/apache/cassandra/cql3/CFPropDefs.java
Patch:
@@ -47,7 +47,7 @@ public class CFPropDefs extends PropertyDefinitions
     public static final String KW_CACHING = "caching";
     public static final String KW_BF_FP_CHANCE = "bloom_filter_fp_chance";
 
-    public static final String KW_COMPACTION = "compaction";
+    public static final String KW_COMPACTION = "compaction_strategy";
     public static final String KW_COMPRESSION = "compression";
 
     public static final String COMPACTION_STRATEGY_CLASS_KEY = "class";

File: src/java/org/apache/cassandra/db/RowMutation.java
Patch:
@@ -483,6 +483,9 @@ public RowMutation deserializeFixingTimestamps(DataInput dis, int version) throw
                         cf.addColumn(new Column(column.name(), column.value(), now));
                 }
 
+                if (cf.isMarkedForDelete() && cf.isEmpty())
+                    continue;
+
                 fixedModifications.put(modification.getKey(), cf);
             }
 

File: src/java/org/apache/cassandra/streaming/StreamInSession.java
Patch:
@@ -127,7 +127,7 @@ public void retry(PendingFile remoteFile)
         retries++;
         if (retries > DatabaseDescriptor.getMaxStreamingRetries())
         {
-            logger.error(String.format("Failed streaming session %d from %s while receiving %s", getSessionId(), getHost().toString(), current),
+            logger.error(String.format("Failed streaming session %s from %s while receiving %s", getSessionId(), getHost().toString(), current),
                          new IllegalStateException("Too many retries for " + remoteFile));
             close(false);
             return;

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -113,6 +113,7 @@ private enum NodeCommand
         GETENDPOINTS,
         GETSSTABLES,
         GOSSIPINFO,
+        HELP,
         INFO,
         INVALIDATEKEYCACHE,
         INVALIDATEROWCACHE,
@@ -994,6 +995,7 @@ else if (inner instanceof UnknownHostException)
 
             switch (command)
             {
+                case HELP : printUsage(); break;
                 case RING :
                     if (arguments.length > 0) { nodeCmd.printRing(System.out, arguments[0]); }
                     else                      { nodeCmd.printRing(System.out, null); };

File: src/java/org/apache/cassandra/transport/messages/ErrorMessage.java
Patch:
@@ -147,7 +147,7 @@ public ChannelBuffer encode(ErrorMessage msg)
                                          : null;
 
                     int extraSize = isWrite  ? 2 + writeType.remaining() : 1;
-                    acb = ChannelBuffers.buffer(rteCl.writableBytes() + 8 + extraSize);
+                    acb = ChannelBuffers.buffer(rteCl.readableBytes() + 8 + extraSize);
 
                     acb.writeBytes(rteCl);
                     acb.writeInt(rte.received);

File: src/java/org/apache/cassandra/io/compress/CompressionMetadata.java
Patch:
@@ -203,9 +203,9 @@ public int compare(Chunk o1, Chunk o2)
             {
                 long offset = i * 8;
                 long chunkOffset = chunkOffsets.getLong(offset);
-                long nextChunkOffset = (i + 8 == chunkOffsets.size())
-                                               ? compressedFileLength
-                                               : chunkOffsets.getLong(offset + 8);
+                long nextChunkOffset = offset + 8 == chunkOffsets.size()
+                                     ? compressedFileLength
+                                     : chunkOffsets.getLong(offset + 8);
                 offsets.add(new Chunk(chunkOffset, (int) (nextChunkOffset - chunkOffset - 4))); // "4" bytes reserved for checksum
             }
         }

File: src/java/org/apache/cassandra/cli/CliMain.java
Patch:
@@ -218,7 +218,7 @@ public static void processStatementInteractive(String query)
 
             sessionState.err.println(errorTemplate + message);
 
-            if (!(e instanceof RuntimeException))
+            if (sessionState.debug || !(e instanceof RuntimeException))
                 e.printStackTrace(sessionState.err);
 
             if (sessionState.batch || sessionState.inFileMode())

File: src/java/org/apache/cassandra/hadoop/ConfigHelper.java
Patch:
@@ -133,7 +133,7 @@ public static void setOutputKeyspace(Configuration conf, String keyspace)
     }
 
     /**
-     * Set the column family for the input of this job.
+     * Set the column family for the output of this job.
      *
      * @param conf         Job configuration you are about to run
      * @param columnFamily
@@ -144,7 +144,7 @@ public static void setOutputColumnFamily(Configuration conf, String columnFamily
     }
 
     /**
-     * Set the column family for the input of this job.
+     * Set the column family for the output of this job.
      *
      * @param conf         Job configuration you are about to run
      * @param keyspace

File: src/java/org/apache/cassandra/tracing/TracingAppender.java
Patch:
@@ -49,6 +49,7 @@ protected void append(final LoggingEvent event)
             return;
 
         final int elapsed = state.elapsed();
+        final String threadName = event.getThreadName();
         final ByteBuffer eventId = ByteBufferUtil.bytes(UUIDGen.makeType1UUIDFromHost(FBUtilities.getBroadcastAddress()));
         StageManager.getStage(Stage.TRACING).execute(new WrappedRunnable()
         {
@@ -57,7 +58,7 @@ public void runMayThrow() throws Exception
                 CFMetaData cfMeta = CFMetaData.TraceEventsCf;
                 ColumnFamily cf = ColumnFamily.create(cfMeta);
                 addColumn(cf, buildName(cfMeta, eventId, bytes("source")), FBUtilities.getBroadcastAddress());
-                addColumn(cf, buildName(cfMeta, eventId, bytes("thread")), event.getThreadName());
+                addColumn(cf, buildName(cfMeta, eventId, bytes("thread")), threadName);
                 addColumn(cf, buildName(cfMeta, eventId, bytes("source_elapsed")), elapsed);
                 addColumn(cf, buildName(cfMeta, eventId, bytes("activity")), event.getMessage().toString());
                 RowMutation mutation = new RowMutation(Tracing.TRACE_KS, state.sessionIdBytes);

File: src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
Patch:
@@ -483,7 +483,7 @@ protected Pair<ByteBuffer, SortedMap<ByteBuffer, IColumn>> computeNext()
                 return endOfData();
 
             Pair<ByteBuffer, SortedMap<ByteBuffer, IColumn>> next = wideColumns.next();
-            lastColumn = next.right.values().iterator().next().name();
+            lastColumn = next.right.values().iterator().next().name().duplicate();
 
             maybeIncreaseRowCounter(next);
             return next;
@@ -556,7 +556,7 @@ public boolean next(ByteBuffer key, SortedMap<ByteBuffer, IColumn> value) throws
         if (this.nextKeyValue())
         {
             key.clear();
-            key.put(this.getCurrentKey());
+            key.put(this.getCurrentKey().duplicate());
             key.flip();
 
             value.clear();

File: src/java/org/apache/cassandra/db/HintedHandOffManager.java
Patch:
@@ -101,7 +101,7 @@ public class HintedHandOffManager implements HintedHandOffManagerMBean
                                                                                  Integer.MAX_VALUE,
                                                                                  TimeUnit.SECONDS,
                                                                                  new LinkedBlockingQueue<Runnable>(),
-                                                                                 new NamedThreadFactory("HintedHandoff", Thread.MIN_PRIORITY), "HintedHandoff");
+                                                                                 new NamedThreadFactory("HintedHandoff", Thread.MIN_PRIORITY), "internal");
 
     public void start()
     {

File: src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
Patch:
@@ -153,15 +153,14 @@ public void collectReducedColumns(IColumnContainer container, Iterator<IColumn>
             columnCounter.count(column, container);
 
             if (columnCounter.live() > count)
-            {
-                logger.debug("Read %s live columns and %s tombstoned", columnCounter.live(), columnCounter.ignored());
                 break;
-            }
 
             // but we need to add all non-gc-able columns to the result for read repair:
             if (QueryFilter.isRelevant(column, container, gcBefore))
                 container.addColumn(column);
         }
+
+        logger.debug("Read {} live cells and {} tombstoned", columnCounter.live(), columnCounter.ignored());
     }
 
     public int getLiveCount(ColumnFamily cf)

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -307,7 +307,7 @@ public void destroyConnectionPool(InetAddress to)
         if (cp.ackCon != null)
             cp.ackCon.closeSocket();
         if (cp.cmdCon != null)
-        cp.cmdCon.closeSocket();
+            cp.cmdCon.closeSocket();
         connectionManagers_.remove(to);
         recentTimeoutsPerHost.remove(to.getHostAddress());
         timeoutsPerHost.remove(to.getHostAddress());

File: src/java/org/apache/cassandra/db/ColumnFamilyStoreMBean.java
Patch:
@@ -39,6 +39,7 @@ public interface ColumnFamilyStoreMBean
      *
      * @see org.apache.cassandra.metrics.ColumnFamilyMetrics#memtableDataSize
      * @return The size in bytes.
+     * @deprecated
      */
     @Deprecated
     public long getMemtableDataSize();
@@ -63,7 +64,7 @@ public interface ColumnFamilyStoreMBean
     public int getMemtableSwitchCount();
 
     /**
-     * @see org.apache.cassandra.metrics.ColumnFamilyMetrics#recentSSTablesPerReadHistogram
+     * @see org.apache.cassandra.metrics.ColumnFamilyMetrics#recentSSTablesPerRead
      * @return a histogram of the number of sstable data files accessed per read: reading this property resets it
      */
     @Deprecated

File: src/java/org/apache/cassandra/db/columniterator/SSTableSliceIterator.java
Patch:
@@ -52,9 +52,9 @@ public SSTableSliceIterator(SSTableReader sstable, DecoratedKey key, ColumnSlice
      * If a caller passes a non-null argument, this class will NOT close the underlying file when the iterator is closed (i.e. the caller is responsible for closing the file)
      * In all cases the caller should explicitly #close() this iterator.
      * @param key The key the requested slice resides under
-     * @param startColumn The start of the slice
-     * @param finishColumn The end of the slice
+     * @param slices the column slices
      * @param reversed Results are returned in reverse order iff reversed is true.
+     * @param indexEntry position of the row
      */
     public SSTableSliceIterator(SSTableReader sstable, FileDataInput file, DecoratedKey key, ColumnSlice[] slices, boolean reversed, RowIndexEntry indexEntry)
     {

File: src/java/org/apache/cassandra/db/compaction/CompactionManagerMBean.java
Patch:
@@ -43,7 +43,7 @@ public interface CompactionManagerMBean
     public long getCompletedTasks();
 
     /**
-     * @see org.apache.cassandra.metrics.CompactionMetrics#totalBytesCompacted
+     * @see org.apache.cassandra.metrics.CompactionMetrics#bytesCompacted
      * @return total number of bytes compacted since server [re]start
      */
     @Deprecated

File: src/java/org/apache/cassandra/db/marshal/AbstractCompositeType.java
Patch:
@@ -327,7 +327,8 @@ public ByteBuffer decompose(ByteBuffer value)
 
     /**
      * @return the comparator for the given component. static CompositeType will consult
-     * @param i; DynamicCompositeType will read the type information from @param bb
+     * @param i DynamicCompositeType will read the type information from @param bb
+     * @param bb name of type definition
      */
     abstract protected AbstractType<?> getComparator(int i, ByteBuffer bb);
 

File: src/java/org/apache/cassandra/io/ISSTableSerializer.java
Patch:
@@ -38,7 +38,7 @@ public interface ISSTableSerializer<T>
      * Deserialize into the specified DataInputStream instance in the format
      * suited for SSTables.
      * @param dis DataInput from which deserialization needs to happen.
-     * @param sstableVersion the version for the sstable we're reading from
+     * @param version the version for the sstable we're reading from
      * @throws IOException
      * @return the type that was deserialized
      */

File: src/java/org/apache/cassandra/locator/TokenMetadata.java
Patch:
@@ -934,7 +934,7 @@ public Collection<InetAddress> pendingEndpointsFor(Token token, String table)
     }
 
     /**
-     * @Deprecated; retained for benefit of old tests
+     * @deprecated retained for benefit of old tests
      */
     public Collection<InetAddress> getWriteEndpoints(Token token, String table, Collection<InetAddress> naturalEndpoints)
     {

File: src/java/org/apache/cassandra/service/EmbeddedCassandraService.java
Patch:
@@ -27,7 +27,7 @@
  * This kind of service is useful when running unit tests of
  * services using cassandra for example.
  *
- * See {@link EmbeddedCassandraServiceTest} for usage.
+ * See {@link org.apache.cassandra.service.EmbeddedCassandraServiceTest} for usage.
  * <p>
  * This is the implementation of https://issues.apache.org/jira/browse/CASSANDRA-740
  * <p>

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -922,7 +922,7 @@ public double getSeverity(InetAddress endpoint)
     /**
      * for a keyspace, return the ranges and corresponding listen addresses.
      * @param keyspace
-     * @return
+     * @return the endpoint map
      */
     public Map<List<String>, List<String>> getRangeToEndpointMap(String keyspace)
     {
@@ -938,7 +938,7 @@ public Map<List<String>, List<String>> getRangeToEndpointMap(String keyspace)
     /**
      * Return the rpc address associated with an endpoint as a string.
      * @param endpoint The endpoint to get rpc address for
-     * @return
+     * @return the rpc address
      */
     public String getRpcaddress(InetAddress endpoint)
     {
@@ -953,7 +953,7 @@ else if (Gossiper.instance.getEndpointStateForEndpoint(endpoint).getApplicationS
     /**
      * for a keyspace, return the ranges and corresponding RPC addresses for a given keyspace.
      * @param keyspace
-     * @return
+     * @return the endpoint map
      */
     public Map<List<String>, List<String>> getRangeToRpcaddressMap(String keyspace)
     {

File: src/java/org/apache/cassandra/db/CounterColumn.java
Patch:
@@ -372,7 +372,7 @@ public void apply(IMutation mutation, Collection<InetAddress> targets, IWriteRes
                 responseHandler.response(null);
                 StorageProxy.sendToHintedEndpoints((RowMutation) mutation, targets, responseHandler, localDataCenter, consistency_level);
             }
-        });
+        }, null);
 
         // we don't wait for answers
     }

File: src/java/org/apache/cassandra/service/DatacenterSyncWriteResponseHandler.java
Patch:
@@ -91,7 +91,7 @@ public void response(Message message)
         }
 
         // all the quorum conditions are met
-        condition.signal();
+        signal();
     }
 
     public void assureSufficientLiveNodes() throws UnavailableException

File: src/java/org/apache/cassandra/service/DatacenterWriteResponseHandler.java
Patch:
@@ -75,7 +75,7 @@ public void response(Message message)
         if (message == null || localdc.equals(snitch.getDatacenter(message.getFrom())))
         {
             if (responses.decrementAndGet() == 0)
-                condition.signal();
+                signal();
         }
     }
     

File: src/java/org/apache/cassandra/service/WriteResponseHandler.java
Patch:
@@ -67,7 +67,7 @@ public static IWriteResponseHandler create(InetAddress endpoint)
     public void response(Message m)
     {
         if (responses.decrementAndGet() == 0)
-            condition.signal();
+            signal();
     }
 
     protected int determineBlockFor(String table)

File: src/java/org/apache/cassandra/db/ColumnIndex.java
Patch:
@@ -106,7 +106,7 @@ public int writtenAtomCount()
          * Serializes the index into in-memory structure with all required components
          * such as Bloom Filter, index block size, IndexInfo list
          *
-         * @param columns Column family to create index for
+         * @param cf Column family to create index for
          *
          * @return information about index - it's Bloom Filter, block size and IndexInfo list
          */

File: src/java/org/apache/cassandra/utils/AlwaysPresentFilter.java
Patch:
@@ -1,5 +1,6 @@
 package org.apache.cassandra.utils;
 
+import java.io.IOException;
 import java.nio.ByteBuffer;
 
 public class AlwaysPresentFilter implements IFilter

File: src/java/org/apache/cassandra/cql/CreateColumnFamilyStatement.java
Patch:
@@ -192,7 +192,7 @@ public CFMetaData getCFMetaData(String keyspace, List<ByteBuffer> variables) thr
                    .compactionStrategyOptions(cfProps.compactionStrategyOptions)
                    .compressionParameters(CompressionParameters.create(cfProps.compressionParameters))
                    .caching(CFMetaData.Caching.fromString(getPropertyString(CFPropDefs.KW_CACHING, CFMetaData.DEFAULT_CACHING_STRATEGY.toString())))
-                   .bloomFilterFpChance(getPropertyDouble(CFPropDefs.KW_BF_FP_CHANCE, CFMetaData.DEFAULT_BF_FP_CHANCE));
+                   .bloomFilterFpChance(getPropertyDouble(CFPropDefs.KW_BF_FP_CHANCE, null));
 
             // CQL2 can have null keyAliases
             if (keyAlias != null)

File: src/java/org/apache/cassandra/db/ColumnIndex.java
Patch:
@@ -24,6 +24,7 @@
 
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.io.sstable.IndexHelper;
+import org.apache.cassandra.utils.AlwaysPresentFilter;
 import org.apache.cassandra.utils.IFilter;
 import org.apache.cassandra.utils.FilterFactory;
 
@@ -32,7 +33,7 @@ public class ColumnIndex
     public final List<IndexHelper.IndexInfo> columnsIndex;
     public final IFilter bloomFilter;
 
-    private static final ColumnIndex EMPTY = new ColumnIndex(Collections.<IndexHelper.IndexInfo>emptyList(), FilterFactory.emptyFilter());
+    private static final ColumnIndex EMPTY = new ColumnIndex(Collections.<IndexHelper.IndexInfo>emptyList(), new AlwaysPresentFilter());
 
     private ColumnIndex(int estimatedColumnCount)
     {

File: src/java/org/apache/cassandra/io/sstable/SSTableReader.java
Patch:
@@ -322,7 +322,7 @@ void loadBloomFilter() throws IOException
     {
         if (!components.contains(Component.FILTER))
         {
-            bf = FilterFactory.emptyFilter();
+            bf = new AlwaysPresentFilter();
             return;
         }
 

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -1305,8 +1305,6 @@ public String system_add_column_family(CfDef cf_def)
             state().hasColumnFamilyAccess(cf_def.name, Permission.CREATE);
             cf_def.unsetId(); // explicitly ignore any id set by client (Hector likes to set zero)
             CFMetaData cfm = CFMetaData.fromThrift(cf_def);
-            if (cfm.getBloomFilterFpChance() == null)
-                cfm.bloomFilterFpChance(CFMetaData.DEFAULT_BF_FP_CHANCE);
             cfm.addDefaultIndexNames();
             MigrationManager.announceNewColumnFamily(cfm);
             return Schema.instance.getVersion().toString();

File: src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java
Patch:
@@ -113,7 +113,7 @@ public Collection<IMutation> getMutations(List<ByteBuffer> variables, boolean lo
         buildColumnNames(cfDef, processedKeys, builder, variables, true);
 
         // Lists SET operation incurs a read.
-        List<ByteBuffer> toRead = null;
+        Set<ByteBuffer> toRead = null;
         for (Map.Entry<CFDefinition.Name, Operation> entry : processedColumns.entries())
         {
             CFDefinition.Name name = entry.getKey();
@@ -125,9 +125,8 @@ public Collection<IMutation> getMutations(List<ByteBuffer> variables, boolean lo
             if (value.requiresRead())
             {
                 if (toRead == null)
-                    toRead = new ArrayList<ByteBuffer>();
+                    toRead = new TreeSet<ByteBuffer>(UTF8Type.instance);
                 toRead.add(name.name.key);
-                break;
             }
         }
 

File: src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
Patch:
@@ -211,7 +211,7 @@ public void trim(ColumnFamily cf, int trimTo)
             }
         }
 
-        if (toRemote != null)
+        if (toRemove != null)
         {
             for (ByteBuffer columnName : toRemove)
                 cf.remove(columnName);

File: src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
Patch:
@@ -211,9 +211,10 @@ public void trim(ColumnFamily cf, int trimTo)
             }
         }
 
-        for (ByteBuffer columnName : toRemove)
+        if (toRemote != null)
         {
-            cf.remove(columnName);
+            for (ByteBuffer columnName : toRemove)
+                cf.remove(columnName);
         }
     }
 

File: src/java/org/apache/cassandra/tools/Shuffle.java
Patch:
@@ -496,7 +496,8 @@ public static CqlResult executeCqlQuery(String hostName, int port, boolean isFra
         }
         finally
         {
-            client.close();
+            if (client != null)
+                client.close();
         }
     }
 

File: src/java/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -25,6 +25,7 @@
 import java.util.Map;
 
 import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.db.filter.IFilter;
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.io.IVersionedSerializer;
@@ -79,6 +80,8 @@ public String getColumnFamilyName()
 
     public abstract Row getRow(Table table) throws IOException;
 
+    public abstract IFilter filter();
+
     protected AbstractType<?> getComparator()
     {
         return ColumnFamily.getComparatorFor(table, getColumnFamilyName(), queryPath.superColumnName);

File: src/java/org/apache/cassandra/service/IResponseResolver.java
Patch:
@@ -42,6 +42,4 @@ public interface IResponseResolver<TMessage, TResolved> {
 
     public void preprocess(MessageIn<TMessage> message);
     public Iterable<MessageIn<TMessage>> getMessages();
-
-    public int getMaxLiveColumns();
 }

File: src/java/org/apache/cassandra/service/ReadCallback.java
Patch:
@@ -219,7 +219,7 @@ protected void runMayThrow() throws IOException
                     logger.debug("Digest mismatch:", e);
 
                 ReadCommand readCommand = (ReadCommand) command;
-                final RowRepairResolver repairResolver = new RowRepairResolver(readCommand.table, readCommand.key);
+                final RowRepairResolver repairResolver = new RowRepairResolver(readCommand.table, readCommand.key, readCommand.filter());
                 IAsyncCallback repairHandler = new AsyncRepairCallback(repairResolver, endpoints.size());
 
                 MessageOut<ReadCommand> message = ((ReadCommand) command).createMessage();

File: src/java/org/apache/cassandra/service/RepairCallback.java
Patch:
@@ -79,8 +79,8 @@ public boolean isLatencyForSnitch()
         return true;
     }
 
-    public int getMaxLiveColumns()
+    public int getMaxLiveCount()
     {
-        return resolver.getMaxLiveColumns();
+        return resolver.getMaxLiveCount();
     }
 }

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -943,7 +943,7 @@ private static List<Row> fetchRows(List<ReadCommand> initialCommands, Consistenc
                 catch (DigestMismatchException ex)
                 {
                     logger.debug("Digest mismatch: {}", ex.toString());
-                    RowRepairResolver resolver = new RowRepairResolver(command.table, command.key);
+                    RowRepairResolver resolver = new RowRepairResolver(command.table, command.key, command.filter());
                     RepairCallback repairHandler = new RepairCallback(resolver, handler.endpoints);
 
                     if (repairCommands == null)

File: src/java/org/apache/cassandra/db/SystemTable.java
Patch:
@@ -164,7 +164,7 @@ private static void upgradeSystemData() throws ExecutionException, InterruptedEx
             Token token = StorageService.getPartitioner().getTokenFactory().fromByteArray(oldColumns.next().value());
             String tokenBytes = serializeTokens(Collections.singleton(token));
             // (assume that any node getting upgraded was bootstrapped, since that was stored in a separate row for no particular reason)
-            String req = "INSERT INTO system.%s (key, cluster_name, tokens, bootstrapped) VALUES ('%s', '%s', '%s', '%s')";
+            String req = "INSERT INTO system.%s (key, cluster_name, tokens, bootstrapped) VALUES ('%s', '%s', %s, '%s')";
             processInternal(String.format(req, LOCAL_CF, LOCAL_KEY, clusterName, tokenBytes, BootstrapState.COMPLETED.name()));
 
             oldStatusCfs.truncate();

File: src/java/org/apache/cassandra/cql3/QueryProcessor.java
Patch:
@@ -127,7 +127,7 @@ private static ResultMessage processStatement(CQLStatement statement, Consistenc
         statement.checkAccess(clientState);
         statement.validate(clientState);
         ResultMessage result = statement.execute(cl, clientState, variables);
-        return result == null ? ResultMessage.Void.instance() : result;
+        return result == null ? new ResultMessage.Void() : result;
     }
 
     public static ResultMessage process(String queryString, ConsistencyLevel cl, ClientState clientState)

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -416,7 +416,6 @@ public void initServerLocally()
                 throw new UnsupportedOperationException("StorageService does not support switching modes.");
             return;
         }
-        initialized = true;
         isClientMode = false;
 
         // Ensure StorageProxy is initialized on start-up; see CASSANDRA-3797.
@@ -514,6 +513,7 @@ public synchronized void maybeJoinRing(int delay) throws ConfigurationException
                 throw new UnsupportedOperationException("StorageService does not support switching modes.");
             return;
         }
+        initialized = true;
 
         if (Boolean.parseBoolean(System.getProperty("cassandra.join_ring", "true")))
         {

File: src/java/org/apache/cassandra/gms/IEndpointStateChangeSubscriber.java
Patch:
@@ -27,7 +27,6 @@
  * instance to decide what he does with this change. Not all modules maybe interested
  * in all state changes.
  */
-
 public interface IEndpointStateChangeSubscriber
 {
     /**

File: test/unit/org/apache/cassandra/service/AntiEntropyServiceTestAbstract.java
Patch:
@@ -79,7 +79,6 @@ public void prepare() throws Exception
             init();
 
             LOCAL = FBUtilities.getBroadcastAddress();
-            StorageService.instance.initServer(0);
             // generate a fake endpoint for which we can spoof receiving/sending trees
             REMOTE = InetAddress.getByName("127.0.0.2");
             store = null;

File: src/java/org/apache/cassandra/cql/jdbc/TypesMap.java
Patch:
@@ -35,6 +35,7 @@ public class TypesMap
         map.put("org.apache.cassandra.db.marshal.DoubleType", JdbcDouble.instance);
         map.put("org.apache.cassandra.db.marshal.FloatType", JdbcFloat.instance);
         map.put("org.apache.cassandra.db.marshal.Int32Type", JdbcInt32.instance);
+        map.put("org.apache.cassandra.db.marshal.InetAddressType", JdbcInetAddress.instance);
         map.put("org.apache.cassandra.db.marshal.IntegerType", JdbcInteger.instance);
         map.put("org.apache.cassandra.db.marshal.LexicalUUIDType", JdbcLexicalUUID.instance);
         map.put("org.apache.cassandra.db.marshal.LongType", JdbcLong.instance);

File: src/java/org/apache/cassandra/thrift/ThriftServer.java
Patch:
@@ -30,8 +30,7 @@
 
 public class ThriftServer implements CassandraDaemon.Server
 {
-    protected static CassandraDaemon instance;
-    private static Logger logger = LoggerFactory.getLogger(CassandraDaemon.class);
+    private static Logger logger = LoggerFactory.getLogger(ThriftServer.class);
     final static String SYNC = "sync";
     final static String ASYNC = "async";
     final static String HSHA = "hsha";

File: tools/stress/src/org/apache/cassandra/stress/SSLTransportFactory.java
Patch:
@@ -15,11 +15,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.apache.cassandra.cli.transport;
+package org.apache.cassandra.stress;
 
 import org.apache.cassandra.cli.transport.FramedTransportFactory;
-import org.apache.cassandra.stress.Session;
-import org.apache.cassandra.stress.Stress;
 import org.apache.thrift.transport.TSSLTransportFactory;
 import org.apache.thrift.transport.TSSLTransportFactory.TSSLTransportParameters;
 import org.apache.thrift.transport.TTransport;

File: tools/stress/src/org/apache/cassandra/stress/Session.java
Patch:
@@ -104,7 +104,7 @@ public class Session implements Serializable
         availableOptions.addOption("Q",  "query-names",          true,   "Comma-separated list of column names to retrieve from each row.");
         availableOptions.addOption("Z",  "compaction-strategy",  true,   "CompactionStrategy to use.");
         availableOptions.addOption("U",  "comparator",           true,   "Column Comparator to use. Currently supported types are: TimeUUIDType, AsciiType, UTF8Type.");
-        availableOptions.addOption("tf", "transport-factory",    true,   "Fully qualified class name for creating a thrift connection");
+        availableOptions.addOption("tf", "transport-factory",    true,   "Fully-qualified TTransportFactory class name for creating a connection. Note: For Thrift over SSL, use org.apache.cassandra.stress.SSLTransportFactory.");
         availableOptions.addOption("ts", SSL_TRUSTSTORE,         true, "SSL: full path to truststore");
         availableOptions.addOption("tspw", SSL_TRUSTSTORE_PW,    true, "SSL: full path to truststore");
         availableOptions.addOption("prtcl", SSL_PROTOCOL,        true, "SSL: connections protocol to use (default: TLS)");

File: src/java/org/apache/cassandra/cql/QueryProcessor.java
Patch:
@@ -718,7 +718,7 @@ else if (oldKeyspace == null)
 
             case CREATE_COLUMNFAMILY:
                 CreateColumnFamilyStatement createCf = (CreateColumnFamilyStatement)statement.statement;
-                clientState.hasColumnFamilySchemaAccess(createCf.getName(), Permission.CREATE);
+                clientState.hasColumnFamilySchemaAccess(keyspace, Permission.CREATE);
                 validateSchemaAgreement();
 
                 try

File: src/java/org/apache/cassandra/cql3/statements/BatchStatement.java
Patch:
@@ -97,17 +97,17 @@ protected void validateConsistency(ConsistencyLevel cl) throws InvalidRequestExc
             statement.validateConsistency(cl);
     }
 
-    public Collection<? extends IMutation> getMutations(ClientState clientState, List<ByteBuffer> variables, boolean local, ConsistencyLevel cl)
+    public Collection<? extends IMutation> getMutations(ClientState clientState, List<ByteBuffer> variables, boolean local, ConsistencyLevel cl, long now)
     throws RequestExecutionException, RequestValidationException
     {
         Map<Pair<String, ByteBuffer>, IMutation> mutations = new HashMap<Pair<String, ByteBuffer>, IMutation>();
         for (ModificationStatement statement : statements)
         {
             if (isSetTimestamp())
-                statement.setTimestamp(getTimestamp(clientState));
+                statement.setTimestamp(getTimestamp(now));
 
             // Group mutation together, otherwise they won't get applied atomically
-            for (IMutation m : statement.getMutations(clientState, variables, local, cl))
+            for (IMutation m : statement.getMutations(clientState, variables, local, cl, now))
             {
                 if (m instanceof CounterMutation && type != Type.COUNTER)
                     throw new InvalidRequestException("Counter mutations are only allowed in COUNTER batches");

File: src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java
Patch:
@@ -69,7 +69,7 @@ protected void validateConsistency(ConsistencyLevel cl) throws InvalidRequestExc
             cl.validateForWrite(cfDef.cfm.ksName);
     }
 
-    public Collection<RowMutation> getMutations(ClientState clientState, List<ByteBuffer> variables, boolean local, ConsistencyLevel cl)
+    public Collection<RowMutation> getMutations(ClientState clientState, List<ByteBuffer> variables, boolean local, ConsistencyLevel cl, long now)
     throws RequestExecutionException, RequestValidationException
     {
         // keys
@@ -104,7 +104,7 @@ public Collection<RowMutation> getMutations(ClientState clientState, List<ByteBu
         Map<ByteBuffer, ColumnGroupMap> rows = toRead != null ? readRows(keys, builder, toRead, (CompositeType)cfDef.cfm.comparator, local, cl) : null;
 
         Collection<RowMutation> rowMutations = new ArrayList<RowMutation>(keys.size());
-        UpdateParameters params = new UpdateParameters(variables, getTimestamp(clientState), -1);
+        UpdateParameters params = new UpdateParameters(variables, getTimestamp(now), -1);
 
         for (ByteBuffer key : keys)
             rowMutations.add(mutationForKey(cfDef, key, builder, isRange, params, rows == null ? null : rows.get(key)));

File: src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java
Patch:
@@ -105,7 +105,7 @@ protected void validateConsistency(ConsistencyLevel cl) throws InvalidRequestExc
     }
 
     /** {@inheritDoc} */
-    public Collection<IMutation> getMutations(ClientState clientState, List<ByteBuffer> variables, boolean local, ConsistencyLevel cl)
+    public Collection<IMutation> getMutations(ClientState clientState, List<ByteBuffer> variables, boolean local, ConsistencyLevel cl, long now)
     throws RequestExecutionException, RequestValidationException
     {
         List<ByteBuffer> keys = buildKeyNames(cfDef, processedKeys, variables);
@@ -135,7 +135,7 @@ public Collection<IMutation> getMutations(ClientState clientState, List<ByteBuff
         Map<ByteBuffer, ColumnGroupMap> rows = toRead != null ? readRows(keys, builder, toRead, (CompositeType)cfDef.cfm.comparator, local, cl) : null;
 
         Collection<IMutation> mutations = new LinkedList<IMutation>();
-        UpdateParameters params = new UpdateParameters(variables, getTimestamp(clientState), getTimeToLive());
+        UpdateParameters params = new UpdateParameters(variables, getTimestamp(now), getTimeToLive());
 
         for (ByteBuffer key: keys)
             mutations.add(mutationForKey(cfDef, key, builder, params, rows == null ? null : rows.get(key), cl));
@@ -449,7 +449,7 @@ public String toString()
                              cfName,
                              whereClause,
                              columns,
-                             isSetTimestamp() ? getTimestamp(null) : "<now>",
+                             isSetTimestamp() ? getTimestamp(-1) : "<now>",
                              getTimeToLive());
     }
 }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1438,7 +1438,7 @@ public List<Row> getRangeSlice(ByteBuffer superColumn, final AbstractBounds<RowP
 
     public List<Row> getRangeSlice(ByteBuffer superColumn, final AbstractBounds<RowPosition> range, int maxResults, IFilter columnFilter, List<IndexExpression> rowFilter, boolean maxIsColumns, boolean isPaging)
     {
-        logger.debug("Executing seq scan");
+        logger.debug("Executing seq scan for {}..{}", range.left, range.right);
         return filter(getSequentialIterator(superColumn, range, columnFilter), ExtendedFilter.create(this, columnFilter, rowFilter, maxResults, maxIsColumns, isPaging));
     }
 
@@ -1449,7 +1449,7 @@ public List<Row> search(List<IndexExpression> clause, AbstractBounds<RowPosition
 
     public List<Row> search(List<IndexExpression> clause, AbstractBounds<RowPosition> range, int maxResults, IFilter dataFilter, boolean maxIsColumns)
     {
-        logger.debug("Executing indexed scan");
+        logger.debug("Executing indexed scan for {}..{}", range.left, range.right);
         return indexManager.search(clause, range, maxResults, dataFilter, maxIsColumns);
     }
 

File: src/java/org/apache/cassandra/db/marshal/AbstractCompositeType.java
Patch:
@@ -222,7 +222,7 @@ public String getString(ByteBuffer bytes)
             if (bb.remaining() != bytes.remaining())
                 sb.append(":");
 
-            AbstractType<?> comparator = getAndAppendNextComparator(i, bb, sb);
+            AbstractType<?> comparator = getAndAppendComparator(i, bb, sb);
             ByteBuffer value = getWithShortLength(bb);
 
             sb.append(escape(comparator.getString(value)));

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -197,7 +197,6 @@ public final class CFMetaData
                                                                + "  source inet,"
                                                                + "  thread text,"
                                                                + "  activity text,"
-                                                               + "  happened_at timestamp,"
                                                                + "  source_elapsed int,"
                                                                + "  PRIMARY KEY (session_id, event_id)"
                                                                + ");", Tracing.TRACE_KS);

File: src/java/org/apache/cassandra/service/IndexScanVerbHandler.java
Patch:
@@ -44,8 +44,7 @@ public void doVerb(MessageIn<IndexScanCommand> message, String id)
                                         command.index_clause.count,
                                         ThriftValidation.asIFilter(command.predicate, cfs.getComparator()));
             RangeSliceReply reply = new RangeSliceReply(rows);
-            if (logger.isDebugEnabled())
-                logger.debug("Sending " + reply+ " to " + id + "@" + message.from);
+            logger.debug("Sending response to {}", message.from);
             MessagingService.instance().sendReply(reply.createMessage(), id, message.from);
         }
         catch (Exception ex)

File: src/java/org/apache/cassandra/service/RangeSliceVerbHandler.java
Patch:
@@ -55,8 +55,7 @@ public void doVerb(MessageIn<RangeSliceCommand> message, String id)
                 throw new RuntimeException("Cannot service reads while bootstrapping!");
             }
             RangeSliceReply reply = new RangeSliceReply(executeLocally(message.payload));
-            if (logger.isDebugEnabled())
-                logger.debug("Sending " + reply+ " to " + id + "@" + message.from);
+            logger.debug("Sending response to {}", message.from);
             MessagingService.instance().sendReply(reply.createMessage(), id, message.from);
         }
         catch (Exception ex)

File: src/java/org/apache/cassandra/service/ReadCallback.java
Patch:
@@ -79,8 +79,8 @@ public ReadCallback(IResponseResolver<TMessage, TResolved> resolver, Consistency
         this.consistencyLevel = consistencyLevel;
         sortForConsistencyLevel(endpoints);
         this.endpoints = resolver instanceof RowRepairResolver ? endpoints : filterEndpoints(endpoints);
-        if (logger.isDebugEnabled())
-            logger.debug(String.format("Blockfor is %s; setting up requests to %s", blockfor, StringUtils.join(this.endpoints, ",")));
+        if (logger.isTraceEnabled())
+            logger.trace(String.format("Blockfor is %s; setting up requests to %s", blockfor, StringUtils.join(this.endpoints, ",")));
     }
 
     /**

File: src/java/org/apache/cassandra/tracing/Tracing.java
Patch:
@@ -250,5 +250,4 @@ public void initializeFromMessage(final MessageIn<?> message)
         checkState(sessionBytes.length == 16);
         state.set(new TraceState(message.from, UUIDGen.getUUID(ByteBuffer.wrap(sessionBytes))));
     }
-
 }

File: src/java/org/apache/cassandra/utils/SlabAllocator.java
Patch:
@@ -95,7 +95,7 @@ private Region getRegion()
                 // we won race - now we need to actually do the expensive allocation step
                 region.init();
                 regionCount++;
-                logger.debug("{} regions now allocated in {}", regionCount, this);
+                logger.trace("{} regions now allocated in {}", regionCount, this);
                 return region;
             }
             // someone else won race - that's fine, we'll try to grab theirs

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -1075,7 +1075,7 @@ else if (!restriction.isEquality())
                 }
                 // We only support IN for the last name and for compact storage so far
                 // TODO: #3885 allows us to extend to non compact as well, but that remains to be done
-                else if (cfDef.isCompact && restriction.eqValues.size() > 1 && i != stmt.columnRestrictions.length - 1)
+                else if (restriction.eqValues.size() > 1 && (!cfDef.isCompact || i != stmt.columnRestrictions.length - 1))
                 {
                     throw new InvalidRequestException(String.format("PRIMARY KEY part %s cannot be restricted by IN relation", cname));
                 }
@@ -1124,7 +1124,7 @@ else if (restriction.isEquality())
                     {
                         // We only support IN for the last name so far
                         if (i != stmt.keyRestrictions.length - 1)
-                            throw new InvalidRequestException(String.format("partition KEY part %s cannot be restricted by IN relation (only the last part of the partition key can)", cname));
+                            throw new InvalidRequestException(String.format("Partition KEY part %s cannot be restricted by IN relation (only the last part of the partition key can)", cname));
                         stmt.keyIsInRelation = true;
                     }
                 }

File: src/java/org/apache/cassandra/streaming/StreamIn.java
Patch:
@@ -83,7 +83,7 @@ public static PendingFile getContextMapping(PendingFile remote) throws IOExcepti
         Directories.DataDirectory localDir = Directories.getLocationCapableOfSize(remote.size);
         if (localDir == null)
             throw new RuntimeException("Insufficient disk space to store " + remote.size + " bytes");
-        Descriptor localdesc = Descriptor.fromFilename(cfStore.getTempSSTablePath(localDir.location));
+        Descriptor localdesc = Descriptor.fromFilename(cfStore.getTempSSTablePath(cfStore.directories.getLocationForDisk(localDir.location)));
 
         return new PendingFile(localdesc, remote);
     }

File: src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
Patch:
@@ -129,8 +129,7 @@ public void resetAndTruncate()
      */
     private long beforeAppend(DecoratedKey<?> decoratedKey) throws IOException
     {
-        assert decoratedKey != null : "Keys must not be null";
-        assert decoratedKey.key.remaining() > 0 : "Keys must not be empty";
+        assert decoratedKey != null : "Keys must not be null"; // empty keys ARE allowed b/c of indexed column values
         if (lastWrittenKey != null && lastWrittenKey.compareTo(decoratedKey) >= 0)
             throw new RuntimeException("Last written key " + lastWrittenKey + " >= current key " + decoratedKey + " writing into " + getFilename());
         return (lastWrittenKey == null) ? 0 : dataFile.getFilePointer();

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -876,6 +876,8 @@ private static void removeDeletedSuper(ColumnFamily cf, int gcBefore)
      */
     public Set<SSTableReader> getOverlappingSSTables(Collection<SSTableReader> sstables)
     {
+        logger.debug("Checking for sstables overlapping {}", sstables);
+
         // a normal compaction won't ever have an empty sstables list, but we create a skeleton
         // compaction controller for streaming, and that passes an empty list.
         if (sstables.isEmpty())
@@ -888,7 +890,7 @@ public Set<SSTableReader> getOverlappingSSTables(Collection<SSTableReader> sstab
         {
             Set<SSTableReader> overlaps = ImmutableSet.copyOf(tree.search(new Interval<SSTableReader>(sstable.first, sstable.last)));
             assert overlaps.contains(sstable);
-            results = results == null ? overlaps : Sets.union(results, overlaps);
+            results = results == null ? overlaps : Sets.union(results, overlaps).immutableCopy();
         }
         results = Sets.difference(results, ImmutableSet.copyOf(sstables));
 

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -20,7 +20,7 @@
  *
  */
 
-import org.apache.cassandra.cache.ConcurrentLinkedHashCacheProvider;
+import org.apache.cassandra.cache.SerializingCacheProvider;
 
 
 public class Config
@@ -135,7 +135,7 @@ public class Config
     public long row_cache_size_in_mb = 0;
     public int row_cache_save_period = 0;
     public int row_cache_keys_to_save = Integer.MAX_VALUE;
-    public String row_cache_provider = ConcurrentLinkedHashCacheProvider.class.getSimpleName();
+    public String row_cache_provider = SerializingCacheProvider.class.getSimpleName();
     public boolean populate_io_cache_on_flush = false;
 
     private static boolean loadYaml = true;

File: src/java/org/apache/cassandra/db/compaction/LeveledCompactionStrategy.java
Patch:
@@ -181,7 +181,9 @@ public List<ICompactionScanner> getScanners(Collection<SSTableReader> sstables,
         List<ICompactionScanner> scanners = new ArrayList<ICompactionScanner>(sstables.size());
         for (Integer level : byLevel.keySet())
         {
-            if (level == 0)
+            // level can be -1 when sstables are added to DataTracker but not to LeveledManifest
+            // since we don't know which level those sstable belong yet, we simply do the same as L0 sstables.
+            if (level <= 0)
             {
                 // L0 makes no guarantees about overlapping-ness.  Just create a direct scanner for each
                 for (SSTableReader sstable : byLevel.get(level))

File: test/unit/org/apache/cassandra/db/compaction/LeveledCompactionStrategyTest.java
Patch:
@@ -64,7 +64,7 @@ public void testValidationMultipleSSTablePerLevel() throws Exception
                 rm.add(new QueryPath(cfname, null, ByteBufferUtil.bytes("column" + c)), value, 0);
             }
             rm.apply();
-            store.forceFlush();
+            store.forceBlockingFlush();
         }
 
         LeveledCompactionStrategy strat = (LeveledCompactionStrategy)store.getCompactionStrategy();

File: src/java/org/apache/cassandra/db/compaction/LeveledManifest.java
Patch:
@@ -479,7 +479,7 @@ private Collection<SSTableReader> getCandidatesFor(int level)
                 candidates.addAll(overlapping(candidates, generations[1]));
             }
 
-            return candidates;
+            return candidates.size() > 1 ? candidates : Collections.<SSTableReader>emptyList();
         }
 
         // for non-L0 compactions, pick up where we left off last time

File: test/unit/org/apache/cassandra/db/compaction/LeveledCompactionStrategyTest.java
Patch:
@@ -69,7 +69,7 @@ public void testValidationMultipleSSTablePerLevel() throws Exception
 
         LeveledCompactionStrategy strat = (LeveledCompactionStrategy)store.getCompactionStrategy();
 
-        while (strat.getLevelSize(0) > 0)
+        while (strat.getLevelSize(0) > 1)
         {
             store.forceMajorCompaction();
             Thread.sleep(200);

File: test/unit/org/apache/cassandra/db/compaction/LeveledCompactionStrategyTest.java
Patch:
@@ -69,7 +69,7 @@ public void testValidationMultipleSSTablePerLevel() throws Exception
 
         LeveledCompactionStrategy strat = (LeveledCompactionStrategy)store.getCompactionStrategy();
 
-        while (strat.getLevelSize(0) > 0)
+        while (strat.getLevelSize(0) > 1)
         {
             store.forceMajorCompaction();
             Thread.sleep(200);

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -71,6 +71,7 @@ public enum Function
         TIMEUUID      (TimeUUIDType.instance),
         UTF8          (UTF8Type.instance),
         ASCII         (AsciiType.instance),
+        DOUBLE        (DoubleType.instance),
         COUNTERCOLUMN (CounterColumnType.instance);
 
         private AbstractType<?> validator;

File: src/java/org/apache/cassandra/db/RangeTombstone.java
Patch:
@@ -170,10 +170,9 @@ public long writeOpenedMarker(OnDiskAtom firstColumn, DataOutput out, OnDiskAtom
                 toWrite.add(tombstone);
             }
 
-            TypeSizes typeSizes = TypeSizes.NATIVE;
             for (RangeTombstone tombstone : toWrite)
             {
-                size += tombstone.serializedSize(typeSizes);
+                size += tombstone.serializedSizeForSSTable();
                 atomCount++;
                 if (out != null)
                     atomSerializer.serializeForSSTable(tombstone, out);

File: src/java/org/apache/cassandra/cql3/CFPropDefs.java
Patch:
@@ -105,7 +105,7 @@ public static AbstractType<?> parseType(String type) throws InvalidRequestExcept
     {
         try
         {
-            String className = comparators.get(type);
+            String className = comparators.get(type.toLowerCase());
             if (className == null)
                 className = type;
             return TypeParser.parse(className);

File: src/java/org/apache/cassandra/cql3/Term.java
Patch:
@@ -127,6 +127,9 @@ public ByteBuffer getByteBuffer(AbstractType<?> validator, List<ByteBuffer> vari
                 throw new AssertionError("a marker Term was encountered with no index value");
 
             ByteBuffer value = variables.get(bindIndex);
+            // We don't yet support null values in prepared statements
+            if (value == null)
+                throw new InvalidRequestException("Invalid null value for prepared variable " + bindIndex);
             validator.validate(value);
             return value;
         }

File: src/java/org/apache/cassandra/transport/messages/ErrorMessage.java
Patch:
@@ -181,7 +181,7 @@ public static ErrorMessage fromException(Throwable e)
             return new ErrorMessage((TransportException)e);
 
         // Unexpected exception
-        logger.debug("Unexpected exception during request", e);
+        logger.error("Unexpected exception during request", e);
         return new ErrorMessage(new ServerError(e));
     }
 

File: src/java/org/apache/cassandra/db/SystemTable.java
Patch:
@@ -238,7 +238,7 @@ public static synchronized void removeTokens(Collection<Token> tokens)
                 continue;
 
             String req = "UPDATE system.%s SET tokens = tokens - %s WHERE peer = '%s'";
-            processInternal(String.format(req, PEERS_CF, serializeTokens(toRemove), entry.getKey()));
+            processInternal(String.format(req, PEERS_CF, serializeTokens(toRemove), entry.getKey().getHostAddress()));
         }
         forceBlockingFlush(PEERS_CF);
     }

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -83,7 +83,6 @@ public class Config
     public Integer rpc_recv_buff_size_in_bytes;
 
     public Boolean start_native_transport = false;
-    public String native_transport_address;
     public Integer native_transport_port = 8000;
     public Integer native_transport_max_threads = Integer.MAX_VALUE;
 

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -34,7 +34,7 @@ public class Config
 
     public Boolean auto_bootstrap = true;
     public Boolean hinted_handoff_enabled = true;
-    public Integer max_hint_window_in_ms = Integer.MAX_VALUE;
+    public Integer max_hint_window_in_ms = 3600 * 1000; // one hour
 
     public SeedProviderDef seed_provider;
     public DiskAccessMode disk_access_mode = DiskAccessMode.auto;
@@ -82,7 +82,7 @@ public class Config
 
     /* if the size of columns or super-columns are more than this, indexing will kick in */
     public Integer column_index_size_in_kb = 64;
-    public Integer in_memory_compaction_limit_in_mb = 256;
+    public Integer in_memory_compaction_limit_in_mb = 64;
     public Integer concurrent_compactors = Runtime.getRuntime().availableProcessors();
     public Integer compaction_throughput_mb_per_sec = 16;
     public Boolean multithreaded_compaction = false;

File: src/java/org/apache/cassandra/cql3/QueryProcessor.java
Patch:
@@ -206,7 +206,7 @@ public static CqlPreparedResult prepare(String queryString, ClientState clientSt
         List<String> var_names = new ArrayList<String>(prepared.boundNames.size());
         for (CFDefinition.Name n : prepared.boundNames)
         {
-            var_types.add(TypeParser.getShortName(n.type));
+            var_types.add(SelectStatement.getShortTypeName(n.type));
             var_names.add(n.name.toString());
         }
 

File: src/java/org/apache/cassandra/db/marshal/ReversedType.java
Patch:
@@ -30,8 +30,7 @@ public class ReversedType<T> extends AbstractType<T>
     // interning instances
     private static final Map<AbstractType<?>, ReversedType> instances = new HashMap<AbstractType<?>, ReversedType>();
 
-    // package protected for unit tests sake
-    final AbstractType<T> baseType;
+    public final AbstractType<T> baseType;
 
     public static <T> ReversedType<T> getInstance(TypeParser parser) throws ConfigurationException
     {

File: src/java/org/apache/cassandra/net/IncomingTcpConnection.java
Patch:
@@ -179,7 +179,7 @@ private InetAddress receiveMessage(DataInputStream input, int version) throws IO
 
         String id = input.readUTF();
         long timestamp = version >= MessagingService.VERSION_12
-                       ? (System.currentTimeMillis() & 0xFFFFFFFF00000000L) | ((input.readInt() << 2) >> 2)
+                       ? (System.currentTimeMillis() & 0xFFFFFFFF00000000L) | (((long) input.readInt() << 2) >> 2)
                        : System.currentTimeMillis();
 
         MessageIn message = MessageIn.read(input, version, id);

File: src/java/org/apache/cassandra/locator/NetworkTopologyStrategy.java
Patch:
@@ -140,7 +140,8 @@ public int getReplicationFactor()
 
     public int getReplicationFactor(String dc)
     {
-        return datacenters.get(dc);
+        Integer replicas = datacenters.get(dc);
+        return replicas == null ? 0 : replicas;
     }
 
     public Set<String> getDatacenters()

File: src/java/org/apache/cassandra/service/MigrationManager.java
Patch:
@@ -304,7 +304,7 @@ public static Collection<RowMutation> deserializeMigrationMessage(byte[] data, i
         int count = in.readInt();
 
         for (int i = 0; i < count; i++)
-            schema.add(RowMutation.serializer().deserialize(in, version));
+            schema.add(RowMutation.serializer().deserializeFixingTimestamps(in, version));
 
         return schema;
     }

File: src/java/org/apache/cassandra/exceptions/PreparedQueryNotFoundException.java
Patch:
@@ -32,9 +32,9 @@ public PreparedQueryNotFoundException(MD5Digest id)
 
     private static String makeMsg(MD5Digest id)
     {
-        return String.format("Prepared query with ID %d not found" +
+        return String.format("Prepared query with ID %s not found" +
                              " (either the query was not prepared on this host (maybe the host has been restarted?)" +
-                             " or you have prepared more than %d queries and queries %d has been evicted from the internal cache)",
+                             " or you have prepared more than %d queries and query %s has been evicted from the internal cache)",
                              id, QueryProcessor.MAX_CACHE_PREPARED, id);
     }
 }

File: src/java/org/apache/cassandra/cql3/statements/BatchStatement.java
Patch:
@@ -119,7 +119,7 @@ public void validate(ClientState state) throws InvalidRequestException
         }
     }
 
-    public List<IMutation> getMutations(ClientState clientState, List<ByteBuffer> variables)
+    public List<IMutation> getMutations(ClientState clientState, List<ByteBuffer> variables, boolean local)
     throws RequestExecutionException, RequestValidationException
     {
         Map<Pair<String, ByteBuffer>, RowAndCounterMutation> mutations = new HashMap<Pair<String, ByteBuffer>, RowAndCounterMutation>();
@@ -128,7 +128,7 @@ public List<IMutation> getMutations(ClientState clientState, List<ByteBuffer> va
             if (isSetTimestamp())
                 statement.setTimestamp(getTimestamp(clientState));
 
-            List<IMutation> lm = statement.getMutations(clientState, variables);
+            List<IMutation> lm = statement.getMutations(clientState, variables, local);
             // Group mutation together, otherwise they won't get applied atomically
             for (IMutation m : lm)
             {

File: src/java/org/apache/cassandra/cql3/statements/CFStatement.java
Patch:
@@ -37,6 +37,7 @@ public void prepareKeyspace(ClientState state) throws InvalidRequestException
     {
         if (!cfName.hasKeyspace())
         {
+            // XXX: We explicitely only want to call state.getKeyspace() in this case, don't move it outside the if.
             cfName.setKeyspace(state.getKeyspace(), true);
         }
     }

File: src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java
Patch:
@@ -62,7 +62,7 @@ public DeleteStatement(CFName name, List<Selector> columns, List<Relation> where
         this.toRemove = new ArrayList<Pair<CFDefinition.Name, Term>>(columns.size());
     }
 
-    public List<IMutation> getMutations(ClientState clientState, List<ByteBuffer> variables)
+    public List<IMutation> getMutations(ClientState clientState, List<ByteBuffer> variables, boolean local)
     throws RequestExecutionException, RequestValidationException
     {
         // keys
@@ -92,7 +92,7 @@ public List<IMutation> getMutations(ClientState clientState, List<ByteBuffer> va
             }
         }
 
-        Map<ByteBuffer, ColumnGroupMap> rows = needsReading ? readRows(keys, builder, (CompositeType)cfDef.cfm.comparator) : null;
+        Map<ByteBuffer, ColumnGroupMap> rows = needsReading ? readRows(keys, builder, (CompositeType)cfDef.cfm.comparator, local) : null;
 
         List<IMutation> rowMutations = new ArrayList<IMutation>(keys.size());
         UpdateParameters params = new UpdateParameters(variables, getTimestamp(clientState), -1);

File: src/java/org/apache/cassandra/cql3/statements/UpdateStatement.java
Patch:
@@ -100,7 +100,7 @@ public UpdateStatement(CFName name,
 
 
     /** {@inheritDoc} */
-    public List<IMutation> getMutations(ClientState clientState, List<ByteBuffer> variables)
+    public List<IMutation> getMutations(ClientState clientState, List<ByteBuffer> variables, boolean local)
     throws RequestExecutionException, RequestValidationException
     {
         List<ByteBuffer> keys = buildKeyNames(cfDef, processedKeys, variables);
@@ -127,7 +127,7 @@ public List<IMutation> getMutations(ClientState clientState, List<ByteBuffer> va
             }
         }
 
-        Map<ByteBuffer, ColumnGroupMap> rows = needsReading ? readRows(keys, builder, (CompositeType)cfDef.cfm.comparator) : null;
+        Map<ByteBuffer, ColumnGroupMap> rows = needsReading ? readRows(keys, builder, (CompositeType)cfDef.cfm.comparator, local) : null;
 
         List<IMutation> rowMutations = new LinkedList<IMutation>();
         UpdateParameters params = new UpdateParameters(variables, getTimestamp(clientState), getTimeToLive());

File: src/java/org/apache/cassandra/service/RangeSliceVerbHandler.java
Patch:
@@ -36,7 +36,7 @@ public class RangeSliceVerbHandler implements IVerbHandler<RangeSliceCommand>
 {
     private static final Logger logger = LoggerFactory.getLogger(RangeSliceVerbHandler.class);
 
-    static List<Row> executeLocally(RangeSliceCommand command) throws ExecutionException, InterruptedException
+    public static List<Row> executeLocally(RangeSliceCommand command) throws ExecutionException, InterruptedException
     {
         ColumnFamilyStore cfs = Table.open(command.keyspace).getColumnFamilyStore(command.column_family);
         if (cfs.indexManager.hasIndexFor(command.row_filter))

File: src/java/org/apache/cassandra/net/IncomingTcpConnection.java
Patch:
@@ -179,7 +179,7 @@ private InetAddress receiveMessage(DataInputStream input, int version) throws IO
 
         String id = input.readUTF();
         long timestamp = version >= MessagingService.VERSION_12
-                       ? (System.currentTimeMillis() | 0x00000000FFFFFFFFL) & input.readInt()
+                       ? (System.currentTimeMillis() & 0xFFFFFFFF00000000L) | ((input.readInt() << 2) >> 2)
                        : System.currentTimeMillis();
 
         MessageIn message = MessageIn.read(input, version, id);

File: src/java/org/apache/cassandra/transport/messages/ResultMessage.java
Patch:
@@ -160,7 +160,7 @@ public String toString()
 
     public static class SetKeyspace extends ResultMessage
     {
-        private final String keyspace;
+        public final String keyspace;
 
         public SetKeyspace(String keyspace)
         {

File: src/java/org/apache/cassandra/cql/QueryProcessor.java
Patch:
@@ -493,7 +493,7 @@ else if (oldKeyspace == null)
                                 if (c.isMarkedForDelete())
                                     continue;
 
-                                ColumnDefinition cd = metadata.getColumnDefinition(c.name());
+                                ColumnDefinition cd = metadata.getColumnDefinitionFromColumnName(c.name());
                                 if (cd != null)
                                     result.schema.value_types.put(c.name(), TypeParser.getShortName(cd.getValidator()));
 
@@ -531,7 +531,7 @@ else if (oldKeyspace == null)
                                 throw new AssertionError(e);
                             }
 
-                            ColumnDefinition cd = metadata.getColumnDefinition(name);
+                            ColumnDefinition cd = metadata.getColumnDefinitionFromColumnName(name);
                             if (cd != null)
                                 result.schema.value_types.put(name, TypeParser.getShortName(cd.getValidator()));
                             IColumn c = row.cf.getColumn(name);

File: src/java/org/apache/cassandra/thrift/ThriftValidation.java
Patch:
@@ -396,7 +396,7 @@ public static void validateColumnData(CFMetaData metadata, Column column, boolea
         if (!column.isSetTimestamp())
             throw new org.apache.cassandra.exceptions.InvalidRequestException("Column timestamp is required");
 
-        ColumnDefinition columnDef = metadata.getColumnDefinition(column.name);
+        ColumnDefinition columnDef = metadata.getColumnDefinitionFromColumnName(column.name);
         try
         {
             AbstractType<?> validator = metadata.getValueValidator(columnDef);

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -1070,13 +1070,13 @@ public CFMetaData validate() throws ConfigurationException
         {
             for (ColumnDefinition def : column_metadata.values())
                 if (!(def.getValidator() instanceof CounterColumnType))
-                    throw new ConfigurationException("Cannot add a non counter column (" + comparator.getString(def.name) + ") in a counter column family");
+                    throw new ConfigurationException("Cannot add a non counter column (" + getColumnDefinitionComparator(def).getString(def.name) + ") in a counter column family");
         }
         else
         {
             for (ColumnDefinition def : column_metadata.values())
                 if (def.getValidator() instanceof CounterColumnType)
-                    throw new ConfigurationException("Cannot add a counter column (" + comparator.getString(def.name) + ") in a non counter column family");
+                    throw new ConfigurationException("Cannot add a counter column (" + getColumnDefinitionComparator(def).getString(def.name) + ") in a non counter column family");
         }
 
         // check if any of the columns has name equal to the cf.key_alias

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -927,9 +927,9 @@ public static boolean isIndexNameValid(String name)
     public CFMetaData validate() throws ConfigurationException
     {
         if (!isNameValid(ksName))
-            throw new ConfigurationException(String.format("Invalid keyspace name: shouldn't be empty nor more than %s characters long (got \"%s\")", Schema.NAME_LENGTH, ksName));
+            throw new ConfigurationException(String.format("Keyspace name must not be empty, more than %s characters long, or contain non-alphanumeric-underscore characters (got \"%s\")", Schema.NAME_LENGTH, ksName));
         if (!isNameValid(cfName))
-            throw new ConfigurationException(String.format("Invalid keyspace name: shouldn't be empty nor more than %s characters long (got \"%s\")", Schema.NAME_LENGTH, cfName));
+            throw new ConfigurationException(String.format("ColumnFamily name must not be empty, more than %s characters long, or contain non-alphanumeric-underscore characters (got \"%s\")", Schema.NAME_LENGTH, cfName));
 
         if (cfType == null)
             throw new ConfigurationException(String.format("Invalid column family type for %s", cfName));

File: src/java/org/apache/cassandra/config/KSMetaData.java
Patch:
@@ -189,7 +189,7 @@ public RowMutation toSchemaUpdate(KSMetaData newState, long modificationTimestam
     public KSMetaData validate() throws ConfigurationException
     {
         if (!CFMetaData.isNameValid(name))
-            throw new ConfigurationException(String.format("Invalid keyspace name: shouldn't be empty nor more than %s characters long (got \"%s\")", Schema.NAME_LENGTH, name));
+            throw new ConfigurationException(String.format("Keyspace name must not be empty, more than %s characters long, or contain non-alphanumeric-underscore characters (got \"%s\")", Schema.NAME_LENGTH, name));
 
         // Attempt to instantiate the ARS, which will throw a ConfigException if the strategy_options aren't fully formed
         TokenMetadata tmd = StorageService.instance.getTokenMetadata();

File: src/java/org/apache/cassandra/cql/UpdateStatement.java
Patch:
@@ -148,7 +148,7 @@ public List<IMutation> prepareRowMutations(String keyspace, ClientState clientSt
 
         CFMetaData metadata = validateColumnFamily(keyspace, columnFamily, hasCommutativeOperation);
         if (hasCommutativeOperation)
-            validateCommutativeForWrite(metadata, cLevel);
+            validateCommutativeForWrite(metadata, getConsistencyLevel());
 
         QueryProcessor.validateKeyAlias(metadata, keyName);
 

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -790,7 +790,7 @@ public void runMayThrow() throws IOException
                 responseHandler.response(null);
 
                 // then send to replicas, if any
-                Set<InetAddress> remotes = Sets.difference(ImmutableSet.copyOf(targets), ImmutableSet.of(FBUtilities.getBroadcastAddress()));
+                final Set<InetAddress> remotes = Sets.difference(ImmutableSet.copyOf(targets), ImmutableSet.of(FBUtilities.getBroadcastAddress()));
                 if (cm.shouldReplicateOnWrite() && !remotes.isEmpty())
                 {
                     // We do the replication on another stage because it involves a read (see CM.makeReplicationMutation)

File: src/java/org/apache/cassandra/gms/GossipDigestAck.java
Patch:
@@ -63,7 +63,7 @@ class GossipDigestAckSerializer implements IVersionedSerializer<GossipDigestAck>
     public void serialize(GossipDigestAck gDigestAckMessage, DataOutput dos, int version) throws IOException
     {
         GossipDigestSerializationHelper.serialize(gDigestAckMessage.gDigestList, dos, version);
-        if (version <= MessagingService.VERSION_10)
+        if (version <= MessagingService.VERSION_11)
             dos.writeBoolean(true); // 0.6 compatibility
         dos.writeInt(gDigestAckMessage.epStateMap.size());
         for (Map.Entry<InetAddress, EndpointState> entry : gDigestAckMessage.epStateMap.entrySet())
@@ -77,7 +77,7 @@ public void serialize(GossipDigestAck gDigestAckMessage, DataOutput dos, int ver
     public GossipDigestAck deserialize(DataInput dis, int version) throws IOException
     {
         List<GossipDigest> gDigestList = GossipDigestSerializationHelper.deserialize(dis, version);
-        if (version <= MessagingService.VERSION_10)
+        if (version <= MessagingService.VERSION_11)
             dis.readBoolean(); // 0.6 compatibility
         int size = dis.readInt();
         Map<InetAddress, EndpointState> epStateMap = new HashMap<InetAddress, EndpointState>(size);

File: src/java/org/apache/cassandra/transport/DataType.java
Patch:
@@ -159,7 +159,7 @@ else if (type instanceof MapType)
                 else
                 {
                     assert type instanceof SetType;
-                    return Pair.<DataType, Object>create(LIST, ((SetType)type).elements);
+                    return Pair.<DataType, Object>create(SET, ((SetType)type).elements);
                 }
             }
             return Pair.<DataType, Object>create(CUSTOM, type.toString());

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -451,8 +451,9 @@ public static Collection<InetAddress> getWriteEndpoints(String table, ByteBuffer
      */
     private static Collection<InetAddress> getBatchlogEndpoints(String localDataCenter) throws UnavailableException
     {
-        // will include every known node including localhost.
-        Collection<InetAddress> localMembers = StorageService.instance.getTokenMetadata().getTopology().getDatacenterEndpoints().get(localDataCenter);
+        // will include every known node in the DC, including localhost.
+        TokenMetadata.Topology topology = StorageService.instance.getTokenMetadata().cloneOnlyTokenMap().getTopology();
+        Collection<InetAddress> localMembers = topology.getDatacenterEndpoints().get(localDataCenter);
 
         // special case for single-node datacenters
         if (localMembers.size() == 1)

File: src/java/org/apache/cassandra/streaming/FileStreamTask.java
Patch:
@@ -192,6 +192,7 @@ protected void receiveReply() throws IOException
     {
         MessagingService.validateMagic(input.readInt());
         String id = input.readUTF();
+        input.readInt(); // skip timestamp
         // since we reject streaming with different version, using current_version here is fine
         MessageIn message = MessageIn.read(input, MessagingService.current_version, id);
         assert message.verb == MessagingService.Verb.STREAM_REPLY : "Non-reply message received on stream socket";

File: src/java/org/apache/cassandra/service/ClientState.java
Patch:
@@ -189,9 +189,9 @@ public void hasColumnFamilyAccess(String keyspace, String columnFamily, Permissi
         resourceClear();
         resource.add(keyspace);
 
-        // check if keyspace access is set to Permission.ALL
+        // check if keyspace access is set to Permission.FULL_ACCESS
         // (which means that user has all access on keyspace and it's underlying elements)
-        if (DatabaseDescriptor.getAuthority().authorize(user, resource).contains(Permission.ALL))
+        if (DatabaseDescriptor.getAuthority().authorize(user, resource).contains(Permission.FULL_ACCESS))
             return;
 
         resource.add(columnFamily);

File: src/java/org/apache/cassandra/service/ClientState.java
Patch:
@@ -46,7 +46,7 @@ public class ClientState
 {
     private static final int MAX_CACHE_PREPARED = 10000;    // Enough to keep buggy clients from OOM'ing us
     private static final Logger logger = LoggerFactory.getLogger(ClientState.class);
-    public static final SemanticVersion DEFAULT_CQL_VERSION = org.apache.cassandra.cql.QueryProcessor.CQL_VERSION;
+    public static final SemanticVersion DEFAULT_CQL_VERSION = org.apache.cassandra.cql3.QueryProcessor.CQL_VERSION;
 
     // Current user for the session
     private AuthenticatedUser user;

File: src/java/org/apache/cassandra/cql/jdbc/JdbcDate.java
Patch:
@@ -108,7 +108,7 @@ public Class<Date> getType()
 
     public int getJdbcType()
     {
-        return Types.DATE;
+        return Types.TIMESTAMP;
     }
 
     public Date compose(ByteBuffer bytes)

File: src/java/org/apache/cassandra/db/CounterColumn.java
Patch:
@@ -370,7 +370,7 @@ public void apply(IMutation mutation, Collection<InetAddress> targets, IWriteRes
                 responseHandler.response(null);
                 StorageProxy.sendToHintedEndpoints((RowMutation) mutation, targets, responseHandler, localDataCenter, consistency_level);
             }
-        });
+        }, null);
 
         // we don't wait for answers
     }

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -1274,6 +1274,9 @@ public void setBound(ColumnIdentifier name, Relation.Type type, Term t) throws I
                     break;
             }
 
+            if (bounds == null)
+                throw new InvalidRequestException(String.format("%s cannot be restricted by both an equal and an inequal relation", name));
+
             if (bounds[b.idx] != null)
                 throw new InvalidRequestException(String.format("Invalid restrictions found on %s", name));
             bounds[b.idx] = t;

File: src/java/org/apache/cassandra/cql/jdbc/JdbcUTF8.java
Patch:
@@ -19,14 +19,14 @@
 
 import java.nio.ByteBuffer;
 import java.nio.charset.CharacterCodingException;
+import java.nio.charset.Charset;
 import java.sql.Types;
 
 import org.apache.cassandra.utils.ByteBufferUtil;
 
-import com.google.common.base.Charsets;
-
 public class JdbcUTF8 extends AbstractJdbcType<String>
 {
+    private static final Charset UTF_8 = Charset.forName("UTF-8");
     public static final JdbcUTF8 instance = new JdbcUTF8();
 
     public JdbcUTF8() {}
@@ -95,6 +95,6 @@ public String compose(ByteBuffer bytes)
 
     public ByteBuffer decompose(String value)
     {
-        return ByteBufferUtil.bytes(value, Charsets.UTF_8);
+        return ByteBufferUtil.bytes(value, UTF_8);
     }
 }

File: src/java/org/apache/cassandra/db/SchemaCheckVerbHandler.java
Patch:
@@ -19,15 +19,15 @@
 
 import java.util.UUID;
 
-import org.apache.cassandra.config.Schema;
-import org.apache.cassandra.utils.UUIDGen;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.net.IVerbHandler;
 import org.apache.cassandra.net.MessageIn;
 import org.apache.cassandra.net.MessageOut;
 import org.apache.cassandra.net.MessagingService;
+import org.apache.cassandra.utils.UUIDSerializer;
 
 public class SchemaCheckVerbHandler implements IVerbHandler
 {
@@ -36,7 +36,7 @@ public class SchemaCheckVerbHandler implements IVerbHandler
     public void doVerb(MessageIn message, String id)
     {
         logger.debug("Received schema check request.");
-        MessageOut<UUID> response = new MessageOut<UUID>(MessagingService.Verb.INTERNAL_RESPONSE, Schema.instance.getVersion(), UUIDGen.serializer);
+        MessageOut<UUID> response = new MessageOut<UUID>(MessagingService.Verb.INTERNAL_RESPONSE, Schema.instance.getVersion(), UUIDSerializer.serializer);
         MessagingService.instance().sendReply(response, id, message.from);
     }
 }

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -184,7 +184,7 @@ public enum Verb
         put(Verb.TREE_REQUEST, AntiEntropyService.TreeRequest.serializer);
         put(Verb.TREE_RESPONSE, AntiEntropyService.Validator.serializer);
         put(Verb.STREAMING_REPAIR_REQUEST, StreamingRepairTask.serializer);
-        put(Verb.STREAMING_REPAIR_RESPONSE, UUIDGen.serializer);
+        put(Verb.STREAMING_REPAIR_RESPONSE, UUIDSerializer.serializer);
         put(Verb.GOSSIP_DIGEST_ACK, GossipDigestAck.serializer);
         put(Verb.GOSSIP_DIGEST_ACK2, GossipDigestAck2.serializer);
         put(Verb.GOSSIP_DIGEST_SYN, GossipDigestSyn.serializer);
@@ -209,7 +209,7 @@ public enum Verb
         put(Verb.SNAPSHOT, null);
 
         put(Verb.MIGRATION_REQUEST, MigrationManager.MigrationsSerializer.instance);
-        put(Verb.SCHEMA_CHECK, UUIDGen.serializer);
+        put(Verb.SCHEMA_CHECK, UUIDSerializer.serializer);
         put(Verb.BOOTSTRAP_TOKEN, BootStrapper.StringSerializer.instance);
         put(Verb.REPLICATION_FINISHED, null);
     }};

File: src/java/org/apache/cassandra/utils/ByteBufferUtil.java
Patch:
@@ -31,8 +31,6 @@
 import java.util.Arrays;
 import java.util.UUID;
 
-import static com.google.common.base.Charsets.UTF_8;
-
 import org.apache.cassandra.io.util.FileDataInput;
 import org.apache.cassandra.io.util.FileUtils;
 
@@ -76,6 +74,7 @@
  */
 public class ByteBufferUtil
 {
+    private static final Charset UTF_8 = Charset.forName("UTF-8");
     public static final ByteBuffer EMPTY_BYTE_BUFFER = ByteBuffer.wrap(new byte[0]);
 
     public static int compareUnsigned(ByteBuffer o1, ByteBuffer o2)

File: examples/simple_authentication/src/org/apache/cassandra/auth/SimpleAuthenticator.java
Patch:
@@ -29,7 +29,7 @@
 import java.util.Map;
 import java.util.Properties;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.thrift.AuthenticationException;
 import org.apache.cassandra.utils.FBUtilities;

File: examples/simple_authentication/src/org/apache/cassandra/auth/SimpleAuthority.java
Patch:
@@ -29,7 +29,7 @@
 import java.util.List;
 import java.util.Properties;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.io.util.FileUtils;
 
 public class SimpleAuthority implements IAuthority

File: src/java/org/apache/cassandra/auth/AllowAllAuthenticator.java
Patch:
@@ -19,7 +19,7 @@
 
 import java.util.Map;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.thrift.AuthenticationException;
 
 public class AllowAllAuthenticator implements IAuthenticator

File: src/java/org/apache/cassandra/auth/AllowAllAuthority.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.EnumSet;
 import java.util.List;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 
 public class AllowAllAuthority implements IAuthority
 {

File: src/java/org/apache/cassandra/auth/IAuthenticator.java
Patch:
@@ -19,7 +19,7 @@
 
 import java.util.Map;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.thrift.AuthenticationException;
 
 public interface IAuthenticator

File: src/java/org/apache/cassandra/auth/IAuthority.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.EnumSet;
 import java.util.List;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 
 /**
  * Cassandra's resource hierarchy looks something like:

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -34,7 +34,7 @@
 
 import org.antlr.runtime.tree.Tree;
 import org.apache.cassandra.auth.IAuthenticator;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.RequestValidationException;
 import org.apache.cassandra.db.ColumnFamilyStoreMBean;
 import org.apache.cassandra.db.compaction.CompactionManagerMBean;
 import org.apache.cassandra.db.compaction.OperationType;
@@ -547,7 +547,7 @@ private AbstractType<?> getFormatType(String compareWith)
             {
                 return TypeParser.parse(compareWith);
             }
-            catch (ConfigurationException ce)
+            catch (RequestValidationException ce)
             {
                 StringBuilder errorMessage = new StringBuilder("Unknown comparator '" + compareWith + "'. ");
                 errorMessage.append("Available functions: ");
@@ -1545,7 +1545,7 @@ private boolean applyAssumption(String cfName, String assumptionElement, String
         {
             comparator = TypeParser.parse(defaultType);
         }
-        catch (ConfigurationException e)
+        catch (RequestValidationException e)
         {
             try
             {

File: src/java/org/apache/cassandra/config/Avro.java
Patch:
@@ -26,6 +26,8 @@
 import org.apache.cassandra.db.marshal.BytesType;
 import org.apache.cassandra.db.marshal.TypeParser;
 import org.apache.cassandra.db.migration.avro.CfDef;
+import org.apache.cassandra.exceptions.ConfigurationException;
+import org.apache.cassandra.exceptions.RequestValidationException;
 import org.apache.cassandra.io.compress.CompressionParameters;
 import org.apache.cassandra.locator.AbstractReplicationStrategy;
 import org.apache.cassandra.locator.NetworkTopologyStrategy;
@@ -211,7 +213,7 @@ public static ColumnDefinition columnFromAvro(org.apache.cassandra.db.migration.
             AbstractType<?> validatorType = TypeParser.parse(cd.validation_class);
             return new ColumnDefinition(ByteBufferUtil.clone(cd.name), validatorType, index_type, ColumnDefinition.getStringMap(cd.index_options), index_name, null);
         }
-        catch (ConfigurationException e)
+        catch (RequestValidationException e)
         {
             throw new RuntimeException(e);
         }

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -40,6 +40,7 @@
 import org.apache.cassandra.db.DefsTable;
 import org.apache.cassandra.db.SystemTable;
 import org.apache.cassandra.dht.IPartitioner;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.io.FSWriteError;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.locator.DynamicEndpointSnitch;

File: src/java/org/apache/cassandra/config/KSMetaData.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.cassandra.cql3.UntypedResultSet;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.filter.QueryPath;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.locator.*;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.thrift.CfDef;

File: src/java/org/apache/cassandra/cql/AlterTableStatement.java
Patch:
@@ -19,8 +19,8 @@
 
 import org.apache.cassandra.config.*;
 import org.apache.cassandra.db.marshal.TypeParser;
+import org.apache.cassandra.exceptions.*;
 import org.apache.cassandra.io.compress.CompressionParameters;
-import org.apache.cassandra.thrift.InvalidRequestException;
 
 import java.nio.ByteBuffer;
 import java.util.HashMap;
@@ -63,7 +63,7 @@ public AlterTableStatement(String columnFamily, OperationType type, String colum
         }
     }
 
-    public CFMetaData getCFMetaData(String keyspace) throws ConfigurationException, InvalidRequestException
+    public CFMetaData getCFMetaData(String keyspace) throws ConfigurationException, InvalidRequestException, SyntaxException
     {
         CFMetaData meta = Schema.instance.getCFMetaData(keyspace, columnFamily);
         CFMetaData cfm = meta.clone();
@@ -171,7 +171,7 @@ public static void applyPropertiesToCFMetadata(CFMetaData cfm, CFPropDefs cfProp
             {
                 cfm.defaultValidator(cfProps.getValidator());
             }
-            catch (ConfigurationException e)
+            catch (RequestValidationException e)
             {
                 throw new InvalidRequestException(String.format("Invalid validation type %s",
                                                                 cfProps.getProperty(CFPropDefs.KW_DEFAULTVALIDATION)));

File: src/java/org/apache/cassandra/cql/Attributes.java
Patch:
@@ -17,7 +17,7 @@
  */
 package org.apache.cassandra.cql;
 
-import org.apache.cassandra.thrift.ConsistencyLevel;
+import org.apache.cassandra.db.ConsistencyLevel;
 
 /**
  * Class to contain attributes for statements

File: src/java/org/apache/cassandra/cql/CreateKeyspaceStatement.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import org.apache.cassandra.thrift.InvalidRequestException;
+import org.apache.cassandra.exceptions.InvalidRequestException;
 
 /** A <code>CREATE KEYSPACE</code> statement parsed from a CQL query. */
 public class CreateKeyspaceStatement

File: src/java/org/apache/cassandra/cql/DropIndexStatement.java
Patch:
@@ -20,9 +20,10 @@
 import java.io.IOException;
 
 import org.apache.cassandra.config.*;
+import org.apache.cassandra.exceptions.ConfigurationException;
+import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.thrift.CfDef;
 import org.apache.cassandra.thrift.ColumnDef;
-import org.apache.cassandra.thrift.InvalidRequestException;
 
 public class DropIndexStatement
 {

File: src/java/org/apache/cassandra/cql/SelectStatement.java
Patch:
@@ -24,7 +24,7 @@
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.db.marshal.AbstractType;
-import org.apache.cassandra.thrift.ConsistencyLevel;
+import org.apache.cassandra.db.ConsistencyLevel;
 
 /**
  * Encapsulates a completely parsed SELECT query, including the target

File: src/java/org/apache/cassandra/cql/Term.java
Patch:
@@ -26,7 +26,7 @@
 import org.apache.cassandra.db.marshal.IntegerType;
 import org.apache.cassandra.db.marshal.LexicalUUIDType;
 import org.apache.cassandra.db.marshal.MarshalException;
-import org.apache.cassandra.thrift.InvalidRequestException;
+import org.apache.cassandra.exceptions.InvalidRequestException;
 
 /** A term parsed from a CQL statement. */
 public class Term

File: src/java/org/apache/cassandra/cql3/Attributes.java
Patch:
@@ -17,7 +17,7 @@
  */
 package org.apache.cassandra.cql3;
 
-import org.apache.cassandra.thrift.ConsistencyLevel;
+import org.apache.cassandra.db.ConsistencyLevel;
 
 /**
  * Utility class for the Parser to gather attributes for modification

File: src/java/org/apache/cassandra/cql3/CFDefinition.java
Patch:
@@ -29,7 +29,7 @@
 import org.apache.cassandra.db.marshal.ColumnToCollectionType;
 import org.apache.cassandra.db.marshal.CompositeType;
 import org.apache.cassandra.db.marshal.UTF8Type;
-import org.apache.cassandra.thrift.InvalidRequestException;
+import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
 /**

File: src/java/org/apache/cassandra/cql3/CFPropDefs.java
Patch:
@@ -19,7 +19,7 @@
 
 import com.google.common.collect.Sets;
 import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.db.compaction.AbstractCompactionStrategy;
 import org.apache.cassandra.io.compress.CompressionParameters;
 import org.slf4j.Logger;

File: src/java/org/apache/cassandra/cql3/ColumnNameBuilder.java
Patch:
@@ -20,7 +20,7 @@
 import java.nio.ByteBuffer;
 import java.util.List;
 
-import org.apache.cassandra.thrift.InvalidRequestException;
+import org.apache.cassandra.exceptions.InvalidRequestException;
 
 /**
  * Build a potentially composite column name.

File: src/java/org/apache/cassandra/cql3/Term.java
Patch:
@@ -21,12 +21,12 @@
 import java.util.Collections;
 import java.util.List;
 
-import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.MarshalException;
-import org.apache.cassandra.thrift.InvalidRequestException;
+import org.apache.cassandra.exceptions.ConfigurationException;
+import org.apache.cassandra.exceptions.InvalidRequestException;
 
 /** A term parsed from a CQL statement. */
 public class Term

File: src/java/org/apache/cassandra/cql3/operations/ColumnOperation.java
Patch:
@@ -28,7 +28,7 @@
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.CollectionType;
 import org.apache.cassandra.db.marshal.LongType;
-import org.apache.cassandra.thrift.InvalidRequestException;
+import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.Pair;
 

File: src/java/org/apache/cassandra/cql3/operations/ListOperation.java
Patch:
@@ -31,7 +31,7 @@
 import org.apache.cassandra.db.IColumn;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.CollectionType;
-import org.apache.cassandra.thrift.InvalidRequestException;
+import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.utils.Pair;
 import org.apache.cassandra.utils.UUIDGen;
 

File: src/java/org/apache/cassandra/cql3/operations/MapOperation.java
Patch:
@@ -30,7 +30,7 @@
 import org.apache.cassandra.db.IColumn;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.CollectionType;
-import org.apache.cassandra.thrift.InvalidRequestException;
+import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.utils.Pair;
 
 public class MapOperation implements Operation

File: src/java/org/apache/cassandra/cql3/operations/Operation.java
Patch:
@@ -27,7 +27,7 @@
 import org.apache.cassandra.db.IColumn;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.CollectionType;
-import org.apache.cassandra.thrift.InvalidRequestException;
+import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.utils.Pair;
 
 public interface Operation

File: src/java/org/apache/cassandra/cql3/operations/SetOperation.java
Patch:
@@ -27,7 +27,7 @@
 import org.apache.cassandra.db.IColumn;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.CollectionType;
-import org.apache.cassandra.thrift.InvalidRequestException;
+import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.Pair;
 

File: src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java
Patch:
@@ -27,8 +27,8 @@
 import org.apache.cassandra.db.marshal.ColumnToCollectionType;
 import org.apache.cassandra.db.marshal.CompositeType;
 import org.apache.cassandra.db.marshal.CounterColumnType;
+import org.apache.cassandra.exceptions.*;
 import org.apache.cassandra.service.MigrationManager;
-import org.apache.cassandra.thrift.InvalidRequestException;
 
 import static org.apache.cassandra.thrift.ThriftValidation.validateColumnFamily;
 

File: src/java/org/apache/cassandra/cql3/statements/CFStatement.java
Patch:
@@ -19,7 +19,7 @@
 
 import org.apache.cassandra.cql3.CFName;
 import org.apache.cassandra.service.ClientState;
-import org.apache.cassandra.thrift.InvalidRequestException;
+import org.apache.cassandra.exceptions.InvalidRequestException;
 
 /**
  * Abstract class for statements that apply on a given column family.

File: src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java
Patch:
@@ -26,13 +26,13 @@
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.ColumnDefinition;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.cql3.*;
 import org.apache.cassandra.db.index.composites.CompositesIndex;
 import org.apache.cassandra.db.marshal.CompositeType;
 import org.apache.cassandra.service.MigrationManager;
 import org.apache.cassandra.thrift.IndexType;
-import org.apache.cassandra.thrift.InvalidRequestException;
+import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.thrift.ThriftValidation;
 
 /** A <code>CREATE INDEX</code> statement parsed from a CQL query. */

File: src/java/org/apache/cassandra/cql3/statements/DeleteStatement.java
Patch:
@@ -35,9 +35,8 @@
 import org.apache.cassandra.db.marshal.CompositeType;
 import org.apache.cassandra.db.marshal.ListType;
 import org.apache.cassandra.db.marshal.MapType;
+import org.apache.cassandra.exceptions.*;
 import org.apache.cassandra.service.ClientState;
-import org.apache.cassandra.thrift.InvalidRequestException;
-import org.apache.cassandra.thrift.UnavailableException;
 import org.apache.cassandra.thrift.ThriftValidation;
 import org.apache.cassandra.utils.Pair;
 
@@ -63,7 +62,8 @@ public DeleteStatement(CFName name, List<Selector> columns, List<Relation> where
         this.toRemove = new ArrayList<Pair<CFDefinition.Name, Term>>(columns.size());
     }
 
-    public List<IMutation> getMutations(ClientState clientState, List<ByteBuffer> variables) throws UnavailableException, TimeoutException, InvalidRequestException
+    public List<IMutation> getMutations(ClientState clientState, List<ByteBuffer> variables)
+    throws RequestExecutionException, RequestValidationException
     {
         // keys
         List<ByteBuffer> keys = UpdateStatement.buildKeyNames(cfDef, processedKeys, variables);

File: src/java/org/apache/cassandra/cql3/statements/DropColumnFamilyStatement.java
Patch:
@@ -17,7 +17,7 @@
  */
 package org.apache.cassandra.cql3.statements;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.cql3.CFName;
 import org.apache.cassandra.service.MigrationManager;
 

File: src/java/org/apache/cassandra/cql3/statements/DropIndexStatement.java
Patch:
@@ -20,8 +20,8 @@
 
 import org.apache.cassandra.cql3.*;
 import org.apache.cassandra.config.*;
+import org.apache.cassandra.exceptions.*;
 import org.apache.cassandra.service.MigrationManager;
-import org.apache.cassandra.thrift.InvalidRequestException;
 
 public class DropIndexStatement extends SchemaAlteringStatement
 {

File: src/java/org/apache/cassandra/cql3/statements/DropKeyspaceStatement.java
Patch:
@@ -18,10 +18,10 @@
 package org.apache.cassandra.cql3.statements;
 
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
+import org.apache.cassandra.exceptions.RequestValidationException;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.MigrationManager;
-import org.apache.cassandra.thrift.InvalidRequestException;
 import org.apache.cassandra.thrift.ThriftValidation;
 
 public class DropKeyspaceStatement extends SchemaAlteringStatement
@@ -35,7 +35,7 @@ public DropKeyspaceStatement(String keyspace)
     }
 
     @Override
-    public void validate(ClientState state) throws InvalidRequestException
+    public void validate(ClientState state) throws RequestValidationException
     {
         super.validate(state);
         ThriftValidation.validateKeyspaceNotSystem(keyspace);

File: src/java/org/apache/cassandra/cql3/statements/ParsedStatement.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.List;
 
 import org.apache.cassandra.cql3.*;
-import org.apache.cassandra.thrift.InvalidRequestException;
+import org.apache.cassandra.exceptions.RequestValidationException;
 
 public abstract class ParsedStatement
 {
@@ -38,7 +38,7 @@ public void setBoundTerms(int boundTerms)
         this.boundTerms = boundTerms;
     }
 
-    public abstract Prepared prepare() throws InvalidRequestException;
+    public abstract Prepared prepare() throws RequestValidationException;
 
     public static class Prepared
     {

File: src/java/org/apache/cassandra/cql3/statements/UseStatement.java
Patch:
@@ -21,9 +21,9 @@
 import java.util.List;
 
 import org.apache.cassandra.cql3.CQLStatement;
+import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.transport.messages.ResultMessage;
 import org.apache.cassandra.service.ClientState;
-import org.apache.cassandra.thrift.InvalidRequestException;
 
 public class UseStatement extends ParsedStatement implements CQLStatement
 {

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -60,6 +60,7 @@
 import org.apache.cassandra.db.index.SecondaryIndexManager;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.dht.*;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.io.compress.CompressionParameters;
 import org.apache.cassandra.io.sstable.*;
 import org.apache.cassandra.io.sstable.Descriptor;

File: src/java/org/apache/cassandra/db/ColumnFamilyStoreMBean.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.Map;
 import java.util.concurrent.ExecutionException;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 
 /**
  * The MBean interface for ColumnFamilyStore

File: src/java/org/apache/cassandra/db/CounterMutation.java
Patch:
@@ -30,7 +30,7 @@
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.net.MessageOut;
 import org.apache.cassandra.net.MessagingService;
-import org.apache.cassandra.thrift.ConsistencyLevel;
+import org.apache.cassandra.db.ConsistencyLevel;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.HeapAllocator;
 

File: src/java/org/apache/cassandra/db/DefsTable.java
Patch:
@@ -41,6 +41,7 @@
 import org.apache.cassandra.db.marshal.AsciiType;
 import org.apache.cassandra.db.marshal.UTF8Type;
 import org.apache.cassandra.db.migration.avro.KsDef;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;

File: src/java/org/apache/cassandra/db/HintedHandOffManager.java
Patch:
@@ -44,6 +44,7 @@
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.Token;
+import org.apache.cassandra.exceptions.WriteTimeoutException;
 import org.apache.cassandra.gms.ApplicationState;
 import org.apache.cassandra.gms.FailureDetector;
 import org.apache.cassandra.gms.Gossiper;
@@ -125,7 +126,7 @@ public void run()
         StorageService.optionalTasks.scheduleWithFixedDelay(runnable, 10, 10, TimeUnit.MINUTES);
     }
 
-    private static void sendMutation(InetAddress endpoint, MessageOut<?> message) throws TimedOutException
+    private static void sendMutation(InetAddress endpoint, MessageOut<?> message) throws WriteTimeoutException
     {
         IWriteResponseHandler responseHandler = WriteResponseHandler.create(endpoint);
         MessagingService.instance().sendRR(message, endpoint, responseHandler);
@@ -364,7 +365,7 @@ public int targetThroughput()
                     }
                     deleteHint(hostIdBytes, hint.name(), hint.maxTimestamp());
                 }
-                catch (TimedOutException e)
+                catch (WriteTimeoutException e)
                 {
                     logger.info(String.format("Timed out replaying hints to %s; aborting further deliveries", endpoint));
                     break delivery;

File: src/java/org/apache/cassandra/db/KeyspaceNotDefinedException.java
Patch:
@@ -17,7 +17,7 @@
  */
 package org.apache.cassandra.db;
 
-import org.apache.cassandra.thrift.InvalidRequestException;
+import org.apache.cassandra.exceptions.InvalidRequestException;
 
 public class KeyspaceNotDefinedException extends InvalidRequestException
 {

File: src/java/org/apache/cassandra/db/SystemTable.java
Patch:
@@ -28,7 +28,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.cql3.QueryProcessor;
 import org.apache.cassandra.cql3.UntypedResultSet;

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -37,6 +37,7 @@
 import org.apache.cassandra.db.filter.QueryFilter;
 import org.apache.cassandra.db.index.SecondaryIndex;
 import org.apache.cassandra.db.index.SecondaryIndexManager;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.io.sstable.SSTableReader;
 import org.apache.cassandra.locator.AbstractReplicationStrategy;
 import org.apache.cassandra.service.StorageService;

File: src/java/org/apache/cassandra/db/index/SecondaryIndex.java
Patch:
@@ -28,7 +28,7 @@
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.ColumnDefinition;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.db.IColumn;

File: src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java
Patch:
@@ -29,7 +29,7 @@
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.config.ColumnDefinition;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.compaction.CompactionManager;
 import org.apache.cassandra.db.filter.IFilter;

File: src/java/org/apache/cassandra/db/index/composites/CompositesIndex.java
Patch:
@@ -21,12 +21,12 @@
 import java.util.Set;
 
 import org.apache.cassandra.config.ColumnDefinition;
-import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.index.AbstractSimplePerColumnSecondaryIndex;
 import org.apache.cassandra.db.index.SecondaryIndex;
 import org.apache.cassandra.db.index.SecondaryIndexSearcher;
 import org.apache.cassandra.db.marshal.*;
+import org.apache.cassandra.exceptions.ConfigurationException;
 
 /**
  * Implements a secondary index for a column family using a second column family

File: src/java/org/apache/cassandra/db/index/keys/KeysIndex.java
Patch:
@@ -23,7 +23,7 @@
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.ColumnDefinition;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.index.AbstractSimplePerColumnSecondaryIndex;
 import org.apache.cassandra.db.index.SecondaryIndexSearcher;

File: src/java/org/apache/cassandra/db/marshal/AbstractType.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.Comparator;
 import java.util.Map;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.SyntaxException;
 import org.apache.cassandra.db.IColumn;
 import org.apache.cassandra.db.OnDiskAtom;
 import org.apache.cassandra.db.RangeTombstone;
@@ -174,7 +174,7 @@ public boolean isCommutative()
         return false;
     }
 
-    public static AbstractType<?> parseDefaultParameters(AbstractType<?> baseType, TypeParser parser) throws ConfigurationException
+    public static AbstractType<?> parseDefaultParameters(AbstractType<?> baseType, TypeParser parser) throws SyntaxException
     {
         Map<String, String> parameters = parser.getKeyValueParameters();
         String reversed = parameters.get("reversed");

File: src/java/org/apache/cassandra/db/marshal/ColumnToCollectionType.java
Patch:
@@ -23,7 +23,8 @@
 
 import com.google.common.collect.ImmutableMap;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
+import org.apache.cassandra.exceptions.SyntaxException;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
 public class ColumnToCollectionType extends AbstractType<ByteBuffer>
@@ -33,7 +34,7 @@ public class ColumnToCollectionType extends AbstractType<ByteBuffer>
 
     public final Map<ByteBuffer, CollectionType> defined;
 
-    public static ColumnToCollectionType getInstance(TypeParser parser) throws ConfigurationException
+    public static ColumnToCollectionType getInstance(TypeParser parser) throws SyntaxException, ConfigurationException
     {
         return getInstance(parser.getCollectionsParameters());
     }

File: src/java/org/apache/cassandra/db/marshal/ListType.java
Patch:
@@ -21,7 +21,8 @@
 import java.util.*;
 
 import org.apache.cassandra.db.IColumn;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
+import org.apache.cassandra.exceptions.SyntaxException;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.Pair;
@@ -33,7 +34,7 @@ public class ListType<T> extends CollectionType<List<T>>
 
     public final AbstractType<T> elements;
 
-    public static ListType<?> getInstance(TypeParser parser) throws ConfigurationException
+    public static ListType<?> getInstance(TypeParser parser) throws ConfigurationException, SyntaxException
     {
         List<AbstractType<?>> l = parser.getTypeParameters();
         if (l.size() != 1)

File: src/java/org/apache/cassandra/db/marshal/MapType.java
Patch:
@@ -21,7 +21,8 @@
 import java.util.*;
 
 import org.apache.cassandra.db.IColumn;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
+import org.apache.cassandra.exceptions.SyntaxException;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.Pair;
@@ -34,7 +35,7 @@ public class MapType<K, V> extends CollectionType<Map<K, V>>
     public final AbstractType<K> keys;
     public final AbstractType<V> values;
 
-    public static MapType<?, ?> getInstance(TypeParser parser) throws ConfigurationException
+    public static MapType<?, ?> getInstance(TypeParser parser) throws ConfigurationException, SyntaxException
     {
         List<AbstractType<?>> l = parser.getTypeParameters();
         if (l.size() != 2)

File: src/java/org/apache/cassandra/db/marshal/ReversedType.java
Patch:
@@ -22,7 +22,8 @@
 import java.util.Map;
 import java.util.List;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
+import org.apache.cassandra.exceptions.SyntaxException;
 
 public class ReversedType<T> extends AbstractType<T>
 {
@@ -32,7 +33,7 @@ public class ReversedType<T> extends AbstractType<T>
     // package protected for unit tests sake
     final AbstractType<T> baseType;
 
-    public static <T> ReversedType<T> getInstance(TypeParser parser) throws ConfigurationException
+    public static <T> ReversedType<T> getInstance(TypeParser parser) throws ConfigurationException, SyntaxException
     {
         List<AbstractType<?>> types = parser.getTypeParameters();
         if (types.size() != 1)

File: src/java/org/apache/cassandra/db/marshal/SetType.java
Patch:
@@ -21,7 +21,8 @@
 import java.util.*;
 
 import org.apache.cassandra.db.IColumn;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
+import org.apache.cassandra.exceptions.SyntaxException;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.Pair;
@@ -33,7 +34,7 @@ public class SetType<T> extends CollectionType<Set<T>>
 
     public final AbstractType<T> elements;
 
-    public static SetType<?> getInstance(TypeParser parser) throws ConfigurationException
+    public static SetType<?> getInstance(TypeParser parser) throws ConfigurationException, SyntaxException
     {
         List<AbstractType<?>> l = parser.getTypeParameters();
         if (l.size() != 1)

File: src/java/org/apache/cassandra/dht/AbstractByteOrderedPartitioner.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.commons.lang.ArrayUtils;
 
 import org.apache.cassandra.db.DecoratedKey;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.Hex;

File: src/java/org/apache/cassandra/dht/BootStrapper.java
Patch:
@@ -28,9 +28,8 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.apache.cassandra.config.Schema;
-import org.apache.cassandra.gms.*;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.Table;
 import org.apache.cassandra.locator.AbstractReplicationStrategy;

File: src/java/org/apache/cassandra/dht/Murmur3Partitioner.java
Patch:
@@ -24,8 +24,8 @@
 import java.util.List;
 import java.util.Map;
 
-import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.db.DecoratedKey;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.MurmurHash;

File: src/java/org/apache/cassandra/dht/OrderPreservingPartitioner.java
Patch:
@@ -24,6 +24,7 @@
 
 import org.apache.cassandra.config.*;
 import org.apache.cassandra.db.DecoratedKey;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.gms.VersionedValue;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.ByteBufferUtil;

File: src/java/org/apache/cassandra/dht/RandomPartitioner.java
Patch:
@@ -23,7 +23,7 @@
 import java.nio.charset.CharacterCodingException;
 import java.util.*;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;

File: src/java/org/apache/cassandra/dht/Token.java
Patch:
@@ -23,7 +23,7 @@
 import java.io.Serializable;
 import java.nio.ByteBuffer;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.db.RowPosition;
 import org.apache.cassandra.io.ISerializer;

File: src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
Patch:
@@ -31,7 +31,7 @@
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.auth.IAuthenticator;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.db.IColumn;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.TypeParser;

File: src/java/org/apache/cassandra/hadoop/ConfigHelper.java
Patch:
@@ -30,7 +30,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.thrift.*;
 import org.apache.cassandra.utils.FBUtilities;

File: src/java/org/apache/cassandra/io/compress/CompressionMetadata.java
Patch:
@@ -22,7 +22,7 @@
 
 import com.google.common.primitives.Longs;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.io.FSReadError;
 import org.apache.cassandra.io.FSWriteError;

File: src/java/org/apache/cassandra/io/compress/CompressionParameters.java
Patch:
@@ -30,7 +30,7 @@
 import org.apache.commons.lang.builder.EqualsBuilder;
 import org.apache.commons.lang.builder.HashCodeBuilder;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.io.IVersionedSerializer;
 

File: src/java/org/apache/cassandra/io/sstable/SSTableLoader.java
Patch:
@@ -28,7 +28,7 @@
 import java.util.concurrent.TimeoutException;
 
 import org.apache.cassandra.config.Config;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.Range;

File: src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
Patch:
@@ -26,15 +26,15 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.RingPosition;
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.service.DatacenterSyncWriteResponseHandler;
 import org.apache.cassandra.service.DatacenterWriteResponseHandler;
 import org.apache.cassandra.service.IWriteResponseHandler;
 import org.apache.cassandra.service.WriteResponseHandler;
-import org.apache.cassandra.thrift.ConsistencyLevel;
+import org.apache.cassandra.db.ConsistencyLevel;
 import org.apache.cassandra.utils.FBUtilities;
 import org.cliffc.high_scale_lib.NonBlockingHashMap;
 

File: src/java/org/apache/cassandra/locator/Ec2MultiRegionSnitch.java
Patch:
@@ -21,7 +21,7 @@
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.gms.ApplicationState;
 import org.apache.cassandra.gms.EndpointState;

File: src/java/org/apache/cassandra/locator/Ec2Snitch.java
Patch:
@@ -28,7 +28,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.gms.ApplicationState;
 import org.apache.cassandra.gms.EndpointState;
 import org.apache.cassandra.gms.Gossiper;

File: src/java/org/apache/cassandra/locator/GossipingPropertyFileSnitch.java
Patch:
@@ -18,7 +18,7 @@
 
 package org.apache.cassandra.locator;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.gms.ApplicationState;
 import org.apache.cassandra.gms.EndpointState;
 import org.apache.cassandra.gms.Gossiper;

File: src/java/org/apache/cassandra/locator/LocalStrategy.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.List;
 import java.util.Map;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.dht.RingPosition;
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.utils.FBUtilities;

File: src/java/org/apache/cassandra/locator/NetworkTopologyStrategy.java
Patch:
@@ -24,7 +24,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.locator.TokenMetadata.Topology;
 import org.apache.cassandra.utils.FBUtilities;

File: src/java/org/apache/cassandra/locator/OldNetworkTopologyStrategy.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.List;
 import java.util.Map;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.dht.Token;
 
 /**

File: src/java/org/apache/cassandra/locator/PropertyFileSnitch.java
Patch:
@@ -27,7 +27,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.FBUtilities;

File: src/java/org/apache/cassandra/locator/SimpleStrategy.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.List;
 import java.util.Map;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.dht.Token;
 
 

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -43,7 +43,7 @@
 import org.apache.cassandra.concurrent.DebuggableThreadPoolExecutor;
 import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.concurrent.StageManager;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.EncryptionOptions;
 import org.apache.cassandra.db.*;

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -32,7 +32,7 @@
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.db.*;

File: src/java/org/apache/cassandra/service/IWriteResponseHandler.java
Patch:
@@ -18,11 +18,11 @@
 package org.apache.cassandra.service;
 
 import org.apache.cassandra.net.IAsyncCallback;
-import org.apache.cassandra.thrift.TimedOutException;
-import org.apache.cassandra.thrift.UnavailableException;
+import org.apache.cassandra.exceptions.WriteTimeoutException;
+import org.apache.cassandra.exceptions.UnavailableException;
 
 public interface IWriteResponseHandler extends IAsyncCallback
 {
-    public void get() throws TimedOutException;
+    public void get() throws WriteTimeoutException;
     public void assureSufficientLiveNodes() throws UnavailableException;
 }

File: src/java/org/apache/cassandra/service/MigrationTask.java
Patch:
@@ -24,7 +24,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.db.DefsTable;
 import org.apache.cassandra.db.RowMutation;
 import org.apache.cassandra.gms.FailureDetector;

File: src/java/org/apache/cassandra/service/RepairCallback.java
Patch:
@@ -53,7 +53,7 @@ public RepairCallback(RowRepairResolver resolver, List<InetAddress> endpoints)
         this.startTime = System.currentTimeMillis();
     }
 
-    public Row get() throws TimeoutException, DigestMismatchException, IOException
+    public Row get() throws DigestMismatchException, IOException
     {
         long timeout = DatabaseDescriptor.getWriteRpcTimeout() - (System.currentTimeMillis() - startTime);
         try

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -34,7 +34,8 @@
 import org.apache.commons.cli.*;
 
 import org.apache.cassandra.concurrent.JMXEnabledThreadPoolExecutorMBean;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
+import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.db.ColumnFamilyStoreMBean;
 import org.apache.cassandra.db.Table;
 import org.apache.cassandra.db.compaction.CompactionManagerMBean;
@@ -43,7 +44,6 @@
 import org.apache.cassandra.net.MessagingServiceMBean;
 import org.apache.cassandra.service.CacheServiceMBean;
 import org.apache.cassandra.service.StorageProxyMBean;
-import org.apache.cassandra.thrift.InvalidRequestException;
 import org.apache.cassandra.utils.EstimatedHistogram;
 import org.apache.cassandra.utils.Pair;
 
@@ -1182,7 +1182,7 @@ private void printDescribeRing(String keyspaceName, PrintStream out)
         }
         catch (InvalidRequestException e)
         {
-            err(e, e.getWhy());
+            err(e, e.getMessage());
         }
     }
 

File: src/java/org/apache/cassandra/tools/NodeProbe.java
Patch:
@@ -37,7 +37,7 @@
 import com.google.common.collect.Iterables;
 
 import org.apache.cassandra.concurrent.JMXEnabledThreadPoolExecutorMBean;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.*;
 import org.apache.cassandra.db.ColumnFamilyStoreMBean;
 import org.apache.cassandra.db.compaction.CompactionManager;
 import org.apache.cassandra.db.compaction.CompactionManagerMBean;
@@ -49,8 +49,6 @@
 import org.apache.cassandra.service.*;
 import org.apache.cassandra.streaming.StreamingService;
 import org.apache.cassandra.streaming.StreamingServiceMBean;
-import org.apache.cassandra.thrift.InvalidRequestException;
-import org.apache.cassandra.thrift.UnavailableException;
 
 /**
  * JMX client operations for Cassandra.

File: src/java/org/apache/cassandra/tools/SSTableExport.java
Patch:
@@ -40,7 +40,7 @@
 import org.apache.commons.cli.PosixParser;
 
 import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.db.AbstractColumnContainer;

File: src/java/org/apache/cassandra/tools/SSTableImport.java
Patch:
@@ -35,7 +35,7 @@
 import org.apache.commons.cli.PosixParser;
 
 import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.db.AbstractColumnContainer;

File: src/java/org/apache/cassandra/tools/SSTableMetadataViewer.java
Patch:
@@ -20,7 +20,7 @@
 import java.io.IOException;
 import java.io.PrintStream;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.io.sstable.Descriptor;
 import org.apache.cassandra.io.sstable.SSTableMetadata;
 

File: src/java/org/apache/cassandra/transport/DataType.java
Patch:
@@ -26,7 +26,7 @@
 import com.google.common.base.Charsets;
 import org.jboss.netty.buffer.ChannelBuffer;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.RequestValidationException;
 import org.apache.cassandra.db.marshal.*;
 import org.apache.cassandra.utils.Pair;
 
@@ -188,7 +188,7 @@ public static AbstractType toType(Pair<DataType, Object> entry)
                     return entry.left.type;
             }
         }
-        catch (ConfigurationException e)
+        catch (RequestValidationException e)
         {
             throw new ProtocolException(e.getMessage());
         }

File: src/java/org/apache/cassandra/transport/SimpleClient.java
Patch:
@@ -154,7 +154,7 @@ protected Message.Response execute(Message.Request request)
             lastWriteFuture = channel.write(request);
             Message.Response msg = responseHandler.responses.take();
             if (msg instanceof ErrorMessage)
-                throw new RuntimeException(((ErrorMessage)msg).errorMsg);
+                throw new RuntimeException((Throwable)((ErrorMessage)msg).error);
             return msg;
         }
         catch (InterruptedException e)

File: src/java/org/apache/cassandra/transport/messages/ExecuteMessage.java
Patch:
@@ -25,8 +25,8 @@
 
 import org.apache.cassandra.cql3.CQLStatement;
 import org.apache.cassandra.cql3.QueryProcessor;
+import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.transport.*;
-import org.apache.cassandra.thrift.InvalidRequestException;
 
 public class ExecuteMessage extends Message.Request
 {

File: src/java/org/apache/cassandra/utils/FBUtilities.java
Patch:
@@ -41,7 +41,7 @@
 
 import org.apache.cassandra.cache.IRowCacheProvider;
 import org.apache.cassandra.concurrent.CreationTimeAwareFuture;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.dht.IPartitioner;

File: test/long/org/apache/cassandra/db/MeteredFlusherTest.java
Patch:
@@ -28,7 +28,7 @@
 
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.db.marshal.UTF8Type;
 import org.apache.cassandra.service.MigrationManager;
 import org.apache.cassandra.utils.ByteBufferUtil;

File: test/unit/org/apache/cassandra/SchemaLoader.java
Patch:
@@ -36,6 +36,7 @@
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.db.index.composites.CompositesIndex;
 import org.apache.cassandra.db.marshal.*;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.gms.Gossiper;
 import org.apache.cassandra.io.compress.CompressionParameters;
 import org.apache.cassandra.io.compress.SnappyCompressor;

File: test/unit/org/apache/cassandra/cli/CliTest.java
Patch:
@@ -19,7 +19,7 @@
 package org.apache.cassandra.cli;
 
 import org.apache.cassandra.SchemaLoader;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.service.EmbeddedCassandraService;
 import org.apache.cassandra.thrift.*;

File: test/unit/org/apache/cassandra/config/DatabaseDescriptorTest.java
Patch:
@@ -19,10 +19,11 @@
 package org.apache.cassandra.config;
 
 import org.apache.cassandra.SchemaLoader;
+import org.apache.cassandra.exceptions.ConfigurationException;
+import org.apache.cassandra.exceptions.InvalidRequestException;
 import org.apache.cassandra.gms.Gossiper;
 import org.apache.cassandra.locator.SimpleStrategy;
 import org.apache.cassandra.service.MigrationManager;
-import org.apache.cassandra.thrift.InvalidRequestException;
 
 import org.junit.Test;
 

File: test/unit/org/apache/cassandra/config/DefsTest.java
Patch:
@@ -32,6 +32,7 @@
 import org.apache.cassandra.db.marshal.BytesType;
 import org.apache.cassandra.db.marshal.UTF8Type;
 import org.apache.cassandra.db.marshal.TimeUUIDType;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.io.sstable.Component;
 import org.apache.cassandra.io.sstable.Descriptor;
 import org.apache.cassandra.io.sstable.SSTableDeletingTask;

File: test/unit/org/apache/cassandra/db/CleanupTest.java
Patch:
@@ -29,7 +29,7 @@
 
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.db.columniterator.IdentityQueryFilter;
 import org.apache.cassandra.db.compaction.CompactionManager;
 import org.apache.cassandra.db.filter.IFilter;

File: test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
Patch:
@@ -56,7 +56,7 @@
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.config.ColumnDefinition;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.db.columniterator.IdentityQueryFilter;
 import org.apache.cassandra.db.filter.*;
 import org.apache.cassandra.db.index.SecondaryIndex;

File: test/unit/org/apache/cassandra/db/ScrubTest.java
Patch:
@@ -30,7 +30,7 @@
 
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.db.columniterator.IdentityQueryFilter;
 import org.apache.cassandra.db.compaction.CompactionManager;
 import org.apache.cassandra.io.util.FileUtils;

File: test/unit/org/apache/cassandra/db/SecondaryIndexColumnSizeTest.java
Patch:
@@ -25,7 +25,7 @@
 
 import org.junit.Test;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.db.index.PerColumnSecondaryIndex;
 import org.apache.cassandra.db.index.PerRowSecondaryIndex;
 import org.apache.cassandra.db.index.SecondaryIndexSearcher;

File: test/unit/org/apache/cassandra/locator/DynamicEndpointSnitchTest.java
Patch:
@@ -23,7 +23,7 @@
 import java.net.InetAddress;
 import java.util.ArrayList;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.service.StorageService;
 import org.junit.Test;
 

File: test/unit/org/apache/cassandra/locator/EC2SnitchTest.java
Patch:
@@ -27,7 +27,7 @@
 import java.net.InetAddress;
 import java.util.Map;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.gms.ApplicationState;
 import org.apache.cassandra.gms.Gossiper;
 import org.apache.cassandra.gms.VersionedValue;

File: test/unit/org/apache/cassandra/locator/NetworkTopologyStrategyTest.java
Patch:
@@ -35,7 +35,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.dht.StringToken;
 import org.apache.cassandra.dht.Token;

File: test/unit/org/apache/cassandra/locator/ReplicationStrategyEndpointCacheTest.java
Patch:
@@ -28,7 +28,7 @@
 import org.junit.Test;
 
 import org.apache.cassandra.SchemaLoader;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.dht.BigIntegerToken;
 import org.apache.cassandra.dht.Token;
 

File: test/unit/org/apache/cassandra/locator/SimpleStrategyTest.java
Patch:
@@ -30,7 +30,7 @@
 import org.junit.Test;
 
 import org.apache.cassandra.SchemaLoader;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.config.KSMetaData;
 import org.apache.cassandra.db.Table;
 import org.apache.cassandra.dht.*;

File: test/unit/org/apache/cassandra/service/AntiEntropyServiceCounterTest.java
Patch:
@@ -26,7 +26,7 @@
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.utils.ByteBufferUtil;
-import org.apache.cassandra.thrift.ConsistencyLevel;
+import org.apache.cassandra.db.ConsistencyLevel;
 
 public class AntiEntropyServiceCounterTest extends AntiEntropyServiceTestAbstract
 {

File: test/unit/org/apache/cassandra/service/EmbeddedCassandraServiceTest.java
Patch:
@@ -26,7 +26,7 @@
 import org.junit.Test;
 
 import org.apache.cassandra.SchemaLoader;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.thrift.*;

File: test/unit/org/apache/cassandra/service/InitClientTest.java
Patch:
@@ -4,7 +4,7 @@
 
 import java.io.IOException;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 
 /**
  * Licensed to the Apache Software Foundation (ASF) under one

File: test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest.java
Patch:
@@ -24,7 +24,7 @@
 import java.net.UnknownHostException;
 import java.util.*;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.config.Schema;
 import org.junit.Test;
 

File: test/unit/org/apache/cassandra/service/MoveTest.java
Patch:
@@ -33,7 +33,7 @@
 import org.junit.BeforeClass;
 import org.junit.Test;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;

File: test/unit/org/apache/cassandra/service/RemoveTest.java
Patch:
@@ -35,7 +35,7 @@
 
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.Util;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.RandomPartitioner;
 import org.apache.cassandra.dht.Token;

File: test/unit/org/apache/cassandra/service/StorageServiceClientTest.java
Patch:
@@ -20,7 +20,7 @@
 package org.apache.cassandra.service;
 
 import org.apache.cassandra.SchemaLoader;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.junit.Test;
 import static org.junit.Assert.assertFalse;

File: test/unit/org/apache/cassandra/service/StorageServiceServerTest.java
Patch:
@@ -26,7 +26,7 @@
 
 import org.junit.Test;
 
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
 import org.apache.cassandra.db.Table;
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.SchemaLoader;

File: tools/stress/src/org/apache/cassandra/stress/Session.java
Patch:
@@ -26,7 +26,8 @@
 import java.util.concurrent.atomic.AtomicLong;
 
 import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.exceptions.ConfigurationException;
+import org.apache.cassandra.exceptions.SyntaxException;
 import org.apache.cassandra.db.marshal.*;
 import org.apache.commons.cli.*;
 
@@ -142,7 +143,7 @@ public class Session implements Serializable
     public final boolean timeUUIDComparator;
     public double traceProbability = 0.0;
 
-    public Session(String[] arguments) throws IllegalArgumentException
+    public Session(String[] arguments) throws IllegalArgumentException, SyntaxException
     {
         float STDev = 0.1f;
         CommandLineParser parser = new PosixParser();

File: src/java/org/apache/cassandra/cql3/ResultSet.java
Patch:
@@ -209,7 +209,7 @@ public static class Metadata
         public Metadata(List<ColumnSpecification> names)
         {
             this(EnumSet.noneOf(Flag.class), names);
-            if (allInSameCF())
+            if (!names.isEmpty() && allInSameCF())
                 flags.add(Flag.GLOBAL_TABLES_SPEC);
         }
 

File: src/java/org/apache/cassandra/db/SystemTable.java
Patch:
@@ -83,6 +83,7 @@ private static DecoratedKey decorate(ByteBuffer key)
 
     public static void finishStartup() throws IOException
     {
+        DefsTable.fixSchemaNanoTimestamps();
         setupVersion();
         purgeIncompatibleHints();
     }

File: src/java/org/apache/cassandra/db/filter/IFilter.java
Patch:
@@ -25,6 +25,7 @@
 
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.columniterator.IColumnIterator;
+import org.apache.cassandra.db.columniterator.ISSTableColumnIterator;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.io.sstable.SSTableReader;
 import org.apache.cassandra.io.util.FileDataInput;
@@ -51,13 +52,13 @@ public interface IFilter
      * @param file Already opened file data input, saves us opening another one
      * @param key The key of the row we are about to iterate over
      */
-    public abstract IColumnIterator getSSTableColumnIterator(SSTableReader sstable, FileDataInput file, DecoratedKey<?> key);
+    public abstract ISSTableColumnIterator getSSTableColumnIterator(SSTableReader sstable, FileDataInput file, DecoratedKey<?> key);
 
     /**
      * returns an iterator that returns columns from the given SSTable
      * matching the Filter criteria in sorted order.
      */
-    public abstract IColumnIterator getSSTableColumnIterator(SSTableReader sstable, DecoratedKey<?> key);
+    public abstract ISSTableColumnIterator getSSTableColumnIterator(SSTableReader sstable, DecoratedKey<?> key);
 
     /**
      * collects columns from reducedColumns into returnCF.  Termination is determined

File: src/java/org/apache/cassandra/db/filter/NamesQueryFilter.java
Patch:
@@ -30,6 +30,7 @@
 
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.columniterator.IColumnIterator;
+import org.apache.cassandra.db.columniterator.ISSTableColumnIterator;
 import org.apache.cassandra.db.columniterator.SSTableNamesIterator;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.io.sstable.SSTableReader;
@@ -55,12 +56,12 @@ public IColumnIterator getMemtableColumnIterator(ColumnFamily cf, DecoratedKey<?
         return Memtable.getNamesIterator(key, cf, this);
     }
 
-    public IColumnIterator getSSTableColumnIterator(SSTableReader sstable, DecoratedKey<?> key)
+    public ISSTableColumnIterator getSSTableColumnIterator(SSTableReader sstable, DecoratedKey<?> key)
     {
         return new SSTableNamesIterator(sstable, key, columns);
     }
 
-    public IColumnIterator getSSTableColumnIterator(SSTableReader sstable, FileDataInput file, DecoratedKey<?> key)
+    public ISSTableColumnIterator getSSTableColumnIterator(SSTableReader sstable, FileDataInput file, DecoratedKey<?> key)
     {
         return new SSTableNamesIterator(sstable, file, key, columns);
     }

File: src/java/org/apache/cassandra/db/filter/QueryFilter.java
Patch:
@@ -29,6 +29,7 @@
 
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.columniterator.IColumnIterator;
+import org.apache.cassandra.db.columniterator.ISSTableColumnIterator;
 import org.apache.cassandra.db.columniterator.IdentityQueryFilter;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.io.sstable.SSTableReader;
@@ -72,14 +73,14 @@ public IColumnIterator getMemtableColumnIterator(ColumnFamily cf, DecoratedKey<?
     }
 
     // TODO move gcBefore into a field
-    public IColumnIterator getSSTableColumnIterator(SSTableReader sstable)
+    public ISSTableColumnIterator getSSTableColumnIterator(SSTableReader sstable)
     {
         if (path.superColumnName == null)
             return filter.getSSTableColumnIterator(sstable, key);
         return superFilter.getSSTableColumnIterator(sstable, key);
     }
 
-    public IColumnIterator getSSTableColumnIterator(SSTableReader sstable, FileDataInput file, DecoratedKey<?> key)
+    public ISSTableColumnIterator getSSTableColumnIterator(SSTableReader sstable, FileDataInput file, DecoratedKey<?> key)
     {
         if (path.superColumnName == null)
             return filter.getSSTableColumnIterator(sstable, file, key);

File: src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
Patch:
@@ -34,6 +34,7 @@
 
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.columniterator.IColumnIterator;
+import org.apache.cassandra.db.columniterator.ISSTableColumnIterator;
 import org.apache.cassandra.db.columniterator.SSTableSliceIterator;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.io.sstable.SSTableReader;
@@ -61,12 +62,12 @@ public IColumnIterator getMemtableColumnIterator(ColumnFamily cf, DecoratedKey<?
         return Memtable.getSliceIterator(key, cf, this);
     }
 
-    public IColumnIterator getSSTableColumnIterator(SSTableReader sstable, DecoratedKey<?> key)
+    public ISSTableColumnIterator getSSTableColumnIterator(SSTableReader sstable, DecoratedKey<?> key)
     {
         return new SSTableSliceIterator(sstable, key, start, finish, reversed);
     }
 
-    public IColumnIterator getSSTableColumnIterator(SSTableReader sstable, FileDataInput file, DecoratedKey<?> key)
+    public ISSTableColumnIterator getSSTableColumnIterator(SSTableReader sstable, FileDataInput file, DecoratedKey<?> key)
     {
         return new SSTableSliceIterator(sstable, file, key, start, finish, reversed);
     }

File: src/java/org/apache/cassandra/utils/Pair.java
Patch:
@@ -24,7 +24,7 @@ public class Pair<T1, T2>
     public final T1 left;
     public final T2 right;
 
-    public Pair(T1 left, T2 right)
+    protected Pair(T1 left, T2 right)
     {
         this.left = left;
         this.right = right;

File: src/java/org/apache/cassandra/service/CacheService.java
Patch:
@@ -331,7 +331,7 @@ public Pair<RowCacheKey, IRowCacheEntry> call() throws Exception
                 {
                     DecoratedKey key = cfs.partitioner.decorateKey(buffer);
                     ColumnFamily data = cfs.getTopLevelColumns(QueryFilter.getIdentityFilter(key, new QueryPath(cfs.columnFamily)), Integer.MIN_VALUE, true);
-                    return Pair.create(new RowCacheKey(cfs.metadata.cfId, key), data);
+                    return Pair.create(new RowCacheKey(cfs.metadata.cfId, key), (IRowCacheEntry) data);
                 }
             });
         }

File: src/java/org/apache/cassandra/utils/Pair.java
Patch:
@@ -24,7 +24,7 @@ public class Pair<T1, T2>
     public final T1 left;
     public final T2 right;
 
-    private Pair(T1 left, T2 right)
+    public Pair(T1 left, T2 right)
     {
         this.left = left;
         this.right = right;

File: src/java/org/apache/cassandra/cache/KeyCacheKey.java
Patch:
@@ -39,7 +39,7 @@ public KeyCacheKey(Descriptor desc, ByteBuffer key)
 
     public Pair<String, String> getPathInfo()
     {
-        return new Pair<String, String>(desc.ksname, desc.cfname);
+        return Pair.create(desc.ksname, desc.cfname);
     }
 
     public String toString()

File: src/java/org/apache/cassandra/config/Schema.java
Patch:
@@ -379,7 +379,7 @@ public Pair<String,String> getCF(UUID cfId)
      */
     public UUID getId(String ksName, String cfName)
     {
-        return cfIdMap.get(new Pair<String, String>(ksName, cfName));
+        return cfIdMap.get(Pair.create(ksName, cfName));
     }
 
     /**
@@ -392,7 +392,7 @@ public UUID getId(String ksName, String cfName)
      */
     public void load(CFMetaData cfm)
     {
-        Pair<String, String> key = new Pair<String, String>(cfm.ksName, cfm.cfName);
+        Pair<String, String> key = Pair.create(cfm.ksName, cfm.cfName);
 
         if (cfIdMap.containsKey(key))
             throw new RuntimeException(String.format("Attempting to load already loaded column family %s.%s", cfm.ksName, cfm.cfName));
@@ -408,7 +408,7 @@ public void load(CFMetaData cfm)
      */
     public void purge(CFMetaData cfm)
     {
-        cfIdMap.remove(new Pair<String, String>(cfm.ksName, cfm.cfName));
+        cfIdMap.remove(Pair.create(cfm.ksName, cfm.cfName));
     }
 
     /* Version control */

File: src/java/org/apache/cassandra/db/compaction/SizeTieredCompactionStrategy.java
Patch:
@@ -134,7 +134,7 @@ private static List<Pair<SSTableReader, Long>> createSSTableAndLengthPairs(Colle
     {
         List<Pair<SSTableReader, Long>> tableLengthPairs = new ArrayList<Pair<SSTableReader, Long>>(collection.size());
         for(SSTableReader table: collection)
-            tableLengthPairs.add(new Pair<SSTableReader, Long>(table, table.onDiskLength()));
+            tableLengthPairs.add(Pair.create(table, table.onDiskLength()));
         return tableLengthPairs;
     }
 

File: src/java/org/apache/cassandra/dht/Bounds.java
Patch:
@@ -58,7 +58,7 @@ public Pair<AbstractBounds<T>, AbstractBounds<T>> split(T position)
 
         AbstractBounds<T> lb = new Bounds<T>(left, position, partitioner);
         AbstractBounds<T> rb = new Range<T>(position, right, partitioner);
-        return new Pair<AbstractBounds<T>, AbstractBounds<T>>(lb, rb);
+        return Pair.create(lb, rb);
     }
 
     public boolean intersects(Bounds<T> that)

File: src/java/org/apache/cassandra/dht/ExcludingBounds.java
Patch:
@@ -53,7 +53,7 @@ public Pair<AbstractBounds<T>, AbstractBounds<T>> split(T position)
             return null;
         AbstractBounds<T> lb = new Range<T>(left, position, partitioner);
         AbstractBounds<T> rb = new ExcludingBounds<T>(position, right, partitioner);
-        return new Pair<AbstractBounds<T>, AbstractBounds<T>>(lb, rb);
+        return Pair.create(lb, rb);
     }
 
     public List<? extends AbstractBounds<T>> unwrap()

File: src/java/org/apache/cassandra/dht/IncludingExcludingBounds.java
Patch:
@@ -52,7 +52,7 @@ public Pair<AbstractBounds<T>, AbstractBounds<T>> split(T position)
         assert contains(position);
         AbstractBounds<T> lb = new Bounds<T>(left, position, partitioner);
         AbstractBounds<T> rb = new ExcludingBounds<T>(position, right, partitioner);
-        return new Pair<AbstractBounds<T>, AbstractBounds<T>>(lb, rb);
+        return Pair.create(lb, rb);
     }
 
     public List<? extends AbstractBounds<T>> unwrap()

File: src/java/org/apache/cassandra/dht/Range.java
Patch:
@@ -224,7 +224,7 @@ public Pair<AbstractBounds<T>, AbstractBounds<T>> split(T position)
 
         AbstractBounds<T> lb = new Range<T>(left, position, partitioner);
         AbstractBounds<T> rb = new Range<T>(position, right, partitioner);
-        return new Pair<AbstractBounds<T>, AbstractBounds<T>>(lb, rb);
+        return Pair.create(lb, rb);
     }
 
     public List<Range<T>> unwrap()

File: src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
Patch:
@@ -406,7 +406,7 @@ protected Pair<ByteBuffer, SortedMap<ByteBuffer, IColumn>> computeNext()
                 IColumn column = unthriftify(cosc);
                 map.put(column.name(), column);
             }
-            return new Pair<ByteBuffer, SortedMap<ByteBuffer, IColumn>>(ks.key, map);
+            return Pair.create(ks.key, map);
         }
     }
 

File: src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordWriter.java
Patch:
@@ -137,7 +137,7 @@ public void write(ByteBuffer keybuff, List<Mutation> value) throws IOException
         }
 
         for (Mutation amut : value)
-            client.put(new Pair<ByteBuffer,Mutation>(keybuff, amut));
+            client.put(Pair.create(keybuff, amut));
             progressable.progress();
     }
 

File: src/java/org/apache/cassandra/io/sstable/Component.java
Patch:
@@ -132,7 +132,7 @@ public static Pair<Descriptor,Component> fromFilename(File directory, String nam
                  throw new IllegalStateException();
         }
 
-        return new Pair<Descriptor,Component>(path.left, component);
+        return Pair.create(path.left, component);
     }
 
     @Override

File: src/java/org/apache/cassandra/io/sstable/Descriptor.java
Patch:
@@ -277,7 +277,7 @@ public static Pair<Descriptor,String> fromFilename(File directory, String name)
         // component suffix
         String component = st.nextToken();
         directory = directory != null ? directory : new File(".");
-        return new Pair<Descriptor,String>(new Descriptor(version, directory, ksname, cfname, generation, temporary), component);
+        return Pair.create(new Descriptor(version, directory, ksname, cfname, generation, temporary), component);
     }
 
     /**

File: src/java/org/apache/cassandra/io/sstable/SSTableReader.java
Patch:
@@ -589,7 +589,7 @@ private static List<Pair<Integer,Integer>> getSampleIndexesForRanges(List<Decora
             if (left > right)
                 // empty range
                 continue;
-            positions.add(new Pair(Integer.valueOf(left), Integer.valueOf(right)));
+            positions.add(Pair.create(Integer.valueOf(left), Integer.valueOf(right)));
         }
         return positions;
     }
@@ -670,7 +670,7 @@ public List<Pair<Long,Long>> getPositionsForRanges(Collection<Range<Token>> rang
             if (left == right)
                 // empty range
                 continue;
-            positions.add(new Pair(Long.valueOf(left), Long.valueOf(right)));
+            positions.add(Pair.create(Long.valueOf(left), Long.valueOf(right)));
         }
         return positions;
     }

File: src/java/org/apache/cassandra/locator/TokenMetadata.java
Patch:
@@ -340,7 +340,7 @@ public void addMovingEndpoint(Token token, InetAddress endpoint)
 
         try
         {
-            movingEndpoints.add(new Pair<Token, InetAddress>(token, endpoint));
+            movingEndpoints.add(Pair.create(token, endpoint));
         }
         finally
         {
@@ -959,7 +959,7 @@ protected void addEndpoint(InetAddress ep)
                 dcRacks.put(dc, HashMultimap.<String, InetAddress>create());
             dcRacks.get(dc).put(rack, ep);
 
-            currentLocations.put(ep, new Pair<String, String>(dc, rack));
+            currentLocations.put(ep, Pair.create(dc, rack));
         }
 
         /**

File: src/java/org/apache/cassandra/service/CacheService.java
Patch:
@@ -331,7 +331,7 @@ public Pair<RowCacheKey, IRowCacheEntry> call() throws Exception
                 {
                     DecoratedKey key = cfs.partitioner.decorateKey(buffer);
                     ColumnFamily data = cfs.getTopLevelColumns(QueryFilter.getIdentityFilter(key, new QueryPath(cfs.columnFamily)), Integer.MIN_VALUE, true);
-                    return new Pair<RowCacheKey, IRowCacheEntry>(new RowCacheKey(cfs.metadata.cfId, key), data);
+                    return Pair.create(new RowCacheKey(cfs.metadata.cfId, key), data);
                 }
             });
         }

File: src/java/org/apache/cassandra/service/RangeSliceResponseResolver.java
Patch:
@@ -111,7 +111,7 @@ private RowIterator(Iterator<Row> iter, InetAddress source)
 
         protected Pair<Row,InetAddress> computeNext()
         {
-            return iter.hasNext() ? new Pair<Row, InetAddress>(iter.next(), source) : endOfData();
+            return iter.hasNext() ? Pair.create(iter.next(), source) : endOfData();
         }
 
         public void close() {}

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -49,7 +49,6 @@
 import org.apache.cassandra.io.sstable.SSTableLoader;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.locator.*;
-import org.apache.cassandra.metrics.ClientRequestMetrics;
 import org.apache.cassandra.metrics.StorageMetrics;
 import org.apache.cassandra.net.IAsyncResult;
 import org.apache.cassandra.net.MessageOut;
@@ -3219,7 +3218,7 @@ public Pair<Set<Range<Token>>, Set<Range<Token>>> calculateStreamAndFetchRanges(
             }
         }
 
-        return new Pair<Set<Range<Token>>, Set<Range<Token>>>(toStream, toFetch);
+        return Pair.create(toStream, toFetch);
     }
 
     public void bulkLoad(String directory)

File: src/java/org/apache/cassandra/streaming/PendingFile.java
Patch:
@@ -153,7 +153,7 @@ public PendingFile deserialize(DataInput dis, int version) throws IOException
             int count = dis.readInt();
             List<Pair<Long,Long>> sections = new ArrayList<Pair<Long,Long>>(count);
             for (int i = 0; i < count; i++)
-                sections.add(new Pair<Long,Long>(dis.readLong(), dis.readLong()));
+                sections.add(Pair.create(dis.readLong(), dis.readLong()));
             // this controls the way indexes are rebuilt when streaming in.
             OperationType type = OperationType.RESTORE_REPLICA_COUNT;
             type = OperationType.valueOf(dis.readUTF());

File: src/java/org/apache/cassandra/streaming/StreamInSession.java
Patch:
@@ -82,15 +82,15 @@ private StreamInSession(Pair<InetAddress, Long> context, IStreamCallback callbac
 
     public static StreamInSession create(InetAddress host, IStreamCallback callback)
     {
-        Pair<InetAddress, Long> context = new Pair<InetAddress, Long>(host, nextSessionId());
+        Pair<InetAddress, Long> context = Pair.create(host, nextSessionId());
         StreamInSession session = new StreamInSession(context, callback);
         sessions.put(context, session);
         return session;
     }
 
     public static StreamInSession get(InetAddress host, long sessionId)
     {
-        Pair<InetAddress, Long> context = new Pair<InetAddress, Long>(host, sessionId);
+        Pair<InetAddress, Long> context = Pair.create(host, sessionId);
         StreamInSession session = sessions.get(context);
         if (session == null)
         {

File: src/java/org/apache/cassandra/streaming/StreamOutSession.java
Patch:
@@ -71,15 +71,15 @@ public static StreamOutSession create(String table, InetAddress host, long sessi
 
     public static StreamOutSession create(String table, InetAddress host, long sessionId, IStreamCallback callback)
     {
-        Pair<InetAddress, Long> context = new Pair<InetAddress, Long>(host, sessionId);
+        Pair<InetAddress, Long> context = Pair.create(host, sessionId);
         StreamOutSession session = new StreamOutSession(table, context, callback);
         streams.put(context, session);
         return session;
     }
 
     public static StreamOutSession get(InetAddress host, long sessionId)
     {
-        return streams.get(new Pair<InetAddress, Long>(host, sessionId));
+        return streams.get(Pair.create(host, sessionId));
     }
 
     private final Map<String, PendingFile> files = new NonBlockingHashMap<String, PendingFile>();

File: src/java/org/apache/cassandra/streaming/compress/CompressedFileStreamTask.java
Patch:
@@ -134,17 +134,17 @@ private List<Pair<Long, Long>> getTransferSections(CompressionMetadata.Chunk[] c
                 if (chunk.offset == lastSection.right)
                 {
                     // extend previous section to end of this chunk
-                    lastSection = new Pair<Long, Long>(lastSection.left, chunk.offset + chunk.length + 4); // 4 bytes for CRC
+                    lastSection = Pair.create(lastSection.left, chunk.offset + chunk.length + 4); // 4 bytes for CRC
                 }
                 else
                 {
                     transferSections.add(lastSection);
-                    lastSection = new Pair<Long, Long>(chunk.offset, chunk.offset + chunk.length + 4);
+                    lastSection = Pair.create(chunk.offset, chunk.offset + chunk.length + 4);
                 }
             }
             else
             {
-                lastSection = new Pair<Long, Long>(chunk.offset, chunk.offset + chunk.length + 4);
+                lastSection = Pair.create(chunk.offset, chunk.offset + chunk.length + 4);
             }
         }
         if (lastSection != null)

File: src/java/org/apache/cassandra/utils/ExpiringMap.java
Patch:
@@ -91,7 +91,7 @@ public void run()
                         cache.remove(entry.getKey());
                         n++;
                         if (postExpireHook != null)
-                            postExpireHook.apply(new Pair<K, CacheableObject<V>>(entry.getKey(), entry.getValue()));
+                            postExpireHook.apply(Pair.create(entry.getKey(), entry.getValue()));
                     }
                 }
                 logger.trace("Expired {} entries", n);

File: src/java/org/apache/cassandra/utils/FBUtilities.java
Patch:
@@ -34,7 +34,6 @@
 import java.util.concurrent.TimeoutException;
 
 import com.google.common.base.Joiner;
-import com.google.common.base.Throwables;
 import com.google.common.collect.AbstractIterator;
 import org.apache.commons.lang.StringUtils;
 import org.slf4j.Logger;
@@ -175,7 +174,7 @@ public static Pair<BigInteger,Boolean> midpoint(BigInteger left, BigInteger righ
             remainder = distance.testBit(0);
             midpoint = distance.shiftRight(1).add(left).mod(max);
         }
-        return new Pair<BigInteger, Boolean>(midpoint, remainder);
+        return Pair.create(midpoint, remainder);
     }
 
     public static int compareUnsigned(byte[] bytes1, byte[] bytes2, int offset1, int offset2, int len1, int len2)

File: src/java/org/apache/cassandra/utils/Pair.java
Patch:
@@ -24,7 +24,7 @@ public class Pair<T1, T2>
     public final T1 left;
     public final T2 right;
 
-    public Pair(T1 left, T2 right)
+    private Pair(T1 left, T2 right)
     {
         this.left = left;
         this.right = right;

File: test/unit/org/apache/cassandra/db/compaction/SizeTieredCompactionStrategyTest.java
Patch:
@@ -33,7 +33,7 @@ public void testGetBuckets()
         String[] strings = { "a", "bbbb", "cccccccc", "cccccccc", "bbbb", "a" };
         for (String st : strings)
         {
-            Pair<String, Long> pair = new Pair<String, Long>(st, new Long(st.length()));
+            Pair<String, Long> pair = Pair.create(st, new Long(st.length()));
             pairs.add(pair);
         }
 
@@ -53,7 +53,7 @@ public void testGetBuckets()
         String[] strings2 = { "aaa", "bbbbbbbb", "aaa", "bbbbbbbb", "bbbbbbbb", "aaa" };
         for (String st : strings2)
         {
-            Pair<String, Long> pair = new Pair<String, Long>(st, new Long(st.length()));
+            Pair<String, Long> pair = Pair.create(st, new Long(st.length()));
             pairs.add(pair);
         }
 
@@ -74,7 +74,7 @@ public void testGetBuckets()
         String[] strings3 = { "aaa", "bbbbbbbb", "aaa", "bbbbbbbb", "bbbbbbbb", "aaa" };
         for (String st : strings3)
         {
-            Pair<String, Long> pair = new Pair<String, Long>(st, new Long(st.length()));
+            Pair<String, Long> pair = Pair.create(st, new Long(st.length()));
             pairs.add(pair);
         }
 

File: test/unit/org/apache/cassandra/streaming/BootstrapTest.java
Patch:
@@ -38,7 +38,7 @@ public void testGetNewNames() throws IOException
     {
         Descriptor desc = Descriptor.fromFilename(new File("Keyspace1", "Keyspace1-Standard1-ia-500-Data.db").toString());
         // assert !desc.isLatestVersion; // minimum compatible version -- for now it is the latest as well
-        PendingFile inContext = new PendingFile(null, desc, "Data.db", Arrays.asList(new Pair<Long,Long>(0L, 1L)), OperationType.BOOTSTRAP);
+        PendingFile inContext = new PendingFile(null, desc, "Data.db", Arrays.asList(Pair.create(0L, 1L)), OperationType.BOOTSTRAP);
 
         PendingFile outContext = StreamIn.getContextMapping(inContext);
         // filename and generation are expected to have changed

File: test/unit/org/apache/cassandra/streaming/SerializationsTest.java
Patch:
@@ -153,7 +153,7 @@ private static PendingFile makePendingFile(boolean sst, int numSecs, OperationTy
         Descriptor desc = new Descriptor("z", new File("path/doesn't/matter"), "Keyspace1", "Standard1", 23, false);
         List<Pair<Long, Long>> sections = new ArrayList<Pair<Long, Long>>();
         for (int i = 0; i < numSecs; i++)
-            sections.add(new Pair<Long, Long>(new Long(i), new Long(i * i)));
+            sections.add(Pair.create(new Long(i), new Long(i * i)));
         return new PendingFile(sst ? makeSSTable() : null, desc, SSTable.COMPONENT_DATA, sections, op);
     }
 

File: src/java/org/apache/cassandra/tracing/TracingAppender.java
Patch:
@@ -34,6 +34,7 @@ protected void append(final LoggingEvent event)
             return;
 
         final int elapsed = state.elapsed();
+        final String threadName = event.getThreadName();
         StageManager.getStage(Stage.TRACING).execute(new WrappedRunnable()
         {
             public void runMayThrow() throws TimedOutException, UnavailableException
@@ -43,7 +44,7 @@ public void runMayThrow() throws TimedOutException, UnavailableException
                 CFMetaData cfMeta = CFMetaData.TraceEventsCf;
                 ColumnFamily cf = ColumnFamily.create(cfMeta);
                 addColumn(cf, buildName(cfMeta, eventId, bytes("source")), FBUtilities.getBroadcastAddress());
-                addColumn(cf, buildName(cfMeta, eventId, bytes("thread")), event.getThreadName());
+                addColumn(cf, buildName(cfMeta, eventId, bytes("thread")), threadName);
                 addColumn(cf, buildName(cfMeta, eventId, bytes("happened_at")), event.getTimeStamp());
                 addColumn(cf, buildName(cfMeta, eventId, bytes("source_elapsed")), elapsed);
                 addColumn(cf, buildName(cfMeta, eventId, bytes("activity")), event.getMessage());

File: src/java/org/apache/cassandra/db/compaction/CompactionTask.java
Patch:
@@ -155,7 +155,7 @@ protected void runWith(File dataDirectory) throws Exception
                 return;
             }
 
-            SSTableWriter writer = cfs.createCompactionWriter(keysPerSSTable, dataDirectory, toCompact);
+            SSTableWriter writer = cfs.createCompactionWriter(keysPerSSTable, cfs.directories.getLocationForDisk(dataDirectory), toCompact);
             writers.add(writer);
             while (nni.hasNext())
             {
@@ -187,7 +187,7 @@ protected void runWith(File dataDirectory) throws Exception
                     sstables.add(toIndex);
                     if (nni.hasNext())
                     {
-                        writer = cfs.createCompactionWriter(keysPerSSTable, dataDirectory, toCompact);
+                        writer = cfs.createCompactionWriter(keysPerSSTable, cfs.directories.getLocationForDisk(dataDirectory), toCompact);
                         writers.add(writer);
                         cachedKeys = new HashMap<DecoratedKey, RowIndexEntry>();
                     }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1192,7 +1192,7 @@ ColumnFamily getColumnFamily(QueryFilter filter, int gcBefore)
             readStats.addNano(System.nanoTime() - start);
         }
 
-        logger.debug("Read {} columns", result.getColumnCount());
+        logger.debug("Read {} columns", result == null ? 0 : result.getColumnCount());
         return result;
     }
 

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -47,7 +47,7 @@
 import org.apache.cassandra.utils.EstimatedHistogram;
 import org.apache.cassandra.utils.Pair;
 
-public class trace_next_queryNodeCmd
+public class NodeCmd
 {
     private static final Pair<String, String> SNAPSHOT_COLUMNFAMILY_OPT = new Pair<String, String>("cf", "column-family");
     private static final Pair<String, String> HOST_OPT = new Pair<String, String>("h", "host");
@@ -147,7 +147,7 @@ private static void printUsage()
         // No args
         addCmdHelp(header, "ring", "Print information about the token ring");
         addCmdHelp(header, "join", "Join the ring");
-        addCmdHelp(header, "igit nfo [-T/--tokens]", "Print node information (uptime, load, ...)");
+        addCmdHelp(header, "info [-T/--tokens]", "Print node information (uptime, load, ...)");
         addCmdHelp(header, "status", "Print cluster information (state, load, IDs, ...)");
         addCmdHelp(header, "cfstats", "Print statistics on column families");
         addCmdHelp(header, "version", "Print cassandra version");

File: src/java/org/apache/cassandra/db/HintedHandOffManager.java
Patch:
@@ -43,6 +43,7 @@
 import org.apache.cassandra.db.marshal.UUIDType;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.Range;
+import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.gms.ApplicationState;
 import org.apache.cassandra.gms.FailureDetector;
 import org.apache.cassandra.gms.Gossiper;

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -773,7 +773,7 @@ public Future<?> submitCacheWrite(final AutoSavingCache.Writer writer)
         {
             public void runMayThrow() throws IOException
             {
-                if (!AutoSavingCache.flushInProgress.compareAndSet(false, true))
+                if (!AutoSavingCache.flushInProgress.add(writer.cacheType()))
                 {
                     logger.debug("Cache flushing was already in progress: skipping {}", writer.getCompactionInfo());
                     return;
@@ -792,7 +792,7 @@ public void runMayThrow() throws IOException
                 }
                 finally
                 {
-                    AutoSavingCache.flushInProgress.set(false);
+                    AutoSavingCache.flushInProgress.remove(writer.cacheType());
                 }
             }
         };

File: src/java/org/apache/cassandra/hadoop/ColumnFamilyOutputFormat.java
Patch:
@@ -33,6 +33,7 @@
 import org.apache.hadoop.mapreduce.*;
 import org.apache.thrift.TException;
 import org.apache.thrift.transport.TSocket;
+import org.apache.thrift.transport.TTransport;
 
 import javax.security.auth.login.LoginException;
 
@@ -62,6 +63,8 @@ public class ColumnFamilyOutputFormat extends OutputFormat<ByteBuffer,List<Mutat
 {
     public static final String BATCH_THRESHOLD = "mapreduce.output.columnfamilyoutputformat.batch.threshold";
     public static final String QUEUE_SIZE = "mapreduce.output.columnfamilyoutputformat.queue.size";
+    private static final Logger logger = LoggerFactory.getLogger(ColumnFamilyOutputFormat.class);
+
 
     /**
      * Check for validity of the output-specification for the job.

File: src/java/org/apache/cassandra/service/CacheService.java
Patch:
@@ -334,7 +334,6 @@ public Pair<RowCacheKey, IRowCacheEntry> deserialize(DataInputStream in, ColumnF
             return new Pair<RowCacheKey, IRowCacheEntry>(new RowCacheKey(cfs.metadata.cfId, key), data);
         }
 
-        @Override
         public void load(Set<ByteBuffer> buffers, ColumnFamilyStore cfs)
         {
             for (ByteBuffer key : buffers)
@@ -390,7 +389,6 @@ private SSTableReader findDesc(int generation, Collection<SSTableReader> collect
             return null;
         }
 
-        @Override
         public void load(Set<ByteBuffer> buffers, ColumnFamilyStore cfs)
         {
             for (ByteBuffer key : buffers)

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -863,7 +863,7 @@ private void handleGroup(List<Pair<CFDefinition.Name, Selector>> selection, Byte
                         if (collection == null)
                             cqlRows.addColumnValue(null);
                         else
-                            cqlRows.addColumnValue(((CollectionType)name.type).serializeForThrift(collection));
+                            cqlRows.addColumnValue(((CollectionType)name.type).serialize(collection));
                         break;
                     }
                     IColumn c = columns.getSimple(name.name.key);

File: src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
Patch:
@@ -416,7 +416,7 @@ public boolean next(ByteBuffer key, SortedMap<ByteBuffer, IColumn> value) throws
         {
             key.clear();
             key.put(this.getCurrentKey());
-            key.rewind();
+            key.flip();
 
             value.clear();
             value.putAll(this.getCurrentValue());

File: src/java/org/apache/cassandra/db/compaction/Scrubber.java
Patch:
@@ -211,7 +211,7 @@ public void scrub() throws IOException
                             }
                             else
                             {
-                                if (prevRow != null && acrComparator.compare(prevRow, compactedRow) > 0)
+                                if (prevRow != null && acrComparator.compare(prevRow, compactedRow) >= 0)
                                 {
                                     outOfOrderRows.add(compactedRow);
                                     outputHandler.warn(String.format("Out of order row detected (%s found after %s)", compactedRow.key, prevRow.key));

File: src/java/org/apache/cassandra/tools/StandaloneScrubber.java
Patch:
@@ -179,7 +179,7 @@ private static void checkManifest(LeveledManifest manifest)
             {
                 SSTableReader current = iter.next();
 
-                if (previous.last.compareTo(current.first) > 0)
+                if (previous.last.compareTo(current.first) >= 0)
                 {
                     System.err.println(String.format("At level %d, %s [%s, %s] overlaps %s [%s, %s]", i,
                                                      previous, previous.first, previous.last,

File: src/java/org/apache/cassandra/db/compaction/Scrubber.java
Patch:
@@ -177,7 +177,7 @@ public void scrub() throws IOException
                     }
                     else
                     {
-                        if (prevRow != null && acrComparator.compare(prevRow, compactedRow) > 0)
+                        if (prevRow != null && acrComparator.compare(prevRow, compactedRow) >= 0)
                         {
                             outOfOrderRows.add(compactedRow);
                             outputHandler.warn(String.format("Out of order row detected (%s found after %s)", compactedRow.key, prevRow.key));

File: src/java/org/apache/cassandra/db/compaction/Scrubber.java
Patch:
@@ -175,7 +175,7 @@ public void scrub() throws IOException
                     }
                     else
                     {
-                        if (prevRow != null && acrComparator.compare(prevRow, compactedRow) > 0)
+                        if (prevRow != null && acrComparator.compare(prevRow, compactedRow) >= 0)
                         {
                             outOfOrderRows.add(compactedRow);
                             outputHandler.warn(String.format("Out of order row detected (%s found after %s)", compactedRow.key, prevRow.key));

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -644,7 +644,7 @@ public void waitForStreaming() throws InterruptedException
 
         for (DebuggableThreadPoolExecutor e : streamExecutors.values())
         {
-            if (e.awaitTermination(24, TimeUnit.HOURS))
+            if (!e.awaitTermination(24, TimeUnit.HOURS))
                 logger.error("Stream took more than 24H to complete; skipping");
         }
     }

File: src/java/org/apache/cassandra/db/marshal/TypeParser.java
Patch:
@@ -503,11 +503,11 @@ public static String stringifyCollectionsParameters(Map<ByteBuffer, CollectionTy
         boolean first = true;
         for (Map.Entry<ByteBuffer, CollectionType> entry : collections.entrySet())
         {
-            if (first)
+            if (!first)
             {
                 sb.append(',');
-                first = false;
             }
+            first = false;
             sb.append(ByteBufferUtil.bytesToHex(entry.getKey())).append(":");
             entry.getValue().appendToStringBuilder(sb);
         }

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -521,7 +521,7 @@ public void waitForStreaming() throws InterruptedException
 
         for (DebuggableThreadPoolExecutor e : streamExecutors.values())
         {
-            if (e.awaitTermination(24, TimeUnit.HOURS))
+            if (!e.awaitTermination(24, TimeUnit.HOURS))
                 logger_.error("Stream took more than 24H to complete; skipping");
         }
     }

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -588,8 +588,8 @@ private void joinTokenRing(int delay) throws IOException, org.apache.cassandra.c
         // as well as avoiding the nonsensical state of trying to stream from cluster with no active peers.
         Token<?> token;
         InetAddress current = null;
-        logger_.debug("Bootstrap variables: %s %s %s %s",
-                      new Object[] {DatabaseDescriptor.isAutoBootstrap(), SystemTable.bootstrapInProgress(), SystemTable.bootstrapComplete(), schemaPresent});
+        logger_.debug(String.format("Bootstrap variables: %s %s %s %s",
+                      DatabaseDescriptor.isAutoBootstrap(), SystemTable.bootstrapInProgress(), SystemTable.bootstrapComplete(), schemaPresent));
         if (DatabaseDescriptor.isAutoBootstrap()
             && (SystemTable.bootstrapInProgress() || (!SystemTable.bootstrapComplete() && schemaPresent)))
         {

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -1172,6 +1172,7 @@ public RowMutation dropFromSchema(long timestamp)
         cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "min_compaction_threshold"));
         cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "max_compaction_threshold"));
         cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "key_alias"));
+        cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "key_aliases"));
         cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "bloom_filter_fp_chance"));
         cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "caching"));
         cf.addColumn(DeletedColumn.create(ldt, timestamp, cfName, "compaction_strategy_class"));

File: test/unit/org/apache/cassandra/thrift/ThriftValidationTest.java
Patch:
@@ -21,6 +21,8 @@
  */
 
 
+import java.util.Arrays;
+
 import org.junit.Test;
 
 import org.apache.cassandra.SchemaLoader;
@@ -54,7 +56,7 @@ public void testColumnNameEqualToKeyAlias()
         boolean gotException = false;
 
         // add a key_alias = "id"
-        newMetadata.keyAlias(AsciiType.instance.decompose("id"));
+        newMetadata.keyAliases(Arrays.asList(AsciiType.instance.decompose("id")));
 
         // should not throw IRE here
         try

File: test/unit/org/apache/cassandra/db/SecondaryIndexColumnSizeTest.java
Patch:
@@ -36,7 +36,7 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
-public class SecondaryIndexColumSizeTest
+public class SecondaryIndexColumnSizeTest
 {
     @Test
     public void test64kColumn()

File: src/java/org/apache/cassandra/io/sstable/Descriptor.java
Patch:
@@ -58,7 +58,7 @@ public class Descriptor
     // hb (1.0.3): records compression ration in metadata component
     // hc (1.0.4): records partitioner in metadata component
     // hd (1.0.10): includes row tombstones in maxtimestamp
-    // he (1.0.11): includes row tombstones in maxtimestamp
+    // he (1.1.3): includes ancestors generation in metadata component
     public static final String CURRENT_VERSION = "he";
 
     public final File directory;

File: src/java/org/apache/cassandra/cache/RowCacheKey.java
Patch:
@@ -76,6 +76,6 @@ public int compareTo(RowCacheKey otherKey)
     @Override
     public String toString()
     {
-        return String.format("RowCacheKey(cfId:%d, key:%s)", cfId, Arrays.toString(key));
+        return String.format("RowCacheKey(cfId:%s, key:%s)", cfId, Arrays.toString(key));
     }
 }

File: src/java/org/apache/cassandra/transport/OptionCodec.java
Patch:
@@ -77,7 +77,7 @@ public Map<T, Object> decode(ChannelBuffer body)
             T opt = fromId(body.readUnsignedShort());
             Object value = opt.readValue(body);
             if (options.containsKey(opt))
-                throw new ProtocolException(String.format("Duplicate option %d in message", opt));
+                throw new ProtocolException(String.format("Duplicate option %s in message", opt.name()));
             options.put(opt, value);
         }
         return options;

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -166,7 +166,7 @@ public final class CFMetaData
                                                          + "token_bytes blob,"
                                                          + "cluster_name text,"
                                                          + "gossip_generation int,"
-                                                         + "bootstrapped boolean,"
+                                                         + "bootstrapped text,"
                                                          + "ring_id uuid,"
                                                          + "release_version text,"
                                                          + "thrift_version text,"

File: src/java/org/apache/cassandra/db/compaction/SizeTieredCompactionStrategy.java
Patch:
@@ -43,8 +43,7 @@ public SizeTieredCompactionStrategy(ColumnFamilyStore cfs, Map<String, String> o
         this.estimatedRemainingTasks = 0;
         String optionValue = options.get(MIN_SSTABLE_SIZE_KEY);
         minSSTableSize = (null != optionValue) ? Long.parseLong(optionValue) : DEFAULT_MIN_SSTABLE_SIZE;
-        cfs.setMaximumCompactionThreshold(cfs.metadata.getMaxCompactionThreshold());
-        cfs.setMinimumCompactionThreshold(cfs.metadata.getMinCompactionThreshold());
+        cfs.setCompactionThresholds(cfs.metadata.getMinCompactionThreshold(), cfs.metadata.getMaxCompactionThreshold());
     }
 
     public AbstractCompactionTask getNextBackgroundTask(final int gcBefore)

File: src/java/org/apache/cassandra/tools/NodeProbe.java
Patch:
@@ -440,8 +440,7 @@ public void getCompactionThreshold(PrintStream outs, String ks, String cf)
     public void setCompactionThreshold(String ks, String cf, int minimumCompactionThreshold, int maximumCompactionThreshold)
     {
         ColumnFamilyStoreMBean cfsProxy = getCfsProxy(ks, cf);
-        cfsProxy.setMinimumCompactionThreshold(minimumCompactionThreshold);
-        cfsProxy.setMaximumCompactionThreshold(maximumCompactionThreshold);
+        cfsProxy.setCompactionThresholds(minimumCompactionThreshold, maximumCompactionThreshold);
     }
 
     public void setCacheCapacities(String tableName, String cfName, int keyCacheCapacity, int rowCacheCapacity)

File: test/unit/org/apache/cassandra/db/compaction/CompactionsTest.java
Patch:
@@ -194,8 +194,7 @@ public void assertMaxTimestamp(ColumnFamilyStore cfs, long maxTimestampExpected)
     private void forceCompactions(ColumnFamilyStore cfs) throws ExecutionException, InterruptedException
     {
         // re-enable compaction with thresholds low enough to force a few rounds
-        cfs.setMinimumCompactionThreshold(2);
-        cfs.setMaximumCompactionThreshold(4);
+        cfs.setCompactionThresholds(2, 4);
 
         // loop submitting parallel compactions until they all return 0
         do

File: src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java
Patch:
@@ -670,7 +670,7 @@ private byte getPigType(AbstractType type)
     {
         if (type instanceof LongType || type instanceof DateType) // DateType is bad and it should feel bad
             return DataType.LONG;
-        else if (type instanceof IntegerType)
+        else if (type instanceof IntegerType || type instanceof Int32Type) // IntegerType will overflow at 2**31, but is kept for compatibility until pig has a BigInteger
             return DataType.INTEGER;
         else if (type instanceof AsciiType)
             return DataType.CHARARRAY;

File: src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java
Patch:
@@ -205,7 +205,6 @@ public synchronized Future<?> addIndexedColumn(ColumnDefinition cdef)
             return null;
 
         assert cdef.getIndexType() != null;
-        logger.info("Creating new index : {}",cdef);
 
         SecondaryIndex index;
         try
@@ -231,6 +230,7 @@ public synchronized Future<?> addIndexedColumn(ColumnDefinition cdef)
             {
                 index = currentIndex;
                 index.addColumnDef(cdef);
+                logger.info("Creating new index : {}",cdef);
             }
         }
         else

File: src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java
Patch:
@@ -205,7 +205,6 @@ public synchronized Future<?> addIndexedColumn(ColumnDefinition cdef)
             return null;
 
         assert cdef.getIndexType() != null;
-        logger.info("Creating new index : {}",cdef);
 
         SecondaryIndex index;
         try
@@ -231,6 +230,7 @@ public synchronized Future<?> addIndexedColumn(ColumnDefinition cdef)
             {
                 index = currentIndex;
                 index.addColumnDef(cdef);
+                logger.info("Creating new index : {}",cdef);
             }
         }
         else

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -886,7 +886,7 @@ public ColumnDefinition getColumnDefinitionForIndex(String indexName)
     public void addDefaultIndexNames() throws ConfigurationException
     {
         // if this is ColumnFamily update we need to add previously defined index names to the existing columns first
-        Integer cfId = Schema.instance.getId(ksName, cfName);
+        UUID cfId = Schema.instance.getId(ksName, cfName);
         if (cfId != null)
         {
             CFMetaData cfm = Schema.instance.getCFMetaData(cfId);

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -877,6 +877,9 @@ public void addDefaultIndexNames() throws ConfigurationException
 
                 String oldIndexName = cfm.column_metadata.get(entry.getKey()).getIndexName();
 
+                if (oldIndexName == null)
+                    continue;
+
                 if (newDef.getIndexName() != null && !oldIndexName.equals(newDef.getIndexName()))
                     throw new ConfigurationException("Can't modify index name: was '" + oldIndexName + "' changed to '" + newDef.getIndexName() + "'.");
 

File: src/java/org/apache/cassandra/db/marshal/DateType.java
Patch:
@@ -108,7 +108,7 @@ else if (source.matches("^\\d+$"))
       {
           try
           {
-              millis = DateUtils.parseDate(source, iso8601Patterns).getTime();
+              millis = DateUtils.parseDateStrictly(source, iso8601Patterns).getTime();
           }
           catch (ParseException e1)
           {

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -65,7 +65,7 @@ public class Config
     public String listen_address;
     public String broadcast_address;
 
-    public Boolean start_rpc = false;
+    public Boolean start_rpc = true;
     public String rpc_address;
     public Integer rpc_port = 9160;
     public String rpc_server_type = "sync";

File: src/java/org/apache/cassandra/db/compaction/CompactionTask.java
Patch:
@@ -169,7 +169,7 @@ public int execute(CompactionExecutorStatsCollector collector) throws IOExceptio
                         }
                     }
                 }
-                if (!nni.hasNext() || newSSTableSegmentThresholdReached(writer, position))
+                if (!nni.hasNext() || newSSTableSegmentThresholdReached(writer))
                 {
                     SSTableReader toIndex = writer.closeAndOpenReader(getMaxDataAge(toCompact));
                     cachedKeyMap.put(toIndex, cachedKeys);
@@ -229,7 +229,7 @@ protected boolean partialCompactionsAcceptable()
     }
 
     //extensibility point for other strategies that may want to limit the upper bounds of the sstable segment size
-    protected boolean newSSTableSegmentThresholdReached(SSTableWriter writer, long position)
+    protected boolean newSSTableSegmentThresholdReached(SSTableWriter writer) throws IOException
     {
         return false;
     }

File: src/java/org/apache/cassandra/db/compaction/LeveledCompactionTask.java
Patch:
@@ -69,9 +69,9 @@ public boolean isDone()
     }
 
     @Override
-    protected boolean newSSTableSegmentThresholdReached(SSTableWriter writer, long position)
+    protected boolean newSSTableSegmentThresholdReached(SSTableWriter writer) throws IOException
     {
-        return position > sstableSizeInMB * 1024L * 1024L;
+        return writer.getOnDiskFilePointer() > sstableSizeInMB * 1024L * 1024L;
     }
 
     @Override

File: src/java/org/apache/cassandra/db/AbstractColumnContainer.java
Patch:
@@ -256,8 +256,9 @@ public boolean hasIrrelevantData(int gcBefore)
         if (isMarkedForDelete() && getLocalDeletionTime() < gcBefore)
             return true;
 
+        long deletedAt = getMarkedForDeleteAt();
         for (IColumn column : columns)
-            if (column.mostRecentLiveChangeAt() < getLocalDeletionTime() || column.hasIrrelevantData(gcBefore))
+            if (column.mostRecentLiveChangeAt() <= deletedAt || column.hasIrrelevantData(gcBefore))
                 return true;
 
         return false;

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -319,7 +319,7 @@ else if (movingNodes.contains(endpoint))
                     ? loadMap.get(endpoint)
                     : "?";
             String owns = new DecimalFormat("##0.00%").format(entry.getValue());
-            outs.printf(format, entry.getKey(), rack, status, state, load, owns, token);
+            outs.printf(format, endpoint, rack, status, state, load, owns, token);
         }
         outs.println();
     }

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -97,11 +97,11 @@ public class Config
 
     // Commit Log
     public String commitlog_directory;
-    public Integer commitlog_total_space_in_mb = 4096;
+    public Integer commitlog_total_space_in_mb;
     public CommitLogSync commitlog_sync;
     public Double commitlog_sync_batch_window_in_ms;
     public Integer commitlog_sync_period_in_ms;
-    public int commitlog_segment_size_in_mb = 128;
+    public int commitlog_segment_size_in_mb = 32;
 
     public String endpoint_snitch;
     public Boolean dynamic_snitch = true;

File: src/java/org/apache/cassandra/utils/Mx4jTool.java
Patch:
@@ -65,7 +65,7 @@ public static boolean maybeLoad()
         }
         catch (ClassNotFoundException e)
         {
-            logger.info("Will not load MX4J, mx4j-tools.jar is not in the classpath");
+            logger.debug("Will not load MX4J, mx4j-tools.jar is not in the classpath");
         }
         catch(Exception e)
         {

File: src/java/org/apache/cassandra/utils/Mx4jTool.java
Patch:
@@ -69,7 +69,7 @@ public static boolean maybeLoad()
         }
         catch (ClassNotFoundException e)
         {
-            logger.info("Will not load MX4J, mx4j-tools.jar is not in the classpath");
+            logger.debug("Will not load MX4J, mx4j-tools.jar is not in the classpath");
         }
         catch(Exception e)
         {

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -72,7 +72,7 @@ public final class CFMetaData
     public final static String DEFAULT_COMPACTION_STRATEGY_CLASS = "SizeTieredCompactionStrategy";
     public final static ByteBuffer DEFAULT_KEY_NAME = ByteBufferUtil.bytes("KEY");
     public final static Caching DEFAULT_CACHING_STRATEGY = Caching.KEYS_ONLY;
-    public final static Double DEFAULT_BF_FP_CHANCE = null;
+    public final static Double DEFAULT_BF_FP_CHANCE = 0.01;
 
     // Note that this is the default only for user created tables
     public final static String DEFAULT_COMPRESSOR = SnappyCompressor.isAvailable() ? SnappyCompressor.class.getCanonicalName() : null;
@@ -317,7 +317,6 @@ private void init()
         minCompactionThreshold       = DEFAULT_MIN_COMPACTION_THRESHOLD;
         maxCompactionThreshold       = DEFAULT_MAX_COMPACTION_THRESHOLD;
         caching                      = DEFAULT_CACHING_STRATEGY;
-        bloomFilterFpChance          = DEFAULT_BF_FP_CHANCE;
 
         // Defaults strange or simple enough to not need a DEFAULT_T for
         defaultValidator = BytesType.instance;

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -926,6 +926,8 @@ public String system_add_column_family(CfDef cf_def)
         {
             cf_def.unsetId(); // explicitly ignore any id set by client (Hector likes to set zero)
             CFMetaData cfm = CFMetaData.fromThrift(cf_def);
+            if (cfm.getBloomFilterFpChance() == null)
+                cfm.bloomFilterFpChance(CFMetaData.DEFAULT_BF_FP_CHANCE);
             cfm.addDefaultIndexNames();
             MigrationManager.announceNewColumnFamily(cfm);
             return Schema.instance.getVersion().toString();

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -107,7 +107,7 @@ public final class CFMetaData
                                                                  + "durable_writes boolean,"
                                                                  + "strategy_class text,"
                                                                  + "strategy_options text"
-                                                                 + ") WITH COMMENT='keyspace definitions' AND gc_grace_seconds=8640");
+                                                                 + ") WITH COMPACT STORAGE AND COMMENT='keyspace definitions' AND gc_grace_seconds=8640");
     public static final CFMetaData SchemaColumnFamiliesCf = compile(9, "CREATE TABLE " + SystemTable.SCHEMA_COLUMNFAMILIES_CF + "("
                                                                      + "keyspace_name text,"
                                                                      + "columnfamily_name text,"

File: src/java/org/apache/cassandra/cql3/QueryProcessor.java
Patch:
@@ -126,6 +126,8 @@ public static UntypedResultSet processInternal(String query)
         {
             ClientState state = new ClientState();
             CqlResult result = processStatement(getStatement(query, state).statement, state, Collections.<ByteBuffer>emptyList());
+            if (result.rows == null)
+                return null;
             return new UntypedResultSet(result.rows);
         }
         catch (UnavailableException e)

File: src/java/org/apache/cassandra/db/Column.java
Patch:
@@ -322,7 +322,7 @@ public static Column create(ByteBuffer value, long timestamp, String... names)
         return new Column(decomposeName(names), value, timestamp);
     }
 
-    public static IColumn create(InetAddress value, long timestamp, String... names)
+    public static Column create(InetAddress value, long timestamp, String... names)
     {
         return new Column(decomposeName(names), InetAddressType.instance.decompose(value), timestamp);
     }

File: src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
Patch:
@@ -130,8 +130,8 @@ public void resetAndTruncate()
     private long beforeAppend(DecoratedKey<?> decoratedKey) throws IOException
     {
         assert decoratedKey != null : "Keys must not be null";
-        assert lastWrittenKey == null || lastWrittenKey.compareTo(decoratedKey) < 0
-               : "Last written key " + lastWrittenKey + " >= current key " + decoratedKey + " writing into " + getFilename();
+        if (lastWrittenKey != null && lastWrittenKey.compareTo(decoratedKey) >= 0)
+            throw new RuntimeException("Last written key " + lastWrittenKey + " >= current key " + decoratedKey + " writing into " + getFilename());
         return (lastWrittenKey == null) ? 0 : dataFile.getFilePointer();
     }
 

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -329,6 +329,7 @@ public Object call() throws IOException
     private void activateNextSegment() throws IOException
     {
         activeSegment = allocator.fetchSegment();
+        logger.debug("Active segment is now {}", activeSegment);
     }
 
     public List<String> getActiveSegmentNames()

File: src/java/org/apache/cassandra/db/commitlog/CommitLogAllocator.java
Patch:
@@ -330,7 +330,7 @@ public void resetUnsafe()
         while (!queue.isEmpty())
             Thread.yield();
 
-        for (CommitLogSegment segment : activeSegments)
+        for (CommitLogSegment segment : Iterables.concat(activeSegments, availableSegments))
             segment.close();
 
         activeSegments.clear();

File: src/java/org/apache/cassandra/db/commitlog/CommitLogReplayer.java
Patch:
@@ -119,9 +119,9 @@ public void recover(File file) throws IOException
         logger.info("Replaying " + file.getPath());
         final long segment = CommitLogSegment.idFromFilename(file.getName());
         RandomAccessReader reader = RandomAccessReader.open(new File(file.getAbsolutePath()), true);
-        assert reader.length() <= Integer.MAX_VALUE;
         try
         {
+            assert reader.length() <= Integer.MAX_VALUE;
             int replayPosition;
             if (globalPosition.segment < segment)
                 replayPosition = 0;

File: src/java/org/apache/cassandra/db/commitlog/CommitLogArchiver.java
Patch:
@@ -1,4 +1,3 @@
-package org.apache.cassandra.db.commitlog;
 /*
  * 
  * Licensed to the Apache Software Foundation (ASF) under one
@@ -19,6 +18,7 @@
  * under the License.
  * 
  */
+package org.apache.cassandra.db.commitlog;
 
 import java.io.File;
 import java.io.IOException;

File: src/java/org/apache/cassandra/db/commitlog/CommitLogDescriptor.java
Patch:
@@ -1,4 +1,3 @@
-package org.apache.cassandra.db.commitlog;
 /*
  * 
  * Licensed to the Apache Software Foundation (ASF) under one
@@ -19,6 +18,7 @@
  * under the License.
  * 
  */
+package org.apache.cassandra.db.commitlog;
 
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -75,6 +75,7 @@ public static CommitLogDescriptor fromFileName(String name)
 
     public int getMessagingVersion()
     {
+        assert MessagingService.current_version == MessagingService.VERSION_12;
         switch (version)
         {
             case LEGACY_VERSION:

File: src/java/org/apache/cassandra/db/compaction/CompactionTask.java
Patch:
@@ -170,7 +170,7 @@ public int execute(CompactionExecutorStatsCollector collector) throws IOExceptio
                         }
                     }
                 }
-                if (!nni.hasNext() || newSSTableSegmentThresholdReached(writer, position))
+                if (!nni.hasNext() || newSSTableSegmentThresholdReached(writer))
                 {
                     SSTableReader toIndex = writer.closeAndOpenReader(getMaxDataAge(toCompact));
                     cachedKeyMap.put(toIndex, cachedKeys);
@@ -230,7 +230,7 @@ protected boolean partialCompactionsAcceptable()
     }
 
     //extensibility point for other strategies that may want to limit the upper bounds of the sstable segment size
-    protected boolean newSSTableSegmentThresholdReached(SSTableWriter writer, long position)
+    protected boolean newSSTableSegmentThresholdReached(SSTableWriter writer) throws IOException
     {
         return false;
     }

File: src/java/org/apache/cassandra/db/compaction/LeveledCompactionTask.java
Patch:
@@ -66,9 +66,9 @@ public boolean markSSTablesForCompaction(int min, int max)
     }
 
     @Override
-    protected boolean newSSTableSegmentThresholdReached(SSTableWriter writer, long position)
+    protected boolean newSSTableSegmentThresholdReached(SSTableWriter writer) throws IOException
     {
-        return position > sstableSizeInMB * 1024L * 1024L;
+        return writer.getOnDiskFilePointer() > sstableSizeInMB * 1024L * 1024L;
     }
 
     @Override

File: src/java/org/apache/cassandra/db/compaction/CompactionTask.java
Patch:
@@ -166,7 +166,7 @@ public int execute(CompactionExecutorStatsCollector collector) throws IOExceptio
                         }
                     }
                 }
-                if (!nni.hasNext() || newSSTableSegmentThresholdReached(writer, indexEntry.position))
+                if (!nni.hasNext() || newSSTableSegmentThresholdReached(writer))
                 {
                     SSTableReader toIndex = writer.closeAndOpenReader(getMaxDataAge(toCompact));
                     cachedKeyMap.put(toIndex, cachedKeys);
@@ -226,7 +226,7 @@ protected boolean partialCompactionsAcceptable()
     }
 
     //extensibility point for other strategies that may want to limit the upper bounds of the sstable segment size
-    protected boolean newSSTableSegmentThresholdReached(SSTableWriter writer, long position)
+    protected boolean newSSTableSegmentThresholdReached(SSTableWriter writer) throws IOException
     {
         return false;
     }

File: src/java/org/apache/cassandra/db/compaction/LeveledCompactionTask.java
Patch:
@@ -62,9 +62,9 @@ public boolean markSSTablesForCompaction(int min, int max)
     }
 
     @Override
-    protected boolean newSSTableSegmentThresholdReached(SSTableWriter writer, long position)
+    protected boolean newSSTableSegmentThresholdReached(SSTableWriter writer) throws IOException
     {
-        return position > sstableSizeInMB * 1024L * 1024L;
+        return writer.getOnDiskFilePointer() > sstableSizeInMB * 1024L * 1024L;
     }
 
     @Override

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -924,7 +924,7 @@ public static List<Row> getRangeSlice(RangeSliceCommand command, ConsistencyLeve
                                     columnsCount += row.getLiveColumnCount();
                                     logger.debug("range slices read {}", row.key);
                                 }
-                                FBUtilities.waitOnFutures(resolver.repairResults, DatabaseDescriptor.getReadRpcTimeout());
+                                FBUtilities.waitOnFutures(resolver.repairResults, DatabaseDescriptor.getRangeRpcTimeout());
                             }
                             catch (TimeoutException ex)
                             {

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -129,7 +129,7 @@ public final class CFMetaData
                                                                      + "caching text,"
                                                                      + "compaction_strategy_class text,"
                                                                      + "compression_parameters text,"
-                                                                     + "value_aliases text,"
+                                                                     + "value_alias text,"
                                                                      + "column_aliases text,"
                                                                      + "compaction_strategy_options text,"
                                                                      + "PRIMARY KEY (keyspace_name, columnfamily_name)"

File: src/java/org/apache/cassandra/dht/BootStrapper.java
Patch:
@@ -155,7 +155,7 @@ static Token<?> getBootstrapTokenFrom(InetAddress maxEndpoint)
     {
         MessageOut message = new MessageOut(MessagingService.Verb.BOOTSTRAP_TOKEN);
         int retries = 5;
-        long timeout = Math.max(MessagingService.getDefaultCallbackTimeout(), BOOTSTRAP_TIMEOUT);
+        long timeout = Math.max(DatabaseDescriptor.getRpcTimeout(), BOOTSTRAP_TIMEOUT);
 
         while (retries > 0)
         {

File: src/java/org/apache/cassandra/net/MessageDeliveryTask.java
Patch:
@@ -41,7 +41,7 @@ public void run()
     {
         MessagingService.Verb verb = message.verb;
         if (MessagingService.DROPPABLE_VERBS.contains(verb)
-            && System.currentTimeMillis() > constructionTime + DatabaseDescriptor.getRpcTimeout())
+            && System.currentTimeMillis() > constructionTime + message.getTimeout())
         {
             MessagingService.instance().incrementDroppedMessages(verb);
             return;

File: src/java/org/apache/cassandra/net/OutboundTcpConnection.java
Patch:
@@ -131,7 +131,7 @@ public void run()
                 disconnect();
                 continue;
             }
-            if (entry.timestamp < System.currentTimeMillis() - DatabaseDescriptor.getRpcTimeout())
+            if (entry.timestamp < System.currentTimeMillis() - m.getTimeout())
                 dropped.incrementAndGet();
             else if (socket != null || connect())
                 writeConnected(m, id);
@@ -312,7 +312,7 @@ private void expireMessages()
         while (true)
         {
             Entry entry = backlog.peek();
-            if (entry == null || entry.timestamp >= System.currentTimeMillis() - DatabaseDescriptor.getRpcTimeout())
+            if (entry == null || entry.timestamp >= System.currentTimeMillis() - entry.message.getTimeout())
                 break;
 
             Entry entry2 = backlog.poll();

File: src/java/org/apache/cassandra/service/AbstractWriteResponseHandler.java
Patch:
@@ -44,7 +44,8 @@ protected AbstractWriteResponseHandler(Collection<InetAddress> writeEndpoints, C
 
     public void get() throws TimeoutException
     {
-        long timeout = DatabaseDescriptor.getRpcTimeout() - (System.currentTimeMillis() - startTime);
+        long timeout = DatabaseDescriptor.getWriteRpcTimeout() - (System.currentTimeMillis() - startTime);
+
         boolean success;
         try
         {

File: src/java/org/apache/cassandra/service/IReadCommand.java
Patch:
@@ -20,4 +20,5 @@
 public interface IReadCommand
 {
     public String getKeyspace();
+    public long getTimeout();
 }

File: src/java/org/apache/cassandra/service/ReadCallback.java
Patch:
@@ -128,7 +128,7 @@ private List<InetAddress> filterEndpoints(List<InetAddress> ep)
 
     public TResolved get() throws TimeoutException, DigestMismatchException, IOException
     {
-        long timeout = DatabaseDescriptor.getRpcTimeout() - (System.currentTimeMillis() - startTime);
+        long timeout = command.getTimeout() - (System.currentTimeMillis() - startTime);
         boolean success;
         try
         {

File: src/java/org/apache/cassandra/service/RepairCallback.java
Patch:
@@ -55,7 +55,7 @@ public RepairCallback(RowRepairResolver resolver, List<InetAddress> endpoints)
 
     public Row get() throws TimeoutException, DigestMismatchException, IOException
     {
-        long timeout = DatabaseDescriptor.getRpcTimeout() - (System.currentTimeMillis() - startTime);
+        long timeout = DatabaseDescriptor.getWriteRpcTimeout() - (System.currentTimeMillis() - startTime);
         try
         {
             condition.await(timeout, TimeUnit.MILLISECONDS);

File: src/java/org/apache/cassandra/service/TruncateResponseHandler.java
Patch:
@@ -49,7 +49,7 @@ public TruncateResponseHandler(int responseCount)
 
     public void get() throws TimeoutException
     {
-        long timeout = DatabaseDescriptor.getRpcTimeout() - (System.currentTimeMillis() - startTime);
+        long timeout = DatabaseDescriptor.getTruncateRpcTimeout() - (System.currentTimeMillis() - startTime);
         boolean success;
         try
         {

File: src/java/org/apache/cassandra/cache/RowCacheKey.java
Patch:
@@ -76,6 +76,6 @@ public int compareTo(RowCacheKey otherKey)
     @Override
     public String toString()
     {
-        return String.format("RowCacheKey(cfId:%d, key:%s)", cfId, key);
+        return String.format("RowCacheKey(cfId:%d, key:%s)", cfId, Arrays.toString(key));
     }
 }

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -1084,6 +1084,8 @@ public void initializeNodeUnsafe(InetAddress addr, int generationNbr) {
             localState.markAlive();
             endpointStateMap.put(addr, localState);
         }
+        // always add the version state
+        localState.addApplicationState(ApplicationState.NET_VERSION, StorageService.instance.valueFactory.networkVersion());
     }
 
     public long getEndpointDowntime(String address) throws UnknownHostException

File: test/unit/org/apache/cassandra/Util.java
Patch:
@@ -40,6 +40,7 @@
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.dht.*;
 import org.apache.cassandra.gms.ApplicationState;
+import org.apache.cassandra.gms.Gossiper;
 import org.apache.cassandra.gms.VersionedValue;
 import org.apache.cassandra.io.sstable.Descriptor;
 import org.apache.cassandra.io.sstable.SSTableReader;
@@ -228,6 +229,7 @@ public static void createInitialRing(StorageService ss, IPartitioner partitioner
         for (int i=0; i<endpointTokens.size(); i++)
         {
             InetAddress ep = InetAddress.getByName("127.0.0." + String.valueOf(i + 1));
+            Gossiper.instance.initializeNodeUnsafe(ep, 1);
             ss.onChange(ep, ApplicationState.STATUS, new VersionedValue.VersionedValueFactory(partitioner).normal(endpointTokens.get(i), hostIds.get(i)));
             hosts.add(ep);
         }

File: test/unit/org/apache/cassandra/dht/BootStrapperTest.java
Patch:
@@ -88,6 +88,8 @@ public void testMulitipleAutomaticBootstraps() throws IOException
         {
             Gossiper.instance.initializeNodeUnsafe(addrs[i], 1);
             load.put(addrs[i], (double)i+2);
+            // also make bootstrapping nodes present in gossip
+            Gossiper.instance.initializeNodeUnsafe(bootstrapAddrs[i], 1);
         }
 
         // give every node a bootstrap source.

File: test/unit/org/apache/cassandra/service/LeaveAndBootstrapTest.java
Patch:
@@ -162,9 +162,11 @@ public void testSimultaneousMove() throws UnknownHostException, ConfigurationExc
 
         // boot two new nodes with keyTokens.get(5) and keyTokens.get(7)
         InetAddress boot1 = InetAddress.getByName("127.0.1.1");
+        Gossiper.instance.initializeNodeUnsafe(boot1, 1);
         UUID boot1Id = UUID.randomUUID();
         ss.onChange(boot1, ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(5), boot1Id));
         InetAddress boot2 = InetAddress.getByName("127.0.1.2");
+        Gossiper.instance.initializeNodeUnsafe(boot2, 1);
         ss.onChange(boot2, ApplicationState.STATUS, valueFactory.bootstrapping(keyTokens.get(7), UUID.randomUUID()));
 
         Collection<InetAddress> endpoints = null;

File: src/java/org/apache/cassandra/utils/IntervalTree.java
Patch:
@@ -251,7 +251,7 @@ public IntervalNode(Collection<I> toBisect)
                     allEndpoints.add(interval.min);
                     allEndpoints.add(interval.max);
                 }
-                if (comparator == null)
+                if (comparator != null)
                     Collections.sort(allEndpoints, comparator);
                 else
                     Collections.sort((List<Comparable>)allEndpoints);

File: src/java/org/apache/cassandra/streaming/compress/CompressedFileStreamTask.java
Patch:
@@ -28,7 +28,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.apache.cassandra.gms.Gossiper;
 import org.apache.cassandra.io.compress.CompressionMetadata;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.io.util.RandomAccessReader;
@@ -62,7 +61,7 @@ protected void stream() throws IOException
         byte[] transferBuffer = null;
 
         // write header
-        ByteBuffer headerBuffer = MessagingService.instance().constructStreamHeader(header, false, Gossiper.instance.getVersion(to));
+        ByteBuffer headerBuffer = MessagingService.instance().constructStreamHeader(header, false, MessagingService.instance().getVersion(to));
         socket.getOutputStream().write(ByteBufferUtil.getArray(headerBuffer));
 
         RandomAccessReader file = RandomAccessReader.open(new File(header.file.getFilename()), true);

File: src/java/org/apache/cassandra/db/marshal/AbstractType.java
Patch:
@@ -89,7 +89,7 @@ public int compare(OnDiskAtom c1, OnDiskAtom c2)
                     {
                         RangeTombstone t1 = (RangeTombstone)c1;
                         RangeTombstone t2 = (RangeTombstone)c2;
-                        int comp2 = AbstractType.this.compare(t1.max, t1.max);
+                        int comp2 = AbstractType.this.compare(t1.max, t2.max);
                         if (comp2 == 0)
                             return t1.data.compareTo(t2.data);
                         else

File: src/java/org/apache/cassandra/db/compaction/AbstractCompactionIterable.java
Patch:
@@ -53,7 +53,7 @@ public AbstractCompactionIterable(CompactionController controller, OperationType
 
     public CompactionInfo getCompactionInfo()
     {
-        return new CompactionInfo(this.hashCode(),
+        return new CompactionInfo(controller.cfs.metadata,
                                   type,
                                   bytesRead,
                                   totalBytes);

File: src/java/org/apache/cassandra/db/compaction/CompactionController.java
Patch:
@@ -42,7 +42,7 @@ public class CompactionController
 {
     private static Logger logger = LoggerFactory.getLogger(CompactionController.class);
 
-    private final ColumnFamilyStore cfs;
+    public final ColumnFamilyStore cfs;
     private final boolean deserializeRequired;
     private final IntervalTree<SSTableReader> overlappingTree;
 

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -1204,7 +1204,7 @@ public CompactionInfo getCompactionInfo()
         {
             try
             {
-                return new CompactionInfo(this.hashCode(),
+                return new CompactionInfo(sstable.metadata,
                                           OperationType.CLEANUP,
                                           scanner.getCurrentPosition(),
                                           scanner.getLengthInBytes());
@@ -1230,7 +1230,7 @@ public CompactionInfo getCompactionInfo()
         {
             try
             {
-                return new CompactionInfo(this.hashCode(),
+                return new CompactionInfo(sstable.metadata,
                                           OperationType.SCRUB,
                                           dataFile.getFilePointer(),
                                           dataFile.length());

File: src/java/org/apache/cassandra/db/index/SecondaryIndexBuilder.java
Patch:
@@ -47,7 +47,7 @@ public SecondaryIndexBuilder(ColumnFamilyStore cfs, SortedSet<ByteBuffer> column
 
     public CompactionInfo getCompactionInfo()
     {
-        return new CompactionInfo(this.hashCode(),
+        return new CompactionInfo(cfs.metadata,
                                   OperationType.INDEX_BUILD,
                                   iter.getBytesRead(),
                                   iter.getTotalBytes());

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -575,7 +575,7 @@ public void printColumnFamilyStats(PrintStream outs)
                 outs.println("\t\tWrite Count: " + cfstore.getWriteCount());
                 outs.println("\t\tWrite Latency: " + String.format("%01.3f", cfstore.getRecentWriteLatencyMicros() / 1000) + " ms.");
                 outs.println("\t\tPending Tasks: " + cfstore.getPendingTasks());
-                outs.println("\t\tBloom Filter False Postives: " + cfstore.getBloomFilterFalsePositives());
+                outs.println("\t\tBloom Filter False Positives: " + cfstore.getBloomFilterFalsePositives());
                 outs.println("\t\tBloom Filter False Ratio: " + String.format("%01.5f", cfstore.getRecentBloomFilterFalseRatio()));
                 outs.println("\t\tBloom Filter Space Used: " + cfstore.getBloomFilterDiskSpaceUsed());
                 outs.println("\t\tCompacted row minimum size: " + cfstore.getMinRowSize());

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -224,7 +224,7 @@ private ColumnFamilyStore(Table table,
         data = new DataTracker(this);
         Directories.SSTableLister sstables = directories.sstableLister().skipCompacted(true).skipTemporary(true);
         data.addInitialSSTables(SSTableReader.batchOpen(sstables.list().entrySet(), data, metadata, this.partitioner));
-        if (caching != Caching.NONE || caching != Caching.ROWS_ONLY)
+        if (caching == Caching.ALL || caching == Caching.KEYS_ONLY)
             CacheService.instance.keyCache.loadSaved(this);
 
         // compaction strategy should be created after the CFS has been prepared

File: src/java/org/apache/cassandra/io/sstable/IndexSummary.java
Patch:
@@ -26,6 +26,7 @@
 
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.DecoratedKey;
+import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
@@ -110,7 +111,7 @@ public void serialize(IndexSummary t, DataOutput dos) throws IOException
             }
         }
 
-        public IndexSummary deserialize(DataInput dis) throws IOException
+        public IndexSummary deserialize(DataInput dis, IPartitioner partitioner) throws IOException
         {
             IndexSummary summary = new IndexSummary();
             if (dis.readInt() != DatabaseDescriptor.getIndexInterval())
@@ -121,7 +122,7 @@ public IndexSummary deserialize(DataInput dis) throws IOException
             {
                 long location = dis.readLong();
                 ByteBuffer key = ByteBufferUtil.readWithLength(dis);
-                summary.addEntry(StorageService.getPartitioner().decorateKey(key), location);
+                summary.addEntry(partitioner.decorateKey(key), location);
             }
             return summary;
         }

File: src/java/org/apache/cassandra/io/sstable/SSTableReader.java
Patch:
@@ -401,9 +401,9 @@ public static boolean loadSummary(SSTableReader reader, SegmentedFile.Builder ib
         try
         {
             iStream = new DataInputStream(new FileInputStream(summariesFile));
-            reader.indexSummary = IndexSummary.serializer.deserialize(iStream);
-            reader.first = decodeKey(StorageService.getPartitioner(), reader.descriptor, ByteBufferUtil.readWithLength(iStream));
-            reader.last = decodeKey(StorageService.getPartitioner(), reader.descriptor, ByteBufferUtil.readWithLength(iStream));
+            reader.indexSummary = IndexSummary.serializer.deserialize(iStream, reader.partitioner);
+            reader.first = decodeKey(reader.partitioner, reader.descriptor, ByteBufferUtil.readWithLength(iStream));
+            reader.last = decodeKey(reader.partitioner, reader.descriptor, ByteBufferUtil.readWithLength(iStream));
             ibuilder.deserializeBounds(iStream);
             dbuilder.deserializeBounds(iStream);
         }

File: src/java/org/apache/cassandra/db/compaction/SizeTieredCompactionStrategy.java
Patch:
@@ -53,11 +53,12 @@ public List<AbstractCompactionTask> getBackgroundTasks(final int gcBefore)
         if (cfs.isCompactionDisabled())
         {
             logger.debug("Compaction is currently disabled.");
-            return Collections.<AbstractCompactionTask>emptyList();
+            return Collections.emptyList();
         }
 
         List<AbstractCompactionTask> tasks = new LinkedList<AbstractCompactionTask>();
         List<List<SSTableReader>> buckets = getBuckets(createSSTableAndLengthPairs(cfs.getSSTables()), minSSTableSize);
+        logger.debug("Compaction buckets are {}", buckets);
 
         for (List<SSTableReader> bucket : buckets)
         {

File: src/java/org/apache/cassandra/db/commitlog/CommitLogAllocator.java
Patch:
@@ -273,7 +273,9 @@ private CommitLogSegment internalAddReadySegment(CommitLogSegment segment)
      */
     private boolean isCapExceeded()
     {
-        return size.get() > DatabaseDescriptor.getTotalCommitlogSpaceInMB() * 1024 * 1024;
+        long currentSize = size.get();
+        logger.debug("Total active commitlog segment space used is {}", currentSize);
+        return currentSize > DatabaseDescriptor.getTotalCommitlogSpaceInMB() * 1024 * 1024;
     }
 
     /**

File: src/java/org/apache/cassandra/utils/MerkleTree.java
Patch:
@@ -105,7 +105,7 @@ public MerkleTree deserialize(DataInput dis, int version) throws IOException
 
         public long serializedSize(MerkleTree mt, int version)
         {
-            return TypeSizes.NATIVE.sizeof(mt.hashdepth)
+            return 1 // mt.hashdepth
                  + TypeSizes.NATIVE.sizeof(mt.maxsize)
                  + TypeSizes.NATIVE.sizeof(mt.size)
                  + Hashable.serializer.serializedSize(mt.root, version);

File: src/java/org/apache/cassandra/db/RowPosition.java
Patch:
@@ -103,11 +103,11 @@ public long serializedSize(RowPosition pos, TypeSizes typeSizes)
             if (kind == Kind.ROW_KEY)
             {
                 int keySize = ((DecoratedKey)pos).key.remaining();
-                size += (typeSizes.sizeof((short) keySize) + keySize);
+                size += typeSizes.sizeof((short) keySize) + keySize;
             }
             else
             {
-                Token.serializer.serializedSize(pos.getToken(), typeSizes);
+                size += Token.serializer.serializedSize(pos.getToken(), typeSizes);
             }
             return size;
         }

File: src/java/org/apache/cassandra/db/SliceByNamesReadCommand.java
Patch:
@@ -27,7 +27,6 @@
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.thrift.ColumnParent;
 import org.apache.cassandra.utils.ByteBufferUtil;
-import org.apache.cassandra.utils.FBUtilities;
 
 public class SliceByNamesReadCommand extends ReadCommand
 {
@@ -116,7 +115,7 @@ public long serializedSize(ReadCommand cmd, int version)
         int keySize = command.key.remaining();
 
         size += sizes.sizeof(command.table);
-        size += sizes.sizeof(keySize) + keySize;
+        size += sizes.sizeof((short)keySize) + keySize;
         size += command.queryPath.serializedSize(sizes);
         size += sizes.sizeof(command.columnNames.size());
         if (!command.columnNames.isEmpty())

File: src/java/org/apache/cassandra/streaming/PendingFile.java
Patch:
@@ -146,13 +146,13 @@ public PendingFile deserialize(DataInput dis, int version) throws IOException
         public long serializedSize(PendingFile pf, int version)
         {
             if (pf == null)
-                return TypeSizes.NATIVE.sizeof(0);
+                return TypeSizes.NATIVE.sizeof("");
 
             long size = TypeSizes.NATIVE.sizeof(pf.desc.filenameFor(pf.component));
             size += TypeSizes.NATIVE.sizeof(pf.component);
             size += TypeSizes.NATIVE.sizeof(pf.sections.size());
             for (Pair<Long,Long> section : pf.sections)
-                size += TypeSizes.NATIVE.sizeof(section.left + TypeSizes.NATIVE.sizeof(section.right));
+                size += TypeSizes.NATIVE.sizeof(section.left) + TypeSizes.NATIVE.sizeof(section.right);
             if (version > MessagingService.VERSION_07)
                 size += TypeSizes.NATIVE.sizeof(pf.type.name());
             if (version > MessagingService.VERSION_080)

File: src/java/org/apache/cassandra/io/sstable/SSTableReader.java
Patch:
@@ -505,10 +505,10 @@ private static List<Pair<Integer,Integer>> getSampleIndexesForRanges(List<Decora
         if (samples.isEmpty())
             return positions;
 
-        for (Range<Token> range : Range.<Token>normalize(ranges))
+        for (Range<Token> range : Range.normalize(ranges))
         {
             RowPosition leftPosition = range.left.maxKeyBound();
-            RowPosition rightPosition = range.left.maxKeyBound();
+            RowPosition rightPosition = range.right.maxKeyBound();
 
             int left = Collections.binarySearch(samples, leftPosition);
             if (left < 0)

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -138,9 +138,9 @@ private static void printUsage()
         StringBuilder header = new StringBuilder();
         header.append("\nAvailable commands:\n");
         // No args
-        addCmdHelp(header, "ring", "Print informations on the token ring");
+        addCmdHelp(header, "ring", "Print information about the token ring");
         addCmdHelp(header, "join", "Join the ring");
-        addCmdHelp(header, "info", "Print node informations (uptime, load, ...)");
+        addCmdHelp(header, "info", "Print node information (uptime, load, ...)");
         addCmdHelp(header, "cfstats", "Print statistics on column families");
         addCmdHelp(header, "version", "Print cassandra version");
         addCmdHelp(header, "tpstats", "Print usage statistics of thread pools");

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -136,9 +136,9 @@ private static void printUsage()
         StringBuilder header = new StringBuilder();
         header.append("\nAvailable commands:\n");
         // No args
-        addCmdHelp(header, "ring", "Print informations on the token ring");
+        addCmdHelp(header, "ring", "Print information about the token ring");
         addCmdHelp(header, "join", "Join the ring");
-        addCmdHelp(header, "info", "Print node informations (uptime, load, ...)");
+        addCmdHelp(header, "info", "Print node information (uptime, load, ...)");
         addCmdHelp(header, "cfstats", "Print statistics on column families");
         addCmdHelp(header, "ids", "Print list of unique host IDs");
         addCmdHelp(header, "version", "Print cassandra version");

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1844,7 +1844,7 @@ public void setMaximumCompactionThreshold(int maxCompactionThreshold)
         this.maxCompactionThreshold.set(maxCompactionThreshold);
     }
 
-    public boolean giisCompactionDisabled()
+    public boolean isCompactionDisabled()
     {
         return getMinimumCompactionThreshold() <= 0 || getMaximumCompactionThreshold() <= 0;
     }

File: src/java/org/apache/cassandra/utils/FBUtilities.java
Patch:
@@ -221,7 +221,7 @@ public static byte[] hash(ByteBuffer... data)
         for (ByteBuffer block : data)
         {
             if (block.hasArray())
-                messageDigest.update(block.array(), block.position(), block.remaining());
+                messageDigest.update(block.array(), block.arrayOffset() + block.position(), block.remaining());
             else
                 messageDigest.update(block.duplicate());
         }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1455,8 +1455,8 @@ public void snapshotWithoutFlush(String snapshotName)
                                      " created in " + snapshotDirectory);
                 }
 
-                if (compactionStrategy instanceof LeveledCompactionStrategy)
-                    directories.snapshotLeveledManifest(snapshotName);
+                if (cfs.compactionStrategy instanceof LeveledCompactionStrategy)
+                    cfs.directories.snapshotLeveledManifest(snapshotName);
             }
             catch (IOException e)
             {

File: src/java/org/apache/cassandra/config/Schema.java
Patch:
@@ -454,7 +454,7 @@ public void updateVersion()
 
             for (Row row : SystemTable.serializedSchema())
             {
-                if (row.cf == null || row.cf.isMarkedForDelete() || row.cf.isEmpty())
+                if (row.cf == null || (row.cf.isMarkedForDelete() && row.cf.isEmpty()))
                     continue;
 
                 row.cf.updateDigest(versionDigest);

File: src/java/org/apache/cassandra/db/DefsTable.java
Patch:
@@ -152,7 +152,7 @@ public static Collection<KSMetaData> loadFromTable() throws IOException
 
         for (Row row : serializedSchema)
         {
-            if (row.cf == null || row.cf.isEmpty() || row.cf.isMarkedForDelete())
+            if (row.cf == null || (row.cf.isMarkedForDelete() && row.cf.isEmpty()))
                 continue;
 
             keyspaces.add(KSMetaData.fromSchema(row, serializedColumnFamilies(row.key)));

File: src/java/org/apache/cassandra/db/ColumnFamily.java
Patch:
@@ -250,12 +250,12 @@ public ColumnFamily diff(ColumnFamily cfComposite)
     }
 
     /** the size of user-provided data, not including internal overhead */
-    int dataSize(TypeSizes typeSizes)
+    int dataSize()
     {
-        int size = TypeSizes.NATIVE.sizeof(1L) + TypeSizes.NATIVE.sizeof(1); // tombstone tracking
+        int size = TypeSizes.NATIVE.sizeof(getMarkedForDeleteAt());
         for (IColumn column : columns)
         {
-            size += column.dataSize(typeSizes);
+            size += column.dataSize();
         }
         return size;
     }

File: src/java/org/apache/cassandra/db/IColumn.java
Patch:
@@ -42,7 +42,8 @@ public interface IColumn
     public long mostRecentLiveChangeAt();
     public long mostRecentNonGCableChangeAt(int gcbefore);
     public ByteBuffer name();
-    public int dataSize(TypeSizes typeSizes);
+    /** the size of user-provided data, not including internal overhead */
+    public int dataSize();
     public int serializedSize(TypeSizes typeSizes);
     public int serializationFlags();
     public long timestamp();

File: src/java/org/apache/cassandra/db/CounterMutation.java
Patch:
@@ -34,7 +34,6 @@
 import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.thrift.ConsistencyLevel;
 import org.apache.cassandra.utils.ByteBufferUtil;
-import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.HeapAllocator;
 
 public class CounterMutation implements IMutation
@@ -182,8 +181,7 @@ public CounterMutation deserialize(DataInput dis, int version) throws IOExceptio
 
     public long serializedSize(CounterMutation cm, int version)
     {
-        int tableSize = FBUtilities.encodedUTF8Length(cm.consistency().name());
         return RowMutation.serializer.serializedSize(cm.rowMutation(), version)
-             + TypeSizes.NATIVE.sizeof((short) tableSize) + tableSize;
+             + TypeSizes.NATIVE.sizeof(cm.consistency().name());
     }
 }

File: src/java/org/apache/cassandra/dht/BootStrapper.java
Patch:
@@ -32,6 +32,7 @@
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.Schema;
 import org.apache.cassandra.db.Table;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.gms.FailureDetector;
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.locator.AbstractReplicationStrategy;
@@ -42,8 +43,6 @@
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.SimpleCondition;
 
-import static org.apache.cassandra.utils.FBUtilities.serializedUTF8Size;
-
 public class BootStrapper
 {
     private static final Logger logger = LoggerFactory.getLogger(BootStrapper.class);
@@ -230,7 +229,7 @@ public String deserialize(DataInput in, int version) throws IOException
 
         public long serializedSize(String s, int version)
         {
-            return serializedUTF8Size(s);
+            return TypeSizes.NATIVE.sizeof(s);
         }
     }
 }

File: src/java/org/apache/cassandra/gms/GossipDigestSyn.java
Patch:
@@ -23,7 +23,6 @@
 
 import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.io.IVersionedSerializer;
-import org.apache.cassandra.utils.FBUtilities;
 
 /**
  * This is the first message that gets sent out as a start of the Gossip protocol in a
@@ -92,7 +91,7 @@ public GossipDigestSyn deserialize(DataInput dis, int version) throws IOExceptio
 
     public long serializedSize(GossipDigestSyn syn, int version)
     {
-        return FBUtilities.serializedUTF8Size(syn.clusterId) + GossipDigestSerializationHelper.serializedSize(syn.gDigests, version);
+        return TypeSizes.NATIVE.sizeof(syn.clusterId) + GossipDigestSerializationHelper.serializedSize(syn.gDigests, version);
     }
 }
 

File: src/java/org/apache/cassandra/gms/VersionedValue.java
Patch:
@@ -235,8 +235,7 @@ public VersionedValue deserialize(DataInput dis, int version) throws IOException
 
         public long serializedSize(VersionedValue value, int version)
         {
-            int outLength = FBUtilities.encodedUTF8Length(outValue(value, version));
-            return TypeSizes.NATIVE.sizeof(outLength) + outLength + TypeSizes.NATIVE.sizeof(value.version);
+            return TypeSizes.NATIVE.sizeof(outValue(value, version)) + TypeSizes.NATIVE.sizeof(value.version);
         }
     }
 }

File: src/java/org/apache/cassandra/streaming/StreamHeader.java
Patch:
@@ -102,7 +102,7 @@ public StreamHeader deserialize(DataInput dis, int version) throws IOException
 
         public long serializedSize(StreamHeader sh, int version)
         {
-            long size = FBUtilities.serializedUTF8Size(sh.table);
+            long size = TypeSizes.NATIVE.sizeof(sh.table);
             size += TypeSizes.NATIVE.sizeof(sh.sessionId);
             size += PendingFile.serializer.serializedSize(sh.file, version);
             size += TypeSizes.NATIVE.sizeof(sh.pendingFiles.size());

File: src/java/org/apache/cassandra/streaming/StreamReply.java
Patch:
@@ -25,7 +25,6 @@
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.net.MessageOut;
 import org.apache.cassandra.net.MessagingService;
-import org.apache.cassandra.utils.FBUtilities;
 
 public class StreamReply
 {
@@ -84,7 +83,7 @@ public StreamReply deserialize(DataInput dis, int version) throws IOException
 
         public long serializedSize(StreamReply reply, int version)
         {
-            return TypeSizes.NATIVE.sizeof(reply.sessionId) + FBUtilities.serializedUTF8Size(reply.file) + TypeSizes.NATIVE.sizeof(reply.action.ordinal());
+            return TypeSizes.NATIVE.sizeof(reply.sessionId) + TypeSizes.NATIVE.sizeof(reply.file) + TypeSizes.NATIVE.sizeof(reply.action.ordinal());
         }
     }
 }

File: src/java/org/apache/cassandra/streaming/StreamRequest.java
Patch:
@@ -37,7 +37,6 @@
 import org.apache.cassandra.net.CompactEndpointSerializationHelper;
 import org.apache.cassandra.net.MessageOut;
 import org.apache.cassandra.net.MessagingService;
-import org.apache.cassandra.utils.FBUtilities;
 
 /**
 * This class encapsulates the message that needs to be sent to nodes
@@ -186,12 +185,12 @@ public long serializedSize(StreamRequest sr, int version)
             if (sr.file != null)
                 return size + PendingFile.serializer.serializedSize(sr.file, version);
 
-            size += FBUtilities.serializedUTF8Size(sr.table);
+            size += TypeSizes.NATIVE.sizeof(sr.table);
             size += TypeSizes.NATIVE.sizeof(sr.ranges.size());
             for (Range<Token> range : sr.ranges)
                 size += AbstractBounds.serializer.serializedSize(range, version);
             if (version > MessagingService.VERSION_07)
-                size += FBUtilities.serializedUTF8Size(sr.type.name());
+                size += TypeSizes.NATIVE.sizeof(sr.type.name());
             if (version > MessagingService.VERSION_080)
             {
                 size += TypeSizes.NATIVE.sizeof(Iterables.size(sr.columnFamilies));

File: src/java/org/apache/cassandra/streaming/StreamingRepairTask.java
Patch:
@@ -265,8 +265,8 @@ public long serializedSize(StreamingRepairTask task, int version)
         {
             long size = UUIDGen.serializer.serializedSize(task.id, version);
             size += 3 * CompactEndpointSerializationHelper.serializedSize(task.owner);
-            size += FBUtilities.serializedUTF8Size(task.tableName);
-            size += FBUtilities.serializedUTF8Size(task.cfName);
+            size += TypeSizes.NATIVE.sizeof(task.tableName);
+            size += TypeSizes.NATIVE.sizeof(task.cfName);
             size += TypeSizes.NATIVE.sizeof(task.ranges.size());
             for (Range<Token> range : task.ranges)
                 size += AbstractBounds.serializer.serializedSize(range, version);

File: src/java/org/apache/cassandra/cache/KeyCacheKey.java
Patch:
@@ -23,7 +23,7 @@
 import java.nio.charset.CharacterCodingException;
 import java.util.Arrays;
 
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.io.sstable.Descriptor;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.Pair;
@@ -52,7 +52,7 @@ public Pair<String, String> getPathInfo()
 
     public int serializedSize()
     {
-        return DBTypeSizes.NATIVE.sizeof(key.length) + key.length;
+        return TypeSizes.NATIVE.sizeof(key.length) + key.length;
     }
 
     public String toString()

File: src/java/org/apache/cassandra/cache/RowCacheKey.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.Arrays;
 
 import org.apache.cassandra.config.Schema;
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
@@ -58,7 +58,7 @@ public Pair<String, String> getPathInfo()
 
     public int serializedSize()
     {
-        return key.length + DBTypeSizes.NATIVE.sizeof(key.length);
+        return key.length + TypeSizes.NATIVE.sizeof(key.length);
     }
 
     @Override

File: src/java/org/apache/cassandra/cache/SerializingCache.java
Patch:
@@ -26,7 +26,7 @@
 import com.googlecode.concurrentlinkedhashmap.Weigher;
 import com.googlecode.concurrentlinkedhashmap.Weighers;
 
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.io.ISerializer;
 import org.apache.cassandra.io.util.MemoryInputStream;
 import org.apache.cassandra.io.util.MemoryOutputStream;
@@ -42,7 +42,7 @@
 public class SerializingCache<K, V> implements ICache<K, V>
 {
     private static final Logger logger = LoggerFactory.getLogger(SerializingCache.class);
-    private static final DBTypeSizes ENCODED_TYPE_SIZES = DBTypeSizes.VINT;
+    private static final TypeSizes ENCODED_TYPE_SIZES = TypeSizes.VINT;
 
     private static final int DEFAULT_CONCURENCY_LEVEL = 64;
 

File: src/java/org/apache/cassandra/cache/SerializingCacheProvider.java
Patch:
@@ -23,7 +23,7 @@
 import java.io.IOException;
 
 import org.apache.cassandra.db.ColumnFamily;
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.io.ISerializer;
 
 public class SerializingCacheProvider implements IRowCacheProvider
@@ -60,7 +60,7 @@ public IRowCacheEntry deserialize(DataInput in) throws IOException
             return ColumnFamily.serializer.deserialize(in);
         }
 
-        public long serializedSize(IRowCacheEntry cf, DBTypeSizes typeSizes)
+        public long serializedSize(IRowCacheEntry cf, TypeSizes typeSizes)
         {
             int size = typeSizes.sizeof(true);
             if (cf instanceof RowCacheSentinel)

File: src/java/org/apache/cassandra/db/Column.java
Patch:
@@ -124,7 +124,7 @@ public long mostRecentNonGCableChangeAt(int gcbefore)
         return timestamp;
     }
 
-    public int size(DBTypeSizes typeSizes)
+    public int size(TypeSizes typeSizes)
     {
         /*
          * Size of a column is =
@@ -143,7 +143,7 @@ public int size(DBTypeSizes typeSizes)
      * This returns the size of the column when serialized.
      * @see com.facebook.infrastructure.db.IColumn#serializedSize()
     */
-    public int serializedSize(DBTypeSizes typeSizes)
+    public int serializedSize(TypeSizes typeSizes)
     {
         return size(typeSizes);
     }

File: src/java/org/apache/cassandra/db/ColumnFamily.java
Patch:
@@ -249,9 +249,9 @@ public ColumnFamily diff(ColumnFamily cfComposite)
         return null;
     }
 
-    int size(DBTypeSizes typeSizes)
+    int size(TypeSizes typeSizes)
     {
-        int size = DBTypeSizes.NATIVE.sizeof(1L) + DBTypeSizes.NATIVE.sizeof(1); // tombstone tracking
+        int size = TypeSizes.NATIVE.sizeof(1L) + TypeSizes.NATIVE.sizeof(1); // tombstone tracking
         for (IColumn column : columns)
         {
             size += column.size(typeSizes);

File: src/java/org/apache/cassandra/db/ColumnFamilySerializer.java
Patch:
@@ -139,7 +139,7 @@ public ColumnFamily deserializeFromSSTableNoColumns(ColumnFamily cf, DataInput i
         return cf;
     }
 
-    public long serializedSize(ColumnFamily cf, DBTypeSizes type)
+    public long serializedSize(ColumnFamily cf, TypeSizes type)
     {
         if (cf == null)
         {
@@ -153,7 +153,7 @@ public long serializedSize(ColumnFamily cf, DBTypeSizes type)
         }
     }
 
-    public long serializedSizeForSSTable(ColumnFamily cf, DBTypeSizes typeSizes)
+    public long serializedSizeForSSTable(ColumnFamily cf, TypeSizes typeSizes)
     {
         int size = typeSizes.sizeof(cf.getLocalDeletionTime()) // local deletion time
                  + typeSizes.sizeof(cf.getMarkedForDeleteAt()) // client deletion time

File: src/java/org/apache/cassandra/db/ColumnIndex.java
Patch:
@@ -73,7 +73,7 @@ public Builder(Comparator<ByteBuffer> comparator, ByteBuffer key, int estimatedC
          */
         private static long rowHeaderSize(ByteBuffer key)
         {
-            DBTypeSizes typeSizes = DBTypeSizes.NATIVE;
+            TypeSizes typeSizes = TypeSizes.NATIVE;
             // TODO fix constantSize when changing the nativeconststs.
             int keysize = key.remaining();
             return typeSizes.sizeof((short) keysize) + keysize + // Row key
@@ -113,7 +113,7 @@ public void add(IColumn column)
                 startPosition = endPosition;
             }
 
-            endPosition += column.serializedSize(DBTypeSizes.NATIVE);
+            endPosition += column.serializedSize(TypeSizes.NATIVE);
 
             // if we hit the column index size that we have to index after, go ahead and index it.
             if (endPosition - startPosition >= DatabaseDescriptor.getColumnIndexSize())

File: src/java/org/apache/cassandra/db/ColumnSerializer.java
Patch:
@@ -121,7 +121,7 @@ else if ((b & EXPIRATION_MASK) != 0)
         }
     }
 
-    public long serializedSize(IColumn object, DBTypeSizes type)
+    public long serializedSize(IColumn object, TypeSizes type)
     {
         return object.serializedSize(type);
     }

File: src/java/org/apache/cassandra/db/CounterColumn.java
Patch:
@@ -93,7 +93,7 @@ public long total()
     }
 
     @Override
-    public int size(DBTypeSizes typeSizes)
+    public int size(TypeSizes typeSizes)
     {
         /*
          * A counter column adds to a Column :

File: src/java/org/apache/cassandra/db/CounterMutation.java
Patch:
@@ -184,6 +184,6 @@ public long serializedSize(CounterMutation cm, int version)
     {
         int tableSize = FBUtilities.encodedUTF8Length(cm.consistency().name());
         return RowMutation.serializer.serializedSize(cm.rowMutation(), version)
-             + DBTypeSizes.NATIVE.sizeof((short) tableSize) + tableSize;
+             + TypeSizes.NATIVE.sizeof((short) tableSize) + tableSize;
     }
 }

File: src/java/org/apache/cassandra/db/ExpiringColumn.java
Patch:
@@ -74,7 +74,7 @@ public int getTimeToLive()
     }
 
     @Override
-    public int size(DBTypeSizes typeSizes)
+    public int size(TypeSizes typeSizes)
     {
         /*
          * An expired column adds to a Column :

File: src/java/org/apache/cassandra/db/IColumn.java
Patch:
@@ -42,8 +42,8 @@ public interface IColumn
     public long mostRecentLiveChangeAt();
     public long mostRecentNonGCableChangeAt(int gcbefore);
     public ByteBuffer name();
-    public int size(DBTypeSizes typeSizes);
-    public int serializedSize(DBTypeSizes typeSizes);
+    public int size(TypeSizes typeSizes);
+    public int serializedSize(TypeSizes typeSizes);
     public int serializationFlags();
     public long timestamp();
     public ByteBuffer value();

File: src/java/org/apache/cassandra/db/Memtable.java
Patch:
@@ -225,7 +225,7 @@ public void run()
 
     private void resolve(DecoratedKey key, ColumnFamily cf)
     {
-        currentThroughput.addAndGet(cf.size(DBTypeSizes.NATIVE));
+        currentThroughput.addAndGet(cf.size(TypeSizes.NATIVE));
         currentOperations.addAndGet((cf.getColumnCount() == 0)
                                     ? cf.isMarkedForDelete() ? 1 : 0
                                     : cf.getColumnCount());

File: src/java/org/apache/cassandra/db/RangeSliceReply.java
Patch:
@@ -80,7 +80,7 @@ public RangeSliceReply deserialize(DataInput in, int version) throws IOException
 
         public long serializedSize(RangeSliceReply rsr, int version)
         {
-            int size = DBTypeSizes.NATIVE.sizeof(rsr.rows.size());
+            int size = TypeSizes.NATIVE.sizeof(rsr.rows.size());
             for (Row row : rsr.rows)
                 size += Row.serializer.serializedSize(row, version);
             return size;

File: src/java/org/apache/cassandra/db/ReadResponse.java
Patch:
@@ -102,7 +102,7 @@ public ReadResponse deserialize(DataInput dis, int version) throws IOException
 
     public long serializedSize(ReadResponse response, int version)
     {
-        DBTypeSizes typeSizes = DBTypeSizes.NATIVE;
+        TypeSizes typeSizes = TypeSizes.NATIVE;
         ByteBuffer buffer = response.isDigestQuery() ? response.digest() : ByteBufferUtil.EMPTY_BYTE_BUFFER;
         int size = typeSizes.sizeof(buffer.remaining());
         size += typeSizes.sizeof(response.isDigestQuery());

File: src/java/org/apache/cassandra/db/Row.java
Patch:
@@ -75,7 +75,7 @@ public Row deserialize(DataInput dis, int version) throws IOException
         public long serializedSize(Row row, int version)
         {
             int keySize = row.key.key.remaining();
-            return DBTypeSizes.NATIVE.sizeof((short) keySize) + keySize + ColumnFamily.serializer.serializedSize(row.cf, DBTypeSizes.NATIVE);
+            return TypeSizes.NATIVE.sizeof((short) keySize) + keySize + ColumnFamily.serializer.serializedSize(row.cf, TypeSizes.NATIVE);
         }
     }
 }

File: src/java/org/apache/cassandra/db/RowIndexEntry.java
Patch:
@@ -183,7 +183,7 @@ public Filter bloomFilter()
 
         public int serializedSize()
         {
-            DBTypeSizes typeSizes = DBTypeSizes.NATIVE;
+            TypeSizes typeSizes = TypeSizes.NATIVE;
             int size = typeSizes.sizeof(deletionInfo.localDeletionTime) + typeSizes.sizeof(deletionInfo.markedForDeleteAt); // deletion info
             size += typeSizes.sizeof(columnsIndex.size()); // number of entries
             for (IndexHelper.IndexInfo info : columnsIndex)

File: src/java/org/apache/cassandra/db/RowMutation.java
Patch:
@@ -440,7 +440,7 @@ public RowMutation deserialize(DataInput dis, int version) throws IOException
 
         public long serializedSize(RowMutation rm, int version)
         {
-            DBTypeSizes typeSizes = DBTypeSizes.NATIVE;
+            TypeSizes typeSizes = TypeSizes.NATIVE;
             int tableSize = FBUtilities.encodedUTF8Length(rm.getTable());
             int keySize = rm.key().remaining();
             int size = typeSizes.sizeof((short) tableSize) + tableSize;
@@ -450,7 +450,7 @@ public long serializedSize(RowMutation rm, int version)
             for (Map.Entry<Integer,ColumnFamily> entry : rm.modifications.entrySet())
             {
                 size += typeSizes.sizeof(entry.getKey());
-                size += ColumnFamily.serializer.serializedSize(entry.getValue(), DBTypeSizes.NATIVE);
+                size += ColumnFamily.serializer.serializedSize(entry.getValue(), TypeSizes.NATIVE);
             }
 
             return size;

File: src/java/org/apache/cassandra/db/RowPosition.java
Patch:
@@ -96,7 +96,7 @@ public RowPosition deserialize(DataInput dis) throws IOException
             }
         }
 
-        public long serializedSize(RowPosition pos, DBTypeSizes typeSizes)
+        public long serializedSize(RowPosition pos, TypeSizes typeSizes)
         {
             Kind kind = pos.kind();
             int size = 1; // 1 byte for enum

File: src/java/org/apache/cassandra/db/SliceByNamesReadCommand.java
Patch:
@@ -110,7 +110,7 @@ public SliceByNamesReadCommand deserialize(DataInput dis, int version) throws IO
 
     public long serializedSize(ReadCommand cmd, int version)
     {
-        DBTypeSizes typeSizes = DBTypeSizes.NATIVE;
+        TypeSizes typeSizes = TypeSizes.NATIVE;
         SliceByNamesReadCommand command = (SliceByNamesReadCommand) cmd;
         int size = typeSizes.sizeof(command.isDigestQuery());
         int tableSize = FBUtilities.encodedUTF8Length(command.table);

File: src/java/org/apache/cassandra/db/SliceFromReadCommand.java
Patch:
@@ -184,7 +184,7 @@ public ReadCommand deserialize(DataInput dis, int version) throws IOException
 
     public long serializedSize(ReadCommand cmd, int version)
     {
-        DBTypeSizes typeSizes = DBTypeSizes.NATIVE;
+        TypeSizes typeSizes = TypeSizes.NATIVE;
         SliceFromReadCommand command = (SliceFromReadCommand) cmd;
         int tableSize = FBUtilities.encodedUTF8Length(command.table);
         int keySize = command.key.remaining();

File: src/java/org/apache/cassandra/db/SuperColumn.java
Patch:
@@ -102,7 +102,7 @@ public IColumn getSubColumn(ByteBuffer columnName)
     /**
      * This calculates the exact size of the sub columns on the fly
      */
-    public int size(DBTypeSizes typeSizes)
+    public int size(TypeSizes typeSizes)
     {
         int size = 0;
         for (IColumn subColumn : getSubColumns())
@@ -116,7 +116,7 @@ public int size(DBTypeSizes typeSizes)
      * This returns the size of the super-column when serialized.
      * @see org.apache.cassandra.db.IColumn#serializedSize()
     */
-    public int serializedSize(DBTypeSizes typeSizes)
+    public int serializedSize(TypeSizes typeSizes)
     {
         /*
          * We need to keep the way we are calculating the column size in sync with the
@@ -412,7 +412,7 @@ public IColumn deserialize(DataInput dis, IColumnSerializer.Flag flag, int expir
         return superColumn;
     }
 
-    public long serializedSize(IColumn object, DBTypeSizes typeSizes)
+    public long serializedSize(IColumn object, TypeSizes typeSizes)
     {
         return object.serializedSize(typeSizes);
     }

File: src/java/org/apache/cassandra/db/TruncateResponse.java
Patch:
@@ -72,7 +72,7 @@ public long serializedSize(TruncateResponse tr, int version)
         {
             return serializedUTF8Size(tr.keyspace)
                  + serializedUTF8Size(tr.columnFamily)
-                 + DBTypeSizes.NATIVE.sizeof(tr.success);
+                 + TypeSizes.NATIVE.sizeof(tr.success);
         }
     }
 }

File: src/java/org/apache/cassandra/db/WriteResponse.java
Patch:
@@ -88,7 +88,7 @@ public WriteResponse deserialize(DataInput dis, int version) throws IOException
 
         public long serializedSize(WriteResponse response, int version)
         {
-            DBTypeSizes typeSizes = DBTypeSizes.NATIVE;
+            TypeSizes typeSizes = TypeSizes.NATIVE;
             int utfSize = FBUtilities.encodedUTF8Length(response.table());
             int keySize = response.key().remaining();
             int size = typeSizes.sizeof((short) utfSize) + utfSize;

File: src/java/org/apache/cassandra/db/commitlog/ReplayPosition.java
Patch:
@@ -26,7 +26,7 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Ordering;
 
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.io.ISerializer;
 import org.apache.cassandra.io.sstable.SSTableReader;
 
@@ -130,7 +130,7 @@ public ReplayPosition deserialize(DataInput dis) throws IOException
             return new ReplayPosition(dis.readLong(), dis.readInt());
         }
 
-        public long serializedSize(ReplayPosition object, DBTypeSizes typeSizes)
+        public long serializedSize(ReplayPosition object, TypeSizes typeSizes)
         {
             throw new UnsupportedOperationException();
         }

File: src/java/org/apache/cassandra/db/compaction/LazilyCompactedRow.java
Patch:
@@ -238,7 +238,7 @@ protected IColumn getReduced()
             IColumn reduced = purged.iterator().next();
             container.clear();
 
-            serializedSize += reduced.serializedSize(DBTypeSizes.NATIVE);
+            serializedSize += reduced.serializedSize(TypeSizes.NATIVE);
             columns++;
             maxTimestampSeen = Math.max(maxTimestampSeen, reduced.maxTimestamp());
             int deletionTime = reduced.getLocalDeletionTime();

File: src/java/org/apache/cassandra/db/filter/QueryPath.java
Patch:
@@ -20,7 +20,7 @@
 import java.io.*;
 import java.nio.ByteBuffer;
 
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.thrift.ColumnParent;
 import org.apache.cassandra.thrift.ColumnPath;
 import org.apache.cassandra.utils.ByteBufferUtil;
@@ -94,7 +94,7 @@ public static QueryPath deserialize(DataInput din) throws IOException
                              cName.remaining() == 0 ? null : cName);
     }
 
-    public int serializedSize(DBTypeSizes typeSizes)
+    public int serializedSize(TypeSizes typeSizes)
     {
         int size = 0;
 

File: src/java/org/apache/cassandra/dht/Token.java
Patch:
@@ -24,7 +24,7 @@
 import java.nio.ByteBuffer;
 
 import org.apache.cassandra.config.ConfigurationException;
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.db.RowPosition;
 import org.apache.cassandra.io.ISerializer;
 import org.apache.cassandra.service.StorageService;
@@ -99,11 +99,11 @@ public Token deserialize(DataInput dis) throws IOException
             return p.getTokenFactory().fromByteArray(ByteBuffer.wrap(bytes));
         }
 
-        public long serializedSize(Token object, DBTypeSizes typeSizes)
+        public long serializedSize(Token object, TypeSizes typeSizes)
         {
             IPartitioner p = StorageService.getPartitioner();
             ByteBuffer b = p.getTokenFactory().toByteArray(object);
-            return DBTypeSizes.NATIVE.sizeof(b.remaining()) + b.remaining();
+            return TypeSizes.NATIVE.sizeof(b.remaining()) + b.remaining();
         }
     }
 

File: src/java/org/apache/cassandra/gms/EndpointState.java
Patch:
@@ -23,7 +23,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.cliffc.high_scale_lib.NonBlockingHashMap;
 
@@ -149,11 +149,11 @@ public EndpointState deserialize(DataInput dis, int version) throws IOException
     public long serializedSize(EndpointState epState, int version)
     {
         long size = HeartBeatState.serializer.serializedSize(epState.getHeartBeatState(), version);
-        size += DBTypeSizes.NATIVE.sizeof(epState.applicationState.size());
+        size += TypeSizes.NATIVE.sizeof(epState.applicationState.size());
         for (Map.Entry<ApplicationState, VersionedValue> entry : epState.applicationState.entrySet())
         {
             VersionedValue value = entry.getValue();
-            size += DBTypeSizes.NATIVE.sizeof(entry.getKey().ordinal());
+            size += TypeSizes.NATIVE.sizeof(entry.getKey().ordinal());
             size += VersionedValue.serializer.serializedSize(value, version);
         }
         return size;

File: src/java/org/apache/cassandra/gms/GossipDigestAck.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.List;
 import java.util.Map;
 
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.net.CompactEndpointSerializationHelper;
 import org.apache.cassandra.net.MessagingService;
@@ -95,8 +95,8 @@ public long serializedSize(GossipDigestAck ack, int version)
     {
         int size = GossipDigestSerializationHelper.serializedSize(ack.gDigestList, version);
         if (version <= MessagingService.VERSION_11)
-            size += DBTypeSizes.NATIVE.sizeof(true);
-        size += DBTypeSizes.NATIVE.sizeof(ack.epStateMap.size());
+            size += TypeSizes.NATIVE.sizeof(true);
+        size += TypeSizes.NATIVE.sizeof(ack.epStateMap.size());
         for (Map.Entry<InetAddress, EndpointState> entry : ack.epStateMap.entrySet())
             size += CompactEndpointSerializationHelper.serializedSize(entry.getKey())
                   + EndpointState.serializer.serializedSize(entry.getValue(), version);

File: src/java/org/apache/cassandra/gms/GossipDigestAck2.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.net.CompactEndpointSerializationHelper;
 
@@ -76,7 +76,7 @@ public GossipDigestAck2 deserialize(DataInput dis, int version) throws IOExcepti
 
     public long serializedSize(GossipDigestAck2 ack2, int version)
     {
-        long size = DBTypeSizes.NATIVE.sizeof(ack2.epStateMap.size());
+        long size = TypeSizes.NATIVE.sizeof(ack2.epStateMap.size());
         for (Map.Entry<InetAddress, EndpointState> entry : ack2.epStateMap.entrySet())
             size += CompactEndpointSerializationHelper.serializedSize(entry.getKey())
                   + EndpointState.serializer.serializedSize(entry.getValue(), version);

File: src/java/org/apache/cassandra/gms/GossipDigestSyn.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.utils.FBUtilities;
 
@@ -68,7 +68,7 @@ static List<GossipDigest> deserialize(DataInput dis, int version) throws IOExcep
     
     static int serializedSize(List<GossipDigest> digests, int version)
     {
-        int size = DBTypeSizes.NATIVE.sizeof(digests.size());
+        int size = TypeSizes.NATIVE.sizeof(digests.size());
         for (GossipDigest digest : digests)
             size += GossipDigest.serializer.serializedSize(digest, version);
         return size;

File: src/java/org/apache/cassandra/gms/HeartBeatState.java
Patch:
@@ -19,7 +19,7 @@
 
 import java.io.*;
 
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.io.IVersionedSerializer;
 
 /**
@@ -79,6 +79,6 @@ public HeartBeatState deserialize(DataInput dis, int version) throws IOException
 
     public long serializedSize(HeartBeatState state, int version)
     {
-        return DBTypeSizes.NATIVE.sizeof(state.getGeneration()) + DBTypeSizes.NATIVE.sizeof(state.getHeartBeatVersion());
+        return TypeSizes.NATIVE.sizeof(state.getGeneration()) + TypeSizes.NATIVE.sizeof(state.getHeartBeatVersion());
     }
 }

File: src/java/org/apache/cassandra/gms/VersionedValue.java
Patch:
@@ -21,7 +21,7 @@
 import java.net.InetAddress;
 import java.util.UUID;
 
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.io.IVersionedSerializer;
@@ -236,7 +236,7 @@ public VersionedValue deserialize(DataInput dis, int version) throws IOException
         public long serializedSize(VersionedValue value, int version)
         {
             int outLength = FBUtilities.encodedUTF8Length(outValue(value, version));
-            return DBTypeSizes.NATIVE.sizeof(outLength) + outLength + DBTypeSizes.NATIVE.sizeof(value.version);
+            return TypeSizes.NATIVE.sizeof(outLength) + outLength + TypeSizes.NATIVE.sizeof(value.version);
         }
     }
 }

File: src/java/org/apache/cassandra/io/ISerializer.java
Patch:
@@ -21,7 +21,7 @@
 import java.io.DataOutput;
 import java.io.IOException;
 
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 
 public interface ISerializer<T>
 {
@@ -41,5 +41,5 @@ public interface ISerializer<T>
      */
     public T deserialize(DataInput dis) throws IOException;
 
-    public long serializedSize(T t, DBTypeSizes type);
+    public long serializedSize(T t, TypeSizes type);
 }

File: src/java/org/apache/cassandra/io/sstable/IndexHelper.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.Comparator;
 import java.util.List;
 
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.io.util.FileDataInput;
 import org.apache.cassandra.io.util.FileMark;
@@ -200,7 +200,7 @@ public void serialize(DataOutput dos) throws IOException
             dos.writeLong(width);
         }
 
-        public int serializedSize(DBTypeSizes typeSizes)
+        public int serializedSize(TypeSizes typeSizes)
         {
             int firstNameSize = firstName.remaining();
             int lastNameSize = lastName.remaining();

File: src/java/org/apache/cassandra/io/sstable/SSTableSimpleUnsortedWriter.java
Patch:
@@ -88,7 +88,7 @@ public SSTableSimpleUnsortedWriter(File directory,
 
     protected void writeRow(DecoratedKey key, ColumnFamily columnFamily) throws IOException
     {
-        currentSize += key.key.remaining() + ColumnFamily.serializer.serializedSize(columnFamily, DBTypeSizes.NATIVE) * 1.2;
+        currentSize += key.key.remaining() + ColumnFamily.serializer.serializedSize(columnFamily, TypeSizes.NATIVE) * 1.2;
 
         if (currentSize > bufferSize)
             sync();
@@ -107,7 +107,7 @@ protected ColumnFamily getColumnFamily()
         {
             // We will reuse a CF that we have counted already. But because it will be easier to add the full size
             // of the CF in the next writeRow call than to find out the delta, we just remove the size until that next call
-            currentSize -= currentKey.key.remaining() + ColumnFamily.serializer.serializedSize(previous, DBTypeSizes.NATIVE) * 1.2;
+            currentSize -= currentKey.key.remaining() + ColumnFamily.serializer.serializedSize(previous, TypeSizes.NATIVE) * 1.2;
         }
         return previous;
     }

File: src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
Patch:
@@ -48,7 +48,7 @@ public class SSTableWriter extends SSTable
     private DecoratedKey lastWrittenKey;
     private FileMark dataMark;
     private final SSTableMetadata.Collector sstableMetadataCollector;
-    private final DBTypeSizes typeSizes = DBTypeSizes.NATIVE;
+    private final TypeSizes typeSizes = TypeSizes.NATIVE;
 
     public SSTableWriter(String filename, long keyCount) throws IOException
     {

File: src/java/org/apache/cassandra/service/MigrationManager.java
Patch:
@@ -327,7 +327,7 @@ public Collection<RowMutation> deserialize(DataInput in, int version) throws IOE
 
         public long serializedSize(Collection<RowMutation> schema, int version)
         {
-            int size = DBTypeSizes.NATIVE.sizeof(schema.size());
+            int size = TypeSizes.NATIVE.sizeof(schema.size());
             for (RowMutation rm : schema)
                 size += RowMutation.serializer.serializedSize(rm, version);
             return size;

File: src/java/org/apache/cassandra/streaming/StreamHeader.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.Collections;
 import java.util.List;
 
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.net.CompactEndpointSerializationHelper;
 import org.apache.cassandra.net.MessagingService;
@@ -103,9 +103,9 @@ public StreamHeader deserialize(DataInput dis, int version) throws IOException
         public long serializedSize(StreamHeader sh, int version)
         {
             long size = FBUtilities.serializedUTF8Size(sh.table);
-            size += DBTypeSizes.NATIVE.sizeof(sh.sessionId);
+            size += TypeSizes.NATIVE.sizeof(sh.sessionId);
             size += PendingFile.serializer.serializedSize(sh.file, version);
-            size += DBTypeSizes.NATIVE.sizeof(sh.pendingFiles.size());
+            size += TypeSizes.NATIVE.sizeof(sh.pendingFiles.size());
             for(PendingFile file : sh.pendingFiles)
                 size += PendingFile.serializer.serializedSize(file, version);
             size += CompactEndpointSerializationHelper.serializedSize(sh.broadcastAddress);

File: src/java/org/apache/cassandra/streaming/StreamReply.java
Patch:
@@ -21,7 +21,7 @@
 import java.io.DataOutput;
 import java.io.IOException;
 
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.net.MessageOut;
 import org.apache.cassandra.net.MessagingService;
@@ -84,7 +84,7 @@ public StreamReply deserialize(DataInput dis, int version) throws IOException
 
         public long serializedSize(StreamReply reply, int version)
         {
-            return DBTypeSizes.NATIVE.sizeof(reply.sessionId) + FBUtilities.serializedUTF8Size(reply.file) + DBTypeSizes.NATIVE.sizeof(reply.action.ordinal());
+            return TypeSizes.NATIVE.sizeof(reply.sessionId) + FBUtilities.serializedUTF8Size(reply.file) + TypeSizes.NATIVE.sizeof(reply.action.ordinal());
         }
     }
 }

File: src/java/org/apache/cassandra/streaming/StreamingRepairTask.java
Patch:
@@ -28,7 +28,7 @@
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.db.ColumnFamilyStore;
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.db.Table;
 import org.apache.cassandra.dht.AbstractBounds;
 import org.apache.cassandra.dht.Range;
@@ -267,7 +267,7 @@ public long serializedSize(StreamingRepairTask task, int version)
             size += 3 * CompactEndpointSerializationHelper.serializedSize(task.owner);
             size += FBUtilities.serializedUTF8Size(task.tableName);
             size += FBUtilities.serializedUTF8Size(task.cfName);
-            size += DBTypeSizes.NATIVE.sizeof(task.ranges.size());
+            size += TypeSizes.NATIVE.sizeof(task.ranges.size());
             for (Range<Token> range : task.ranges)
                 size += AbstractBounds.serializer.serializedSize(range, version);
             return size;

File: src/java/org/apache/cassandra/utils/BloomFilterSerializer.java
Patch:
@@ -21,7 +21,7 @@
 import java.io.DataOutput;
 import java.io.IOException;
 
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.io.ISerializer;
 import org.apache.cassandra.utils.obs.OpenBitSet;
 
@@ -72,7 +72,7 @@ public BloomFilter deserialize(DataInput dis) throws IOException
      *
      * @return serialized size of the given bloom filter
      */
-    public long serializedSize(BloomFilter bf, DBTypeSizes typeSizes)
+    public long serializedSize(BloomFilter bf, TypeSizes typeSizes)
     {
         int bitLength = bf.bitset.getNumWords();
         int pageSize = bf.bitset.getPageSize();

File: src/java/org/apache/cassandra/utils/EstimatedHistogram.java
Patch:
@@ -25,7 +25,7 @@
 
 import com.google.common.base.Objects;
 
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.io.ISerializer;
 
 public class EstimatedHistogram
@@ -273,7 +273,7 @@ public EstimatedHistogram deserialize(DataInput dis) throws IOException
             return new EstimatedHistogram(offsets, buckets);
         }
 
-        public long serializedSize(EstimatedHistogram object, DBTypeSizes typeSizes)
+        public long serializedSize(EstimatedHistogram object, TypeSizes typeSizes)
         {
             throw new UnsupportedOperationException();
         }

File: src/java/org/apache/cassandra/utils/FilterFactory.java
Patch:
@@ -21,15 +21,15 @@
 import java.io.DataOutput;
 import java.io.IOException;
 
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 public class FilterFactory
 {
     private static final Logger logger = LoggerFactory.getLogger(FilterFactory.class);
-    private static final DBTypeSizes TYPE_SIZES = DBTypeSizes.NATIVE;
+    private static final TypeSizes TYPE_SIZES = TypeSizes.NATIVE;
 
     public enum Type
     {

File: src/java/org/apache/cassandra/utils/StreamingHistogram.java
Patch:
@@ -17,7 +17,7 @@
  */
 package org.apache.cassandra.utils;
 
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.io.ISerializer;
 
 import java.io.DataInput;
@@ -193,7 +193,7 @@ public StreamingHistogram deserialize(DataInput dis) throws IOException
             return new StreamingHistogram(maxBinSize, tmp);
         }
 
-        public long serializedSize(StreamingHistogram histogram, DBTypeSizes typeSizes)
+        public long serializedSize(StreamingHistogram histogram, TypeSizes typeSizes)
         {
             throw new UnsupportedOperationException();
         }

File: src/java/org/apache/cassandra/utils/UUIDGen.java
Patch:
@@ -27,7 +27,7 @@
 import java.util.Random;
 import java.util.UUID;
 
-import org.apache.cassandra.db.DBTypeSizes;
+import org.apache.cassandra.db.TypeSizes;
 import org.apache.cassandra.io.IVersionedSerializer;
 
 /**
@@ -110,7 +110,7 @@ public UUID deserialize(DataInput in, int version) throws IOException
 
         public long serializedSize(UUID uuid, int version)
         {
-            return DBTypeSizes.NATIVE.sizeof(uuid.getMostSignificantBits()) + DBTypeSizes.NATIVE.sizeof(uuid.getLeastSignificantBits());
+            return TypeSizes.NATIVE.sizeof(uuid.getMostSignificantBits()) + TypeSizes.NATIVE.sizeof(uuid.getLeastSignificantBits());
         }
     }
 

File: src/java/org/apache/cassandra/dht/BootStrapper.java
Patch:
@@ -25,7 +25,6 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Condition;
 
-import com.google.common.base.Charsets;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -43,6 +42,7 @@
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.SimpleCondition;
 
+import static org.apache.cassandra.utils.FBUtilities.serializedUTF8Size;
 
 public class BootStrapper
 {
@@ -230,7 +230,7 @@ public String deserialize(DataInput in, int version) throws IOException
 
         public long serializedSize(String s, int version)
         {
-            return 2 + FBUtilities.encodedUTF8Length(s);
+            return serializedUTF8Size(s);
         }
     }
 }

File: src/java/org/apache/cassandra/dht/Token.java
Patch:
@@ -105,7 +105,9 @@ public Token deserialize(DataInput dis) throws IOException
 
         public long serializedSize(Token object, DBTypeSizes typeSizes)
         {
-            throw new UnsupportedOperationException();
+            IPartitioner p = StorageService.getPartitioner();
+            ByteBuffer b = p.getTokenFactory().toByteArray(object);
+            return DBTypeSizes.NATIVE.sizeof(b.remaining()) + b.remaining();
         }
     }
 

File: src/java/org/apache/cassandra/net/IncomingTcpConnection.java
Patch:
@@ -64,7 +64,6 @@ public void run()
             int header = input.readInt();
             isStream = MessagingService.getBits(header, 3, 1) == 1;
             version = MessagingService.getBits(header, 15, 8);
-            logger.debug("Version for {} is {}", from, version);
             if (isStream)
             {
                 if (version == MessagingService.current_version)
@@ -88,6 +87,7 @@ public void run()
             input = new DataInputStream(new BufferedInputStream(socket.getInputStream(), 4096));
             // Receive the first message to set the version.
             from = receiveMessage(input, version); // why? see => CASSANDRA-4099
+            logger.debug("Version for {} is {}", from, version);
             if (version > MessagingService.current_version)
             {
                 // save the endpoint so gossip will reconnect to it

File: src/java/org/apache/cassandra/streaming/FileStreamTask.java
Patch:
@@ -195,7 +195,8 @@ private void receiveReply() throws IOException
         assert MessagingService.getBits(msheader, 3, 1) == 0 : "Stream received before stream reply";
         int version = MessagingService.getBits(msheader, 15, 8);
 
-        input.readInt(); // Read total size
+        if (version <= MessagingService.VERSION_11)
+            input.readInt(); // Read total size
         String id = input.readUTF();
         MessageIn message = MessageIn.read(input, version, id);
         assert message.verb == MessagingService.Verb.STREAM_REPLY : "Non-reply message received on stream socket";

File: src/java/org/apache/cassandra/utils/MerkleTree.java
Patch:
@@ -828,7 +828,7 @@ public String toString()
     /**
      * Abstract class containing hashing logic, and containing a single hash field.
      */
-    static abstract class Hashable
+    static abstract class Hashable implements Serializable
     {
         private static final long serialVersionUID = 1L;
         private static final IVersionedSerializer<Hashable> serializer = new HashableSerializer();

File: test/unit/org/apache/cassandra/service/RemoveTest.java
Patch:
@@ -22,6 +22,7 @@
 import java.io.IOException;
 import java.net.InetAddress;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.UUID;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -153,8 +154,7 @@ public void run()
 
         for (InetAddress host : hosts)
         {
-            // TODO how to spoof host here?
-            MessageOut msg = new MessageOut(MessagingService.Verb.REPLICATION_FINISHED);
+            MessageOut msg = new MessageOut(host, MessagingService.Verb.REPLICATION_FINISHED, null, null, Collections.<String, byte[]>emptyMap());
             MessagingService.instance().sendRR(msg, FBUtilities.getBroadcastAddress());
         }
 

File: src/java/org/apache/cassandra/db/marshal/DateType.java
Patch:
@@ -88,7 +88,6 @@ public ByteBuffer fromString(String source) throws MarshalException
     public static long dateStringToTimestamp(String source) throws MarshalException
     {
       long millis;
-      source = source.toLowerCase();
 
       if (source.toLowerCase().equals("now"))
       {

File: test/unit/org/apache/cassandra/streaming/BootstrapTest.java
Patch:
@@ -36,8 +36,8 @@ public class BootstrapTest extends SchemaLoader
     @Test
     public void testGetNewNames() throws IOException
     {
-        Descriptor desc = Descriptor.fromFilename(new File("Keyspace1", "Keyspace1-Standard1-f-500-Data.db").toString());
-        assert !desc.isLatestVersion; // deliberately test old version
+        Descriptor desc = Descriptor.fromFilename(new File("Keyspace1", "Keyspace1-Standard1-ia-500-Data.db").toString());
+        // assert !desc.isLatestVersion; // minimum compatible version -- for now it is the latest as well
         PendingFile inContext = new PendingFile(null, desc, "Data.db", Arrays.asList(new Pair<Long,Long>(0L, 1L)), OperationType.BOOTSTRAP);
 
         PendingFile outContext = StreamIn.getContextMapping(inContext);

File: src/java/org/apache/cassandra/db/ColumnFamily.java
Patch:
@@ -256,7 +256,7 @@ public ColumnFamily diff(ColumnFamily cfComposite)
 
     int size(DBTypeSizes typeSizes)
     {
-        int size = DBConstants.longSize + DBConstants.intSize; // tombstone tracking
+        int size = DBTypeSizes.NATIVE.sizeof(1L) + DBTypeSizes.NATIVE.sizeof(1); // tombstone tracking
         for (IColumn column : columns)
         {
             size += column.size(typeSizes);

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -25,6 +25,7 @@
 import org.apache.cassandra.auth.Permission;
 import org.apache.cassandra.cql3.*;
 import org.apache.cassandra.db.IMutation;
+import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.StorageProxy;
 import org.apache.cassandra.thrift.ConsistencyLevel;
@@ -125,4 +126,6 @@ public int getTimeToLive()
      * @throws InvalidRequestException on invalid requests
      */
     public abstract List<IMutation> getMutations(ClientState clientState, List<ByteBuffer> variables) throws InvalidRequestException;
+
+    public abstract ParsedStatement.Prepared prepare(AbstractType[] boundTypes) throws InvalidRequestException;
 }

File: src/java/org/apache/cassandra/cql3/CFPropDefs.java
Patch:
@@ -74,6 +74,7 @@ public class CFPropDefs
         comparators.put("uuid", "UUIDType");
         comparators.put("varchar", "UTF8Type");
         comparators.put("varint", "IntegerType");
+        comparators.put("timeuuid", "TimeUUIDType");
 
         keywords.add(KW_COMMENT);
         keywords.add(KW_READREPAIRCHANCE);

File: src/java/org/apache/cassandra/cql/SelectStatement.java
Patch:
@@ -196,6 +196,4 @@ public String toString()
                              clause,
                              numRecords);
     }
-
-
 }

File: src/java/org/apache/cassandra/db/ColumnFamily.java
Patch:
@@ -367,7 +367,7 @@ public void validateColumnFields() throws MarshalException
 
     public ColumnStats getColumnStats()
     {
-        long maxTimestampSeen = Long.MIN_VALUE;
+        long maxTimestampSeen = getMarkedForDeleteAt();
         StreamingHistogram tombstones = new StreamingHistogram(SSTable.TOMBSTONE_HISTOGRAM_BIN_SIZE);
 
         for (IColumn column : columns)

File: src/java/org/apache/cassandra/db/ColumnFamily.java
Patch:
@@ -272,7 +272,7 @@ int size()
 
     public long maxTimestamp()
     {
-        long maxTimestamp = Long.MIN_VALUE;
+        long maxTimestamp = getMarkedForDeleteAt();
         for (IColumn column : columns)
             maxTimestamp = Math.max(maxTimestamp, column.maxTimestamp());
         return maxTimestamp;

File: src/java/org/apache/cassandra/streaming/StreamIn.java
Patch:
@@ -81,7 +81,7 @@ public static PendingFile getContextMapping(PendingFile remote) throws IOExcepti
         // new local sstable
         Table table = Table.open(remotedesc.ksname);
         ColumnFamilyStore cfStore = table.getColumnFamilyStore(remotedesc.cfname);
-        Descriptor localdesc = Descriptor.fromFilename(cfStore.getFlushPath(remote.size, remote.desc.version));
+        Descriptor localdesc = Descriptor.fromFilename(cfStore.getFlushPath(remote.size, Descriptor.CURRENT_VERSION));
 
         return new PendingFile(localdesc, remote);
     }

File: contrib/pig/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java
Patch:
@@ -218,7 +218,7 @@ else if (value instanceof ByteBuffer)
        else if (value instanceof UUID)
            pair.set(position, new DataByteArray(UUIDGen.decompose((java.util.UUID) value)));
        else if (value instanceof Date)
-           pair.set(position, new DataByteArray(ByteBufferUtil.getArray(DateType.instance.decompose((Date) value))));
+           pair.set(position, DateType.instance.decompose((Date) value).getLong());
        else
            pair.set(position, value);
     }

File: contrib/pig/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java
Patch:
@@ -217,6 +217,8 @@ else if (value instanceof ByteBuffer)
            pair.set(position, new DataByteArray(ByteBufferUtil.getArray((ByteBuffer) value)));
        else if (value instanceof UUID)
            pair.set(position, new DataByteArray(UUIDGen.decompose((java.util.UUID) value)));
+       else if (value instanceof Date)
+           pair.set(position, new DataByteArray(ByteBufferUtil.getArray(DateType.instance.decompose((Date) value))));
        else
            pair.set(position, value);
     }
@@ -463,7 +465,7 @@ public ResourceSchema getSchema(String location, Job job) throws IOException
 
     private byte getPigType(AbstractType type)
     {
-        if (type instanceof LongType)
+        if (type instanceof LongType || type instanceof DateType) // DateType is bad and it should feel bad
             return DataType.LONG;
         else if (type instanceof IntegerType)
             return DataType.INTEGER;

File: src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
Patch:
@@ -349,10 +349,11 @@ public static void rename(Descriptor tmpdesc, Descriptor newdesc, Set<Component>
         try
         {
             // do -Data last because -Data present should mean the sstable was completely renamed before crash
-            // don't rename -Summary component as it is not created yet and created when SSTable is loaded.
             for (Component component : Sets.difference(components, Sets.newHashSet(Component.DATA, Component.SUMMARY)))
                 FBUtilities.renameWithConfirm(tmpdesc.filenameFor(component), newdesc.filenameFor(component));
             FBUtilities.renameWithConfirm(tmpdesc.filenameFor(Component.DATA), newdesc.filenameFor(Component.DATA));
+            // rename it without confirmation because summary can be available for loadNewSSTables but not for closeAndOpenReader
+            FBUtilities.renameWithOutConfirm(tmpdesc.filenameFor(Component.SUMMARY), newdesc.filenameFor(Component.SUMMARY));
         }
         catch (IOException e)
         {

File: src/java/org/apache/cassandra/db/ColumnFamily.java
Patch:
@@ -141,7 +141,7 @@ public boolean isSuper()
     }
 
     /**
-     * Same as addAll() but do a cloneMeShallow of SuperColumn if necessary to
+     * Same as addAll() but do a cloneMe of SuperColumn if necessary to
      * avoid keeping references to the structure (see #3957).
      */
     public void addAllWithSCCopy(ColumnFamily cf, Allocator allocator)
@@ -150,7 +150,7 @@ public void addAllWithSCCopy(ColumnFamily cf, Allocator allocator)
         {
             for (IColumn c : cf)
             {
-                columns.addColumn(((SuperColumn)c).cloneMeShallow(), allocator);
+                columns.addColumn(((SuperColumn)c).cloneMe(), allocator);
             }
             delete(cf);
         }

File: src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
Patch:
@@ -497,7 +497,8 @@ protected Pair<ByteBuffer, SortedMap<ByteBuffer, IColumn>> computeNext()
                     if (columns.hasNext())
                     {
                         ColumnOrSuperColumn cosc = columns.next();
-                        ImmutableSortedMap<ByteBuffer, IColumn> map = ImmutableSortedMap.of(cosc.column.name, unthriftifySimple(cosc.column));
+                        IColumn column = unthriftify(cosc);
+                        ImmutableSortedMap<ByteBuffer, IColumn> map = ImmutableSortedMap.of(column.name(), column);
                         return Pair.<ByteBuffer, SortedMap<ByteBuffer, IColumn>>create(currentRow.key, map);
                     }
 

File: src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
Patch:
@@ -501,7 +501,8 @@ protected Pair<ByteBuffer, SortedMap<ByteBuffer, IColumn>> computeNext()
                     if (columns.hasNext())
                     {
                         ColumnOrSuperColumn cosc = columns.next();
-                        ImmutableSortedMap<ByteBuffer, IColumn> map = ImmutableSortedMap.of(cosc.column.name, unthriftifySimple(cosc.column));
+                        IColumn column = unthriftify(cosc);
+                        ImmutableSortedMap<ByteBuffer, IColumn> map = ImmutableSortedMap.of(column.name(), column);
                         return Pair.<ByteBuffer, SortedMap<ByteBuffer, IColumn>>create(currentRow.key, map);
                     }
 

File: src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java
Patch:
@@ -98,7 +98,7 @@ public void announceMigration() throws InvalidRequestException, ConfigurationExc
                         cfm.defaultValidator(CFPropDefs.parseType(validator));
                         break;
                     case COLUMN_METADATA:
-                        ColumnDefinition column = meta.getColumnDefinition(columnName.key);
+                        ColumnDefinition column = cfm.getColumnDefinition(columnName.key);
                         column.setValidator(CFPropDefs.parseType(validator));
                         cfm.addColumnDefinition(column);
                         break;

File: tools/stress/src/org/apache/cassandra/stress/Stress.java
Patch:
@@ -88,7 +88,7 @@ public static void main(String[] arguments) throws Exception
         }
         else
         {
-            new StressAction(session, outStream).run();
+            new StressAction(session, outStream).start();
         }
     }
 

File: src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java
Patch:
@@ -47,7 +47,7 @@ public AlterTableStatement(CFName name, Type type, ColumnIdentifier columnName,
     {
         super(name);
         this.oType = type;
-        this.columnName = null;
+        this.columnName = columnName;
         this.validator = validator; // used only for ADD/ALTER commands
         this.cfProps.addAll(propertyMap);
     }

File: src/java/org/apache/cassandra/hadoop/BulkRecordWriter.java
Patch:
@@ -100,7 +100,7 @@ private enum ColType
         Config.setOutboundBindAny(true);
         this.conf = conf;
         DatabaseDescriptor.setStreamThroughputOutboundMegabitsPerSec(Integer.valueOf(conf.get(STREAM_THROTTLE_MBITS, "0")));
-        maxFailures = Integer.valueOf(conf.get(MAX_FAILED_HOSTS, "O"));
+        maxFailures = Integer.valueOf(conf.get(MAX_FAILED_HOSTS, "0"));
         String keyspace = ConfigHelper.getOutputKeyspace(conf);
         outputdir = new File(getOutputLocation() + File.separator + keyspace + File.separator + ConfigHelper.getOutputColumnFamily(conf)); //dir must be named by ks/cf for the loader
         outputdir.mkdirs();

File: src/java/org/apache/cassandra/io/sstable/AbstractSSTableSimpleWriter.java
Patch:
@@ -79,7 +79,7 @@ public boolean accept(File dir, String name)
         int maxGen = 0;
         for (Descriptor desc : existing)
             maxGen = Math.max(maxGen, desc.generation);
-        return new Descriptor(directory, keyspace, columnFamily, maxGen + 1, false).filenameFor(Component.DATA);
+        return new Descriptor(directory, keyspace, columnFamily, maxGen + 1, true).filenameFor(Component.DATA);
     }
 
     /**

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1985,7 +1985,7 @@ public void forceTableRepairRange(String beginToken, String endToken, final Stri
         Token parsedBeginToken = getPartitioner().getTokenFactory().fromString(beginToken);
         Token parsedEndToken = getPartitioner().getTokenFactory().fromString(endToken);
 
-        logger_.info("starting user-requested repair of range ({}, {}] for keyspace {} and column families {}",
+        logger.info("starting user-requested repair of range ({}, {}] for keyspace {} and column families {}",
                      new Object[] {parsedBeginToken, parsedEndToken, tableName, columnFamilies});
         AntiEntropyService.RepairFuture future = forceTableRepair(new Range<Token>(parsedBeginToken, parsedEndToken), tableName, isSequential, columnFamilies);
         if (future == null)
@@ -1996,7 +1996,7 @@ public void forceTableRepairRange(String beginToken, String endToken, final Stri
         }
         catch (Exception e)
         {
-            logger_.error("Repair session " + future.session.getName() + " failed.", e);
+            logger.error("Repair session " + future.session.getName() + " failed.", e);
         }
     }
 

File: src/java/org/apache/cassandra/db/HintedHandOffManager.java
Patch:
@@ -289,7 +289,7 @@ private void deliverHintsToEndpointInternal(InetAddress endpoint) throws IOExcep
 
         if (!FailureDetector.instance.isAlive(endpoint))
         {
-            logger_.info("Endpoint {} died before hint delivery, aborting", endpoint);
+            logger_.debug("Endpoint {} died before hint delivery, aborting", endpoint);
             return;
         }
 

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -285,7 +285,8 @@ private List<Row> multiRangeSlice(List<ByteBuffer> variables) throws InvalidRequ
                                                                     bounds,
                                                                     expressions,
                                                                     getLimit(),
-                                                                    true), // limit by columns, not keys
+                                                                    true, // limit by columns, not keys
+                                                                    false),
                                               parameters.consistencyLevel);
         }
         catch (IOException e)

File: src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
Patch:
@@ -43,7 +43,8 @@ public class SliceQueryFilter implements IFilter
 {
     private static Logger logger = LoggerFactory.getLogger(SliceQueryFilter.class);
 
-    public final ByteBuffer start; public final ByteBuffer finish;
+    public volatile ByteBuffer start;
+    public volatile ByteBuffer finish;
     public final boolean reversed;
     public volatile int count;
 

File: src/java/org/apache/cassandra/db/index/keys/KeysSearcher.java
Patch:
@@ -84,7 +84,7 @@ public boolean isIndexing(List<IndexExpression> clause)
     public List<Row> search(List<IndexExpression> clause, AbstractBounds<RowPosition> range, int maxResults, IFilter dataFilter, boolean maxIsColumns)
     {
         assert clause != null && !clause.isEmpty();
-        ExtendedFilter filter = ExtendedFilter.create(baseCfs, dataFilter, clause, maxResults, maxIsColumns);
+        ExtendedFilter filter = ExtendedFilter.create(baseCfs, dataFilter, clause, maxResults, maxIsColumns, false);
         return baseCfs.filter(getIndexedIterator(range, filter), filter);
     }
 

File: src/java/org/apache/cassandra/service/RangeSliceVerbHandler.java
Patch:
@@ -47,7 +47,7 @@ static List<Row> executeLocally(RangeSliceCommand command) throws ExecutionExcep
         if (cfs.indexManager.hasIndexFor(command.row_filter))
             return cfs.search(command.row_filter, command.range, command.maxResults, columnFilter, command.maxIsColumns);
         else
-            return cfs.getRangeSlice(command.super_column, command.range, command.maxResults, columnFilter, command.row_filter, command.maxIsColumns);
+            return cfs.getRangeSlice(command.super_column, command.range, command.maxResults, columnFilter, command.row_filter, command.maxIsColumns, command.isPaging);
     }
 
     public void doVerb(Message message, String id)

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -851,7 +851,8 @@ public static List<Row> getRangeSlice(RangeSliceCommand command, ConsistencyLeve
                                                                   range,
                                                                   command.row_filter,
                                                                   command.maxResults,
-                                                                  command.maxIsColumns);
+                                                                  command.maxIsColumns,
+                                                                  command.isPaging);
 
                 List<InetAddress> liveEndpoints = StorageService.instance.getLiveNaturalEndpoints(nodeCmd.keyspace, range.right);
                 DatabaseDescriptor.getEndpointSnitch().sortByProximity(FBUtilities.getBroadcastAddress(), liveEndpoints);

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -749,7 +749,7 @@ public List<KeySlice> get_paged_slice(String column_family, KeyRange range, Byte
             schedule(DatabaseDescriptor.getRpcTimeout());
             try
             {
-                rows = StorageProxy.getRangeSlice(new RangeSliceCommand(keyspace, column_family, null, predicate, bounds, range.row_filter, range.count, true), consistency_level);
+                rows = StorageProxy.getRangeSlice(new RangeSliceCommand(keyspace, column_family, null, predicate, bounds, range.row_filter, range.count, true, true), consistency_level);
             }
             finally
             {

File: tools/stress/src/org/apache/cassandra/stress/Stress.java
Patch:
@@ -88,7 +88,7 @@ public static void main(String[] arguments) throws Exception
         }
         else
         {
-            new StressAction(session, outStream).run();
+            new StressAction(session, outStream).start();
         }
     }
 

File: test/unit/org/apache/cassandra/utils/BoundedStatsDequeTest.java
Patch:
@@ -39,7 +39,7 @@ public void test()
         //check the values for an empty result
         assertEquals(0, bsd.size());
         assertEquals(0, bsd.sum(), 0.001d);
-        assertEquals(Double.NaN, bsd.mean(), 0.001d);
+        assertEquals(0, bsd.mean(), 0.001d)
 
         bsd.add(1d); //this one falls out, over limit
         bsd.add(2d);

File: src/java/org/apache/cassandra/cache/KeyCacheKey.java
Patch:
@@ -28,8 +28,6 @@
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.Pair;
 
-import com.google.common.base.Objects;
-
 public class KeyCacheKey implements CacheKey
 {
     private final Descriptor desc;
@@ -54,7 +52,7 @@ public Pair<String, String> getPathInfo()
 
     public int serializedSize()
     {
-        return key.length + DBConstants.intSize;
+        return key.length + DBConstants.INT_SIZE;
     }
 
     public String toString()

File: src/java/org/apache/cassandra/cache/RowCacheKey.java
Patch:
@@ -58,7 +58,7 @@ public Pair<String, String> getPathInfo()
 
     public int serializedSize()
     {
-        return key.length + DBConstants.intSize;
+        return key.length + DBConstants.INT_SIZE;
     }
 
     @Override

File: interface/thrift/gen-java/org/apache/cassandra/thrift/Constants.java
Patch:
@@ -44,6 +44,6 @@
 
 public class Constants {
 
-  public static final String VERSION = "19.29.0";
+  public static final String VERSION = "19.30.0";
 
 }

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -614,13 +614,14 @@ public static CFMetaData fromThrift(org.apache.cassandra.thrift.CfDef cf_def) th
             newCFMD.bloomFilterFpChance(cf_def.bloom_filter_fp_chance);
         if (cf_def.isSetCaching())
             newCFMD.caching(Caching.fromString(cf_def.caching));
+        if (cf_def.isSetRead_repair_chance())
+            newCFMD.readRepairChance(cf_def.read_repair_chance);
         if (cf_def.isSetDclocal_read_repair_chance())
             newCFMD.dcLocalReadRepairChance(cf_def.dclocal_read_repair_chance);
 
         CompressionParameters cp = CompressionParameters.create(cf_def.compression_options);
 
         return newCFMD.comment(cf_def.comment)
-                      .readRepairChance(cf_def.read_repair_chance)
                       .replicateOnWrite(cf_def.replicate_on_write)
                       .defaultValidator(TypeParser.parse(cf_def.default_validation_class))
                       .keyValidator(TypeParser.parse(cf_def.key_validation_class))

File: src/java/org/apache/cassandra/db/SliceFromReadCommand.java
Patch:
@@ -73,7 +73,7 @@ public Row getRow(Table table) throws IOException
     public ReadCommand maybeGenerateRetryCommand(RepairCallback handler, Row row)
     {
         int maxLiveColumns = handler.getMaxLiveColumns();
-        int liveColumnsInRow = row != null ? row.cf.getLiveColumnCount() : 0;
+        int liveColumnsInRow = row != null ? row.getLiveColumnCount() : 0;
 
         assert maxLiveColumns <= count;
         // We generate a retry if at least one node reply with count live columns but after merge we have less

File: src/java/org/apache/cassandra/db/compaction/ParallelCompactionIterable.java
Patch:
@@ -59,7 +59,6 @@ public class ParallelCompactionIterable extends AbstractCompactionIterable
 {
     private static Logger logger = LoggerFactory.getLogger(ParallelCompactionIterable.class);
 
-    private final List<SSTableScanner> scanners;
     private final int maxInMemorySize;
 
     public ParallelCompactionIterable(OperationType type, Iterable<SSTableReader> sstables, CompactionController controller) throws IOException
@@ -74,8 +73,7 @@ public ParallelCompactionIterable(OperationType type, Iterable<SSTableReader> ss
 
     protected ParallelCompactionIterable(OperationType type, List<SSTableScanner> scanners, CompactionController controller, int maxInMemorySize)
     {
-        super(controller, type);
-        this.scanners = scanners;
+        super(controller, type, scanners);
         this.maxInMemorySize = maxInMemorySize;
     }
 

File: src/java/org/apache/cassandra/gms/FailureDetector.java
Patch:
@@ -197,10 +197,10 @@ public void interpret(InetAddress ep)
 
     public void forceConviction(InetAddress ep)
     {
-        logger.debug("Forcing conviction of {}", ep);
-        for ( IFailureDetectionEventListener listener : fdEvntListeners )
+        logger_.debug("Forcing conviction of {}", ep);
+        for ( IFailureDetectionEventListener listener : fdEvntListeners_ )
         {
-            listener.convict(ep, phiConvictThreshold);
+            listener.convict(ep, phiConvictThreshold_);
         }
     }
 

File: src/java/org/apache/cassandra/cql/QueryProcessor.java
Patch:
@@ -612,7 +612,7 @@ else if (oldKeyspace == null)
                                 "Timestamp must be set either on BATCH or individual statements");
                 }
 
-                List<IMutation> mutations = batch.getMutations(keyspace, clientState);
+                List<IMutation> mutations = batch.getMutations(keyspace, clientState, variables);
                 for (IMutation mutation : mutations)
                 {
                     validateKey(mutation.key());
@@ -667,7 +667,7 @@ else if (oldKeyspace == null)
                 DeleteStatement delete = (DeleteStatement)statement.statement;
 
                 keyspace = delete.keyspace == null ? clientState.getKeyspace() : delete.keyspace;
-                List<IMutation> deletions = delete.prepareRowMutations(keyspace, clientState);
+                List<IMutation> deletions = delete.prepareRowMutations(keyspace, clientState, variables);
                 for (IMutation deletion : deletions)
                 {
                     validateKey(deletion.key());

File: src/java/org/apache/cassandra/db/index/keys/KeysSearcher.java
Patch:
@@ -159,14 +159,12 @@ protected Row computeNext()
                         {
                             // skip the row we already saw w/ the last page of results
                             indexColumns.next();
-                            columnsRead--;
                             logger.debug("Skipping {}", baseCfs.metadata.getKeyValidator().getString(firstColumn.name()));
                         }
                         else if (range instanceof Range && indexColumns.hasNext() && firstColumn.name().equals(startKey))
                         {
                             // skip key excluded by range
                             indexColumns.next();
-                            columnsRead--;
                             logger.debug("Skipping first key as range excludes it");
                         }
                     }

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -197,7 +197,7 @@ else if (conf.disk_access_mode == Config.DiskAccessMode.mmap_index_only)
             }
             try
             {
-                partitioner = FBUtilities.newPartitioner(conf.partitioner);
+                partitioner = FBUtilities.newPartitioner(System.getProperty("cassandra.partitioner", conf.partitioner));
             }
             catch (Exception e)
             {

File: src/java/org/apache/cassandra/utils/MerkleTree.java
Patch:
@@ -73,6 +73,7 @@ public class MerkleTree implements Serializable
      */
     public transient Range fullRange;
 
+    // TODO This is broken; Token serialization assumes system partitioner, so if this doesn't match all hell breaks loose
     private transient IPartitioner partitioner;
 
     private long maxsize;

File: test/unit/org/apache/cassandra/utils/SerializationsTest.java
Patch:
@@ -73,8 +73,9 @@ private void testLegacyBloomFilterWrite() throws IOException
     @Test
     public void testLegacyBloomFilterRead() throws IOException
     {
-        if (EXECUTE_WRITES)
-            testLegacyBloomFilterWrite();
+        // We never write out a new LBF.  Copy the data file from 0.7 instead.
+        // if (EXECUTE_WRITES)
+        //      testLegacyBloomFilterWrite();
         
         DataInputStream in = getInput("utils.LegacyBloomFilter.bin");
         assert LegacyBloomFilter.serializer().deserialize(in) != null;

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -347,7 +347,7 @@ protected void runMayThrow() throws IOException
                     {
                         if (sstables.isEmpty())
                         {
-                            logger.error("No file to compact for user defined compaction");
+                            logger.info("No file to compact for user defined compaction");
                         }
                         // attempt to schedule the set
                         else if ((toCompact = cfs.getDataTracker().markCompacting(sstables, 1, Integer.MAX_VALUE)) != null)
@@ -366,7 +366,7 @@ else if ((toCompact = cfs.getDataTracker().markCompacting(sstables, 1, Integer.M
                         }
                         else
                         {
-                            logger.error("SSTables for user defined compaction are already being compacted.");
+                            logger.info("SSTables for user defined compaction are already being compacted.");
                         }
                     }
                     finally

File: src/java/org/apache/cassandra/cql/CreateColumnFamilyStatement.java
Patch:
@@ -177,7 +177,7 @@ public CFMetaData getCFMetaData(String keyspace, List<ByteBuffer> variables) thr
 
             newCFMD.comment(cfProps.getProperty(CFPropDefs.KW_COMMENT))
                    .readRepairChance(getPropertyDouble(CFPropDefs.KW_READREPAIRCHANCE, CFMetaData.DEFAULT_READ_REPAIR_CHANCE))
-                   .dclocalReadRepairChance(getPropertyDouble(CFPropDefs.KW_DCLOCALREADREPAIRCHANCE, CFMetaData.DEFAULT_DCLOCAL_READ_REPAIR_CHANCE))
+                   .dcLocalReadRepairChance(getPropertyDouble(CFPropDefs.KW_DCLOCALREADREPAIRCHANCE, CFMetaData.DEFAULT_DCLOCAL_READ_REPAIR_CHANCE))
                    .replicateOnWrite(getPropertyBoolean(CFPropDefs.KW_REPLICATEONWRITE, CFMetaData.DEFAULT_REPLICATE_ON_WRITE))
                    .gcGraceSeconds(getPropertyInt(CFPropDefs.KW_GCGRACESECONDS, CFMetaData.DEFAULT_GC_GRACE_SECONDS))
                    .defaultValidator(cfProps.getValidator())

File: src/java/org/apache/cassandra/cql/DropIndexStatement.java
Patch:
@@ -54,7 +54,7 @@ public UpdateColumnFamily generateMutation(String keyspace)
         if (cfDef == null)
             throw new InvalidRequestException("Index '" + index + "' could not be found in any of the ColumnFamilies of keyspace '" + keyspace + "'");
 
-        return new UpdateColumnFamily(cfDef);
+        return new UpdateColumnFamily(CFMetaData.fromThrift(cfDef));
     }
 
     private CfDef getUpdatedCFDef(CfDef cfDef) throws InvalidRequestException

File: src/java/org/apache/cassandra/cql/QueryProcessor.java
Patch:
@@ -790,7 +790,7 @@ else if (oldKeyspace == null)
                 ThriftValidation.validateCfDef(cf_def, oldCfm);
                 try
                 {
-                    applyMigrationOnStage(new UpdateColumnFamily(cf_def));
+                    applyMigrationOnStage(new UpdateColumnFamily(CFMetaData.fromThrift(cf_def)));
                 }
                 catch (ConfigurationException e)
                 {
@@ -875,7 +875,7 @@ else if (oldKeyspace == null)
 
                 try
                 {
-                    applyMigrationOnStage(new UpdateColumnFamily(alterTable.getCfDef(keyspace)));
+                    applyMigrationOnStage(new UpdateColumnFamily(CFMetaData.fromThrift(alterTable.getCfDef(keyspace))));
                 }
                 catch (ConfigurationException e)
                 {

File: src/java/org/apache/cassandra/cql3/statements/AlterTableStatement.java
Patch:
@@ -136,7 +136,7 @@ public Migration getMigration() throws InvalidRequestException, IOException
                     applyPropertiesToCfDef(thriftDef, cfProps);
                     break;
             }
-            return new UpdateColumnFamily(thriftDef);
+            return new UpdateColumnFamily(CFMetaData.fromThrift(thriftDef));
         }
         catch (ConfigurationException e)
         {

File: src/java/org/apache/cassandra/cql3/statements/CreateColumnFamilyStatement.java
Patch:
@@ -105,7 +105,7 @@ public CFMetaData getCFMetaData() throws InvalidRequestException
 
             newCFMD.comment(properties.get(CFPropDefs.KW_COMMENT))
                    .readRepairChance(properties.getDouble(CFPropDefs.KW_READREPAIRCHANCE, CFMetaData.DEFAULT_READ_REPAIR_CHANCE))
-                   .dclocalReadRepairChance(properties.getDouble(CFPropDefs.KW_DCLOCALREADREPAIRCHANCE, CFMetaData.DEFAULT_DCLOCAL_READ_REPAIR_CHANCE))
+                   .dcLocalReadRepairChance(properties.getDouble(CFPropDefs.KW_DCLOCALREADREPAIRCHANCE, CFMetaData.DEFAULT_DCLOCAL_READ_REPAIR_CHANCE))
                    .replicateOnWrite(properties.getBoolean(CFPropDefs.KW_REPLICATEONWRITE, CFMetaData.DEFAULT_REPLICATE_ON_WRITE))
                    .gcGraceSeconds(properties.getInt(CFPropDefs.KW_GCGRACESECONDS, CFMetaData.DEFAULT_GC_GRACE_SECONDS))
                    .defaultValidator(defaultValidator)

File: src/java/org/apache/cassandra/cql3/statements/CreateIndexStatement.java
Patch:
@@ -90,7 +90,7 @@ public Migration getMigration() throws InvalidRequestException, ConfigurationExc
 
             CFMetaData.addDefaultIndexNames(cf_def);
             ThriftValidation.validateCfDef(cf_def, oldCfm);
-            return new UpdateColumnFamily(cf_def);
+            return new UpdateColumnFamily(CFMetaData.fromThrift(cf_def));
         }
         catch (InvalidRequestException e)
         {

File: src/java/org/apache/cassandra/cql3/statements/DropIndexStatement.java
Patch:
@@ -54,7 +54,7 @@ public Migration getMigration() throws InvalidRequestException, ConfigurationExc
         if (cfDef == null)
             throw new InvalidRequestException("Index '" + index + "' could not be found in any of the column families of keyspace '" + keyspace() + "'");
 
-        return new UpdateColumnFamily(cfDef);
+        return new UpdateColumnFamily(CFMetaData.fromThrift(cfDef));
     }
 
     private CfDef getUpdatedCFDef(CfDef cfDef) throws InvalidRequestException

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -64,7 +64,6 @@ public void checkAccess(ClientState state) throws InvalidRequestException
         state.hasColumnFamilyAccess(keyspace(), columnFamily(), Permission.WRITE);
     }
 
-    @Override
     public void validate(ClientState state) throws InvalidRequestException
     {
         if (timeToLive < 0)

File: src/java/org/apache/cassandra/db/migration/AddColumnFamily.java
Patch:
@@ -46,9 +46,9 @@ else if (!Migration.isLegalName(cfm.cfName))
         this.cfm = cfm;
     }
 
-    protected Collection<RowMutation> applyImpl() throws ConfigurationException, IOException
+    protected RowMutation applyImpl() throws ConfigurationException, IOException
     {
-        return MigrationHelper.addColumnFamily(cfm, timestamp);
+        return MigrationHelper.addColumnFamily(cfm, timestamp, true);
     }
 
     @Override

File: src/java/org/apache/cassandra/db/migration/AddKeyspace.java
Patch:
@@ -46,9 +46,9 @@ else if (!Migration.isLegalName(ksm.name))
         this.ksm = ksm;
     }
 
-    protected Collection<RowMutation> applyImpl() throws ConfigurationException, IOException
+    protected RowMutation applyImpl() throws ConfigurationException, IOException
     {
-        return MigrationHelper.addKeyspace(ksm, timestamp);
+        return MigrationHelper.addKeyspace(ksm, timestamp, true);
     }
 
     @Override

File: src/java/org/apache/cassandra/db/migration/DropColumnFamily.java
Patch:
@@ -44,9 +44,9 @@ else if (!ksm.cfMetaData().containsKey(cfName))
         this.cfName = cfName;
     }
 
-    protected Collection<RowMutation> applyImpl() throws ConfigurationException, IOException
+    protected RowMutation applyImpl() throws ConfigurationException, IOException
     {
-        return MigrationHelper.dropColumnFamily(ksName, cfName, timestamp);
+        return MigrationHelper.dropColumnFamily(ksName, cfName, timestamp, true);
     }
 
     @Override

File: src/java/org/apache/cassandra/db/migration/DropKeyspace.java
Patch:
@@ -41,9 +41,9 @@ public DropKeyspace(String name) throws ConfigurationException
         this.name = name;
     }
 
-    protected Collection<RowMutation> applyImpl() throws ConfigurationException, IOException
+    protected RowMutation applyImpl() throws ConfigurationException, IOException
     {
-        return MigrationHelper.dropKeyspace(name, timestamp);
+        return MigrationHelper.dropKeyspace(name, timestamp, true);
     }
 
     @Override

File: src/java/org/apache/cassandra/service/MigrationManager.java
Patch:
@@ -85,7 +85,7 @@ public void onRestart(InetAddress endpoint, EndpointState state)
     public void onRemove(InetAddress endpoint)
     {}
 
-    public static void rectifySchema(UUID theirVersion, final InetAddress endpoint)
+    private static void rectifySchema(UUID theirVersion, final InetAddress endpoint)
     {
         // Can't request migrations from nodes with versions younger than 1.1
         if (Gossiper.instance.getVersion(endpoint) < MessagingService.VERSION_11)

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -1050,7 +1050,7 @@ public synchronized String system_update_keyspace(KsDef ks_def)
         try
         {
             ThriftValidation.validateKsDef(ks_def);
-            applyMigrationOnStage(new UpdateKeyspace(ks_def));
+            applyMigrationOnStage(new UpdateKeyspace(KSMetaData.fromThrift(ks_def)));
             return Schema.instance.getVersion().toString();
         }
         catch (ConfigurationException e)
@@ -1079,7 +1079,7 @@ public synchronized String system_update_column_family(CfDef cf_def)
         {
             // ideally, apply() would happen on the stage with the
             CFMetaData.applyImplicitDefaults(cf_def);
-            UpdateColumnFamily update = new UpdateColumnFamily(cf_def);
+            UpdateColumnFamily update = new UpdateColumnFamily(CFMetaData.fromThrift(cf_def));
             applyMigrationOnStage(update);
             return Schema.instance.getVersion().toString();
         }

File: src/java/org/apache/cassandra/db/SliceFromReadCommand.java
Patch:
@@ -84,7 +84,7 @@ public ReadCommand maybeGenerateRetryCommand(RepairCallback handler, Row row)
             // From that, we can estimate that on this row, for x requested
             // columns, only l/t end up live after reconciliation. So for next
             // round we want to ask x column so that x * (l/t) == t, i.e. x = t^2/l.
-            int retryCount = ((count * count) / liveColumnsInRow) + 1;
+            int retryCount = liveColumnsInRow == 0 ? count + 1 : ((count * count) / liveColumnsInRow) + 1;
             return new RetriedSliceFromReadCommand(table, key, queryPath, start, finish, reversed, getOriginalRequestedCount(), retryCount);
         }
 

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1938,7 +1938,7 @@ public AntiEntropyService.RepairFuture forceTableRepair(final Range<Token> range
 
         if (names.isEmpty())
         {
-            logger_.info("No column family to repair for keyspace " + tableName);
+            logger.info("No column family to repair for keyspace " + tableName);
             return null;
         }
 

File: src/java/org/apache/cassandra/db/index/SecondaryIndexManager.java
Patch:
@@ -604,6 +604,6 @@ public void setIndexBuilt(Collection<ByteBuffer> indexes)
     public void setIndexRemoved(Collection<ByteBuffer> indexes)
     {
         for (ByteBuffer colName : indexes)
-            indexesByColumn.get(colName).setIndexBuilt(colName);
+            indexesByColumn.get(colName).setIndexRemoved(colName);
     }
 }

File: src/java/org/apache/cassandra/db/UnknownColumnFamilyException.java
Patch:
@@ -21,11 +21,11 @@
  */
 
 
-public class UnserializableColumnFamilyException extends IOException
+public class UnknownColumnFamilyException extends IOException
 {
     public final int cfId;
     
-    public UnserializableColumnFamilyException(String msg, int cfId)
+    public UnknownColumnFamilyException(String msg, int cfId)
     {
         super(msg);
         this.cfId = cfId;

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -285,7 +285,7 @@ else if (globalPosition.segment == segment)
                         // the current version.  so do make sure the CL is drained prior to upgrading a node.
                         rm = RowMutation.serializer().deserialize(new DataInputStream(bufIn), MessagingService.version_, IColumnSerializer.Flag.LOCAL);
                     }
-                    catch (UnserializableColumnFamilyException ex)
+                    catch (UnknownColumnFamilyException ex)
                     {
                         AtomicInteger i = invalidMutations.get(ex.cfId);
                         if (i == null)

File: src/java/org/apache/cassandra/db/HintedHandOffManager.java
Patch:
@@ -345,7 +345,7 @@ private void deliverHintsToEndpointInternal(InetAddress endpoint) throws IOExcep
                 }
                 catch (UnknownColumnFamilyException e)
                 {
-                    logger_.debug("Skipping delivery of hint for deleted columnfamily", e);
+                    logger.debug("Skipping delivery of hint for deleted columnfamily", e);
                     rm = null;
                 }
 

File: src/java/org/apache/cassandra/cache/IRowCacheProvider.java
Patch:
@@ -27,5 +27,5 @@
  */
 public interface IRowCacheProvider
 {
-    public ICache<RowCacheKey, ColumnFamily> create(int capacity, boolean useMemoryWeigher);
+    public ICache<RowCacheKey, IRowCacheEntry> create(int capacity, boolean useMemoryWeigher);
 }

File: src/java/org/apache/cassandra/db/RowIteratorFactory.java
Patch:
@@ -103,8 +103,10 @@ protected Row getReduced()
                 // First check if this row is in the rowCache. If it is we can skip the rest
                 ColumnFamily cached = cfs.getRawCachedRow(key);
                 if (cached == null)
+                {
                     // not cached: collate
                     filter.collateColumns(returnCF, colIters, gcBefore);
+                }
                 else
                 {
                     QueryFilter keyFilter = new QueryFilter(key, filter.path, filter.filter);

File: src/java/org/apache/cassandra/db/compaction/CompactionIterable.java
Patch:
@@ -110,7 +110,7 @@ protected AbstractCompactedRow getReduced()
                     // If the raw is cached, we call removeDeleted on it to have/ coherent query returns. However it would look
                     // like some deleted columns lived longer than gc_grace + compaction. This can also free up big amount of
                     // memory on long running instances
-                    controller.removeDeletedInCache(compactedRow.key);
+                    controller.invalidateCachedRow(compactedRow.key);
                 }
 
                 return compactedRow;

File: src/java/org/apache/cassandra/db/compaction/ParallelCompactionIterable.java
Patch:
@@ -130,7 +130,7 @@ protected AbstractCompactedRow computeNext()
                 // If the raw is cached, we call removeDeleted on it to have/ coherent query returns. However it would look
                 // like some deleted columns lived longer than gc_grace + compaction. This can also free up big amount of
                 // memory on long running instances
-                controller.removeDeletedInCache(compactedRow.key);
+                controller.invalidateCachedRow(compactedRow.key);
                 return compactedRow;
             }
         }

File: src/java/org/apache/cassandra/streaming/IncomingStreamReader.java
Patch:
@@ -124,8 +124,7 @@ private SSTableReader streamIn(DataInput input, PendingFile localFile, PendingFi
                     key = SSTableReader.decodeKey(StorageService.getPartitioner(), localFile.desc, ByteBufferUtil.readWithShortLength(in));
                     long dataSize = SSTableReader.readRowSize(in, localFile.desc);
 
-                    ColumnFamily cached = cfs.getRawCachedRow(key);
-                    if (cached != null && remoteFile.type == OperationType.AES && dataSize <= DatabaseDescriptor.getInMemoryCompactionLimit())
+                    if (cfs.containsCachedRow(key) && remoteFile.type == OperationType.AES && dataSize <= DatabaseDescriptor.getInMemoryCompactionLimit())
                     {
                         // need to update row cache
                         // Note: Because we won't just echo the columns, there is no need to use the PRESERVE_SIZE flag, contrarily to what appendFromStream does below

File: src/java/org/apache/cassandra/utils/StatusLogger.java
Patch:
@@ -31,6 +31,7 @@
 import com.google.common.collect.Iterables;
 
 import org.apache.cassandra.cache.AutoSavingCache;
+import org.apache.cassandra.cache.IRowCacheEntry;
 import org.apache.cassandra.cache.KeyCacheKey;
 import org.apache.cassandra.cache.RowCacheKey;
 import org.apache.cassandra.db.ColumnFamily;
@@ -90,7 +91,7 @@ public static void log()
 
         // Global key/row cache information
         AutoSavingCache<KeyCacheKey, Long> keyCache = CacheService.instance.keyCache;
-        AutoSavingCache<RowCacheKey, ColumnFamily> rowCache = CacheService.instance.rowCache;
+        AutoSavingCache<RowCacheKey, IRowCacheEntry> rowCache = CacheService.instance.rowCache;
 
         int keyCacheKeysToSave = DatabaseDescriptor.getKeyCacheKeysToSave();
         int rowCacheKeysToSave = DatabaseDescriptor.getRowCacheKeysToSave();

File: test/unit/org/apache/cassandra/db/RowCacheTest.java
Patch:
@@ -66,7 +66,7 @@ public void testRowCache() throws Exception
 
             cachedStore.getColumnFamily(key, path, ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1);
             assert CacheService.instance.rowCache.size() == i + 1;
-            assert cachedStore.getRawCachedRow(key) != null; // current key should be stored in the cache
+            assert cachedStore.containsCachedRow(key); // current key should be stored in the cache
 
             // checking if column is read correctly after cache
             ColumnFamily cf = cachedStore.getColumnFamily(key, path, ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1);
@@ -88,7 +88,7 @@ public void testRowCache() throws Exception
             QueryPath path = new QueryPath(COLUMN_FAMILY, null, ByteBufferUtil.bytes("col" + i));
 
             cachedStore.getColumnFamily(key, path, ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1);
-            assert cachedStore.getRawCachedRow(key) != null; // cache should be populated with the latest rows read (old ones should be popped)
+            assert cachedStore.containsCachedRow(key); // cache should be populated with the latest rows read (old ones should be popped)
 
             // checking if column is read correctly after cache
             ColumnFamily cf = cachedStore.getColumnFamily(key, path, ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1);

File: test/unit/org/apache/cassandra/net/MessageSerializer.java
Patch:
@@ -30,7 +30,7 @@ public class MessageSerializer implements IVersionedSerializer<Message>
     public void serialize(Message t, DataOutput dos, int version) throws IOException
     {
         assert t.getVersion() == version : "internode protocol version mismatch"; // indicates programmer error.
-        Header.serializer().serialize( t.header_, dos, version);
+        Header.serializer().serialize(t.header, dos, version);
         byte[] bytes = t.getMessageBody();
         dos.writeInt(bytes.length);
         dos.write(bytes);

File: src/java/org/apache/cassandra/net/IncomingTcpConnection.java
Patch:
@@ -98,7 +98,7 @@ public void run()
             {
                 // save the endpoint so gossip will reconnect to it
                 Gossiper.instance.addSavedEndpoint(from);
-                logger.info("Received " + (isStream ? "streaming " : "") + "connection from newer protocol version. Ignorning");
+                logger.info("Received " + (isStream ? "streaming " : "") + "connection from newer protocol version. Ignoring");
             }
             else if (msg != null)
             {
@@ -160,7 +160,7 @@ private Message receiveMessage(DataInputStream input, int version) throws IOExce
             MessagingService.instance().receive(message, id);
             return message;
         }
-        logger.debug("Received connection from newer protocol version {}. Ignorning message", version);
+        logger.debug("Received connection from newer protocol version {}. Ignoring message", version);
         return null;
     }
 

File: src/java/org/apache/cassandra/config/Schema.java
Patch:
@@ -462,7 +462,7 @@ public void updateVersion()
 
             for (Row row : SystemTable.serializedSchema())
             {
-                if (row.cf == null || row.cf.getColumnCount() == 0)
+                if (row.cf == null || row.cf.isMarkedForDelete() || row.cf.isEmpty())
                     continue;
 
                 row.cf.updateDigest(versionDigest);

File: src/java/org/apache/cassandra/cql/QueryProcessor.java
Patch:
@@ -332,7 +332,6 @@ private static void applyMigrationOnStage(final Migration m) throws SchemaDisagr
             public Object call() throws Exception
             {
                 m.apply();
-                m.announce();
                 return null;
             }
         });

File: src/java/org/apache/cassandra/cql3/statements/SchemaAlteringStatement.java
Patch:
@@ -129,7 +129,6 @@ private static void applyMigrationOnStage(final Migration m) throws SchemaDisagr
             public Object call() throws Exception
             {
                 m.apply();
-                m.announce();
                 return null;
             }
         });

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -920,7 +920,6 @@ private static void applyMigrationOnStage(final Migration m)
             public void runMayThrow() throws Exception
             {
                 m.apply();
-                m.announce();
             }
         });
 

File: src/java/org/apache/cassandra/db/RetriedSliceFromReadCommand.java
Patch:
@@ -53,7 +53,7 @@ public ReadCommand copy()
     }
 
     @Override
-    public int getRequestedCount()
+    public int getOriginalRequestedCount()
     {
         return originalCount;
     }

File: src/java/org/apache/cassandra/db/Memtable.java
Patch:
@@ -223,7 +223,8 @@ private void resolve(DecoratedKey key, ColumnFamily cf)
 
         if (previous == null)
         {
-            ColumnFamily empty = cf.cloneMeShallow(AtomicSortedColumns.factory(), false);
+            // AtomicSortedColumns doesn't work for super columns (see #3821)
+            ColumnFamily empty = cf.cloneMeShallow(cf.isSuper() ? ThreadSafeSortedColumns.factory() : AtomicSortedColumns.factory(), false);
             // We'll add the columns later. This avoids wasting works if we get beaten in the putIfAbsent
             previous = columnFamilies.putIfAbsent(new DecoratedKey(key.token, allocator.clone(key.key)), empty);
             if (previous == null)

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1519,11 +1519,10 @@ public void forceMajorCompaction() throws InterruptedException, ExecutionExcepti
 
     public static Iterable<ColumnFamilyStore> all()
     {
-        Iterable<ColumnFamilyStore>[] stores = new Iterable[Schema.instance.getTables().size()];
-        int i = 0;
+        List<Iterable<ColumnFamilyStore>> stores = new ArrayList<Iterable<ColumnFamilyStore>>(Schema.instance.getTables().size());
         for (Table table : Table.all())
         {
-            stores[i++] = table.getColumnFamilyStores();
+            stores.add(table.getColumnFamilyStores());
         }
         return Iterables.concat(stores);
     }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1511,11 +1511,10 @@ public void forceMajorCompaction() throws InterruptedException, ExecutionExcepti
 
     public static Iterable<ColumnFamilyStore> all()
     {
-        Iterable<ColumnFamilyStore>[] stores = new Iterable[Schema.instance.getTables().size()];
-        int i = 0;
+        List<Iterable<ColumnFamilyStore>> stores = new ArrayList<Iterable<ColumnFamilyStore>>(Schema.instance.getTables().size());
         for (Table table : Table.all())
         {
-            stores[i++] = table.getColumnFamilyStores();
+            stores.add(table.getColumnFamilyStores());
         }
         return Iterables.concat(stores);
     }

File: src/java/org/apache/cassandra/dht/RangeStreamer.java
Patch:
@@ -189,6 +189,7 @@ private static Multimap<InetAddress, Range<Token>> getRangeFetchMap(Multimap<Ran
 
                 rangeFetchMapMap.put(address, range);
                 foundSource = true;
+                break; // ensure we only stream from one other node for each range
             }
 
             if (!foundSource)

File: src/java/org/apache/cassandra/db/SuperColumn.java
Patch:
@@ -144,7 +144,7 @@ public long mostRecentLiveChangeAt()
         long max = Long.MIN_VALUE;
         for (IColumn column : getSubColumns())
         {
-            if (column.isMarkedForDelete() && column.timestamp() > max)
+            if (!column.isMarkedForDelete() && column.timestamp() > max)
             {
                 max = column.timestamp();
             }

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -155,7 +155,7 @@ private static void printUsage()
         addCmdHelp(header, "snapshot [keyspaces...] -t [snapshotName]", "Take a snapshot of the specified keyspaces using optional name snapshotName");
         addCmdHelp(header, "clearsnapshot [keyspaces...] -t [snapshotName]", "Remove snapshots for the specified keyspaces. Either remove all snapshots or remove the snapshots with the given name.");
         addCmdHelp(header, "flush [keyspace] [cfnames]", "Flush one or more column family");
-        addCmdHelp(header, "repair [keyspace] [cfnames]", "Repair one or more column family (use -rp to repair only the first range returned by the partitioner)");
+        addCmdHelp(header, "repair [keyspace] [cfnames]", "Repair one or more column family (use -pr to repair only the first range returned by the partitioner)");
         addCmdHelp(header, "cleanup [keyspace] [cfnames]", "Run cleanup on one or more column family");
         addCmdHelp(header, "compact [keyspace] [cfnames]", "Force a (major) compaction on one or more column family");
         addCmdHelp(header, "scrub [keyspace] [cfnames]", "Scrub (rebuild sstables for) one or more column family");

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -71,7 +71,7 @@ public class Table
      *
      * (Enabling fairness in the RRWL is observed to decrease throughput, so we leave it off.)
      */
-    static final ReentrantReadWriteLock switchLock = new ReentrantReadWriteLock();
+    public static final ReentrantReadWriteLock switchLock = new ReentrantReadWriteLock();
 
     // It is possible to call Table.open without a running daemon, so it makes sense to ensure
     // proper directories here as well as in CassandraDaemon.

File: src/java/org/apache/cassandra/locator/NetworkTopologyStrategy.java
Patch:
@@ -88,7 +88,7 @@ public List<InetAddress> calculateNaturalEndpoints(Token searchToken, TokenMetad
 
             // collect endpoints in this DC
             TokenMetadata dcTokens = new TokenMetadata();
-            for (Entry<Token, InetAddress> tokenEntry : tokenMetadata.entrySet())
+            for (Entry<Token, InetAddress> tokenEntry : tokenMetadata.getTokenToEndpointMapForReading().entrySet())
             {
                 if (snitch.getDatacenter(tokenEntry.getValue()).equals(dcName))
                     dcTokens.updateNormalToken(tokenEntry.getKey(), tokenEntry.getValue());

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -854,7 +854,7 @@ public List<TokenRange> describeRing(String keyspace) throws InvalidRequestExcep
 
     public Map<Token, String> getTokenToEndpointMap()
     {
-        Map<Token, InetAddress> mapInetAddress = tokenMetadata_.getTokenToEndpointMap();
+        Map<Token, InetAddress> mapInetAddress = tokenMetadata_.getNormalAndBootstrappingTokenToEndpointMap();
         Map<Token, String> mapString = new HashMap<Token, String>(mapInetAddress.size());
         for (Map.Entry<Token, InetAddress> entry : mapInetAddress.entrySet())
         {
@@ -2074,7 +2074,7 @@ public Token getBootstrapToken()
         if (token instanceof StringToken)
         {
             token = new StringToken(((String)token.token).replaceAll(VersionedValue.DELIMITER_STR, ""));
-            if (tokenMetadata_.getTokenToEndpointMap().containsKey(token))
+            if (tokenMetadata_.getNormalAndBootstrappingTokenToEndpointMap().containsKey(token))
                 throw new RuntimeException("Unable to compute unique token for new node -- specify one manually with initial_token");
         }
         return token;

File: src/java/org/apache/cassandra/locator/NetworkTopologyStrategy.java
Patch:
@@ -90,7 +90,7 @@ public List<InetAddress> calculateNaturalEndpoints(Token searchToken, TokenMetad
             // collect endpoints in this DC; add in bulk to token meta data for computational complexity
             // reasons (CASSANDRA-3831).
             Set<Pair<Token, InetAddress>> dcTokensToUpdate = new HashSet<Pair<Token, InetAddress>>();
-            for (Entry<Token, InetAddress> tokenEntry : tokenMetadata.entrySet())
+            for (Entry<Token, InetAddress> tokenEntry : tokenMetadata.getTokenToEndpointMapForReading().entrySet())
             {
                 if (snitch.getDatacenter(tokenEntry.getValue()).equals(dcName))
                     dcTokensToUpdate.add(Pair.create(tokenEntry.getKey(), tokenEntry.getValue()));

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -908,7 +908,7 @@ public List<TokenRange> describeRing(String keyspace) throws InvalidRequestExcep
 
     public Map<String, String> getTokenToEndpointMap()
     {
-        Map<Token, InetAddress> mapInetAddress = tokenMetadata_.getTokenToEndpointMap();
+        Map<Token, InetAddress> mapInetAddress = tokenMetadata_.getNormalAndBootstrappingTokenToEndpointMap();
         // in order to preserve tokens in ascending order, we use LinkedHashMap here
         Map<String, String> mapString = new LinkedHashMap<String, String>(mapInetAddress.size());
         List<Token> tokens = new ArrayList<Token>(mapInetAddress.keySet());
@@ -2102,7 +2102,7 @@ public Token getBootstrapToken()
         if (token instanceof StringToken)
         {
             token = new StringToken(((String)token.token).replaceAll(VersionedValue.DELIMITER_STR, ""));
-            if (tokenMetadata_.getTokenToEndpointMap().containsKey(token))
+            if (tokenMetadata_.getNormalAndBootstrappingTokenToEndpointMap().containsKey(token))
                 throw new RuntimeException("Unable to compute unique token for new node -- specify one manually with initial_token");
         }
         return token;
@@ -2605,7 +2605,7 @@ public void truncate(String keyspace, String columnFamily) throws UnavailableExc
 
     public Map<String, Float> getOwnership()
     {
-        List<Token> sortedTokens = new ArrayList<Token>(tokenMetadata_.getTokenToEndpointMap().keySet());
+        List<Token> sortedTokens = new ArrayList<Token>(tokenMetadata_.getTokenToEndpointMapForReading().keySet());
         Collections.sort(sortedTokens);
         Map<Token, Float> token_map = partitioner.describeOwnership(sortedTokens);
         Map<String, Float> string_map = new HashMap<String, Float>();

File: src/java/org/apache/cassandra/locator/NetworkTopologyStrategy.java
Patch:
@@ -88,7 +88,7 @@ public List<InetAddress> calculateNaturalEndpoints(Token searchToken, TokenMetad
 
             // collect endpoints in this DC
             TokenMetadata dcTokens = new TokenMetadata();
-            for (Entry<Token, InetAddress> tokenEntry : tokenMetadata.entrySet())
+            for (Entry<Token, InetAddress> tokenEntry : tokenMetadata.getTokenToEndpointMapForReading().entrySet())
             {
                 if (snitch.getDatacenter(tokenEntry.getValue()).equals(dcName))
                     dcTokens.updateNormalToken(tokenEntry.getKey(), tokenEntry.getValue());

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -854,7 +854,7 @@ public List<TokenRange> describeRing(String keyspace) throws InvalidRequestExcep
 
     public Map<Token, String> getTokenToEndpointMap()
     {
-        Map<Token, InetAddress> mapInetAddress = tokenMetadata_.getTokenToEndpointMap();
+        Map<Token, InetAddress> mapInetAddress = tokenMetadata_.getNormalAndBootstrappingTokenToEndpointMap();
         Map<Token, String> mapString = new HashMap<Token, String>(mapInetAddress.size());
         for (Map.Entry<Token, InetAddress> entry : mapInetAddress.entrySet())
         {
@@ -2074,7 +2074,7 @@ public Token getBootstrapToken()
         if (token instanceof StringToken)
         {
             token = new StringToken(((String)token.token).replaceAll(VersionedValue.DELIMITER_STR, ""));
-            if (tokenMetadata_.getTokenToEndpointMap().containsKey(token))
+            if (tokenMetadata_.getNormalAndBootstrappingTokenToEndpointMap().containsKey(token))
                 throw new RuntimeException("Unable to compute unique token for new node -- specify one manually with initial_token");
         }
         return token;

File: contrib/pig/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java
Patch:
@@ -493,7 +493,7 @@ private ByteBuffer objToBB(Object o)
         if (o instanceof java.lang.String)
             return ByteBuffer.wrap(new DataByteArray((String)o).get());
         if (o instanceof Integer)
-            return IntegerType.instance.decompose((BigInteger)o);
+            return Int32Type.instance.decompose((Integer)o);
         if (o instanceof Long)
             return LongType.instance.decompose((Long)o);
         if (o instanceof Float)

File: contrib/pig/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java
Patch:
@@ -491,7 +491,7 @@ private ByteBuffer objToBB(Object o)
         if (o == null)
             return (ByteBuffer)o;
         if (o instanceof java.lang.String)
-            return new ByteBuffer.wrap(DataByteArray((String)o).get());
+            return ByteBuffer.wrap(new DataByteArray((String)o).get());
         if (o instanceof Integer)
             return IntegerType.instance.decompose((BigInteger)o);
         if (o instanceof Long)

File: src/java/org/apache/cassandra/cql3/statements/SelectStatement.java
Patch:
@@ -329,7 +329,7 @@ private boolean isKeyRange()
 
     private Collection<ByteBuffer> getKeys(final List<ByteBuffer> variables) throws InvalidRequestException
     {
-        assert keyRestriction != null || keyRestriction.isEquality();
+        assert keyRestriction != null && keyRestriction.isEquality();
 
         List<ByteBuffer> keys = new ArrayList<ByteBuffer>(keyRestriction.eqValues.size());
         for (Term t : keyRestriction.eqValues)

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -263,7 +263,7 @@ public long getEndpointDowntime(InetAddress ep)
      * This method is part of IFailureDetectionEventListener interface. This is invoked
      * by the Failure Detector when it convicts an end point.
      *
-     * param @ endpoint end point that is convicted.
+     * @param endpoint end point that is convicted.
     */
     public void convict(InetAddress endpoint, double phi)
     {

File: src/java/org/apache/cassandra/io/compress/CompressionParameters.java
Patch:
@@ -82,7 +82,7 @@ public int chunkLength()
 
     private static Class<? extends ICompressor> parseCompressorClass(String className) throws ConfigurationException
     {
-        if (className == null)
+        if (className == null || className.isEmpty())
             return null;
 
         className = className.contains(".") ? className : "org.apache.cassandra.io.compress." + className;

File: src/java/org/apache/cassandra/tools/SSTableImport.java
Patch:
@@ -116,7 +116,7 @@ public JsonColumn(T json, CFMetaData meta, boolean isSubColumn)
                         {
                             kind = "e";
                             ttl = (Integer) fields.get(4);
-                            localExpirationTime = (int) (long) ((Long) fields.get(5));
+                            localExpirationTime = (Integer) fields.get(5);
                         }
                         else
                         {
@@ -129,7 +129,7 @@ public JsonColumn(T json, CFMetaData meta, boolean isSubColumn)
                         if (isExpiring())
                         {
                             ttl = (Integer) fields.get(4);
-                            localExpirationTime = (int) (long) ((Long) fields.get(5));
+                            localExpirationTime = (Integer) fields.get(5);
                         }
                         else if (isCounter())
                         {

File: test/unit/org/apache/cassandra/db/DefsTest.java
Patch:
@@ -31,6 +31,7 @@
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.db.marshal.BytesType;
 import org.apache.cassandra.db.marshal.UTF8Type;
+import org.apache.cassandra.db.marshal.TimeUUIDType;
 import org.apache.cassandra.db.migration.AddColumnFamily;
 import org.apache.cassandra.db.migration.AddKeyspace;
 import org.apache.cassandra.db.migration.DropColumnFamily;
@@ -534,7 +535,7 @@ public void testUpdateColumnFamilyNoIndexes() throws ConfigurationException, IOE
         oldStr = cf_def.comparator_type;
         try 
         {
-            cf_def.comparator_type = BytesType.class.getSimpleName();
+            cf_def.comparator_type = TimeUUIDType.class.getSimpleName();
             cf.apply(cf_def);
             throw new AssertionError("Should have blown up when you used a different comparator.");
         }
@@ -605,4 +606,4 @@ private CFMetaData addTestCF(String ks, String cf, String comment)
 
         return newCFMD;
     }
-}
\ No newline at end of file
+}

File: src/java/org/apache/cassandra/db/HintedHandOffManager.java
Patch:
@@ -391,7 +391,9 @@ private void scheduleAllDeliveries()
         {
             Token<?> token = StorageService.getPartitioner().getTokenFactory().fromByteArray(row.key.key);
             InetAddress target = StorageService.instance.getTokenMetadata().getEndpoint(token);
-            scheduleHintDelivery(target);
+            // token may have since been removed (in which case we have just read back a tombstone)
+            if (target != null)
+                scheduleHintDelivery(target);
         }
 
         if (logger_.isDebugEnabled())

File: src/java/org/apache/cassandra/hadoop/BulkRecordWriter.java
Patch:
@@ -91,9 +91,9 @@ final class BulkRecordWriter extends RecordWriter<ByteBuffer,List<Mutation>>
 
     private String getOutputLocation() throws IOException
     {
-        String dir = conf.get(OUTPUT_LOCATION, conf.get("mapred.local.dir"));
+        String dir = conf.get(OUTPUT_LOCATION, System.getProperty("java.io.tmpdir"));
         if (dir == null)
-            throw new IOException("Output directory not defined, if hadoop is not setting mapred.local.dir then define " + OUTPUT_LOCATION);
+            throw new IOException("Output directory not defined, if hadoop is not setting java.io.tmpdir then define " + OUTPUT_LOCATION);
         return dir;
     }
 

File: src/java/org/apache/cassandra/db/SystemTable.java
Patch:
@@ -138,7 +138,7 @@ private static void purgeIncompatibleHints() throws IOException
      */
     public static synchronized void updateToken(InetAddress ep, Token token)
     {
-        if (ep == FBUtilities.getLocalAddress())
+        if (ep == FBUtilities.getBroadcastAddress())
         {
             removeToken(token);
             return;

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -1095,7 +1095,7 @@ public void maybeInitializeLocalState(int generationNbr)
      */
     public void addSavedEndpoint(InetAddress ep)
     {
-        if (ep == FBUtilities.getLocalAddress())
+        if (ep == FBUtilities.getBroadcastAddress())
         {
             logger.debug("Attempt to add self as saved endpoint");
             return;

File: src/java/org/apache/cassandra/service/MigrationManager.java
Patch:
@@ -54,7 +54,7 @@ public class MigrationManager implements IEndpointStateChangeSubscriber
     // avoids re-pushing migrations that we're waiting on target to apply already
     private static Map<InetAddress,UUID> lastPushed = new MapMaker().expiration(1, TimeUnit.MINUTES).makeMap();
     
-    private static UUID highestKnown;
+    private static volatile UUID highestKnown;
 
     public void onJoin(InetAddress endpoint, EndpointState epState) { 
         VersionedValue value = epState.getApplicationState(ApplicationState.SCHEMA);

File: src/java/org/apache/cassandra/db/SystemTable.java
Patch:
@@ -138,7 +138,7 @@ private static void purgeIncompatibleHints() throws IOException
      */
     public static synchronized void updateToken(InetAddress ep, Token token)
     {
-        if (ep == FBUtilities.getBroadcastAddress())
+        if (ep == FBUtilities.getLocalAddress())
         {
             removeToken(token);
             return;

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -1095,7 +1095,7 @@ public void maybeInitializeLocalState(int generationNbr)
      */
     public void addSavedEndpoint(InetAddress ep)
     {
-        if (ep == FBUtilities.getBroadcastAddress())
+        if (ep == FBUtilities.getLocalAddress())
         {
             logger.debug("Attempt to add self as saved endpoint");
             return;

File: src/java/org/apache/cassandra/service/MigrationManager.java
Patch:
@@ -54,7 +54,7 @@ public class MigrationManager implements IEndpointStateChangeSubscriber
     // avoids re-pushing migrations that we're waiting on target to apply already
     private static Map<InetAddress,UUID> lastPushed = new MapMaker().expiration(1, TimeUnit.MINUTES).makeMap();
     
-    private static volatile UUID highestKnown;
+    private static UUID highestKnown;
 
     public void onJoin(InetAddress endpoint, EndpointState epState) { 
         VersionedValue value = epState.getApplicationState(ApplicationState.SCHEMA);

File: src/java/org/apache/cassandra/db/SystemTable.java
Patch:
@@ -143,7 +143,7 @@ private static void purgeIncompatibleHints() throws IOException
      */
     public static synchronized void updateToken(InetAddress ep, Token token)
     {
-        if (ep == FBUtilities.getLocalAddress())
+        if (ep == FBUtilities.getBroadcastAddress())
         {
             removeToken(token);
             return;

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -1090,7 +1090,7 @@ public void maybeInitializeLocalState(int generationNbr)
      */
     public void addSavedEndpoint(InetAddress ep)
     {
-        if (ep == FBUtilities.getLocalAddress())
+        if (ep == FBUtilities.getBroadcastAddress())
         {
             logger.debug("Attempt to add self as saved endpoint");
             return;

File: src/java/org/apache/cassandra/db/SystemTable.java
Patch:
@@ -143,7 +143,7 @@ private static void purgeIncompatibleHints() throws IOException
      */
     public static synchronized void updateToken(InetAddress ep, Token token)
     {
-        if (ep == FBUtilities.getLocalAddress())
+        if (ep == FBUtilities.getBroadcastAddress())
         {
             removeToken(token);
             return;

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -1090,7 +1090,7 @@ public void maybeInitializeLocalState(int generationNbr)
      */
     public void addSavedEndpoint(InetAddress ep)
     {
-        if (ep == FBUtilities.getLocalAddress())
+        if (ep == FBUtilities.getBroadcastAddress())
         {
             logger.debug("Attempt to add self as saved endpoint");
             return;

File: src/java/org/apache/cassandra/db/SystemTable.java
Patch:
@@ -138,7 +138,7 @@ private static void purgeIncompatibleHints() throws IOException
      */
     public static synchronized void updateToken(InetAddress ep, Token token)
     {
-        if (ep == FBUtilities.getLocalAddress())
+        if (ep == FBUtilities.getBroadcastAddress())
         {
             removeToken(token);
             return;

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -1095,7 +1095,7 @@ public void maybeInitializeLocalState(int generationNbr)
      */
     public void addSavedEndpoint(InetAddress ep)
     {
-        if (ep == FBUtilities.getLocalAddress())
+        if (ep == FBUtilities.getBroadcastAddress())
         {
             logger.debug("Attempt to add self as saved endpoint");
             return;

File: src/java/org/apache/cassandra/service/MigrationManager.java
Patch:
@@ -54,7 +54,7 @@ public class MigrationManager implements IEndpointStateChangeSubscriber
     // avoids re-pushing migrations that we're waiting on target to apply already
     private static Map<InetAddress,UUID> lastPushed = new MapMaker().expiration(1, TimeUnit.MINUTES).makeMap();
     
-    private static UUID highestKnown;
+    private static volatile UUID highestKnown;
 
     public void onJoin(InetAddress endpoint, EndpointState epState) { 
         VersionedValue value = epState.getApplicationState(ApplicationState.SCHEMA);

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -48,6 +48,7 @@
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.WrappedRunnable;
+import org.cliffc.high_scale_lib.NonBlockingHashSet;
 
 /*
  * Commit Log tracks every write operation into the system. The aim
@@ -170,7 +171,7 @@ public boolean accept(File dir, String name)
     // returns the number of replayed mutation (useful for tests in particular)
     public static int recover(File[] clogs) throws IOException
     {
-        final Set<Table> tablesRecovered = new HashSet<Table>();
+        final Set<Table> tablesRecovered = new NonBlockingHashSet<Table>();
         List<Future<?>> futures = new ArrayList<Future<?>>();
         byte[] bytes = new byte[4096];
         Map<Integer, AtomicInteger> invalidMutations = new HashMap<Integer, AtomicInteger>();

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1305,6 +1305,7 @@ public static void calculatePendingRanges(AbstractReplicationStrategy strategy,
                 for (Range<Token> range : strategy.getAddressRanges(allLeftMetadata).get(endpoint))
                     pendingRanges.put(range, endpoint);
                 allLeftMetadata.removeEndpoint(endpoint);
+            }
         }
 
         // At this stage pendingRanges has been updated according to leaving and bootstrapping nodes.

File: src/java/org/apache/cassandra/cql3/statements/CFStatement.java
Patch:
@@ -26,7 +26,7 @@
 /**
  * Abstract class for statements that apply on a given column family.
  */
-public abstract class CFStatement extends CQLStatement
+public abstract class CFStatement extends ParsedStatement
 {
     protected final CFName cfName;
 

File: src/java/org/apache/cassandra/cql3/statements/CreateColumnFamilyStatement.java
Patch:
@@ -137,7 +137,7 @@ public CFMetaData getCFMetaData() throws InvalidRequestException
         return newCFMD;
     }
 
-    public static class RawStatement extends CFStatement implements Preprocessable
+    public static class RawStatement extends CFStatement
     {
         private final Map<ColumnIdentifier, String> definitions = new HashMap<ColumnIdentifier, String>();
         private final CFPropDefs properties = new CFPropDefs();
@@ -156,7 +156,7 @@ public RawStatement(CFName name)
         /**
          * Transform this raw statement into a CreateColumnFamilyStatement.
          */
-        public CreateColumnFamilyStatement preprocess() throws InvalidRequestException
+        public ParsedStatement.Prepared prepare() throws InvalidRequestException
         {
             try
             {
@@ -238,7 +238,7 @@ else if (keyAliases.size() > 1)
                     stmt.defaultValidator = CFDefinition.definitionType;
                 }
 
-                return stmt;
+                return new ParsedStatement.Prepared(stmt);
             }
             catch (ConfigurationException e)
             {

File: src/java/org/apache/cassandra/cql3/statements/ModificationStatement.java
Patch:
@@ -38,7 +38,7 @@
 /**
  * Abstract class for statements that apply on a given column family.
  */
-public abstract class ModificationStatement extends CFStatement
+public abstract class ModificationStatement extends CFStatement implements CQLStatement
 {
     public static final ConsistencyLevel defaultConsistency = ConsistencyLevel.ONE;
 

File: src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java
Patch:
@@ -397,7 +397,7 @@ public ResourceSchema getSchema(String location, Job job) throws IOException
             tupleFields.add(colSchema);
 
             valSchema = new ResourceFieldSchema();
-            validator = validators.get(cdef.getName());
+            validator = validators.get(ByteBuffer.wrap(cdef.getName()));
             if (validator == null)
                 validator = marshallers.get(1);
             valSchema.setName("value");

File: src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
Patch:
@@ -461,7 +461,7 @@ private void maybeInit()
                 }
                     
                 // nothing new? reached the end
-                if (lastRow != null && (rows.get(0).key.equals(lastRow.key) || rows.get(0).columns.get(0).column.equals(startColumn)))
+                if (lastRow != null && (rows.get(0).key.equals(lastRow.key) || rows.get(0).columns.get(0).column.name.equals(startColumn)))
                 {
                     rows = null;
                     return;

File: src/java/org/apache/cassandra/db/index/keys/KeysSearcher.java
Patch:
@@ -162,7 +162,7 @@ protected Row computeNext()
                             columnsRead--;
                             logger.debug("Skipping {}", baseCfs.metadata.getKeyValidator().getString(firstColumn.name()));
                         }
-                        else if (range instanceof Range && indexColumns.hasNext() && firstColumn.equals(startKey))
+                        else if (range instanceof Range && indexColumns.hasNext() && firstColumn.name().equals(startKey))
                         {
                             // skip key excluded by range
                             indexColumns.next();

File: contrib/pig/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java
Patch:
@@ -373,7 +373,7 @@ public ResourceSchema getSchema(String location, Job job) throws IOException
             tupleFields.add(colSchema);
 
             valSchema = new ResourceFieldSchema();
-            validator = validators.get(cdef.getName());
+            validator = validators.get(ByteBuffer.wrap(cdef.getName()));
             if (validator == null)
                 validator = marshallers.get(1);
             valSchema.setName("value");

File: src/java/org/apache/cassandra/cli/CliMain.java
Patch:
@@ -57,7 +57,6 @@ public class CliMain
      */
     public static void connect(String server, int port)
     {
-
         TSocket socket = new TSocket(server, port);
 
         if (transport != null)
@@ -258,7 +257,6 @@ public static void main(String args[]) throws IOException
             catch (RuntimeException e)
             {
                 sessionState.err.println(e.getMessage());
-                System.exit(-1);
             }
         }
         

File: test/unit/org/apache/cassandra/dht/RangeTest.java
Patch:
@@ -179,9 +179,9 @@ public void testIntersectsWrapping()
         assert not.intersects(twowrap);
     }
 
-    static void assertIntersection(Range one, Range two, Range ... ranges)
+    static <T extends RingPosition> void assertIntersection(Range one, Range two, Range<T> ... ranges)
     {
-        Set<Range> correct = Range.rangeSet(ranges);
+        Set<Range<T>> correct = Range.rangeSet(ranges);
         Set<Range> result1 = one.intersectionWith(two);
         assert result1.equals(correct) : String.format("%s != %s",
                                                        StringUtils.join(result1, ","),

File: src/java/org/apache/cassandra/cql/QueryProcessor.java
Patch:
@@ -750,6 +750,7 @@ else if (oldKeyspace == null)
             case CREATE_KEYSPACE:
                 CreateKeyspaceStatement create = (CreateKeyspaceStatement)statement.statement;
                 create.validate();
+                ThriftValidation.validateKeyspaceNotSystem(create.getName());
                 clientState.hasKeyspaceSchemaAccess(Permission.WRITE);
                 validateSchemaAgreement();
                 
@@ -893,6 +894,7 @@ else if (oldKeyspace == null)
 
             case DROP_KEYSPACE:
                 String deleteKeyspace = (String)statement.statement;
+                ThriftValidation.validateKeyspaceNotSystem(deleteKeyspace);
                 clientState.hasKeyspaceSchemaAccess(Permission.WRITE);
                 validateSchemaAgreement();
                 

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -925,6 +925,7 @@ public synchronized String system_add_keyspace(KsDef ks_def)
     throws InvalidRequestException, SchemaDisagreementException, TException
     {
         logger.debug("add_keyspace");
+        ThriftValidation.validateKeyspaceNotSystem(ks_def.name);
         state().hasKeyspaceSchemaAccess(Permission.WRITE);
         validateSchemaAgreement();
         ThriftValidation.validateKeyspaceNotYetExisting(ks_def.name);
@@ -971,6 +972,7 @@ public synchronized String system_drop_keyspace(String keyspace)
     throws InvalidRequestException, SchemaDisagreementException, TException
     {
         logger.debug("drop_keyspace");
+        ThriftValidation.validateKeyspaceNotSystem(keyspace);
         state().hasKeyspaceSchemaAccess(Permission.WRITE);
         validateSchemaAgreement();
         
@@ -999,6 +1001,7 @@ public synchronized String system_update_keyspace(KsDef ks_def)
     throws InvalidRequestException, SchemaDisagreementException, TException
     {
         logger.debug("update_keyspace");
+        ThriftValidation.validateKeyspaceNotSystem(ks_def.name);
         state().hasKeyspaceSchemaAccess(Permission.WRITE);
         ThriftValidation.validateTable(ks_def.name);
         if (ks_def.getCf_defs() != null && ks_def.getCf_defs().size() > 0)

File: src/java/org/apache/cassandra/service/ClientState.java
Patch:
@@ -124,7 +124,7 @@ public void hasKeyspaceSchemaAccess(Permission perm) throws InvalidRequestExcept
         validateLogin();
         
         // hardcode disallowing messing with system keyspace
-        if (keyspace.equalsIgnoreCase(Table.SYSTEM_TABLE) && perm == Permission.WRITE)
+        if (keyspace != null && keyspace.equalsIgnoreCase(Table.SYSTEM_TABLE) && perm == Permission.WRITE)
             throw new InvalidRequestException("system keyspace is not user-modifiable");
 
         resourceClear();

File: src/java/org/apache/cassandra/service/ClientState.java
Patch:
@@ -141,7 +141,7 @@ public void hasKeyspaceSchemaAccess(Permission perm) throws InvalidRequestExcept
         validateLogin();
         
         // hardcode disallowing messing with system keyspace
-        if (keyspace.equalsIgnoreCase(Table.SYSTEM_TABLE) && perm == Permission.WRITE)
+        if (keyspace != null && keyspace.equalsIgnoreCase(Table.SYSTEM_TABLE) && perm == Permission.WRITE)
             throw new InvalidRequestException("system keyspace is not user-modifiable");
 
         resourceClear();

File: src/java/org/apache/cassandra/io/sstable/SSTableLoader.java
Patch:
@@ -50,7 +50,7 @@ public class SSTableLoader
     public SSTableLoader(File directory, Client client, OutputHandler outputHandler)
     {
         this.directory = directory;
-        this.keyspace = directory.getName();
+        this.keyspace = directory.getParentFile().getName();
         this.client = client;
         this.outputHandler = outputHandler;
     }

File: src/java/org/apache/cassandra/db/index/keys/KeysSearcher.java
Patch:
@@ -160,7 +160,7 @@ protected Row computeNext()
                             // skip the row we already saw w/ the last page of results
                             indexColumns.next();
                             columnsRead--;
-                            logger.debug("Skipping {}", baseCfs.getComparator().getString(firstColumn.name()));
+                            logger.debug("Skipping {}", baseCfs.metadata.getKeyValidator().getString(firstColumn.name()));
                         }
                         else if (range instanceof Range && indexColumns.hasNext() && firstColumn.equals(startKey))
                         {

File: src/java/org/apache/cassandra/cql/jdbc/AbstractJdbcType.java
Patch:
@@ -36,4 +36,5 @@ public abstract class AbstractJdbcType<T>
     public abstract Class<T> getType();
     public abstract int getJdbcType();
     public abstract T compose(ByteBuffer bytes);
+    public abstract ByteBuffer decompose(T obj);
 }

File: src/java/org/apache/cassandra/db/marshal/BytesType.java
Patch:
@@ -40,7 +40,7 @@ public ByteBuffer compose(ByteBuffer bytes)
 
     public ByteBuffer decompose(ByteBuffer value)
     {
-        return value;
+        return JdbcBytes.instance.decompose(value);
     }
     
     public int compare(ByteBuffer o1, ByteBuffer o2)

File: src/java/org/apache/cassandra/db/marshal/CounterColumnType.java
Patch:
@@ -20,12 +20,10 @@
  */
 package org.apache.cassandra.db.marshal;
 
-import java.net.InetAddress;
 import java.nio.ByteBuffer;
 
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.utils.ByteBufferUtil;
-import org.apache.cassandra.utils.HeapAllocator;
 
 public class CounterColumnType extends AbstractCommutativeType
 {

File: src/java/org/apache/cassandra/db/marshal/DateType.java
Patch:
@@ -47,11 +47,9 @@ public Date compose(ByteBuffer bytes)
     
     public ByteBuffer decompose(Date value)
     {
-      return (value==null) ? ByteBufferUtil.EMPTY_BYTE_BUFFER
-                           : ByteBufferUtil.bytes(value.getTime());
+        return JdbcDate.instance.decompose(value);
     }
     
-
     public int compare(ByteBuffer o1, ByteBuffer o2)
     {
         if (o1.remaining() == 0)

File: src/java/org/apache/cassandra/db/marshal/DoubleType.java
Patch:
@@ -38,9 +38,8 @@ public Double compose(ByteBuffer bytes)
     
     public ByteBuffer decompose(Double value)
     {
-        return (value==null) ? ByteBufferUtil.EMPTY_BYTE_BUFFER : ByteBufferUtil.bytes(value);
-    }
-    
+        return JdbcDouble.instance.decompose(value);
+    }    
 
     public int compare(ByteBuffer o1, ByteBuffer o2)
     {

File: src/java/org/apache/cassandra/db/marshal/FloatType.java
Patch:
@@ -39,9 +39,8 @@ public Float compose(ByteBuffer bytes)
     
     public ByteBuffer decompose(Float value)
     {
-        return (value==null) ? ByteBufferUtil.EMPTY_BYTE_BUFFER : ByteBufferUtil.bytes(value);
-    }
-    
+        return JdbcFloat.instance.decompose(value);
+    }    
 
     public int compare(ByteBuffer o1, ByteBuffer o2)
     {

File: src/java/org/apache/cassandra/db/marshal/Int32Type.java
Patch:
@@ -34,12 +34,12 @@ public class Int32Type extends AbstractType<Integer>
 
     public Integer compose(ByteBuffer bytes)
     {
-        return ByteBufferUtil.toInt(bytes);
+        return JdbcInt32.instance.compose(bytes);
     }
 
     public ByteBuffer decompose(Integer value)
     {
-        return ByteBufferUtil.bytes(value);
+        return JdbcInt32.instance.decompose(value);
     }
 
     public int compare(ByteBuffer o1, ByteBuffer o2)

File: src/java/org/apache/cassandra/db/marshal/IntegerType.java
Patch:
@@ -64,7 +64,7 @@ public BigInteger compose(ByteBuffer bytes)
 
     public ByteBuffer decompose(BigInteger value)
     {
-        return ByteBuffer.wrap(value.toByteArray());
+        return JdbcInteger.instance.decompose(value);
     }
 
     public int compare(ByteBuffer lhs, ByteBuffer rhs)

File: src/java/org/apache/cassandra/db/marshal/LexicalUUIDType.java
Patch:
@@ -41,7 +41,7 @@ public UUID compose(ByteBuffer bytes)
 
     public ByteBuffer decompose(UUID value)
     {
-        return ByteBuffer.wrap(UUIDGen.decompose(value));
+        return JdbcLexicalUUID.instance.decompose(value);
     }
 
     public int compare(ByteBuffer o1, ByteBuffer o2)

File: src/java/org/apache/cassandra/db/marshal/LongType.java
Patch:
@@ -34,12 +34,12 @@ public class LongType extends AbstractType<Long>
 
     public Long compose(ByteBuffer bytes)
     {
-        return ByteBufferUtil.toLong(bytes);
+        return JdbcLong.instance.compose(bytes);
     }
 
     public ByteBuffer decompose(Long value)
     {
-        return ByteBufferUtil.bytes(value);
+        return JdbcLong.instance.decompose(value);
     }
 
     public int compare(ByteBuffer o1, ByteBuffer o2)

File: src/java/org/apache/cassandra/db/marshal/TimeUUIDType.java
Patch:
@@ -49,7 +49,7 @@ public UUID compose(ByteBuffer bytes)
 
     public ByteBuffer decompose(UUID value)
     {
-        return ByteBuffer.wrap(UUIDGen.decompose(value));
+        return JdbcTimeUUID.instance.decompose(value);
     }
 
     public int compare(ByteBuffer o1, ByteBuffer o2)

File: src/java/org/apache/cassandra/db/marshal/UUIDType.java
Patch:
@@ -187,7 +187,7 @@ public String getString(ByteBuffer bytes)
 
     public ByteBuffer decompose(UUID value)
     {
-        return ByteBuffer.wrap(UUIDGen.decompose(value));
+        return JdbcUUID.instance.decompose(value);
     }
 
     @Override

File: test/unit/org/apache/cassandra/SchemaLoader.java
Patch:
@@ -92,11 +92,11 @@ public static Collection<KSMetaData> schemaDefinition() throws ConfigurationExce
         ColumnFamilyType su = ColumnFamilyType.Super;
         AbstractType bytes = BytesType.instance;
 
-        AbstractType composite = CompositeType.getInstance(Arrays.asList(new AbstractType[]{BytesType.instance, TimeUUIDType.instance, IntegerType.instance}));
-        Map<Byte, AbstractType> aliases = new HashMap<Byte, AbstractType>();
+        AbstractType<?> composite = CompositeType.getInstance(Arrays.asList(new AbstractType<?>[]{BytesType.instance, TimeUUIDType.instance, IntegerType.instance}));
+        Map<Byte, AbstractType<?>> aliases = new HashMap<Byte, AbstractType<?>>();
         aliases.put((byte)'b', BytesType.instance);
         aliases.put((byte)'t', TimeUUIDType.instance);
-        AbstractType dynamicComposite = DynamicCompositeType.getInstance(aliases);
+        AbstractType<?> dynamicComposite = DynamicCompositeType.getInstance(aliases);
       
         // these column definitions will will be applied to the jdbc utf and integer column familes respectively.
         Map<ByteBuffer, ColumnDefinition> integerColumn = new HashMap<ByteBuffer, ColumnDefinition>();

File: test/unit/org/apache/cassandra/db/marshal/CompositeTypeTest.java
Patch:
@@ -42,7 +42,7 @@ public class CompositeTypeTest extends CleanupHelper
     private static final CompositeType comparator;
     static
     {
-        List<AbstractType> subComparators = new ArrayList<AbstractType>();
+        List<AbstractType<?>> subComparators = new ArrayList<AbstractType<?>>();
         subComparators.add(BytesType.instance);
         subComparators.add(TimeUUIDType.instance);
         subComparators.add(IntegerType.instance);

File: test/unit/org/apache/cassandra/db/marshal/DynamicCompositeTypeTest.java
Patch:
@@ -42,7 +42,7 @@ public class DynamicCompositeTypeTest extends CleanupHelper
     private static final DynamicCompositeType comparator;
     static
     {
-        Map<Byte, AbstractType> aliases = new HashMap<Byte, AbstractType>();
+        Map<Byte, AbstractType<?>> aliases = new HashMap<Byte, AbstractType<?>>();
         aliases.put((byte)'b', BytesType.instance);
         aliases.put((byte)'t', TimeUUIDType.instance);
         comparator = DynamicCompositeType.getInstance(aliases);

File: src/java/org/apache/cassandra/config/Schema.java
Patch:
@@ -215,7 +215,7 @@ public ColumnFamilyType getColumnFamilyType(String ksName, String cfName)
      *
      * @return The comparator of the ColumnFamily
      */
-    public AbstractType getComparator(String ksName, String cfName)
+    public AbstractType<?> getComparator(String ksName, String cfName)
     {
         assert ksName != null;
         CFMetaData cfmd = getCFMetaData(ksName, cfName);
@@ -232,7 +232,7 @@ public AbstractType getComparator(String ksName, String cfName)
      *
      * @return The subComparator of the ColumnFamily
      */
-    public AbstractType getSubComparator(String ksName, String cfName)
+    public AbstractType<?> getSubComparator(String ksName, String cfName)
     {
         assert ksName != null;
         return getCFMetaData(ksName, cfName).subcolumnComparator;
@@ -247,7 +247,7 @@ public AbstractType getSubComparator(String ksName, String cfName)
      *
      * @return value validator specific to the column or default (per-cf) one
      */
-    public AbstractType getValueValidator(String ksName, String cfName, ByteBuffer column)
+    public AbstractType<?> getValueValidator(String ksName, String cfName, ByteBuffer column)
     {
         return getCFMetaData(ksName, cfName).getValueValidator(column);
     }

File: src/java/org/apache/cassandra/db/AbstractColumnContainer.java
Patch:
@@ -69,7 +69,7 @@ public int getLocalDeletionTime()
         return columns.getDeletionInfo().localDeletionTime;
     }
 
-    public AbstractType getComparator()
+    public AbstractType<?> getComparator()
     {
         return columns.getComparator();
     }

File: src/java/org/apache/cassandra/db/AbstractThreadUnsafeSortedColumns.java
Patch:
@@ -58,7 +58,7 @@ public void retainAll(ISortedColumns columns)
         Iterator<IColumn> toRetain = columns.iterator();
         IColumn current = iter.hasNext() ? iter.next() : null;
         IColumn retain = toRetain.hasNext() ? toRetain.next() : null;
-        AbstractType comparator = getComparator();
+        AbstractType<?> comparator = getComparator();
         while (current != null && retain != null)
         {
             int c = comparator.compare(current.name(), retain.name());

File: src/java/org/apache/cassandra/db/ArrayBackedSortedColumns.java
Patch:
@@ -47,7 +47,7 @@ public ISortedColumns create(AbstractType<?> comparator, boolean insertReversed)
 
         public ISortedColumns fromSorted(SortedMap<ByteBuffer, IColumn> sortedMap, boolean insertReversed)
         {
-            return new ArrayBackedSortedColumns(sortedMap.values(), (AbstractType)sortedMap.comparator(), insertReversed);
+            return new ArrayBackedSortedColumns(sortedMap.values(), (AbstractType<?>)sortedMap.comparator(), insertReversed);
         }
     };
 

File: src/java/org/apache/cassandra/db/AtomicSortedColumns.java
Patch:
@@ -84,7 +84,7 @@ private AtomicSortedColumns(Holder holder)
 
     public AbstractType<?> getComparator()
     {
-        return (AbstractType)ref.get().map.comparator();
+        return (AbstractType<?>)ref.get().map.comparator();
     }
 
     public ISortedColumns.Factory getFactory()

File: src/java/org/apache/cassandra/db/Column.java
Patch:
@@ -244,7 +244,7 @@ public IColumn localCopy(ColumnFamilyStore cfs, Allocator allocator)
         return new Column(cfs.internOrCopy(name, allocator), allocator.clone(value), timestamp);
     }
 
-    public String getString(AbstractType comparator)
+    public String getString(AbstractType<?> comparator)
     {
         StringBuilder sb = new StringBuilder();
         sb.append(comparator.getString(name));
@@ -264,14 +264,14 @@ public boolean isLive()
 
     protected void validateName(CFMetaData metadata) throws MarshalException
     {
-        AbstractType nameValidator = metadata.cfType == ColumnFamilyType.Super ? metadata.subcolumnComparator : metadata.comparator;
+        AbstractType<?> nameValidator = metadata.cfType == ColumnFamilyType.Super ? metadata.subcolumnComparator : metadata.comparator;
         nameValidator.validate(name());
     }
 
     public void validateFields(CFMetaData metadata) throws MarshalException
     {
         validateName(metadata);
-        AbstractType valueValidator = metadata.getValueValidator(name());
+        AbstractType<?> valueValidator = metadata.getValueValidator(name());
         if (valueValidator != null)
             valueValidator.validate(value());
     }

File: src/java/org/apache/cassandra/db/ColumnFamily.java
Patch:
@@ -93,7 +93,7 @@ public ColumnFamily cloneMeShallow()
         return cloneMeShallow(columns.getFactory(), columns.isInsertReversed());
     }
 
-    public AbstractType getSubComparator()
+    public AbstractType<?> getSubComparator()
     {
         IColumnSerializer s = getColumnSerializer();
         return (s instanceof SuperColumnSerializer) ? ((SuperColumnSerializer) s).getComparator() : null;
@@ -292,7 +292,7 @@ public void updateDigest(MessageDigest digest)
             column.updateDigest(digest);
     }
 
-    public static AbstractType getComparatorFor(String table, String columnFamilyName, ByteBuffer superColumnName)
+    public static AbstractType<?> getComparatorFor(String table, String columnFamilyName, ByteBuffer superColumnName)
     {
         return superColumnName == null
                ? Schema.instance.getComparator(table, columnFamilyName)

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1351,7 +1351,7 @@ public List<Row> filter(AbstractScanIterator rowIterator, ExtendedFilter filter)
          }
     }
 
-    public AbstractType getComparator()
+    public AbstractType<?> getComparator()
     {
         return metadata.comparator;
     }

File: src/java/org/apache/cassandra/db/CounterColumn.java
Patch:
@@ -208,7 +208,7 @@ public IColumn localCopy(ColumnFamilyStore cfs, Allocator allocator)
     }
 
     @Override
-    public String getString(AbstractType comparator)
+    public String getString(AbstractType<?> comparator)
     {
         StringBuilder sb = new StringBuilder();
         sb.append(comparator.getString(name));

File: src/java/org/apache/cassandra/db/ExpiringColumn.java
Patch:
@@ -145,7 +145,7 @@ public IColumn localCopy(ColumnFamilyStore cfs, Allocator allocator)
     }
     
     @Override
-    public String getString(AbstractType comparator)
+    public String getString(AbstractType<?> comparator)
     {
         StringBuilder sb = new StringBuilder();
         sb.append(super.getString(comparator));

File: src/java/org/apache/cassandra/db/IColumn.java
Patch:
@@ -51,7 +51,7 @@ public interface IColumn
     public IColumn reconcile(IColumn column, Allocator allocator);
     public void updateDigest(MessageDigest digest);
     public int getLocalDeletionTime(); // for tombstone GC, so int is sufficient granularity
-    public String getString(AbstractType comparator);
+    public String getString(AbstractType<?> comparator);
     public void validateFields(CFMetaData metadata) throws MarshalException;
 
     /** clones the column for the row cache, interning column names and making copies of other underlying byte buffers */

File: src/java/org/apache/cassandra/db/IColumnContainer.java
Patch:
@@ -46,7 +46,7 @@ public interface IColumnContainer
     public long getMarkedForDeleteAt();
     public boolean hasExpiredTombstones(int gcBefore);
 
-    public AbstractType getComparator();
+    public AbstractType<?> getComparator();
 
     public Collection<IColumn> getSortedColumns();
 }

File: src/java/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -87,7 +87,7 @@ public String getColumnFamilyName()
 
     public abstract Row getRow(Table table) throws IOException;
 
-    protected AbstractType getComparator()
+    protected AbstractType<?> getComparator()
     {
         return ColumnFamily.getComparatorFor(table, getColumnFamilyName(), queryPath.superColumnName);
     }

File: src/java/org/apache/cassandra/db/ReadVerbHandler.java
Patch:
@@ -18,14 +18,12 @@
 
 package org.apache.cassandra.db;
 
-import java.io.ByteArrayOutputStream;
 import java.io.DataInputStream;
 import java.io.IOException;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.io.util.FastByteArrayInputStream;
 import org.apache.cassandra.net.IVerbHandler;
 import org.apache.cassandra.net.Message;

File: src/java/org/apache/cassandra/db/TreeMapBackedSortedColumns.java
Patch:
@@ -53,7 +53,7 @@ public static ISortedColumns.Factory factory()
 
     public AbstractType<?> getComparator()
     {
-        return (AbstractType)map.comparator();
+        return (AbstractType<?>)map.comparator();
     }
 
     private TreeMapBackedSortedColumns(AbstractType<?> comparator)

File: src/java/org/apache/cassandra/db/columniterator/IndexedSliceReader.java
Patch:
@@ -30,7 +30,6 @@
 
 import com.google.common.collect.AbstractIterator;
 
-import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.db.ColumnFamily;
 import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.db.IColumn;
@@ -58,7 +57,7 @@ class IndexedSliceReader extends AbstractIterator<IColumn> implements IColumnIte
 
     private BlockFetcher fetcher;
     private Deque<IColumn> blockColumns = new ArrayDeque<IColumn>();
-    private AbstractType comparator;
+    private AbstractType<?> comparator;
 
     public IndexedSliceReader(SSTableReader sstable, FileDataInput input, ByteBuffer startColumn, ByteBuffer finishColumn, boolean reversed)
     {

File: src/java/org/apache/cassandra/db/columniterator/SSTableNamesIterator.java
Patch:
@@ -155,7 +155,7 @@ private void readIndexedColumns(CFMetaData metadata, FileDataInput file, SortedS
         file.readInt(); // column count
 
         /* get the various column ranges we have to read */
-        AbstractType comparator = metadata.comparator;
+        AbstractType<?> comparator = metadata.comparator;
         SortedSet<IndexHelper.IndexInfo> ranges = new TreeSet<IndexHelper.IndexInfo>(IndexHelper.getComparator(comparator, false));
         for (ByteBuffer name : filteredColumnNames)
         {

File: src/java/org/apache/cassandra/db/columniterator/SimpleSliceReader.java
Patch:
@@ -41,7 +41,7 @@ class SimpleSliceReader extends AbstractIterator<IColumn> implements IColumnIter
 {
     private final FileDataInput file;
     private final ByteBuffer finishColumn;
-    private final AbstractType comparator;
+    private final AbstractType<?> comparator;
     private final ColumnFamily emptyColumnFamily;
     private final int columns;
     private int i;

File: src/java/org/apache/cassandra/db/compaction/LazilyCompactedRow.java
Patch:
@@ -170,7 +170,7 @@ public int getEstimatedColumnCount()
         return n;
     }
 
-    public AbstractType getComparator()
+    public AbstractType<?> getComparator()
     {
         return emptyColumnFamily.getComparator();
     }

File: src/java/org/apache/cassandra/db/filter/IFilter.java
Patch:
@@ -72,7 +72,7 @@ public interface IFilter
      */
     public abstract SuperColumn filterSuperColumn(SuperColumn superColumn, int gcBefore);
 
-    public Comparator<IColumn> getColumnComparator(AbstractType comparator);
+    public Comparator<IColumn> getColumnComparator(AbstractType<?> comparator);
 
     public boolean isReversed();
     public void updateColumnsLimit(int newLimit);

File: src/java/org/apache/cassandra/db/filter/NamesQueryFilter.java
Patch:
@@ -87,7 +87,7 @@ public void collectReducedColumns(IColumnContainer container, Iterator<IColumn>
         }
     }
 
-    public Comparator<IColumn> getColumnComparator(AbstractType comparator)
+    public Comparator<IColumn> getColumnComparator(AbstractType<?> comparator)
     {
         return comparator.columnComparator;
     }

File: src/java/org/apache/cassandra/db/filter/QueryFilter.java
Patch:
@@ -187,7 +187,7 @@ public static QueryFilter getNamesFilter(DecoratedKey<?> key, QueryPath path, So
         return new QueryFilter(key, path, new NamesQueryFilter(columns));
     }
 
-    public static IFilter getFilter(SlicePredicate predicate, AbstractType comparator)
+    public static IFilter getFilter(SlicePredicate predicate, AbstractType<?> comparator)
     {
         if (predicate.column_names != null)
         {

File: src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
Patch:
@@ -102,15 +102,15 @@ public SuperColumn filterSuperColumn(SuperColumn superColumn, int gcBefore)
         return scFiltered;
     }
 
-    public Comparator<IColumn> getColumnComparator(AbstractType comparator)
+    public Comparator<IColumn> getColumnComparator(AbstractType<?> comparator)
     {
         return reversed ? comparator.columnReverseComparator : comparator.columnComparator;
     }
 
     public void collectReducedColumns(IColumnContainer container, Iterator<IColumn> reducedColumns, int gcBefore)
     {
         int liveColumns = 0;
-        AbstractType comparator = container.getComparator();
+        AbstractType<?> comparator = container.getComparator();
 
         while (reducedColumns.hasNext())
         {

File: src/java/org/apache/cassandra/db/index/keys/KeysIndex.java
Patch:
@@ -63,7 +63,7 @@ public void init()
                                                              indexedCfMetadata);
     }
 
-    public static AbstractType indexComparator()
+    public static AbstractType<?> indexComparator()
     {
         IPartitioner rowPartitioner = StorageService.getPartitioner();
         return (rowPartitioner instanceof OrderPreservingPartitioner || rowPartitioner instanceof ByteOrderedPartitioner)

File: src/java/org/apache/cassandra/db/index/keys/KeysSearcher.java
Patch:
@@ -21,9 +21,7 @@
 import java.nio.ByteBuffer;
 import java.util.*;
 
-import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.*;
-import org.apache.cassandra.db.columniterator.IColumnIterator;
 import org.apache.cassandra.db.filter.*;
 import org.apache.cassandra.db.index.SecondaryIndex;
 import org.apache.cassandra.db.index.SecondaryIndexManager;
@@ -33,7 +31,6 @@
 import org.apache.cassandra.thrift.IndexExpression;
 import org.apache.cassandra.thrift.IndexOperator;
 import org.apache.cassandra.utils.ByteBufferUtil;
-import org.apache.cassandra.utils.HeapAllocator;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: src/java/org/apache/cassandra/db/marshal/AbstractType.java
Patch:
@@ -144,7 +144,7 @@ public boolean isCommutative()
         return false;
     }
 
-    public static AbstractType parseDefaultParameters(AbstractType baseType, TypeParser parser) throws ConfigurationException
+    public static AbstractType<?> parseDefaultParameters(AbstractType<?> baseType, TypeParser parser) throws ConfigurationException
     {
         Map<String, String> parameters = parser.getKeyValueParameters();
         String reversed = parameters.get("reversed");

File: src/java/org/apache/cassandra/dht/LocalPartitioner.java
Patch:
@@ -30,9 +30,9 @@
 
 public class LocalPartitioner extends AbstractPartitioner<LocalToken>
 {
-    private final AbstractType comparator;
+    private final AbstractType<?> comparator;
 
-    public LocalPartitioner(AbstractType comparator)
+    public LocalPartitioner(AbstractType<?> comparator)
     {
         this.comparator = comparator;
     }

File: src/java/org/apache/cassandra/dht/LocalToken.java
Patch:
@@ -26,9 +26,9 @@ public class LocalToken extends Token<ByteBuffer>
 {
     static final long serialVersionUID = 8437543776403014875L;
 
-    private final AbstractType comparator;
+    private final AbstractType<?> comparator;
 
-    public LocalToken(AbstractType comparator, ByteBuffer token)
+    public LocalToken(AbstractType<?> comparator, ByteBuffer token)
     {
         super(token);
         this.comparator = comparator;

File: src/java/org/apache/cassandra/hadoop/BulkRecordWriter.java
Patch:
@@ -75,7 +75,7 @@ final class BulkRecordWriter extends RecordWriter<ByteBuffer,List<Mutation>>
         File outputdir = new File(getOutputLocation() + File.separator + keyspace); //dir must be named by ks for the loader
         outputdir.mkdirs();
         this.isSuper = Boolean.valueOf(conf.get(IS_SUPERCF));
-        AbstractType subcomparator = null;
+        AbstractType<?> subcomparator = null;
         if (isSuper)
             subcomparator = BytesType.instance;
         this.writer = new SSTableSimpleUnsortedWriter(
@@ -184,7 +184,7 @@ public void init(String keyspace)
 
                     for (TokenRange tr : tokenRanges)
                     {
-                        Range range = new Range(tkFactory.fromString(tr.start_token), tkFactory.fromString(tr.end_token));
+                        Range<Token> range = new Range<Token>(tkFactory.fromString(tr.start_token), tkFactory.fromString(tr.end_token));
                         for (String ep : tr.endpoints)
                         {
                             addRangeForEndpoint(range, InetAddress.getByName(ep));

File: src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
Patch:
@@ -225,8 +225,8 @@ private class RowIterator extends AbstractIterator<Pair<ByteBuffer, SortedMap<By
         private String startToken;
         private int totalRead = 0;
         private int i = 0;
-        private final AbstractType comparator;
-        private final AbstractType subComparator;
+        private final AbstractType<?> comparator;
+        private final AbstractType<?> subComparator;
         private final IPartitioner partitioner;
 
         private RowIterator()

File: src/java/org/apache/cassandra/io/sstable/IndexHelper.java
Patch:
@@ -152,7 +152,7 @@ public static Filter defreezeBloomFilter(FileDataInput file, long maxSize, boole
      *
      * @return int index
      */
-    public static int indexFor(ByteBuffer name, List<IndexInfo> indexList, AbstractType comparator, boolean reversed)
+    public static int indexFor(ByteBuffer name, List<IndexInfo> indexList, AbstractType<?> comparator, boolean reversed)
     {
         if (name.remaining() == 0 && reversed)
             return indexList.size() - 1;
@@ -174,7 +174,7 @@ first slot where firstName > start ([20..25] here), so we subtract an extra one
         return index < 0 ? -index - (reversed ? 2 : 1) : index;
     }
 
-    public static Comparator<IndexInfo> getComparator(final AbstractType nameComparator, boolean reversed)
+    public static Comparator<IndexInfo> getComparator(final AbstractType<?> nameComparator, boolean reversed)
     {
         return reversed ? nameComparator.indexReverseComparator : nameComparator.indexComparator;
     }

File: src/java/org/apache/cassandra/io/sstable/SSTableSimpleUnsortedWriter.java
Patch:
@@ -70,8 +70,8 @@ public class SSTableSimpleUnsortedWriter extends AbstractSSTableSimpleWriter
     public SSTableSimpleUnsortedWriter(File directory,
                                        String keyspace,
                                        String columnFamily,
-                                       AbstractType comparator,
-                                       AbstractType subComparator,
+                                       AbstractType<?> comparator,
+                                       AbstractType<?> subComparator,
                                        int bufferSizeInMB) throws IOException
     {
         super(directory, new CFMetaData(keyspace, columnFamily, subComparator == null ? ColumnFamilyType.Standard : ColumnFamilyType.Super, comparator, subComparator));

File: src/java/org/apache/cassandra/io/sstable/SSTableSimpleWriter.java
Patch:
@@ -20,7 +20,6 @@
 
 import java.io.File;
 import java.io.IOException;
-import java.nio.ByteBuffer;
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.db.*;
@@ -52,8 +51,8 @@ public class SSTableSimpleWriter extends AbstractSSTableSimpleWriter
     public SSTableSimpleWriter(File directory,
                                String keyspace,
                                String columnFamily,
-                               AbstractType comparator,
-                               AbstractType subComparator) throws IOException
+                               AbstractType<?> comparator,
+                               AbstractType<?> subComparator) throws IOException
     {
         this(directory,
              new CFMetaData(keyspace, columnFamily, subComparator == null ? ColumnFamilyType.Standard : ColumnFamilyType.Super, comparator, subComparator));

File: src/java/org/apache/cassandra/io/util/IIterableColumns.java
Patch:
@@ -28,5 +28,5 @@ public interface IIterableColumns extends Iterable<IColumn>
 {
     public int getEstimatedColumnCount();
 
-    AbstractType getComparator();
+    AbstractType<?> getComparator();
 }

File: src/java/org/apache/cassandra/tools/SSTableImport.java
Patch:
@@ -98,7 +98,7 @@ public JsonColumn(T json, CFMetaData meta, boolean isSubColumn)
         {
             if (json instanceof List)
             {
-                AbstractType comparator = (isSubColumn) ? meta.subcolumnComparator : meta.comparator;
+                AbstractType<?> comparator = (isSubColumn) ? meta.subcolumnComparator : meta.comparator;
                 List fields = (List<?>) json;
 
                 assert fields.size() >= 3 : "Column definition should have at least 3";
@@ -221,7 +221,7 @@ private static void addToSuperCF(Map<?, ?> row, ColumnFamily cfamily)
         CFMetaData metaData = cfamily.metadata();
         assert metaData != null;
 
-        AbstractType comparator = metaData.comparator;
+        AbstractType<?> comparator = metaData.comparator;
 
         // Super columns
         for (Map.Entry<?, ?> entry : row.entrySet())
@@ -516,7 +516,7 @@ public static void setKeyCountToImport(Integer keyCount)
      * @param type type to use for conversion
      * @return byte buffer representation of the given string
      */
-    private static ByteBuffer stringAsType(String content, AbstractType type)
+    private static ByteBuffer stringAsType(String content, AbstractType<?> type)
     {
         try
         {

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -392,7 +392,7 @@ public static CFMetaData fromAvro(org.apache.cassandra.db.migration.avro.CfDef c
 
         try
         {
-            caching = Caching.fromString(cf.caching.toString());
+            caching = cf.caching == null ? Caching.KEYS_ONLY : Caching.fromString(cf.caching.toString());
         }
         catch (ConfigurationException e)
         {

File: src/java/org/apache/cassandra/db/AbstractColumnContainer.java
Patch:
@@ -102,7 +102,7 @@ public void maybeResetDeletionTimes(int gcBefore)
             // Stop if either we don't need to change the deletion info (it's
             // still MIN_VALUE or not expired yet) or we've succesfully changed it
             if (current.localDeletionTime == Integer.MIN_VALUE
-                || current.localDeletionTime > gcBefore
+                || current.localDeletionTime >= gcBefore
                 || deletionInfo.compareAndSet(current, new DeletionInfo()))
             {
                 break;

File: src/java/org/apache/cassandra/db/filter/QueryFilter.java
Patch:
@@ -155,7 +155,7 @@ public static boolean isRelevant(IColumn column, IColumnContainer container, int
         // and if its container is deleted, the column must be changed more recently than the container tombstone (2)
         // (since otherwise, the only thing repair cares about is the container tombstone)
         long maxChange = column.mostRecentLiveChangeAt();
-        return (!column.isMarkedForDelete() || column.getLocalDeletionTime() > gcBefore || maxChange > column.getMarkedForDeleteAt()) // (1)
+        return (!column.isMarkedForDelete() || column.getLocalDeletionTime() >= gcBefore || maxChange > column.getMarkedForDeleteAt()) // (1)
                && (!container.isMarkedForDelete() || maxChange > container.getMarkedForDeleteAt()); // (2)
     }
 

File: src/java/org/apache/cassandra/cql/QueryProcessor.java
Patch:
@@ -412,7 +412,7 @@ public static void validateKeyAlias(CFMetaData cfm, String key) throws InvalidRe
         assert key.toUpperCase().equals(key); // should always be uppercased by caller
         String realKeyAlias = bufferToString(cfm.getKeyName()).toUpperCase();
         if (!realKeyAlias.equals(key))
-            throw new InvalidRequestException(String.format("Expected key '%s' to be present in WHERE clause for '%s'", key, cfm.cfName));
+            throw new InvalidRequestException(String.format("Expected key '%s' to be present in WHERE clause for '%s'", realKeyAlias, cfm.cfName));
     }
 
     private static void validateColumnNames(Iterable<ByteBuffer> columns)

File: src/java/org/apache/cassandra/db/HintedHandOffManager.java
Patch:
@@ -346,7 +346,8 @@ private void scheduleAllDeliveries()
 
         ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_TABLE).getColumnFamilyStore(HINTS_CF);
         IPartitioner p = StorageService.getPartitioner();
-        Range range = new Range(p.getMinimumToken(), p.getMinimumToken(), p);
+        RowPosition minPos = p.getMinimumToken().minKeyBound();
+        Range<RowPosition> range = new Range<RowPosition>(minPos, minPos, p);
         IFilter filter = new NamesQueryFilter(ImmutableSortedSet.<ByteBuffer>of());
         List<Row> rows = hintStore.getRangeSlice(null, range, Integer.MAX_VALUE, filter, null);
         for (Row row : rows)

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -529,7 +529,7 @@ public void waitForStreaming() throws InterruptedException
             {
                 for (DebuggableThreadPoolExecutor e : streamExecutors.values())
                 {
-                    e.shutdown()
+                    e.shutdown();
                     if (!e.isTerminated())
                     {
                         stillWaiting = true;

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -465,6 +465,7 @@ public void register(ILatencySubscriber subcriber)
 
     public void waitForStreaming() throws InterruptedException
     {
+        streamExecutor_.shutdown();
         streamExecutor_.awaitTermination(24, TimeUnit.HOURS);
     }
 

File: src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
Patch:
@@ -87,7 +87,7 @@ public void clearEndpointCache()
      * get the (possibly cached) endpoints that should store the given Token.
      * Note that while the endpoints are conceptually a Set (no duplicates will be included),
      * we return a List to avoid an extra allocation when sorting by proximity later
-     * @param searchToken the token the natural endpoints are requested for
+     * @param searchPosition the position the natural endpoints are requested for
      * @return a copy of the natural endpoints for the given token
      */
     public ArrayList<InetAddress> getNaturalEndpoints(RingPosition searchPosition)
@@ -109,7 +109,7 @@ public ArrayList<InetAddress> getNaturalEndpoints(RingPosition searchPosition)
     /**
      * calculate the natural endpoints for the given token
      *
-     * @see #getNaturalEndpoints(org.apache.cassandra.dht.Token)
+     * @see #getNaturalEndpoints(org.apache.cassandra.dht.RingPosition)
      *
      * @param searchToken the token the natural endpoints are requested for
      * @return a copy of the natural endpoints for the given token

File: src/java/org/apache/cassandra/scheduler/IRequestScheduler.java
Patch:
@@ -32,7 +32,7 @@ public interface IRequestScheduler
      * 
      * @param t Thread handing the request
      * @param id    Scheduling parameter, an id to distinguish profiles (users/keyspace)
-     * @param timeout   The max time in milliseconds to spend blocking for a slot
+     * @param timeoutMS   The max time in milliseconds to spend blocking for a slot
      */
     public void queue(Thread t, String id, long timeoutMS) throws TimeoutException;
 

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -43,7 +43,7 @@ public interface CassandraDaemon
     
     /**
      * Start the Cassandra Daemon, assuming that it has already been
-     * initialized, via either {@link #init(String[])} or
+     * initialized, via either {@link CassandraDaemon#init(String[])} or
      * {@link #load(String[])}.
      * 
      * @throws IOException

File: src/java/org/apache/cassandra/utils/BloomFilterSerializer.java
Patch:
@@ -68,7 +68,7 @@ public BloomFilter deserialize(DataInput dis) throws IOException
 
     /**
      * Calculates a serialized size of the given Bloom Filter
-     * @see this.serialize(BloomFilter, DataOutput)
+     * @see BloomFilterSerializer#serialize(BloomFilter, DataOutput)
      *
      * @param bf Bloom filter to calculate serialized size
      *

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -913,8 +913,6 @@ private void executeIncr(Tree statement, long multiplier)
         String columnFamily = CliCompiler.getColumnFamily(columnFamilySpec, keyspacesMap.get(keySpace).cf_defs);
         ByteBuffer key = getKeyAsBytes(columnFamily, columnFamilySpec.getChild(1));
         int columnSpecCnt = CliCompiler.numColumnSpecifiers(columnFamilySpec);
-        CfDef cfDef = getCfDef(columnFamily);
-        boolean isSuper = cfDef.column_type.equals("Super");
         
         byte[] superColumnName = null;
         ByteBuffer columnName;

File: src/java/org/apache/cassandra/db/ArrayBackedSortedColumns.java
Patch:
@@ -181,7 +181,7 @@ private int binarySearch(ByteBuffer name)
         while (low <= high)
         {
             mid = (low + high) >> 1;
-            if ((result = -compare(get(mid).name(), name)) > 0)
+            if ((result = compare(name, get(mid).name())) > 0)
             {
                 low = mid + 1;
             }

File: src/java/org/apache/cassandra/db/ColumnFamily.java
Patch:
@@ -258,16 +258,19 @@ public long maxTimestamp()
         return maxTimestamp;
     }
 
+    @Override
     public int hashCode()
     {
         throw new RuntimeException("Not implemented.");
     }
 
+    @Override
     public boolean equals(Object o)
     {
         throw new RuntimeException("Not implemented.");
     }
 
+    @Override
     public String toString()
     {
         StringBuilder sb = new StringBuilder("ColumnFamily(");

File: src/java/org/apache/cassandra/db/RowIteratorFactory.java
Patch:
@@ -90,7 +90,6 @@ public boolean apply(IColumnIterator row)
             iterators.add(scanner);
         }
 
-        final Memtable firstMemtable = memtables.iterator().next();
         // reduce rows from all sources into a single row
         return MergeIterator.get(iterators, COMPARE_BY_KEY, new MergeIterator.Reducer<IColumnIterator, Row>()
         {

File: src/java/org/apache/cassandra/db/compaction/SizeTieredCompactionStrategy.java
Patch:
@@ -35,7 +35,7 @@ public class SizeTieredCompactionStrategy extends AbstractCompactionStrategy
     private static final Logger logger = LoggerFactory.getLogger(SizeTieredCompactionStrategy.class);
     protected static final long DEFAULT_MIN_SSTABLE_SIZE = 50L * 1024L * 1024L;
     protected static final String MIN_SSTABLE_SIZE_KEY = "min_sstable_size";
-    protected static long minSSTableSize;
+    protected long minSSTableSize;
     protected volatile int estimatedRemainingTasks;
 
     public SizeTieredCompactionStrategy(ColumnFamilyStore cfs, Map<String, String> options)

File: src/java/org/apache/cassandra/db/marshal/AbstractType.java
Patch:
@@ -89,7 +89,7 @@ public int compare(ByteBuffer o1, ByteBuffer o2)
                     return 1;
                 }
 
-                return -AbstractType.this.compare(o1, o2);
+                return AbstractType.this.compare(o2, o1);
             }
         };
     }

File: src/java/org/apache/cassandra/db/marshal/DynamicCompositeType.java
Patch:
@@ -248,7 +248,7 @@ public void serializeComparator(ByteBuffer bb)
         {
             int header = 0;
             if (isAlias)
-                header = 0x8000 | ((byte)comparatorName.charAt(0));
+                header = 0x8000 | (((byte)comparatorName.charAt(0)) & 0xFF);
             else
                 header = comparatorName.length();
             putShortLength(bb, header);

File: src/java/org/apache/cassandra/db/marshal/ReversedType.java
Patch:
@@ -69,7 +69,7 @@ public int compare(ByteBuffer o1, ByteBuffer o2)
             return 1;
         }
 
-        return -baseType.compare(o1, o2);
+        return baseType.compare(o2, o1);
     }
 
     public String getString(ByteBuffer bytes)

File: src/java/org/apache/cassandra/dht/LocalToken.java
Patch:
@@ -24,8 +24,6 @@
 
 public class LocalToken extends Token<ByteBuffer>
 {
-    static final long serialVersionUID = 8437543776403014875L;
-
     private final AbstractType comparator;
 
     public LocalToken(AbstractType comparator, ByteBuffer token)

File: src/java/org/apache/cassandra/dht/Token.java
Patch:
@@ -30,7 +30,7 @@
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
-public abstract class Token<T> implements RingPosition<Token<T>>, Serializable
+public abstract class Token<T> implements RingPosition<Token<T>>
 {
     private static final long serialVersionUID = 1L;
 

File: src/java/org/apache/cassandra/io/compress/CompressionMetadata.java
Patch:
@@ -258,7 +258,7 @@ public void resetAndTruncate(int chunkIndex) throws IOException
     /**
      * Holds offset and length of the file chunk
      */
-    public class Chunk
+    public static class Chunk
     {
         public final long offset;
         public final int length;

File: src/java/org/apache/cassandra/service/AntiEntropyService.java
Patch:
@@ -595,7 +595,7 @@ public String toString()
      * Triggers repairs with all neighbors for the given table, cfs and range.
      * Typical lifecycle is: start() then join(). Executed in client threads.
      */
-    class RepairSession extends WrappedRunnable implements IEndpointStateChangeSubscriber, IFailureDetectionEventListener
+    static class RepairSession extends WrappedRunnable implements IEndpointStateChangeSubscriber, IFailureDetectionEventListener
     {
         private final String sessionName;
         private final String tablename;

File: src/java/org/apache/cassandra/streaming/FileStreamTask.java
Patch:
@@ -185,7 +185,7 @@ private void receiveReply() throws IOException
         assert MessagingService.getBits(msheader, 3, 1) == 0 : "Stream received before stream reply";
         int version = MessagingService.getBits(msheader, 15, 8);
 
-        int totalSize = input.readInt();
+        input.readInt(); // Read total size
         String id = input.readUTF();
         Header header = Header.serializer().deserialize(input, version);
 

File: src/java/org/apache/cassandra/utils/FBUtilities.java
Patch:
@@ -414,7 +414,7 @@ public int compare(DecoratedKey o1, DecoratedKey o2)
                         // both tokens are on the same side of the wrap point
                         return o1.compareTo(o2);
                     }
-                    return -o1.compareTo(o2);
+                    return o2.compareTo(o1);
                 }
             };
             Collections.sort(keys, comparator);

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1313,7 +1313,6 @@ private ColumnFamily getTopLevelColumns(QueryFilter filter, int gcBefore, boolea
       * @return true if we found all keys we were looking for, otherwise false
      */
     public List<Row> getRangeSlice(ByteBuffer superColumn, final AbstractBounds range, int maxResults, IFilter columnFilter)
-    throws ExecutionException, InterruptedException
     {
         assert range instanceof Bounds
                || (!((Range)range).isWrapAround() || range.right.equals(StorageService.getPartitioner().getMinimumToken()))

File: src/java/org/apache/cassandra/db/RowMutation.java
Patch:
@@ -112,7 +112,7 @@ public ColumnFamily getColumnFamily(Integer cfId)
      * The format is the following:
      *
      * HintsColumnFamily: {        // cf
-     *   <dest ip>: {              // key
+     *   <dest token>: {           // key
      *     <uuid>: {               // super-column
      *       table: <table>        // columns
      *       key: <key>

File: src/java/org/apache/cassandra/service/StorageServiceMBean.java
Patch:
@@ -300,9 +300,6 @@ public interface StorageServiceMBean
      */
     public void truncate(String keyspace, String columnFamily) throws UnavailableException, TimeoutException, IOException;
 
-    /** force hint delivery to an endpoint **/
-    public void deliverHints(String host) throws UnknownHostException;
-
     /** save row and key caches */
     public void saveCaches() throws ExecutionException, InterruptedException;
 

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -1431,7 +1431,7 @@ private void executeDropIndex(Tree statement) throws TException, SchemaDisagreem
     }
 
     // TRUNCATE <columnFamily>
-    private void executeTruncate(String columnFamily) throws TException, InvalidRequestException, UnavailableException
+    private void executeTruncate(String columnFamily) throws TException, InvalidRequestException, UnavailableException, TimedOutException
     {
         if (!CliMain.isConnected() || !hasKeySpace())
             return;

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -157,7 +157,7 @@ private static void printUsage()
         addCmdHelp(header, "cleanup [keyspace] [cfnames]", "Run cleanup on one or more column family");
         addCmdHelp(header, "compact [keyspace] [cfnames]", "Force a (major) compaction on one or more column family");
         addCmdHelp(header, "scrub [keyspace] [cfnames]", "Scrub (rebuild sstables for) one or more column family");
-        addCmdHelp(header, "upgradesstables [keyspace] [cfnames]", "Scrub (rebuild sstables for) one or more column family");
+        addCmdHelp(header, "upgradesstables [keyspace] [cfnames]", "Upgrade sstables for one or more column family");
         addCmdHelp(header, "invalidatekeycache [keyspace] [cfnames]", "Invalidate the key cache of one or more column family");
         addCmdHelp(header, "invalidaterowcache [keyspace] [cfnames]", "Invalidate the key cache of one or more column family");
         addCmdHelp(header, "getcompactionthreshold <keyspace> <cfname>", "Print min and max compaction thresholds for a given column family");

File: src/java/org/apache/cassandra/service/ClientState.java
Patch:
@@ -43,7 +43,7 @@
  */
 public class ClientState
 {
-    private static final int MAX_CACHE_PREPARED = 50;   // Ridiculously large, right?
+    private static final int MAX_CACHE_PREPARED = 10000;    // Enough to keep buggy clients from OOM'ing us
     private static Logger logger = LoggerFactory.getLogger(ClientState.class);
 
     // Current user for the session
@@ -53,7 +53,7 @@ public class ClientState
     private final List<Object> resource = new ArrayList<Object>();
 
     // An LRU map of prepared statements
-    private Map<Integer, CQLStatement> prepared = new HashMap<Integer, CQLStatement>() {
+    private Map<Integer, CQLStatement> prepared = new LinkedHashMap<Integer, CQLStatement>(16, 0.75f, true) {
         protected boolean removeEldestEntry(Map.Entry<Integer, CQLStatement> eldest) {
             return size() > MAX_CACHE_PREPARED;
         }

File: src/java/org/apache/cassandra/cql/DeleteStatement.java
Patch:
@@ -92,8 +92,7 @@ public RowMutation mutationForKey(ByteBuffer key, String keyspace, Long timestam
         CFMetaData metadata = validateColumnFamily(keyspace, columnFamily);
         QueryProcessor.validateKeyAlias(metadata, keyName);
 
-        @SuppressWarnings("rawtypes")
-        AbstractType comparator = metadata.getComparatorFor(null);
+        AbstractType<?> comparator = metadata.getComparatorFor(null);
 
         if (columns.size() < 1)
         {

File: src/java/org/apache/cassandra/cql/QueryProcessor.java
Patch:
@@ -203,15 +203,15 @@ private static List<org.apache.cassandra.db.Row> multiRangeSlice(CFMetaData meta
         // if start key was set and relation was "greater than"
         if (select.getKeyStart() != null && !select.includeStartKey() && !rows.isEmpty())
         {
-            if (rows.get(0).key.key.equals(startKey))
+            if (rows.get(0).key.key.equals(startKeyBytes))
                 rows.remove(0);
         }
 
         // if finish key was set and relation was "less than"
         if (select.getKeyFinish() != null && !select.includeFinishKey() && !rows.isEmpty())
         {
             int lastIndex = rows.size() - 1;
-            if (rows.get(lastIndex).key.key.equals(finishKey))
+            if (rows.get(lastIndex).key.key.equals(finishKeyBytes))
                 rows.remove(lastIndex);
         }
 

File: src/java/org/apache/cassandra/db/SystemTable.java
Patch:
@@ -100,7 +100,7 @@ public static void purgeIncompatibleHints() throws IOException
      */
     public static synchronized void updateToken(InetAddress ep, Token token)
     {
-        if (ep == FBUtilities.getBroadcastAddress())
+        if (ep == FBUtilities.getLocalAddress())
             return;
         IPartitioner p = StorageService.getPartitioner();
         ColumnFamily cf = ColumnFamily.create(Table.SYSTEM_TABLE, STATUS_CF);

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -995,7 +995,7 @@ public void maybeInitializeLocalState(int generationNbr)
      */
     public void addSavedEndpoint(InetAddress ep)
     {
-        if (ep == FBUtilities.getBroadcastAddress())
+        if (ep == FBUtilities.getLocalAddress())
         {
             logger.debug("Attempt to add self as saved endpoint");
             return;

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -387,7 +387,7 @@ public synchronized void initServer() throws IOException, org.apache.cassandra.c
             logger_.info("Loading persisted ring state");
             for (Map.Entry<Token, InetAddress> entry : SystemTable.loadTokens().entrySet())
             {
-                if (entry.getValue() == FBUtilities.getBroadcastAddress())
+                if (entry.getValue() == FBUtilities.getLocalAddress())
                 {
                     // entry has been mistakenly added, delete it
                     SystemTable.removeToken(entry.getKey());

File: src/java/org/apache/cassandra/thrift/ThriftValidation.java
Patch:
@@ -732,7 +732,9 @@ public static void validateKeyspaceNotYetExisting(String newKsName) throws Inval
         for (String ksName : Schema.instance.getTables())
         {
             if (ksName.equalsIgnoreCase(newKsName))
-                throw new InvalidRequestException("Keyspace names must be case-insensitively unique");
+                throw new InvalidRequestException(String.format("Keyspace names must be case-insensitively unique (\"%s\" conflicts with \"%s\")",
+                                                                newKsName,
+                                                                ksName));
         }
     }
 }

File: test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java
Patch:
@@ -260,7 +260,7 @@ private void assertIndexQueryWorks(ColumnFamilyStore indexedCFS)
         IndexExpression expr = new IndexExpression(ByteBufferUtil.bytes("birthdate"), IndexOperator.EQ, ByteBufferUtil.bytes(1L));
         IndexClause clause = new IndexClause(Arrays.asList(expr), ByteBufferUtil.EMPTY_BYTE_BUFFER, 100);
         IPartitioner p = StorageService.getPartitioner();
-        Range range = new Range(p.getMinimumToken(), p.getMinimumToken());
+        Range<RowPosition> range = Util.range("", "");
         List<Row> rows = indexedCFS.search(clause, range, new IdentityQueryFilter());
         assert rows.size() == 1;
     }

File: src/java/org/apache/cassandra/cql/CreateColumnFamilyStatement.java
Patch:
@@ -313,7 +313,8 @@ public CFMetaData getCFMetaData(String keyspace) throws InvalidRequestException
                    .columnMetadata(getColumns(comparator))
                    .keyValidator(TypeParser.parse(comparators.get(getKeyType())))
                    .rowCacheProvider(FBUtilities.newCacheProvider(getPropertyString(KW_ROW_CACHE_PROVIDER, CFMetaData.DEFAULT_ROW_CACHE_PROVIDER)))
-                   .keyAlias(keyAlias);
+                   .keyAlias(keyAlias)
+                   .validate();
         }
         catch (ConfigurationException e)
         {

File: src/java/org/apache/cassandra/cql/QueryProcessor.java
Patch:
@@ -153,13 +153,13 @@ private static List<org.apache.cassandra.db.Row> multiRangeSlice(CFMetaData meta
 
         ByteBuffer startKeyBytes = (select.getKeyStart() != null)
                                    ? select.getKeyStart().getByteBuffer(keyType)
-                                   : (new Term()).getByteBuffer();
+                                   : null;
 
         ByteBuffer finishKeyBytes = (select.getKeyFinish() != null)
                                     ? select.getKeyFinish().getByteBuffer(keyType)
-                                    : (new Term()).getByteBuffer();
+                                    : null;
 
-        RowPosition startKey = p.decorateKey(startKeyBytes), finishKey = p.decorateKey(finishKeyBytes);
+        RowPosition startKey = RowPosition.forKey(startKeyBytes, p), finishKey = RowPosition.forKey(finishKeyBytes, p);
         if (startKey.compareTo(finishKey) > 0 && !finishKey.isMinimum(p))
         {
             if (p instanceof RandomPartitioner)

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -810,7 +810,7 @@ public static List<Row> getRangeSlice(RangeSliceCommand command, ConsistencyLeve
     throws IOException, UnavailableException, TimeoutException
     {
         if (logger.isDebugEnabled())
-            logger.debug(command.toString());
+            logger.debug("Command/ConsistencyLevel is {}/{}", command.toString(), consistency_level);
         long startTime = System.nanoTime();
         List<Row> rows;
         // now scan until we have enough results

File: tools/stress/src/org/apache/cassandra/stress/Session.java
Patch:
@@ -316,7 +316,7 @@ else if (replicationStrategy.endsWith("SimpleStrategy"))
                 try
                 {
                     // validate compaction strategy class
-                    CFMetaData.createCompactionSrategy(compactionStrategy);
+                    CFMetaData.createCompactionStrategy(compactionStrategy);
                 }
                 catch (ConfigurationException e)
                 {

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -230,7 +230,7 @@ private ColumnFamilyStore(Table table, String columnFamilyName, IPartitioner par
         data = new DataTracker(this);
         Set<DecoratedKey> savedKeys = keyCache.readSaved();
         Set<Map.Entry<Descriptor, Set<Component>>> entries = files(table.name, columnFamilyName, false, false).entrySet();
-        data.addSSTables(SSTableReader.batchOpen(entries, savedKeys, data, metadata, this.partitioner));
+        data.addInitialSSTables(SSTableReader.batchOpen(entries, savedKeys, data, metadata, this.partitioner));
 
         // compaction strategy should be created after the CFS has been prepared
         this.compactionStrategy = metadata.createCompactionStrategyInstance(this);
@@ -916,7 +916,7 @@ public boolean isKeyInRemainingSSTables(DecoratedKey key, Set<? extends SSTable>
     public void addSSTable(SSTableReader sstable)
     {
         assert sstable.getColumnFamilyName().equals(columnFamily);
-        data.addStreamedSSTable(sstable);
+        data.addSSTables(Arrays.asList(sstable));
         CompactionManager.instance.submitBackground(this);
     }
 
@@ -971,6 +971,7 @@ public void sstablesRewrite() throws ExecutionException, InterruptedException
 
     public void markCompacted(Collection<SSTableReader> sstables)
     {
+        assert !sstables.isEmpty();
         data.markCompacted(sstables);
     }
 

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -937,7 +937,8 @@ public void runMayThrow() throws InterruptedException, IOException
                             if (!sstable.newSince(truncatedAt))
                                 truncatedSSTables.add(sstable);
                         }
-                        cfs.markCompacted(truncatedSSTables);
+                        if (!truncatedSSTables.isEmpty())
+                            cfs.markCompacted(truncatedSSTables);
                     }
                 }
                 finally

File: src/java/org/apache/cassandra/db/compaction/LeveledManifest.java
Patch:
@@ -153,9 +153,10 @@ private int skipLevels(int newLevel, Iterable<SSTableReader> added)
 
     public synchronized void promote(Iterable<SSTableReader> removed, Iterable<SSTableReader> added)
     {
+        assert !Iterables.isEmpty(removed); // use add() instead of promote when adding new sstables
         logDistribution();
         if (logger.isDebugEnabled())
-            logger.debug((Iterables.isEmpty(added) ? "Removing [" : "Replacing [") + toString(removed) + "]");
+            logger.debug("Replacing [" + toString(removed) + "]");
 
         // the level for the added sstables is the max of the removed ones,
         // plus one if the removed were all on the same level

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -2497,7 +2497,8 @@ private byte[] subColumnNameAsByteArray(String superColumn, CfDef cfDef)
     private ByteBuffer columnValueAsBytes(ByteBuffer columnName, String columnFamilyName, String columnValue)
     {
         CfDef columnFamilyDef = getCfDef(columnFamilyName);
-        
+        AbstractType defaultValidator = getFormatType(columnFamilyDef.default_validation_class);
+
         for (ColumnDef columnDefinition : columnFamilyDef.getColumn_metadata())
         {
             byte[] currentColumnName = columnDefinition.getName();
@@ -2516,8 +2517,7 @@ private ByteBuffer columnValueAsBytes(ByteBuffer columnName, String columnFamily
             }
         }
 
-        // if no validation were set returning simple .getBytes()
-        return ByteBufferUtil.bytes(columnValue);
+        return defaultValidator.fromString(columnValue);
     }
 
     /**

File: tools/stress/src/org/apache/cassandra/stress/operations/Inserter.java
Patch:
@@ -52,9 +52,9 @@ public void run(Cassandra.Client client) throws IOException
 
         for (int i = 0; i < session.getColumnsPerKey(); i++)
         {
-            String columnName = ("C" + Integer.toString(i));
-            ByteBuffer columnValue = values.get(i % values.size());
-            columns.add(new Column(ByteBufferUtil.bytes(columnName)).setValue(columnValue).setTimestamp(System.currentTimeMillis()));
+            columns.add(new Column(columnName(i, session.timeUUIDComparator))
+                                .setValue(values.get(i % values.size()))
+                                .setTimestamp(System.currentTimeMillis()));
         }
 
         if (session.getColumnFamilyType() == ColumnFamilyType.Super)

File: src/java/org/apache/cassandra/db/RowMutationVerbHandler.java
Patch:
@@ -86,7 +86,7 @@ public void doVerb(Message message, String id)
     private void forwardToLocalNodes(Message message, byte[] forwardBytes) throws UnknownHostException
     {
         // remove fwds from message to avoid infinite loop
-        Message messageCopy = message.withHeaderRemoved(RowMutation.FORWARD_HEADER);
+        message.removeHeader(RowMutation.FORWARD_HEADER);
 
         int bytesPerInetAddress = FBUtilities.getLocalAddress().getAddress().length;
         assert forwardBytes.length >= bytesPerInetAddress;
@@ -106,7 +106,7 @@ private void forwardToLocalNodes(Message message, byte[] forwardBytes) throws Un
 
             // Send the original message to the address specified by the FORWARD_HINT
             // Let the response go back to the coordinator
-            MessagingService.instance().sendOneWay(messageCopy, address);
+            MessagingService.instance().sendOneWay(message, address);
 
             offset += bytesPerInetAddress;
         }

File: src/java/org/apache/cassandra/db/RowMutation.java
Patch:
@@ -263,10 +263,10 @@ public void applyUnsafe() throws IOException
 
     public Message getMessage(Integer version) throws IOException
     {
-        return makeRowMutationMessage(StorageService.Verb.MUTATION, version);
+        return getMessage(StorageService.Verb.MUTATION, version);
     }
 
-    public Message makeRowMutationMessage(StorageService.Verb verb, int version) throws IOException
+    public Message getMessage(StorageService.Verb verb, int version) throws IOException
     {
         return new Message(FBUtilities.getBroadcastAddress(), verb, getSerializedBuffer(version), version);
     }

File: src/java/org/apache/cassandra/db/CollationController.java
Patch:
@@ -152,8 +152,8 @@ public DecoratedKey getKey()
             filter.collateColumns(returnCF, Collections.singletonList(toCollate), cfs.metadata.comparator, gcBefore);
             
             // "hoist up" the requested data into a more recent sstable
-            if (!cfs.isCompactionDisabled()
-                && cfs.getMinimumCompactionThreshold() > 0
+            if (sstablesIterated > cfs.getMinimumCompactionThreshold()
+                && !cfs.isCompactionDisabled()
                 && cfs.getCompactionStrategy() instanceof SizeTieredCompactionStrategy)
             {
                 RowMutation rm = new RowMutation(cfs.table.name, new Row(filter.key, returnCF.cloneMe()));

File: src/java/org/apache/cassandra/gms/FailureDetector.java
Patch:
@@ -22,6 +22,7 @@
 import java.lang.management.ManagementFactory;
 import java.net.InetAddress;
 import java.util.*;
+import java.util.concurrent.CopyOnWriteArrayList;
 import javax.management.MBeanServer;
 import javax.management.ObjectName;
 
@@ -47,7 +48,7 @@ public class FailureDetector implements IFailureDetector, FailureDetectorMBean
     private static int phiConvictThreshold_;
 
     private Map<InetAddress, ArrivalWindow> arrivalSamples_ = new Hashtable<InetAddress, ArrivalWindow>();
-    private List<IFailureDetectionEventListener> fdEvntListeners_ = new ArrayList<IFailureDetectionEventListener>();
+    private List<IFailureDetectionEventListener> fdEvntListeners_ = new CopyOnWriteArrayList<IFailureDetectionEventListener>();
     
     public FailureDetector()
     {

File: src/java/org/apache/cassandra/db/CollationController.java
Patch:
@@ -170,7 +170,8 @@ private void reduceNameFilter(QueryFilter filter, ColumnFamily returnCF, long ss
         AbstractColumnContainer container = filter.path.superColumnName == null
                                           ? returnCF
                                           : (SuperColumn) returnCF.getColumn(filter.path.superColumnName);
-        if (container == null)
+        // MIN_VALUE means we don't know any information
+        if (container == null || sstableTimestamp == Long.MIN_VALUE)
             return;
 
         for (Iterator<ByteBuffer> iterator = ((NamesQueryFilter) filter.filter).columns.iterator(); iterator.hasNext(); )

File: src/java/org/apache/cassandra/db/EchoedRow.java
Patch:
@@ -73,6 +73,6 @@ public int columnCount()
 
     public long maxTimestamp()
     {
-        throw new UnsupportedOperationException();
+        return Long.MIN_VALUE;
     }
 }

File: src/java/org/apache/cassandra/db/compaction/AbstractCompactedRow.java
Patch:
@@ -69,7 +69,9 @@ public AbstractCompactedRow(DecoratedKey<?> key)
     public abstract int columnCount();
 
     /**
-     * @return the max column timestamp in the row
+     * @return the max column timestamp in the row or Long.MIN_VALUE if
+     * computing this value would require extra effort we're not willing to
+     * make.
      */
     public abstract long maxTimestamp();
 }

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -1482,7 +1482,7 @@ private void describeRing(String name) throws TException
             sessionState.err.println(e.getWhy());
 
             if (sessionState.debug)
-                e.printStackTrace();
+                e.printStackTrace(sessionState.err);
         }
     }
 
@@ -1956,8 +1956,8 @@ private void executeUseKeySpace(Tree statement) throws TException
         catch (TException e) 
         {
             if (sessionState.debug)
-                e.printStackTrace();
-            
+                e.printStackTrace(sessionState.err);
+
             sessionState.err.println("Login failure. Did you specify 'keyspace', 'username' and 'password'?");
         }
     }

File: src/java/org/apache/cassandra/cli/CliOptions.java
Patch:
@@ -67,7 +67,7 @@ public class CliOptions
         // options without argument
         options.addOption("B",  BATCH_OPTION,   "enabled batch mode (suppress output; errors are fatal)");
         options.addOption(null, UNFRAME_OPTION, "use cassandra server's unframed transport");
-        options.addOption(null, DEBUG_OPTION,   "display stack traces");
+        options.addOption(null, DEBUG_OPTION,   "display stack-traces (NOTE: We print strack-traces in the places where it makes sense even without --debug)");
         options.addOption("?",  HELP_OPTION,    "usage help");
         options.addOption("v",  VERBOSE_OPTION, "verbose output when using batch mode");
     }

File: src/java/org/apache/cassandra/dht/RandomPartitioner.java
Patch:
@@ -168,7 +168,7 @@ public Map<Token, Float> describeOwnership(List<Token> sortedTokens)
         // n-case
         else {
             // NOTE: All divisions must take place in BigDecimals, and all modulo operators must take place in BigIntegers.
-            final BigInteger ri = MAXIMUM(127);                             //  (used for addition later)
+            final BigInteger ri = MAXIMUM;                                                  //  (used for addition later)
             final BigDecimal r  = new BigDecimal(ri);                                       // The entire range, 2**127
             Token start = (Token)i.next(); BigInteger ti = ((BigIntegerToken)start).token;  // The first token and its value
             Token t; BigInteger tim1 = ti;                                                  // The last token and its value (after loop)

File: src/java/org/apache/cassandra/db/DataTracker.java
Patch:
@@ -298,9 +298,9 @@ private void removeOldSSTablesSize(Iterable<SSTableReader> oldSSTables)
             if (logger.isDebugEnabled())
                 logger.debug(String.format("removing %s from list of files tracked for %s.%s",
                             sstable.descriptor, cfstore.table.name, cfstore.getColumnFamilyName()));
+            liveSize.addAndGet(-sstable.bytesOnDisk());
             sstable.markCompacted();
             sstable.releaseReference();
-            liveSize.addAndGet(-sstable.bytesOnDisk());
         }
     }
 

File: src/java/org/apache/cassandra/db/HintedHandOffManager.java
Patch:
@@ -230,7 +230,7 @@ private int waitForSchemaAgreement(InetAddress endpoint) throws InterruptedExcep
     private void deliverHintsToEndpoint(InetAddress endpoint) throws IOException, DigestMismatchException, InvalidRequestException, TimeoutException, InterruptedException
     {
         ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_TABLE).getColumnFamilyStore(HINTS_CF);
-        if (hintStore.getSSTables().isEmpty())
+        if (hintStore.isEmpty())
             return; // nothing to do, don't confuse users by logging a no-op handoff
 
         try
@@ -289,7 +289,7 @@ private void deliverHintsToEndpoint(InetAddress endpoint) throws IOException, Di
                     if (ByteBufferUtil.string(subColumn.name()).contains(SEPARATOR_08))
                     {
                         logger_.debug("0.8-style hint found.  This should have been taken care of by purgeIncompatibleHints");
-                        deleteHint(tokenBytes, hint.name(), subColumn.timestamp());
+                        deleteHint(tokenBytes, hint.name(), hint.maxTimestamp());
                         continue page;
                     }
                 }
@@ -307,7 +307,7 @@ private void deliverHintsToEndpoint(InetAddress endpoint) throws IOException, Di
 
                 if (sendMutation(endpoint, rm))
                 {
-                    deleteHint(tokenBytes, hint.name(), versionColumn.timestamp());
+                    deleteHint(tokenBytes, hint.name(), hint.maxTimestamp());
                     rowsReplayed++;
                 }
                 else

File: src/java/org/apache/cassandra/db/CollationController.java
Patch:
@@ -154,7 +154,7 @@ public DecoratedKey getKey()
             // "hoist up" the requested data into a more recent sstable
             if (sstablesIterated >= cfs.getMinimumCompactionThreshold() && cfs.getCompactionStrategy() instanceof SizeTieredCompactionStrategy)
             {
-                RowMutation rm = new RowMutation(cfs.table.name, new Row(filter.key, returnCF));
+                RowMutation rm = new RowMutation(cfs.table.name, new Row(filter.key, returnCF.cloneMe()));
                 try
                 {
                     rm.applyUnsafe(); // skipping commitlog is fine since we're just de-fragmenting existing data

File: src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
Patch:
@@ -22,6 +22,7 @@
 import java.io.*;
 import java.nio.ByteBuffer;
 import java.util.*;
+import java.util.regex.Pattern;
 
 import com.google.common.collect.Sets;
 
@@ -339,7 +340,7 @@ private void maybeWriteDigest() throws IOException
         SequentialWriter out = SequentialWriter.open(new File(descriptor.filenameFor(SSTable.COMPONENT_DIGEST)), true);
         // Writting output compatible with sha1sum
         Descriptor newdesc = descriptor.asTemporary(false);
-        String[] tmp = newdesc.filenameFor(SSTable.COMPONENT_DATA).split(new Character(File.separatorChar).toString());
+        String[] tmp = newdesc.filenameFor(SSTable.COMPONENT_DATA).split(Pattern.quote(File.separator));
         String dataFileName = tmp[tmp.length - 1];
         out.write(String.format("%s  %s", Hex.bytesToHex(digest), dataFileName).getBytes());
         out.close();

File: src/java/org/apache/cassandra/cql/UpdateStatement.java
Patch:
@@ -220,7 +220,7 @@ private IMutation mutationForKey(String keyspace, ByteBuffer key, CFMetaData met
 
                     if (op.type == OperationType.MINUS)
                     {
-                        value *= -1;
+                        if (value > 0) value *= -1;
                     }
                 }
                 catch (NumberFormatException e)

File: src/java/org/apache/cassandra/db/CounterColumn.java
Patch:
@@ -36,6 +36,7 @@
 import org.apache.cassandra.db.context.IContext.ContextRelationship;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.MarshalException;
+import org.apache.cassandra.io.IColumnSerializer;
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.utils.Allocator;
 import org.apache.cassandra.service.IWriteResponseHandler;
@@ -76,11 +77,11 @@ public CounterColumn(ByteBuffer name, ByteBuffer value, long timestamp, long tim
         this.timestampOfLastDelete = timestampOfLastDelete;
     }
 
-    public static CounterColumn create(ByteBuffer name, ByteBuffer value, long timestamp, long timestampOfLastDelete, boolean fromRemote)
+    public static CounterColumn create(ByteBuffer name, ByteBuffer value, long timestamp, long timestampOfLastDelete, IColumnSerializer.Flag flag)
     {
         // #elt being negative means we have to clean delta
         short count = value.getShort(value.position());
-        if (fromRemote || count < 0)
+        if (flag == IColumnSerializer.Flag.FROM_REMOTE || (flag == IColumnSerializer.Flag.LOCAL && count < 0))
             value = CounterContext.instance().clearAllDelta(value);
         return new CounterColumn(name, value, timestamp, timestampOfLastDelete);
     }

File: src/java/org/apache/cassandra/db/ExpiringColumn.java
Patch:
@@ -25,6 +25,7 @@
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.MarshalException;
+import org.apache.cassandra.io.IColumnSerializer;
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.utils.Allocator;
 import org.apache.cassandra.utils.ByteBufferUtil;
@@ -60,9 +61,9 @@ public ExpiringColumn(ByteBuffer name, ByteBuffer value, long timestamp, int tim
     }
 
     /** @return Either a DeletedColumn, or an ExpiringColumn. */
-    public static Column create(ByteBuffer name, ByteBuffer value, long timestamp, int timeToLive, int localExpirationTime, int expireBefore)
+    public static Column create(ByteBuffer name, ByteBuffer value, long timestamp, int timeToLive, int localExpirationTime, int expireBefore, IColumnSerializer.Flag flag)
     {
-        if (localExpirationTime >= expireBefore)
+        if (localExpirationTime >= expireBefore || flag == IColumnSerializer.Flag.PRESERVE_SIZE)
             return new ExpiringColumn(name, value, timestamp, timeToLive, localExpirationTime);
         // the column is now expired, we can safely return a simple tombstone
         return new DeletedColumn(name, localExpirationTime, timestamp);

File: src/java/org/apache/cassandra/db/ReadResponse.java
Patch:
@@ -21,6 +21,7 @@
 import java.io.*;
 import java.nio.ByteBuffer;
 
+import org.apache.cassandra.io.IColumnSerializer;
 import org.apache.cassandra.io.IVersionedSerializer;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
@@ -105,7 +106,7 @@ public ReadResponse deserialize(DataInput dis, int version) throws IOException
         if (!isDigest)
         {
             // This is coming from a remote host
-            row = Row.serializer().deserialize(dis, version, true, ArrayBackedSortedColumns.factory());
+            row = Row.serializer().deserialize(dis, version, IColumnSerializer.Flag.FROM_REMOTE, ArrayBackedSortedColumns.factory());
         }
 
         return isDigest ? new ReadResponse(ByteBuffer.wrap(digest)) : new ReadResponse(row);

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -42,6 +42,7 @@
 import org.apache.cassandra.concurrent.StageManager;
 import org.apache.cassandra.config.Config;
 import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.io.IColumnSerializer;
 import org.apache.cassandra.io.util.FastByteArrayInputStream;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.ByteBufferUtil;
@@ -281,7 +282,7 @@ else if (globalPosition.segment == segment)
                     {
                         // assuming version here. We've gone to lengths to make sure what gets written to the CL is in
                         // the current version.  so do make sure the CL is drained prior to upgrading a node.
-                        rm = RowMutation.serializer().deserialize(new DataInputStream(bufIn), MessagingService.version_, false);
+                        rm = RowMutation.serializer().deserialize(new DataInputStream(bufIn), MessagingService.version_, IColumnSerializer.Flag.LOCAL);
                     }
                     catch (UnserializableColumnFamilyException ex)
                     {

File: src/java/org/apache/cassandra/streaming/IncomingStreamReader.java
Patch:
@@ -31,6 +31,7 @@
 import org.apache.cassandra.db.compaction.AbstractCompactedRow;
 import org.apache.cassandra.db.compaction.CompactionController;
 import org.apache.cassandra.db.compaction.PrecompactedRow;
+import org.apache.cassandra.io.IColumnSerializer;
 import org.apache.cassandra.io.sstable.*;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.service.StorageService;
@@ -129,7 +130,8 @@ private SSTableReader streamIn(DataInput input, PendingFile localFile, PendingFi
                         // need to update row cache
                         if (controller == null)
                             controller = new CompactionController(cfs, Collections.<SSTableReader>emptyList(), Integer.MIN_VALUE, true);
-                        SSTableIdentityIterator iter = new SSTableIdentityIterator(cfs.metadata, in, key, 0, dataSize, true);
+                        // Note: Because we won't just echo the columns, there is no need to use the PRESERVE_SIZE flag, contrarily to what appendFromStream does below
+                        SSTableIdentityIterator iter = new SSTableIdentityIterator(cfs.metadata, in, key, 0, dataSize, IColumnSerializer.Flag.FROM_REMOTE);
                         PrecompactedRow row = new PrecompactedRow(controller, Collections.singletonList(iter));
                         // We don't expire anything so the row shouldn't be empty
                         assert !row.isEmpty();

File: test/unit/org/apache/cassandra/db/CounterColumnTest.java
Patch:
@@ -39,6 +39,7 @@
 import org.apache.cassandra.db.context.CounterContext;
 import static org.apache.cassandra.db.context.CounterContext.ContextState;
 import org.apache.cassandra.db.marshal.*;
+import org.apache.cassandra.io.IColumnSerializer;
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.utils.Allocator;
 import org.apache.cassandra.utils.HeapAllocator;
@@ -295,7 +296,7 @@ public void testSerializeDeserialize() throws IOException
         assert original.equals(deserialized);
 
         bufIn = new ByteArrayInputStream(serialized, 0, serialized.length);
-        CounterColumn deserializedOnRemote = (CounterColumn)Column.serializer().deserialize(new DataInputStream(bufIn), true);
+        CounterColumn deserializedOnRemote = (CounterColumn)Column.serializer().deserialize(new DataInputStream(bufIn), IColumnSerializer.Flag.FROM_REMOTE);
         assert deserializedOnRemote.name().equals(original.name());
         assert deserializedOnRemote.total() == original.total();
         assert deserializedOnRemote.value().equals(cc.clearAllDelta(original.value()));

File: test/unit/org/apache/cassandra/io/sstable/SSTableMetadataSerializerTest.java
Patch:
@@ -58,8 +58,7 @@ public void testSerialization() throws IOException
 
         ByteArrayInputStream byteInput = new ByteArrayInputStream(byteOutput.toByteArray());
         DataInputStream dis = new DataInputStream(byteInput);
-
-        SSTableMetadata stats = SSTableMetadata.serializer.deserialize(dis);
+        SSTableMetadata stats = SSTableMetadata.serializer.deserialize(dis, true, true);
 
         assert stats.getEstimatedRowSize().equals(originalMetadata.getEstimatedRowSize());
         assert stats.getEstimatedRowSize().equals(rowSizes);

File: test/unit/org/apache/cassandra/db/KeyCacheTest.java
Patch:
@@ -92,7 +92,7 @@ public void testKeyCacheLoad() throws Exception
 
         // load the cache from disk.  unregister the old mbean so we can recreate a new CFS object.
         // but don't invalidate() the old CFS, which would nuke the data we want to try to load
-        store.invalidate(); // unregistering old MBean to test how key cache will be loaded
+        store.unregisterMBean();
         ColumnFamilyStore newStore = ColumnFamilyStore.createColumnFamilyStore(Table.open(TABLE1), COLUMN_FAMILY3);
         assertEquals(100, newStore.getKeyCacheSize());
 

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -306,7 +306,7 @@ private static void sendMessages(String localDataCenter, Map<String, Multimap<Me
                 // from previous loop iterations
                 message.removeHeader(RowMutation.FORWARD_HEADER);
 
-                if (dataCenter.equals(localDataCenter) || StorageService.instance.useEfficientCrossDCWrites())
+                if (dataCenter.equals(localDataCenter))
                 {
                     // direct writes to local DC or old Cassadra versions
                     for (InetAddress destination : messages.getValue())

File: src/java/org/apache/cassandra/db/index/SecondaryIndex.java
Patch:
@@ -132,9 +132,9 @@ public boolean isIndexBuilt(ByteBuffer columnName)
     public abstract void renameIndex(String newCfName) throws IOException;
     
     /**
-     * Unregisters this index's mbean if one exists
+     * Remove the index and unregisters this index's mbean if one exists
      */
-    public abstract void unregisterMbean();
+    public abstract void invalidate();
     
     
     /**

File: test/unit/org/apache/cassandra/db/compaction/CompactionsTest.java
Patch:
@@ -39,7 +39,6 @@
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.io.sstable.*;
 import org.apache.cassandra.utils.ByteBufferUtil;
-import org.apache.cassandra.utils.FBUtilities;
 
 public class CompactionsTest extends CleanupHelper
 {
@@ -231,7 +230,7 @@ private void testDontPurgeAccidentaly(String k, boolean forceDeserialize) throws
         ColumnFamilyStore store = table.getColumnFamilyStore(cfname);
 
         // disable compaction while flushing
-        store.removeAllSSTables();
+        store.clearUnsafe();
         store.disableAutoCompaction();
 
         // Add test row

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -98,7 +98,7 @@ public class ColumnFamilyStore implements ColumnFamilyStoreMBean
     public final CFMetaData metadata;
     public final IPartitioner partitioner;
     private final String mbeanName;
-    private boolean valid = false;
+    private boolean valid = true;
 
     /* Memtables and SSTables on disk for this column family */
     private final DataTracker data;

File: src/java/org/apache/cassandra/io/sstable/SSTableLoader.java
Patch:
@@ -125,6 +125,8 @@ public LoaderFuture stream(Set<InetAddress> toIgnore) throws IOException
             }
             Collection<Range> ranges = entry.getValue();
             StreamOutSession session = StreamOutSession.create(keyspace, remote, new CountDownCallback(future.latch, remote));
+            // transferSSTables assumes references have been acquired
+            SSTableReader.acquireReferences(sstables);
             StreamOut.transferSSTables(session, sstables, ranges, OperationType.BULK_LOAD);
             future.setPendings(remote, session.getFiles());
         }

File: src/java/org/apache/cassandra/io/util/CompressedSegmentedFile.java
Patch:
@@ -26,7 +26,7 @@
 
 public class CompressedSegmentedFile extends SegmentedFile
 {
-    private final CompressionMetadata metadata;
+    public final CompressionMetadata metadata;
 
     public CompressedSegmentedFile(String path, CompressionMetadata metadata)
     {
@@ -52,7 +52,7 @@ public void addPotentialBoundary(long boundary)
          */
         public SegmentedFile complete(String path)
         {
-            return new CompressedSegmentedFile(path, CompressionMetadata.get(path));
+            return new CompressedSegmentedFile(path, CompressionMetadata.create(path));
         }
     }
 

File: src/java/org/apache/cassandra/io/util/SegmentedFile.java
Patch:
@@ -26,6 +26,7 @@
 import java.util.NoSuchElementException;
 
 import org.apache.cassandra.config.Config;
+import org.apache.cassandra.io.compress.CompressionMetadata;
 import org.apache.cassandra.utils.Pair;
 
 /**

File: src/java/org/apache/cassandra/streaming/FileStreamTask.java
Patch:
@@ -121,7 +121,7 @@ private void stream() throws IOException
 
         // TODO just use a raw RandomAccessFile since we're managing our own buffer here
         RandomAccessReader file = (header.file.sstable.compression) // try to skip kernel page cache if possible
-                                ? CompressedRandomAccessReader.open(header.file.getFilename(), true)
+                                ? CompressedRandomAccessReader.open(header.file.getFilename(), header.file.sstable.getCompressionMetadata(), true)
                                 : RandomAccessReader.open(new File(header.file.getFilename()), true);
 
         // setting up data compression stream

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -1705,9 +1705,9 @@ private void showColumnMeta(StringBuilder sb, CfDef cfDef, ColumnDef colDef)
     {
         sb.append(NEWLINE + TAB + TAB + "{");
 
-        final AbstractType comparator = getFormatType((cfDef.column_type == "Super")
-                                                        ? cfDef.subcomparator_type
-                                                        : cfDef.comparator_type);
+        final AbstractType comparator = getFormatType(cfDef.column_type.equals("Super")
+                                                      ? cfDef.subcomparator_type
+                                                      : cfDef.comparator_type);
         sb.append("column_name : '" + CliUtils.escapeSQLString(comparator.getString(colDef.name)) + "'," + NEWLINE);
         String validationClass = normaliseType(colDef.validation_class, "org.apache.cassandra.db.marshal");
         sb.append(TAB + TAB + "validation_class : " + CliUtils.escapeSQLString(validationClass));

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -244,6 +244,7 @@ private static CFMetaData newSystemMetadata(String cfName, int cfId, String comm
     public static CFMetaData newIndexMetadata(CFMetaData parent, ColumnDefinition info, AbstractType columnComparator)
     {
         return new CFMetaData(parent.ksName, parent.indexColumnFamilyName(info), ColumnFamilyType.Standard, columnComparator, null)
+                             .keyValidator(info.getValidator())
                              .keyCacheSize(0.0)
                              .readRepairChance(0.0)
                              .gcGraceSeconds(parent.gcGraceSeconds)

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1544,9 +1544,10 @@ public Iterable<DecoratedKey> keySamples(Range range)
      * For testing.  no effort is made to clear historical memtables, nor for
      * thread safety
      */
-    void clearUnsafe()
+    public void clearUnsafe()
     {
-        data.init();
+        for (ColumnFamilyStore cfs : concatWithIndexes())
+            cfs.data.init();
     }
 
     /**

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -514,7 +514,9 @@ public AbstractReplicationStrategy getReplicationStrategy()
 
     public static void indexRow(DecoratedKey<?> key, ColumnFamilyStore cfs, SortedSet<ByteBuffer> indexedColumns)
     {
-        logger.debug("Indexing row {} ", key);
+        if (logger.isDebugEnabled())
+            logger.debug("Indexing row {} ", cfs.metadata.getKeyValidator().getString(key.key));
+
         switchLock.readLock().lock();
         try
         {

File: src/java/org/apache/cassandra/db/index/keys/KeysSearcher.java
Patch:
@@ -149,7 +149,7 @@ public List<Row> search(IndexClause clause, AbstractBounds range, IFilter dataFi
              * should be pretty close to `start_key`. */
             if (logger.isDebugEnabled())
                 logger.debug(String.format("Scanning index %s starting with %s",
-                                           expressionString(primary), index.getUnderlyingCfs().getComparator().getString(startKey)));
+                                           expressionString(primary), index.getBaseCFStore().metadata.getKeyValidator().getString(startKey)));
 
             // We shouldn't fetch only 1 row as this provides buggy paging in case the first row doesn't satisfy all clauses
             int count = Math.max(clause.count, 2);

File: test/unit/org/apache/cassandra/SchemaLoader.java
Patch:
@@ -276,8 +276,9 @@ private static CFMetaData superCFMD(String ksName, String cfName, AbstractType s
     private static CFMetaData indexCFMD(String ksName, String cfName, final Boolean withIdxType) throws ConfigurationException
     {
         return standardCFMD(ksName, cfName)
-                .columnMetadata(new HashMap<ByteBuffer, ColumnDefinition>()
-                    {{
+               .keyValidator(AsciiType.instance)
+               .columnMetadata(new HashMap<ByteBuffer, ColumnDefinition>()
+                   {{
                         ByteBuffer cName = ByteBuffer.wrap("birthdate".getBytes(Charsets.UTF_8));
                         IndexType keys = withIdxType ? IndexType.KEYS : null;
                         put(cName, new ColumnDefinition(cName, LongType.instance, keys, null, ByteBufferUtil.bytesToHex(cName)));

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -232,6 +232,7 @@ private static CFMetaData newSystemMetadata(String cfName, int cfId, String comm
     public static CFMetaData newIndexMetadata(CFMetaData parent, ColumnDefinition info, AbstractType columnComparator)
     {
         return new CFMetaData(parent.ksName, parent.indexColumnFamilyName(info), ColumnFamilyType.Standard, columnComparator, null)
+                             .keyValidator(info.getValidator())
                              .keyCacheSize(0.0)
                              .readRepairChance(0.0)
                              .gcGraceSeconds(parent.gcGraceSeconds)

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1533,9 +1533,10 @@ public Iterable<DecoratedKey> keySamples(Range range)
      * For testing.  no effort is made to clear historical memtables, nor for
      * thread safety
      */
-    void clearUnsafe()
+    public void clearUnsafe()
     {
-        data.init();
+        for (ColumnFamilyStore cfs : concatWithIndexes())
+            cfs.data.init();
     }
 
     /**

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -512,7 +512,9 @@ public AbstractReplicationStrategy getReplicationStrategy()
 
     public static void indexRow(DecoratedKey<?> key, ColumnFamilyStore cfs, SortedSet<ByteBuffer> indexedColumns)
     {
-        logger.debug("Indexing row {} ", key);
+        if (logger.isDebugEnabled())
+            logger.debug("Indexing row {} ", cfs.metadata.getKeyValidator().getString(key.key));
+
         switchLock.readLock().lock();
         try
         {

File: src/java/org/apache/cassandra/db/index/keys/KeysSearcher.java
Patch:
@@ -149,7 +149,7 @@ public List<Row> search(IndexClause clause, AbstractBounds range, IFilter dataFi
              * should be pretty close to `start_key`. */
             if (logger.isDebugEnabled())
                 logger.debug(String.format("Scanning index %s starting with %s",
-                                           expressionString(primary), index.getUnderlyingCfs().getComparator().getString(startKey)));
+                                           expressionString(primary), index.getBaseCFStore().metadata.getKeyValidator().getString(startKey)));
 
             // We shouldn't fetch only 1 row as this provides buggy paging in case the first row doesn't satisfy all clauses
             int count = Math.max(clause.count, 2);

File: test/unit/org/apache/cassandra/SchemaLoader.java
Patch:
@@ -276,8 +276,9 @@ private static CFMetaData superCFMD(String ksName, String cfName, AbstractType s
     private static CFMetaData indexCFMD(String ksName, String cfName, final Boolean withIdxType) throws ConfigurationException
     {
         return standardCFMD(ksName, cfName)
-                .columnMetadata(new HashMap<ByteBuffer, ColumnDefinition>()
-                    {{
+               .keyValidator(AsciiType.instance)
+               .columnMetadata(new HashMap<ByteBuffer, ColumnDefinition>()
+                   {{
                         ByteBuffer cName = ByteBuffer.wrap("birthdate".getBytes(Charsets.UTF_8));
                         IndexType keys = withIdxType ? IndexType.KEYS : null;
                         put(cName, new ColumnDefinition(cName, LongType.instance, keys, null, ByteBufferUtil.bytesToHex(cName)));

File: src/java/org/apache/cassandra/cql/QueryProcessor.java
Patch:
@@ -573,7 +573,7 @@ else if (oldKeyspace == null)
                 // otherwise create resultset from query results
                 result.schema = new CqlMetadata(new HashMap<ByteBuffer, String>(),
                                                 new HashMap<ByteBuffer, String>(),
-                                                metadata.comparator.toString(),
+                                                TypeParser.getShortName(metadata.comparator),
                                                 TypeParser.getShortName(metadata.getDefaultValidator()));
                 List<CqlRow> cqlRows = new ArrayList<CqlRow>();
                 for (org.apache.cassandra.db.Row row : rows)

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -882,6 +882,7 @@ public static org.apache.cassandra.db.migration.avro.CfDef convertToAvro(org.apa
         newDef.subcomparator_type = def.getSubcomparator_type();
         newDef.merge_shards_chance = def.getMerge_shards_chance();
         newDef.key_alias = def.key_alias;
+        newDef.row_cache_provider = def.row_cache_provider;
 
         List<org.apache.cassandra.db.migration.avro.ColumnDef> columnMeta = new ArrayList<org.apache.cassandra.db.migration.avro.ColumnDef>();
         if (def.isSetColumn_metadata())

File: src/java/org/apache/cassandra/db/ColumnFamilySerializer.java
Patch:
@@ -85,10 +85,13 @@ public int serializeForSSTable(ColumnFamily columnFamily, DataOutput dos)
             Collection<IColumn> columns = columnFamily.getSortedColumns();
             int count = columns.size();
             dos.writeInt(count);
+            int i = 0;
             for (IColumn column : columns)
             {
                 columnFamily.getColumnSerializer().serialize(column, dos);
+                i++;
             }
+            assert count == i: "CF size changed during serialization: was " + count + " initially but " + i + " written";
             return count;
         }
         catch (IOException e)

File: src/java/org/apache/cassandra/db/compaction/AbstractCompactionIterable.java
Patch:
@@ -37,7 +37,7 @@
 
 public abstract class AbstractCompactionIterable implements Iterable<AbstractCompactedRow>, CompactionInfo.Holder
 {
-    private static Logger logger = LoggerFactory.getLogger(CompactionIterable.class);
+    private static Logger logger = LoggerFactory.getLogger(AbstractCompactionIterable.class);
 
     protected final OperationType type;
     protected final CompactionController controller;

File: src/java/org/apache/cassandra/db/compaction/LeveledManifest.java
Patch:
@@ -45,7 +45,7 @@
 
 public class LeveledManifest
 {
-    private static final Logger logger = LoggerFactory.getLogger(LeveledCompactionStrategy.class);
+    private static final Logger logger = LoggerFactory.getLogger(LeveledManifest.class);
 
     public static final String EXTENSION = ".json";
 

File: src/java/org/apache/cassandra/hadoop/ConfigHelper.java
Patch:
@@ -66,7 +66,7 @@ public class ConfigHelper
     private static final String READ_CONSISTENCY_LEVEL = "cassandra.consistencylevel.read";
     private static final String WRITE_CONSISTENCY_LEVEL = "cassandra.consistencylevel.write";
     
-    private static final Logger logger = LoggerFactory.getLogger(ColumnFamilyInputFormat.class);
+    private static final Logger logger = LoggerFactory.getLogger(ConfigHelper.class);
 
 
     /**

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1648,7 +1648,7 @@ public Future<?> truncate() throws IOException, ExecutionException, InterruptedE
             throw new AssertionError(e);
         }
         long truncatedAt = System.currentTimeMillis();
-        snapshot(Table.getTimestampedSnapshotName("before-truncate"));
+        snapshot(Table.getTimestampedSnapshotName(columnFamily));
 
         return CompactionManager.instance.submitTruncate(this, truncatedAt);
     }

File: src/java/org/apache/cassandra/db/migration/DropColumnFamily.java
Patch:
@@ -78,7 +78,7 @@ public void applyModels() throws IOException
 
         if (!StorageService.instance.isClientMode())
         {
-            cfs.snapshot(Table.getTimestampedSnapshotName(null));
+            cfs.snapshot(Table.getTimestampedSnapshotName(cfs.columnFamily));
 
             CompactionManager.instance.getCompactionLock().lock();
             cfs.flushLock.lock();

File: src/java/org/apache/cassandra/db/migration/DropKeyspace.java
Patch:
@@ -47,7 +47,7 @@ public DropKeyspace(String name) throws ConfigurationException, IOException
 
     public void applyModels() throws IOException
     {
-        String snapshotName = Table.getTimestampedSnapshotName(null);
+        String snapshotName = Table.getTimestampedSnapshotName(name);
         CompactionManager.instance.getCompactionLock().lock();
         try
         {

File: src/java/org/apache/cassandra/service/AntiEntropyService.java
Patch:
@@ -281,7 +281,7 @@ public void prepare(ColumnFamilyStore cfs)
                 List<DecoratedKey> keys = new ArrayList<DecoratedKey>();
                 for (DecoratedKey sample : cfs.keySamples(request.range))
                 {
-                    assert request.range.contains(sample.token);
+                    assert request.range.contains(sample.token): "Token " + sample.token + " is not within range " + request.range;
                     keys.add(sample);
                 }
 

File: src/java/org/apache/cassandra/io/compress/DeflateCompressor.java
Patch:
@@ -76,7 +76,7 @@ public int compress(byte[] input, int inputOffset, int inputLength, ICompressor.
         while (true)
         {
             offs += def.deflate(output.buffer, offs, output.buffer.length - offs);
-            if (def.needsInput())
+            if (def.finished())
             {
                 return offs - outputOffset;
             }

File: test/unit/org/apache/cassandra/config/DatabaseDescriptorTest.java
Patch:
@@ -80,9 +80,9 @@ public void testTransKsMigration() throws IOException, ConfigurationException
         assert DatabaseDescriptor.getNonSystemTables().size() == 0;
         
         // add a few.
-        AddKeyspace ks0 = new AddKeyspace(new KSMetaData("ks0", SimpleStrategy.class, KSMetaData.optsWithRF(3)));
+        AddKeyspace ks0 = new AddKeyspace(KSMetaData.testMetadata("ks0", SimpleStrategy.class, KSMetaData.optsWithRF(3)));
         ks0.apply();
-        AddKeyspace ks1 = new AddKeyspace(new KSMetaData("ks1", SimpleStrategy.class, KSMetaData.optsWithRF(3)));
+        AddKeyspace ks1 = new AddKeyspace(KSMetaData.testMetadata("ks1", SimpleStrategy.class, KSMetaData.optsWithRF(3)));
         ks1.apply();
         
         assert DatabaseDescriptor.getTableDefinition("ks0") != null;

File: src/java/org/apache/cassandra/db/ReadResponse.java
Patch:
@@ -114,7 +114,6 @@ public ReadResponse deserialize(DataInput dis, int version) throws IOException
     public long serializedSize(ReadResponse response, int version)
     {
         int size = DBConstants.intSize;
-        size += (response.isDigestQuery() ? response.digest() : ByteBufferUtil.EMPTY_BYTE_BUFFER).remaining();
         size += DBConstants.boolSize;
         if (response.isDigestQuery())
             size += response.digest().remaining();

File: test/unit/org/apache/cassandra/cli/CliTest.java
Patch:
@@ -155,6 +155,7 @@ public class CliTest extends CleanupHelper
         "drop column family cF8;",
         "create keyspace TESTIN;",
         "drop keyspace tesTIN;",
+        "update column family 123 with comparator=UTF8Type and column_metadata=[];",
         "drop column family 123;",
         "create column family myCF with column_type='Super' and comparator='UTF8Type' AND subcomparator='UTF8Type';",
         "assume myCF keys as utf8;",

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -169,6 +169,7 @@ public void apply(IMutation mutation,
      */
     public static void mutate(List<? extends IMutation> mutations, ConsistencyLevel consistency_level) throws UnavailableException, TimeoutException
     {
+        logger.debug("Mutations/ConsistencyLevel are {}/{}", mutations, consistency_level);
         final String localDataCenter = DatabaseDescriptor.getEndpointSnitch().getDatacenter(FBUtilities.getBroadcastAddress());
 
         long startTime = System.nanoTime();

File: src/java/org/apache/cassandra/db/ColumnIndexer.java
Patch:
@@ -70,7 +70,7 @@ public static void serializeInternal(IIterableColumns columns, DataOutput dos) t
         // update bloom filter and create a list of IndexInfo objects marking the first and last column
         // in each block of ColumnIndexSize
         List<IndexHelper.IndexInfo> indexList = new ArrayList<IndexHelper.IndexInfo>();
-        int endPosition = 0, startPosition = -1;
+        long endPosition = 0, startPosition = -1;
         int indexSizeInBytes = 0;
         IColumn lastColumn = null, firstColumn = null;
         for (IColumn column : columns)

File: contrib/pig/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java
Patch:
@@ -26,7 +26,7 @@
 import org.apache.cassandra.db.marshal.IntegerType;
 import org.apache.cassandra.db.marshal.TypeParser;
 import org.apache.cassandra.thrift.*;
-import org.apache.cassandra.utils.FBUtilities;
+import org.apache.cassandra.utils.Hex;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -601,7 +601,7 @@ private static String cfdefToString(CfDef cfDef)
         TSerializer serializer = new TSerializer(new TBinaryProtocol.Factory());
         try
         {
-            return FBUtilities.bytesToHex(serializer.serialize(cfDef));
+            return Hex.bytesToHex(serializer.serialize(cfDef));
         }
         catch (TException e)
         {
@@ -616,7 +616,7 @@ private static CfDef cfdefFromString(String st)
         CfDef cfDef = new CfDef();
         try
         {
-            deserializer.deserialize(cfDef, FBUtilities.hexToBytes(st));
+            deserializer.deserialize(cfDef, Hex.hexToBytes(st));
         }
         catch (TException e)
         {

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -371,7 +371,7 @@ else if (conf.memtable_flush_writers == null)
                                      : 16;
             if (conf.rpc_max_threads == null)
                 conf.rpc_max_threads = conf.rpc_server_type.toLowerCase().equals("hsha")
-                                     ? Runtime.getRuntime().availableProcessors()
+                                     ? Runtime.getRuntime().availableProcessors() * 4
                                      : Integer.MAX_VALUE;
 
             /* data file and commit log directories. they get created later, when they're needed. */

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -915,7 +915,7 @@ public long getExpectedCompactedFileSize(Iterable<SSTableReader> sstables)
         long expectedFileSize = 0;
         for (SSTableReader sstable : sstables)
         {
-            long size = sstable.length();
+            long size = sstable.onDiskLength();
             expectedFileSize = expectedFileSize + size;
         }
         return expectedFileSize;
@@ -930,9 +930,9 @@ public SSTableReader getMaxSizeFile(Iterable<SSTableReader> sstables)
         SSTableReader maxFile = null;
         for (SSTableReader sstable : sstables)
         {
-            if (sstable.length() > maxSize)
+            if (sstable.onDiskLength() > maxSize)
             {
-                maxSize = sstable.length();
+                maxSize = sstable.onDiskLength();
                 maxFile = sstable;
             }
         }

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -472,7 +472,7 @@ private void scrubOne(ColumnFamilyStore cfs, SSTableReader sstable) throws IOExc
         boolean isCommutative = cfs.metadata.getDefaultValidator().isCommutative();
 
         // Calculate the expected compacted filesize
-        String compactionFileLocation = cfs.table.getDataFileLocation(sstable.length());
+        String compactionFileLocation = cfs.table.getDataFileLocation(sstable.onDiskLength());
         if (compactionFileLocation == null)
             throw new IOException("disk full");
         int expectedBloomFilterSize = Math.max(DatabaseDescriptor.getIndexInterval(),
@@ -765,8 +765,8 @@ private void doCleanupCompaction(ColumnFamilyStore cfs, Collection<SSTableReader
 
                 String format = "Cleaned up to %s.  %,d to %,d (~%d%% of original) bytes for %,d keys.  Time: %,dms.";
                 long dTime = System.currentTimeMillis() - startTime;
-                long startsize = sstable.length();
-                long endsize = newSstable.length();
+                long startsize = sstable.onDiskLength();
+                long endsize = newSstable.onDiskLength();
                 double ratio = (double)endsize / (double)startsize;
                 logger.info(String.format(format, writer.getFilename(), startsize, endsize, (int)(ratio*100), totalkeysWritten, dTime));
             }

File: src/java/org/apache/cassandra/db/compaction/SizeTieredCompactionStrategy.java
Patch:
@@ -100,7 +100,7 @@ private static List<Pair<SSTableReader, Long>> createSSTableAndLengthPairs(Colle
     {
         List<Pair<SSTableReader, Long>> tableLengthPairs = new ArrayList<Pair<SSTableReader, Long>>();
         for(SSTableReader table: collection)
-            tableLengthPairs.add(new Pair<SSTableReader, Long>(table, table.length()));
+            tableLengthPairs.add(new Pair<SSTableReader, Long>(table, table.onDiskLength()));
         return tableLengthPairs;
     }
 

File: src/java/org/apache/cassandra/io/sstable/SSTable.java
Patch:
@@ -257,7 +257,7 @@ public static long getTotalBytes(Iterable<SSTableReader> sstables)
         long sum = 0;
         for (SSTableReader sstable : sstables)
         {
-            sum += sstable.length();
+            sum += sstable.onDiskLength();
         }
         return sum;
     }

File: src/java/org/apache/cassandra/io/util/CompressedSegmentedFile.java
Patch:
@@ -30,7 +30,7 @@ public class CompressedSegmentedFile extends SegmentedFile
 
     public CompressedSegmentedFile(String path, CompressionMetadata metadata)
     {
-        super(path, metadata.dataLength);
+        super(path, metadata.dataLength, metadata.compressedFileLength);
         this.metadata = metadata;
     }
 

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -69,8 +69,8 @@ public class Config
     public Integer rpc_port = 9160;
     public String rpc_server_type = "sync";
     public Boolean rpc_keepalive = true;
-    public Integer rpc_min_threads = 16;
-    public Integer rpc_max_threads = Integer.MAX_VALUE;
+    public Integer rpc_min_threads = null;
+    public Integer rpc_max_threads = null;
     public Integer rpc_send_buff_size_in_bytes;
     public Integer rpc_recv_buff_size_in_bytes;
 

File: src/java/org/apache/cassandra/db/compaction/LeveledManifest.java
Patch:
@@ -239,7 +239,7 @@ public synchronized Collection<SSTableReader> getCompactionCandidates()
 
             // L0 gets a special case that if we don't have anything more important to do,
             // we'll go ahead and compact even just one sstable
-            if (score > 1 || i == 0)
+            if (score > 1.001 || i == 0)
             {
                 Collection<SSTableReader> candidates = getCandidatesFor(i);
                 if (logger.isDebugEnabled())
@@ -427,7 +427,7 @@ public int getEstimatedTasks()
             List<SSTableReader> sstables = generations[i];
             if (sstables.isEmpty())
                 continue;
-            n += (SSTableReader.getTotalBytes(sstables) - maxBytesForLevel(i)) / maxSSTableSizeInMB;
+            n += Math.max(0L, SSTableReader.getTotalBytes(sstables) - maxBytesForLevel(i)) / (maxSSTableSizeInMB * 1024 * 1024);
         }
         return n;
     }

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -1622,6 +1622,9 @@ private void showKeyspace(StringBuilder sb, KsDef ksDef)
             opts.append("}]");
             writeAttrRaw(sb, false, "strategy_options", opts.toString());
         }
+
+        writeAttr(sb, false, "durable_writes", ksDef.durable_writes);
+
         sb.append(";" + NEWLINE);
         sb.append(NEWLINE);
 

File: tools/stress/src/org/apache/cassandra/stress/operations/CounterGetter.java
Patch:
@@ -64,7 +64,7 @@ private void runSuperCounterGetter(SlicePredicate predicate, Cassandra.Client cl
         for (int j = 0; j < session.getSuperColumns(); j++)
         {
             String superColumn = 'S' + Integer.toString(j);
-            ColumnParent parent = new ColumnParent("CounterSuper1").setSuper_column(superColumn.getBytes());
+            ColumnParent parent = new ColumnParent("SuperCounter1").setSuper_column(superColumn.getBytes());
 
             long start = System.currentTimeMillis();
 

File: test/unit/org/apache/cassandra/dht/BootStrapperTest.java
Patch:
@@ -187,6 +187,7 @@ public boolean isAlive(InetAddress ep)
             public void registerFailureDetectionEventListener(IFailureDetectionEventListener listener) { throw new UnsupportedOperationException(); }
             public void unregisterFailureDetectionEventListener(IFailureDetectionEventListener listener) { throw new UnsupportedOperationException(); }
             public void remove(InetAddress ep) { throw new UnsupportedOperationException(); }
+            public void clear(InetAddress ep) { throw new UnsupportedOperationException(); }
         };
         Multimap<InetAddress, Range> temp = BootStrapper.getWorkMap(res, mockFailureDetector);
         // there isn't any point in testing the size of these collections for any specific size.  When a random partitioner

File: test/unit/org/apache/cassandra/dht/BootStrapperTest.java
Patch:
@@ -187,6 +187,7 @@ public boolean isAlive(InetAddress ep)
             public void registerFailureDetectionEventListener(IFailureDetectionEventListener listener) { throw new UnsupportedOperationException(); }
             public void unregisterFailureDetectionEventListener(IFailureDetectionEventListener listener) { throw new UnsupportedOperationException(); }
             public void remove(InetAddress ep) { throw new UnsupportedOperationException(); }
+            public void clear(InetAddress ep) { throw new UnsupportedOperationException(); }
         };
         Multimap<InetAddress, Range> temp = BootStrapper.getWorkMap(res, mockFailureDetector);
         // there isn't any point in testing the size of these collections for any specific size.  When a random partitioner

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -890,7 +890,7 @@ public synchronized String system_add_keyspace(KsDef ks_def)
         {
             if (!cf.getKeyspace().equals(ks_def.getName()))
             {
-                throw new InvalidRequestException("CsDef (" + cf.getName() +") had a keyspace definition that did not match KsDef");
+                throw new InvalidRequestException("CfDef (" + cf.getName() +") had a keyspace definition that did not match KsDef");
             }
         }
 

File: src/java/org/apache/cassandra/cql/jdbc/TypesMap.java
Patch:
@@ -33,7 +33,7 @@ public class TypesMap
         map.put("org.apache.cassandra.db.marshal.AsciiType", JdbcAscii.instance);
         map.put("org.apache.cassandra.db.marshal.BooleanType", JdbcBoolean.instance);
         map.put("org.apache.cassandra.db.marshal.BytesType", JdbcBytes.instance);
-        map.put("org.apache.cassandra.db.marshal.ColumnCounterType", JdbcCounterColumn.instance);
+        map.put("org.apache.cassandra.db.marshal.CounterColumnType", JdbcCounterColumn.instance);
         map.put("org.apache.cassandra.db.marshal.DateType", JdbcDate.instance);
         map.put("org.apache.cassandra.db.marshal.DecimalType", JdbcDecimal.instance);
         map.put("org.apache.cassandra.db.marshal.DoubleType", JdbcDouble.instance);

File: src/java/org/apache/cassandra/utils/MergeIterator.java
Patch:
@@ -40,7 +40,6 @@ public static <In, Out> IMergeIterator<In, Out> get(final List<? extends Closeab
                                                     Comparator<In> comparator,
                                                     final Reducer<In, Out> reducer)
     {
-        assert !sources.isEmpty();
         if (sources.size() == 1)
             return reducer.trivialReduceIsTrivial()
                    ? new TrivialOneToOne<In, Out>(sources, reducer)

File: src/java/org/apache/cassandra/tools/BulkLoader.java
Patch:
@@ -314,12 +314,12 @@ public static LoaderOptions parseArgs(String cmdArgs[])
                     {
                         for (String node : nodes)
                         {
-                            opts.ignores.add(InetAddress.getByName(node));
+                            opts.ignores.add(InetAddress.getByName(node.trim()));
                         }
                     }
                     catch (UnknownHostException e)
                     {
-                        errorMsg(e.getMessage(), options);
+                        errorMsg("Unknown host: " + e.getMessage(), options);
                     }
                 }
 
@@ -357,7 +357,7 @@ private static CmdLineOptions getCmdLineOptions()
             options.addOption("v",  VERBOSE_OPTION,      "verbose output");
             options.addOption("h",  HELP_OPTION,         "display this help message");
             options.addOption(null, NOPROGRESS_OPTION,   "don't display progress");
-            options.addOption("i",  IGNORE_NODES_OPTION, "don't stream to this (comma separated) list of nodes");
+            options.addOption("i",  IGNORE_NODES_OPTION, "NODES", "don't stream to this (comma separated) list of nodes");
             return options;
         }
 

File: src/java/org/apache/cassandra/io/sstable/ReducingKeyIterator.java
Patch:
@@ -43,6 +43,7 @@ public ReducingKeyIterator(Collection<SSTableReader> sstables)
         {
             DecoratedKey<?> reduced = null;
 
+            @Override
             public boolean trivialReduceIsTrivial()
             {
                 return true;

File: src/java/org/apache/cassandra/service/AntiEntropyService.java
Patch:
@@ -652,7 +652,7 @@ public void runMayThrow() throws Exception
                 if (!FailureDetector.instance.isAlive(endpoint))
                 {
                     differencingDone.signalAll();
-                    logger.info("[repair #%s] Could not proceed on repair because a neighbor (%s) is dead: session failed", getName(), endpoint);
+                    logger.info(String.format("[repair #%s] Cannot proceed on repair because a neighbor (%s) is dead: session failed", getName(), endpoint));
                     return;
                 }
             }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -328,7 +328,7 @@ public static synchronized ColumnFamilyStore createColumnFamilyStore(Table table
      */
     public static void scrubDataDirectories(String table, String columnFamily)
     {
-        logger.info("Removing compacted SSTable files (see http://wiki.apache.org/cassandra/MemtableSSTable)");
+        logger.info("Removing compacted SSTable files from " + columnFamily + " (see http://wiki.apache.org/cassandra/MemtableSSTable)");
         for (Map.Entry<Descriptor,Set<Component>> sstableFiles : files(table, columnFamily, true, true).entrySet())
         {
             Descriptor desc = sstableFiles.getKey();

File: src/java/org/apache/cassandra/cql/AbstractModification.java
Patch:
@@ -71,9 +71,9 @@ public boolean isSetConsistencyLevel()
         return cLevel != null;
     }
 
-    public long getTimestamp()
+    public long getTimestamp(ClientState clientState)
     {
-        return timestamp == null ? System.currentTimeMillis() : timestamp;
+        return timestamp == null ? clientState.getTimestamp() : timestamp;
     }
 
     public boolean isSetTimestamp()

File: src/java/org/apache/cassandra/service/AntiEntropyService.java
Patch:
@@ -680,7 +680,7 @@ public void runMayThrow() throws Exception
                 completed.await();
                 if (exception == null)
                 {
-                    logger.info(String.format("Repair session %s (on cfs %s, range %s) completed successfully", getName()), cfnames, range);
+                    logger.info(String.format("Repair session %s (on cfs %s, range %s) completed successfully", getName(), cfnames, range));
                 }
                 else
                 {

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -470,8 +470,8 @@ private void printCfHistograms(String keySpace, String columnFamily, PrintStream
             output.println(String.format("%-10d%10s%18s%18s%18s%18s",
                                          offsets[i],
                                          (i < sprh.length ? sprh[i] : ""),
-                                         (i < rwlh.length ? rrlh[i] : ""),
-                                         (i < rrlh.length ? rwlh[i] : ""),
+                                         (i < rwlh.length ? rwlh[i] : ""),
+                                         (i < rrlh.length ? rrlh[i] : ""),
                                          (i < ersh.length ? ersh[i] : ""),
                                          (i < ecch.length ? ecch[i] : "")));
         }

File: src/java/org/apache/cassandra/service/GCInspector.java
Patch:
@@ -106,7 +106,7 @@ private void logGCResults()
             
             if (previousCount == null)
                 previousCount = 0L;           
-            if (count == previousCount)
+            if (count.equals(previousCount))
                 continue;
             
             gccounts.put(gc.getName(), count);

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -447,7 +447,7 @@ public double getReadRepairChance()
 
     public double getMergeShardsChance()
     {
-        return readRepairChance;
+        return mergeShardsChance;
     }
 
     public boolean getReplicateOnWrite()

File: src/java/org/apache/cassandra/service/RowRepairResolver.java
Patch:
@@ -79,7 +79,7 @@ public Row resolve() throws DigestMismatchException, IOException
                 endpoints.add(message.getFrom());
 
                 // compute maxLiveColumns to prevent short reads -- see https://issues.apache.org/jira/browse/CASSANDRA-2643
-                int liveColumns = cf.getLiveColumnCount();
+                int liveColumns = cf == null ? 0 : cf.getLiveColumnCount();
                 if (liveColumns > maxLiveColumns)
                     maxLiveColumns = liveColumns;
             }

File: interface/thrift/gen-java/org/apache/cassandra/thrift/Cassandra.java
Patch:
@@ -9086,6 +9086,8 @@ private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOExcept
 
     private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
       try {
+        // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
+        __isset_bit_vector = new BitSet(1);
         read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
       } catch (org.apache.thrift.TException te) {
         throw new java.io.IOException(te);

File: interface/thrift/gen-java/org/apache/cassandra/thrift/Constants.java
Patch:
@@ -44,6 +44,6 @@
 
 public class Constants {
 
-  public static final String VERSION = "19.14.0";
+  public static final String VERSION = "19.15.0";
 
 }

File: src/java/org/apache/cassandra/cache/SerializingCacheProvider.java
Patch:
@@ -20,7 +20,6 @@
  * 
  */
 
-
 import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.db.ColumnFamily;
 import org.apache.cassandra.db.DecoratedKey;
@@ -37,7 +36,7 @@ public SerializingCacheProvider() throws ConfigurationException
         }
         catch (NoClassDefFoundError e)
         {
-            throw new ConfigurationException("Cannot intialize SerializationCache without JNA in the class path");
+            throw new ConfigurationException("Cannot initialize SerializationCache without JNA in the class path");
         }
     }
 

File: src/java/org/apache/cassandra/cql/CreateColumnFamilyStatement.java
Patch:
@@ -304,7 +304,7 @@ public CFMetaData getCFMetaData(String keyspace) throws InvalidRequestException
                    .mergeShardsChance(0.0)
                    .columnMetadata(getColumns(comparator))
                    .keyValidator(TypeParser.parse(comparators.get(getKeyType())))
-                   .rowCacheProvider(FBUtilities.newCacheProvider(getPropertyString(KW_ROW_CACHE_PROVIDER, CFMetaData.DEFAULT_ROW_CACHE_PROVIDER)))
+                   .rowCacheProvider(FBUtilities.newCacheProvider(getPropertyString(KW_ROW_CACHE_PROVIDER, CFMetaData.DEFAULT_ROW_CACHE_PROVIDER.getClass().getName())))
                    .keyAlias(keyAlias);
         }
         catch (ConfigurationException e)

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -55,7 +55,7 @@ public final class CFMetaData
 
     public final static double DEFAULT_ROW_CACHE_SIZE = 0.0;
     public final static double DEFAULT_KEY_CACHE_SIZE = 200000;
-    public final static double DEFAULT_READ_REPAIR_CHANCE = 1.0;
+    public final static double DEFAULT_READ_REPAIR_CHANCE = 0.1;
     public final static boolean DEFAULT_REPLICATE_ON_WRITE = true;
     public final static int DEFAULT_ROW_CACHE_SAVE_PERIOD_IN_SECONDS = 0;
     public final static int DEFAULT_KEY_CACHE_SAVE_PERIOD_IN_SECONDS = 4 * 3600;

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -203,8 +203,7 @@ public static int recover(File[] clogs) throws IOException
         {
             final long segment = CommitLogSegment.idFromFilename(file.getName());
 
-            int bufferSize = (int) Math.min(Math.max(file.length(), 1), 32 * 1024 * 1024);
-            RandomAccessReader reader = RandomAccessReader.open(new File(file.getAbsolutePath()), bufferSize, true);
+            RandomAccessReader reader = RandomAccessReader.open(new File(file.getAbsolutePath()), true);
             assert reader.length() <= Integer.MAX_VALUE;
 
             try

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
Patch:
@@ -92,7 +92,7 @@ public static boolean possibleCommitLogFile(String filename)
 
     private static SequentialWriter createWriter(String file) throws IOException
     {
-        return SequentialWriter.open(new File(file), 128 * 1024, true);
+        return SequentialWriter.open(new File(file), true);
     }
 
     public ReplayPosition write(RowMutation rowMutation) throws IOException

File: src/java/org/apache/cassandra/db/compaction/AbstractCompactionIterable.java
Patch:
@@ -16,8 +16,6 @@
 
 public abstract class AbstractCompactionIterable implements Iterable<AbstractCompactedRow>, CompactionInfo.Holder
 {
-    public static final int FILE_BUFFER_SIZE = 1024 * 1024;
-
     private static Logger logger = LoggerFactory.getLogger(CompactionIterable.class);
 
     protected final OperationType type;
@@ -51,7 +49,7 @@ protected static List<SSTableScanner> getScanners(Iterable<SSTableReader> sstabl
     {
         ArrayList<SSTableScanner> scanners = new ArrayList<SSTableScanner>();
         for (SSTableReader sstable : sstables)
-            scanners.add(sstable.getDirectScanner(FILE_BUFFER_SIZE));
+            scanners.add(sstable.getDirectScanner());
         return scanners;
     }
 

File: src/java/org/apache/cassandra/db/compaction/CompactionIterable.java
Patch:
@@ -70,7 +70,7 @@ protected static List<SSTableScanner> getScanners(Iterable<SSTableReader> sstabl
     {
         ArrayList<SSTableScanner> scanners = new ArrayList<SSTableScanner>();
         for (SSTableReader sstable : sstables)
-            scanners.add(sstable.getDirectScanner(FILE_BUFFER_SIZE));
+            scanners.add(sstable.getDirectScanner());
         return scanners;
     }
 

File: src/java/org/apache/cassandra/db/compaction/CompactionManager.java
Patch:
@@ -699,7 +699,7 @@ private void doCleanupCompaction(ColumnFamilyStore cfs, Collection<SSTableReader
             if (compactionFileLocation == null)
                 throw new IOException("disk full");
 
-            SSTableScanner scanner = sstable.getDirectScanner(AbstractCompactionIterable.FILE_BUFFER_SIZE);
+            SSTableScanner scanner = sstable.getDirectScanner();
             Collection<ByteBuffer> indexedColumns = cfs.indexManager.getIndexedColumns();
             CleanupInfo ci = new CleanupInfo(sstable, scanner);
             executor.beginCompaction(ci);
@@ -949,7 +949,7 @@ protected static List<SSTableScanner> getScanners(Iterable<SSTableReader> sstabl
         {
             ArrayList<SSTableScanner> scanners = new ArrayList<SSTableScanner>();
             for (SSTableReader sstable : sstables)
-                scanners.add(sstable.getDirectScanner(FILE_BUFFER_SIZE, range));
+                scanners.add(sstable.getDirectScanner(range));
             return scanners;
         }
     }

File: src/java/org/apache/cassandra/io/compress/CompressedRandomAccessReader.java
Patch:
@@ -31,6 +31,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+// TODO refactor this to separate concept of "buffer to avoid lots of read() syscalls" and "compression buffer"
 public class CompressedRandomAccessReader extends RandomAccessReader
 {
     private static final Logger logger = LoggerFactory.getLogger(CompressedRandomAccessReader.class);

File: src/java/org/apache/cassandra/io/sstable/SSTableBoundedScanner.java
Patch:
@@ -24,7 +24,6 @@
 import java.util.Iterator;
 
 import org.apache.cassandra.db.columniterator.IColumnIterator;
-import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.utils.Pair;
 
@@ -36,9 +35,9 @@ public class SSTableBoundedScanner extends SSTableScanner
     private final Iterator<Pair<Long, Long>> rangeIterator;
     private Pair<Long, Long> currentRange;
 
-    SSTableBoundedScanner(SSTableReader sstable, int bufferSize, boolean skipCache, Range range)
+    SSTableBoundedScanner(SSTableReader sstable, boolean skipCache, Range range)
     {
-        super(sstable, bufferSize, skipCache);
+        super(sstable, skipCache);
         this.rangeIterator = sstable.getPositionsForRanges(Collections.singletonList(range)).iterator();
         if (rangeIterator.hasNext())
         {

File: src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
Patch:
@@ -369,7 +369,7 @@ static class IndexWriter implements Closeable
         {
             this.desc = desc;
             this.partitioner = part;
-            indexFile = SequentialWriter.open(new File(desc.filenameFor(SSTable.COMPONENT_INDEX)), 8 * 1024 * 1024, true);
+            indexFile = SequentialWriter.open(new File(desc.filenameFor(SSTable.COMPONENT_INDEX)), true);
             builder = SegmentedFile.getBuilder(DatabaseDescriptor.getIndexAccessMode());
             summary = new IndexSummary(keyCount);
             bf = BloomFilter.getFilter(keyCount, 15);

File: src/java/org/apache/cassandra/io/util/BufferedSegmentedFile.java
Patch:
@@ -55,11 +55,11 @@ public SegmentedFile complete(String path)
         }
     }
 
-    public FileDataInput getSegment(long position, int bufferSize)
+    public FileDataInput getSegment(long position)
     {
         try
         {
-            RandomAccessReader file = RandomAccessReader.open(new File(path), bufferSize);
+            RandomAccessReader file = RandomAccessReader.open(new File(path));
             file.seek(position);
             return file;
         }

File: src/java/org/apache/cassandra/io/util/CompressedSegmentedFile.java
Patch:
@@ -56,7 +56,7 @@ public SegmentedFile complete(String path)
         }
     }
 
-    public FileDataInput getSegment(long position, int bufferSize)
+    public FileDataInput getSegment(long position)
     {
         try
         {

File: src/java/org/apache/cassandra/io/util/MmappedSegmentedFile.java
Patch:
@@ -75,7 +75,7 @@ private Segment floor(long position)
     /**
      * @return The segment containing the given position: must be closed after use.
      */
-    public FileDataInput getSegment(long position, int bufferSize)
+    public FileDataInput getSegment(long position)
     {
         Segment segment = floor(position);
         if (segment.right != null)
@@ -88,7 +88,7 @@ public FileDataInput getSegment(long position, int bufferSize)
         try
         {
             // FIXME: brafs are unbounded, so this segment will cover the rest of the file, rather than just the row
-            RandomAccessReader file = RandomAccessReader.open(new File(path), bufferSize);
+            RandomAccessReader file = RandomAccessReader.open(new File(path));
             file.seek(position);
             return file;
         }

File: src/java/org/apache/cassandra/io/util/SegmentedFile.java
Patch:
@@ -66,7 +66,7 @@ public static Builder getCompressedBuilder()
         return new CompressedSegmentedFile.Builder();
     }
 
-    public abstract FileDataInput getSegment(long position, int bufferSize);
+    public abstract FileDataInput getSegment(long position);
 
     /**
      * @return An Iterator over segments, beginning with the segment containing the given position: each segment must be closed after use.
@@ -137,7 +137,7 @@ public FileDataInput next()
             if (position >= length)
                 throw new NoSuchElementException();
 
-            FileDataInput segment = getSegment(nextpos, bufferSize);
+            FileDataInput segment = getSegment(nextpos);
             try
             {
                 nextpos = nextpos + segment.bytesRemaining();

File: src/java/org/apache/cassandra/tools/SSTableExport.java
Patch:
@@ -31,7 +31,6 @@
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.index.keys.KeysIndex;
 import org.apache.cassandra.db.marshal.AbstractType;
-import org.apache.cassandra.io.util.RandomAccessReader;
 import org.apache.cassandra.service.StorageService;
 
 import org.apache.commons.cli.*;
@@ -238,7 +237,7 @@ public static void enumeratekeys(String ssTableFile, PrintStream outs)
     public static void export(String ssTableFile, PrintStream outs, Collection<String> toExport, String[] excludes) throws IOException
     {
         SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(ssTableFile));
-        SSTableScanner scanner = reader.getDirectScanner(RandomAccessReader.DEFAULT_BUFFER_SIZE);
+        SSTableScanner scanner = reader.getDirectScanner();
 
         IPartitioner<?> partitioner = StorageService.getPartitioner();
 
@@ -295,7 +294,7 @@ static void export(SSTableReader reader, PrintStream outs, String[] excludes) th
 
 
         SSTableIdentityIterator row;
-        SSTableScanner scanner = reader.getDirectScanner(RandomAccessReader.DEFAULT_BUFFER_SIZE);
+        SSTableScanner scanner = reader.getDirectScanner();
 
         outs.println("{");
 

File: test/unit/org/apache/cassandra/io/sstable/SSTableUtils.java
Patch:
@@ -32,7 +32,6 @@
 import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.db.IColumn;
 import org.apache.cassandra.db.columniterator.IColumnIterator;
-import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
 import org.apache.cassandra.Util;
@@ -78,8 +77,8 @@ public static File tempSSTableFile(String tablename, String cfname, int generati
 
     public static void assertContentEquals(SSTableReader lhs, SSTableReader rhs) throws IOException
     {
-        SSTableScanner slhs = lhs.getDirectScanner(2048);
-        SSTableScanner srhs = rhs.getDirectScanner(2048);
+        SSTableScanner slhs = lhs.getDirectScanner();
+        SSTableScanner srhs = rhs.getDirectScanner();
         while (slhs.hasNext())
         {
             IColumnIterator ilhs = slhs.next();

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -66,6 +66,7 @@ public enum Function
         BYTES         (BytesType.instance),
         INTEGER       (IntegerType.instance),
         LONG          (LongType.instance),
+        INT           (Int32Type.instance),
         LEXICALUUID   (LexicalUUIDType.instance),
         TIMEUUID      (TimeUUIDType.instance),
         UTF8          (UTF8Type.instance),

File: src/java/org/apache/cassandra/cql/CreateColumnFamilyStatement.java
Patch:
@@ -71,7 +71,7 @@ public class CreateColumnFamilyStatement
         comparators.put("decimal", "DecimalType");
         comparators.put("double", "DoubleType");
         comparators.put("float", "FloatType");
-        // comparators.put("int", "LongType"); TODO add int -> Int32Type
+        comparators.put("int", "Int32Type");
         comparators.put("text", "UTF8Type");
         comparators.put("timestamp", "DateType");
         comparators.put("uuid", "UUIDType");

File: src/java/org/apache/cassandra/cql/jdbc/JdbcLong.java
Patch:
@@ -90,7 +90,7 @@ public Class<Long> getType()
 
     public int getJdbcType()
     {
-        return Types.INTEGER;
+        return Types.BIGINT;
     }
 
     public Long compose(ByteBuffer bytes)

File: src/java/org/apache/cassandra/cql/jdbc/TypesMap.java
Patch:
@@ -17,6 +17,7 @@ public class TypesMap
         map.put("org.apache.cassandra.db.marshal.DecimalType", JdbcDecimal.instance);
         map.put("org.apache.cassandra.db.marshal.DoubleType", JdbcDouble.instance);
         map.put("org.apache.cassandra.db.marshal.FloatType", JdbcFloat.instance);
+        map.put("org.apache.cassandra.db.marshal.Int32Type", JdbcInt32.instance);
         map.put("org.apache.cassandra.db.marshal.IntegerType", JdbcInteger.instance);
         map.put("org.apache.cassandra.db.marshal.LexicalUUIDType", JdbcLexicalUUID.instance);
         map.put("org.apache.cassandra.db.marshal.LongType", JdbcLong.instance);

File: test/unit/org/apache/cassandra/db/RemoveSubColumnTest.java
Patch:
@@ -51,11 +51,11 @@ public void testRemoveSubColumn() throws IOException, ExecutionException, Interr
 
         // remove
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.delete(new QueryPath("Super1", ByteBufferUtil.bytes("SC1"), getBytes(1)), 1);
+        rm.delete(new QueryPath("Super1", ByteBufferUtil.bytes("SC1"), getBytes(1L)), 1);
         rm.apply();
 
         ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getIdentityFilter(dk, new QueryPath("Super1", ByteBufferUtil.bytes("SC1"))));
-        assert retrieved.getColumn(ByteBufferUtil.bytes("SC1")).getSubColumn(getBytes(1)).isMarkedForDelete();
+        assert retrieved.getColumn(ByteBufferUtil.bytes("SC1")).getSubColumn(getBytes(1L)).isMarkedForDelete();
         assertNull(Util.cloneAndRemoveDeleted(retrieved, Integer.MAX_VALUE));
     }
 }

File: test/unit/org/apache/cassandra/db/TableTest.java
Patch:
@@ -41,7 +41,7 @@
 import static org.apache.cassandra.Util.getBytes;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.db.filter.QueryPath;
-import org.apache.cassandra.db.marshal.LongType;
+import org.apache.cassandra.db.marshal.Int32Type;
 import org.apache.cassandra.io.sstable.IndexHelper;
 import org.apache.cassandra.io.sstable.SSTableReader;
 import org.apache.cassandra.utils.ByteBufferUtil;
@@ -487,7 +487,7 @@ public void testGetSliceFromSuperBasic() throws Throwable
 
         RowMutation rm = new RowMutation("Keyspace1", ROW.key);
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Super1");
-        SuperColumn sc = new SuperColumn(ByteBufferUtil.bytes("sc1"), LongType.instance);
+        SuperColumn sc = new SuperColumn(ByteBufferUtil.bytes("sc1"), Int32Type.instance);
         sc.addColumn(new Column(getBytes(1), ByteBufferUtil.bytes("val1"), 1L));
         cf.addColumn(sc);
         rm.add(cf);

File: test/unit/org/apache/cassandra/cli/CliTest.java
Patch:
@@ -129,6 +129,7 @@ public class CliTest extends CleanupHelper
         "drop index on CF3.'big world';",
         "update keyspace TestKeySpace with placement_strategy='org.apache.cassandra.locator.LocalStrategy' and durable_writes = false;",
         "update keyspace TestKeySpace with strategy_options={DC1:3, DC2:4, DC5:1};",
+        "update keyspace TestKeySpace with strategy_options=[{DC1:3, DC2:4, DC5:1}];",
         "assume 123 comparator as utf8;",
         "assume 123 sub_comparator as integer;",
         "assume 123 validator as lexicaluuid;",

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1303,7 +1303,7 @@ public ViewFragment markReferenced(DecoratedKey startWith, DecoratedKey stopAt)
             view = data.getView();
             // startAt == minimum is ok, but stopAt == minimum is confusing because all IntervalTree deals with
             // is Comparable, so it won't know to special-case that.
-            Comparable stopInTree = stopAt.isEmpty() ? view.intervalTree.max : stopAt;
+            Comparable stopInTree = stopAt.isEmpty() ? view.intervalTree.max() : stopAt;
             sstables = view.intervalTree.search(new Interval(startWith, stopInTree));
             if (SSTableReader.acquireReferences(sstables))
                 break;

File: src/java/org/apache/cassandra/thrift/CustomTThreadPoolServer.java
Patch:
@@ -193,6 +193,8 @@ public void run()
             catch (TTransportException ttx)
             {
                 // Assume the client died and continue silently
+                // Log at debug to allow debugging of "frame too large" errors (see CASSANDRA-3142).
+                LOGGER.debug("Thrift transport error occurred during processing of message.", ttx);
             }
             catch (TException tx)
             {

File: src/java/org/apache/cassandra/cql/CreateColumnFamilyStatement.java
Patch:
@@ -76,6 +76,7 @@ public class CreateColumnFamilyStatement
         comparators.put("date", "DateType");
         comparators.put("float", "FloatType");
         comparators.put("double", "DoubleType");
+        comparators.put("decimal", "DecimalType");
 
         keywords.add(KW_COMPARATOR);
         keywords.add(KW_COMMENT);

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -1607,11 +1607,10 @@ public boolean apply(KsDef ksDef)
      */
     private void showKeyspace(StringBuilder sb, KsDef ksDef)
     {
-
         sb.append("create keyspace " + ksDef.name);
-        if (ksDef.isSetReplication_factor())
-            writeAttr(sb, false, "replication_factor", ksDef.getReplication_factor());
+
         writeAttr(sb, true, "placement_strategy", normaliseType(ksDef.strategy_class, "org.apache.cassandra.locator"));
+
         if (ksDef.strategy_options != null && !ksDef.strategy_options.isEmpty())
         {
             final StringBuilder opts = new StringBuilder();

File: drivers/java/src/org/apache/cassandra/cql/jdbc/ColumnDecoder.java
Patch:
@@ -86,7 +86,7 @@ private AbstractJdbcType<?> getNameType(String keyspace, String columnFamily, By
         try
         {
             if (ByteBufferUtil.string(name).equalsIgnoreCase(ByteBufferUtil.string(cf.keyAlias)))
-                return AsciiTerm.instance;
+                return JdbcAscii.instance;
         }
         catch (CharacterCodingException e)
         {

File: src/java/org/apache/cassandra/cql/jdbc/JdbcCounterColumn.java
Patch:
@@ -1,6 +1,6 @@
 package org.apache.cassandra.cql.jdbc;
 
-public class JdbcCounterColumn extends LongTerm
+public class JdbcCounterColumn extends JdbcLong
 {
     public static final JdbcCounterColumn instance = new JdbcCounterColumn();
     

File: src/java/org/apache/cassandra/cql/jdbc/JdbcLexicalUUID.java
Patch:
@@ -26,7 +26,7 @@
 
 import org.apache.cassandra.utils.UUIDGen;
 
-public class JdbcLexicalUUID extends JdbcLong
+public class JdbcLexicalUUID extends AbstractJdbcUUID
 {
     public static final JdbcLexicalUUID instance = new JdbcLexicalUUID();
     

File: src/java/org/apache/cassandra/cql/jdbc/JdbcTimeUUID.java
Patch:
@@ -26,7 +26,7 @@
 
 import org.apache.cassandra.utils.UUIDGen;
 
-public class JdbcTimeUUID extends JdbcLong
+public class JdbcTimeUUID extends AbstractJdbcUUID
 {
     public static final JdbcTimeUUID instance = new JdbcTimeUUID();
     

File: src/java/org/apache/cassandra/cql/jdbc/JdbcUUID.java
Patch:
@@ -24,7 +24,7 @@
 import java.nio.ByteBuffer;
 import java.util.UUID;
 
-public class JdbcUUID extends JdbcLong
+public class JdbcUUID extends AbstractJdbcUUID
 {
     public static final JdbcUUID instance = new JdbcUUID();
     

File: src/java/org/apache/cassandra/cql/jdbc/TypesMap.java
Patch:
@@ -9,7 +9,7 @@ public class TypesMap
     
     static
     {
-        map.put("org.apache.cassandra.db.marshal.AsciiType", AsciiTerm.instance);
+        map.put("org.apache.cassandra.db.marshal.AsciiType", JdbcAscii.instance);
         map.put("org.apache.cassandra.db.marshal.BooleanType", JdbcBoolean.instance);
         map.put("org.apache.cassandra.db.marshal.BytesType", JdbcBytes.instance);
         map.put("org.apache.cassandra.db.marshal.ColumnCounterType", JdbcCounterColumn.instance);
@@ -18,7 +18,7 @@ public class TypesMap
         map.put("org.apache.cassandra.db.marshal.FloatType", JdbcFloat.instance);
         map.put("org.apache.cassandra.db.marshal.IntegerType", JdbcInteger.instance);
         map.put("org.apache.cassandra.db.marshal.LexicalUUIDType", JdbcLexicalUUID.instance);
-        map.put("org.apache.cassandra.db.marshal.LongType", LongTerm.instance);
+        map.put("org.apache.cassandra.db.marshal.LongType", JdbcLong.instance);
         map.put("org.apache.cassandra.db.marshal.TimeUUIDType", JdbcTimeUUID.instance);
         map.put("org.apache.cassandra.db.marshal.UTF8Type", JdbcUTF8.instance);
         map.put("org.apache.cassandra.db.marshal.UUIDType", JdbcUUID.instance);
@@ -28,7 +28,7 @@ public static AbstractJdbcType<?> getTermForComparator(String comparator)
     {
         // If not fully qualified, assume it's the short name for a built-in.
         if ((comparator != null) && (!comparator.contains(".")))
-            return map.get("org.apache.cassandra.db." + comparator);
+            return map.get("org.apache.cassandra.db.marshal." + comparator);
         return map.get(comparator);
     }
 }

File: src/java/org/apache/cassandra/db/marshal/AsciiType.java
Patch:
@@ -25,7 +25,7 @@
 
 import com.google.common.base.Charsets;
 
-import org.apache.cassandra.cql.jdbc.AsciiTerm;
+import org.apache.cassandra.cql.jdbc.JdbcAscii;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
 public class AsciiType extends AbstractType<String>
@@ -38,7 +38,7 @@ public String getString(ByteBuffer bytes)
     {
         try
         {
-            return AsciiTerm.instance.getString(bytes);
+            return JdbcAscii.instance.getString(bytes);
         }
         catch (org.apache.cassandra.cql.jdbc.MarshalException e)
         {
@@ -53,7 +53,7 @@ public int compare(ByteBuffer o1, ByteBuffer o2)
 
     public String compose(ByteBuffer bytes)
     {
-        return AsciiTerm.instance.getString(bytes);
+        return JdbcAscii.instance.getString(bytes);
     }
 
     public ByteBuffer decompose(String value)

File: src/java/org/apache/cassandra/db/marshal/LongType.java
Patch:
@@ -23,7 +23,7 @@
 
 import java.nio.ByteBuffer;
 
-import org.apache.cassandra.cql.jdbc.LongTerm;
+import org.apache.cassandra.cql.jdbc.JdbcLong;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
 public class LongType extends AbstractType<Long>
@@ -34,7 +34,7 @@ public class LongType extends AbstractType<Long>
 
     public Long compose(ByteBuffer bytes)
     {
-        return LongTerm.instance.compose(bytes);
+        return ByteBufferUtil.toLong(bytes);
     }
 
     public ByteBuffer decompose(Long value)
@@ -65,7 +65,7 @@ public String getString(ByteBuffer bytes)
     {
         try
         {
-            return LongTerm.instance.getString(bytes);
+            return JdbcLong.instance.getString(bytes);
         }
         catch (org.apache.cassandra.cql.jdbc.MarshalException e)
         {

File: test/unit/org/apache/cassandra/db/marshal/RoundTripTest.java
Patch:
@@ -56,7 +56,7 @@ public void testLong()
         assert LongType.instance.fromString(LongType.instance.getString(ByteBuffer.wrap(v)))
                 .equals(ByteBuffer.wrap(v));
         assert LongType.instance.compose(ByteBuffer.wrap(v)) == 1L;
-        assert LongTerm.instance.toString(1L).equals("1");
+        assert JdbcLong.instance.toString(1L).equals("1");
     }
     
     @Test
@@ -67,7 +67,7 @@ public void testAscii() throws Exception
         assert AsciiType.instance.fromString(AsciiType.instance.getString(ByteBuffer.wrap(abc)))
                 .equals(ByteBuffer.wrap(abc));
         assert AsciiType.instance.compose(ByteBuffer.wrap(abc)).equals("abc");
-        assert AsciiTerm.instance.toString("abc").equals("abc");
+        assert JdbcAscii.instance.toString("abc").equals("abc");
     }
     
     @Test

File: src/java/org/apache/cassandra/db/marshal/AbstractType.java
Patch:
@@ -98,9 +98,6 @@ public int compare(ByteBuffer o1, ByteBuffer o2)
     
     public abstract ByteBuffer decompose(T value);
 
-    /** get a string representation of a particular type. */
-    public abstract String toString(T t);
-
     /** get a string representation of the bytes suitable for log messages */
     public abstract String getString(ByteBuffer bytes);
 

File: test/unit/org/apache/cassandra/io/sstable/SSTableWriterTest.java
Patch:
@@ -82,7 +82,7 @@ public void testRecoverAndOpen() throws IOException, ExecutionException, Interru
         assert sstr != null;
         ColumnFamilyStore cfs = Table.open("Keyspace1").getColumnFamilyStore("Indexed1");
         cfs.addSSTable(sstr);
-        cfs.buildSecondaryIndexes(cfs.getSSTables(), cfs.getIndexedColumns());
+        cfs.maybeBuildSecondaryIndexes(cfs.getSSTables(), cfs.getIndexedColumns());
         
         IndexExpression expr = new IndexExpression(ByteBufferUtil.bytes("birthdate"), IndexOperator.EQ, ByteBufferUtil.bytes(1L));
         IndexClause clause = new IndexClause(Arrays.asList(expr), ByteBufferUtil.EMPTY_BYTE_BUFFER, 100);

File: src/java/org/apache/cassandra/streaming/StreamingRepairTask.java
Patch:
@@ -115,7 +115,8 @@ private void initiateStreaming()
         try
         {
             logger.info(String.format("[streaming task #%s] Performing streaming repair of %d ranges with %s", id, ranges.size(), dst));
-            Collection<SSTableReader> sstables = cfstore.getSSTables();
+            // We acquire references for transferSSTables
+            Collection<SSTableReader> sstables = cfstore.markCurrentSSTablesReferenced();
             // send ranges to the remote node
             StreamOutSession outsession = StreamOutSession.create(tableName, dst, callback);
             StreamOut.transferSSTables(outsession, sstables, ranges, OperationType.AES);

File: src/java/org/apache/cassandra/utils/BloomFilter.java
Patch:
@@ -70,7 +70,7 @@ public static BloomFilter getFilter(long numElements, int targetBucketsPerElem)
                                       numElements, bucketsPerElement, targetBucketsPerElem));
         }
         BloomCalculations.BloomSpecification spec = BloomCalculations.computeBloomSpec(bucketsPerElement);
-        logger.debug("Creating bloom filter for {} elements and spec {}", numElements, spec);
+        logger.trace("Creating bloom filter for {} elements and spec {}", numElements, spec);
         return new BloomFilter(spec.K, bucketsFor(numElements, spec.bucketsPerElement));
     }
 

File: src/java/org/apache/cassandra/scheduler/WeightedQueue.java
Patch:
@@ -60,7 +60,8 @@ public void register()
 
     public void put(Thread t, long timeoutMS) throws InterruptedException, TimeoutException
     {
-        queue.offer(new WeightedQueue.Entry(t), timeoutMS, TimeUnit.MILLISECONDS);
+        if (!queue.offer(new WeightedQueue.Entry(t), timeoutMS, TimeUnit.MILLISECONDS))
+            throw new TimeoutException("Failed to acquire request scheduler slot for '" + key + "'");
     }
 
     public Thread poll()

File: src/java/org/apache/cassandra/thrift/ThriftValidation.java
Patch:
@@ -725,7 +725,7 @@ public static void validateKeyspaceNotYetExisting(String newKsName) throws Inval
         // keyspace names must be unique case-insensitively because the keyspace name becomes the directory
         // where we store CF sstables.  Names that differ only in case would thus cause problems on
         // case-insensitive filesystems (NTFS, most installations of HFS+).
-        for (String ksName : DatabaseDescriptor.getTables())
+        for (String ksName : Schema.instance.getTables())
         {
             if (ksName.equalsIgnoreCase(newKsName))
                 throw new InvalidRequestException("Keyspace names must be case-insensitively unique");

File: src/java/org/apache/cassandra/service/GCInspector.java
Patch:
@@ -103,6 +103,8 @@ private void logGCResults()
 
             Long previousCount = gccounts.get(gc.getName());
             Long count = gc.getCollectionCount();
+            if (count == 0)
+                continue;
             if (previousCount == null)
                 previousCount = 0L;
             gccounts.put(gc.getName(), count);

File: src/java/org/apache/cassandra/db/RowIteratorFactory.java
Patch:
@@ -61,14 +61,13 @@ public int compare(IColumnIterator o1, IColumnIterator o2)
      * @param comparator
      * @return A row iterator following all the given restrictions
      */
-    public static CloseableIterator<Row> getIterator(final Collection<Memtable> memtables,
+    public static CloseableIterator<Row> getIterator(final Iterable<Memtable> memtables,
                                           final Collection<SSTableReader> sstables,
                                           final DecoratedKey startWith,
                                           final DecoratedKey stopAt,
                                           final QueryFilter filter,
                                           final AbstractType comparator,
-                                          final ColumnFamilyStore cfs
-    )
+                                          final ColumnFamilyStore cfs)
     {
         // fetch data from current memtable, historical memtables, and SSTables in the correct order.
         final List<CloseableIterator<IColumnIterator>> iterators = new ArrayList<CloseableIterator<IColumnIterator>>();

File: src/java/org/apache/cassandra/cli/CliCompiler.java
Patch:
@@ -96,7 +96,7 @@ public static Tree compileQuery(String query)
 
     public static String getColumnFamily(Tree astNode, List<CfDef> cfDefs)
     {
-        return getColumnFamily(astNode.getChild(0).getText(), cfDefs);
+        return getColumnFamily(CliUtils.unescapeSQLString(astNode.getChild(0).getText()), cfDefs);
     }
 
     public static String getColumnFamily(String cfName, List<CfDef> cfDefs)

File: src/java/org/apache/cassandra/service/DatacenterSyncWriteResponseHandler.java
Patch:
@@ -113,7 +113,7 @@ public void assureSufficientLiveNodes() throws UnavailableException
         // Throw exception if any of the DC doesn't have livenodes to accept write.
         for (String dc: strategy.getDatacenters())
         {
-        	if (dcEndpoints.get(dc).get() != responses.get(dc).get())
+        	if (dcEndpoints.get(dc).get() < responses.get(dc).get())
                 throw new UnavailableException();
         }
     }

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -619,6 +619,8 @@ public Map<Range, List<String>> getRangeToRpcaddressMap(String keyspace)
             {
                 if (endpoint.equals(FBUtilities.getLocalAddress()))
                     rpcaddrs.add(DatabaseDescriptor.getRpcAddress().getHostAddress());
+                else if (Gossiper.instance.getEndpointStateForEndpoint(endpoint).getApplicationState(ApplicationState.RPC_ADDRESS) == null)
+                    rpcaddrs.add(endpoint.getHostAddress());
                 else
                     rpcaddrs.add(Gossiper.instance.getEndpointStateForEndpoint(endpoint).getApplicationState(ApplicationState.RPC_ADDRESS).value);
             }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -478,13 +478,15 @@ private static Map<Descriptor,Set<Component>> files(String keyspace, final Strin
     private static List<Pair<Descriptor, Component>> files(File path, final String columnFamilyName)
     {
         final List<Pair<Descriptor, Component>> sstables = new ArrayList<Pair<Descriptor, Component>>();
+        final String sstableFilePrefix = columnFamilyName + Component.separator;
+
         // NB: we never "accept" a file in the FilenameFilter sense: they are added to the sstable map
         path.listFiles(new FileFilter()
         {
             public boolean accept(File file)
             {
                 // we are only interested in the SSTable files that belong to the specific ColumnFamily
-                if (file.isDirectory() || !file.getName().startsWith(columnFamilyName))
+                if (file.isDirectory() || !file.getName().startsWith(sstableFilePrefix))
                     return false;
 
                 Pair<Descriptor, Component> pair = SSTable.tryComponentFromFilename(file.getParentFile(), file.getName());

File: src/java/org/apache/cassandra/io/sstable/SSTable.java
Patch:
@@ -158,12 +158,13 @@ public static Pair<Descriptor,Component> tryComponentFromFilename(File dir, Stri
     static Set<Component> componentsFor(final Descriptor desc, final Descriptor.TempState matchState)
     {
         final Set<Component> components = new HashSet<Component>();
+        final String sstableFilePrefix = desc.cfname + Component.separator;
 
         desc.directory.listFiles(new FileFilter()
         {
             public boolean accept(File file)
             {
-                if (file.isDirectory() || !file.getName().startsWith(desc.cfname))
+                if (file.isDirectory() || !file.getName().startsWith(sstableFilePrefix))
                     return false;
 
                 Pair<Descriptor, Component> component = tryComponentFromFilename(file.getParentFile(), file.getName());

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -1389,7 +1389,7 @@ private void executeDropIndex(Tree statement)
 
         // getColumnFamily will check if CF exists for us
         String columnFamily = CliCompiler.getColumnFamily(statement, keyspacesMap.get(keySpace).cf_defs);
-        String rawColumName = statement.getChild(1).getText();
+        String rawColumName = CliUtils.unescapeSQLString(statement.getChild(1).getText());
 
         CfDef cfDef = getCfDef(columnFamily);
 

File: src/java/org/apache/cassandra/gms/VersionedValue.java
Patch:
@@ -160,7 +160,7 @@ public VersionedValue rack(String rackId)
 
         public VersionedValue rpcaddress(InetAddress endpoint)
         {
-            return new VersionedValue(endpoint.toString());
+            return new VersionedValue(endpoint.getHostAddress());
         }
 
         public VersionedValue releaseVersion()

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -36,7 +36,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import org.apache.cassandra.concurrent.RetryingScheduledThreadPoolExecutor;
+import org.apache.cassandra.concurrent.DebuggableScheduledThreadPoolExecutor;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.net.Message;
@@ -56,7 +56,7 @@
 
 public class Gossiper implements IFailureDetectionEventListener
 {
-    private static final RetryingScheduledThreadPoolExecutor executor = new RetryingScheduledThreadPoolExecutor("GossipTasks");
+    private static final DebuggableScheduledThreadPoolExecutor executor = new DebuggableScheduledThreadPoolExecutor("GossipTasks");
 
     static final ApplicationState[] STATES = ApplicationState.values();
     static final List<String> DEAD_STATES = Arrays.asList(VersionedValue.REMOVING_TOKEN, VersionedValue.REMOVED_TOKEN, VersionedValue.STATUS_LEFT);

File: test/unit/org/apache/cassandra/locator/DynamicEndpointSnitchTest.java
Patch:
@@ -35,7 +35,7 @@ public class DynamicEndpointSnitchTest
     public void testSnitch() throws InterruptedException, IOException, ConfigurationException
     {
         // do this because SS needs to be initialized before DES can work properly.
-        StorageService.instance.initClient();
+        StorageService.instance.initClient(0);
         int sleeptime = 150;
         DynamicEndpointSnitch dsnitch = new DynamicEndpointSnitch(new SimpleSnitch());
         InetAddress self = FBUtilities.getBroadcastAddress();

File: test/unit/org/apache/cassandra/db/CleanupTest.java
Patch:
@@ -67,7 +67,7 @@ public class CleanupTest extends CleanupHelper
     @Test
     public void testCleanup() throws IOException, ExecutionException, InterruptedException, ConfigurationException
     {
-        StorageService.instance.initServer();
+        StorageService.instance.initServer(0);
 
         Table table = Table.open(TABLE1);
         ColumnFamilyStore cfs = table.getColumnFamilyStore(CF2);

File: test/unit/org/apache/cassandra/dht/BootStrapperTest.java
Patch:
@@ -46,7 +46,7 @@ public class BootStrapperTest extends CleanupHelper
     @Test
     public void testTokenRoundtrip() throws Exception
     {
-        StorageService.instance.initServer();
+        StorageService.instance.initServer(0);
         // fetch a bootstrap token from the local node
         assert BootStrapper.getBootstrapTokenFrom(FBUtilities.getBroadcastAddress()) != null;
     }

File: test/unit/org/apache/cassandra/service/AntiEntropyServiceTestAbstract.java
Patch:
@@ -78,7 +78,7 @@ public void prepare() throws Exception
             init();
 
             LOCAL = FBUtilities.getBroadcastAddress();
-            StorageService.instance.initServer();
+            StorageService.instance.initServer(0);
             // generate a fake endpoint for which we can spoof receiving/sending trees
             REMOTE = InetAddress.getByName("127.0.0.2");
             store = null;

File: test/unit/org/apache/cassandra/service/StorageServiceServerTest.java
Patch:
@@ -42,7 +42,7 @@ public void testRegularMode() throws IOException, InterruptedException, Configur
     {
         CleanupHelper.mkdirs();
         CleanupHelper.cleanup();
-        StorageService.instance.initServer();
+        StorageService.instance.initServer(0);
         for (String path : DatabaseDescriptor.getAllDataFileLocations())
         {
             // verify that storage directories are there.

File: src/java/org/apache/cassandra/io/compress/CompressedSequentialWriter.java
Patch:
@@ -139,7 +139,7 @@ public synchronized void resetAndTruncate(FileMark mark) throws IOException
         int chunkSize = (int) (metadataWriter.chunkOffsetBy(realMark.nextChunkIndex) - chunkOffset - 4);
 
         out.seek(chunkOffset);
-        out.read(compressed, 0, chunkSize);
+        out.readFully(compressed, 0, chunkSize);
 
         // decompress data chunk and store its length
         int validBytes = Snappy.rawUncompress(compressed, 0, chunkSize, buffer, 0);

File: src/java/org/apache/cassandra/io/sstable/SSTableSimpleUnsortedWriter.java
Patch:
@@ -63,7 +63,7 @@ public SSTableSimpleUnsortedWriter(File directory,
                                        int bufferSizeInMB) throws IOException
     {
         super(directory, new CFMetaData(keyspace, columnFamily, subComparator == null ? ColumnFamilyType.Standard : ColumnFamilyType.Super, comparator, subComparator));
-        this.bufferSize = bufferSizeInMB * 1024 * 1024;
+        this.bufferSize = bufferSizeInMB * 1024L * 1024L;
     }
 
     protected void writeRow(DecoratedKey key, ColumnFamily columnFamily) throws IOException

File: src/java/org/apache/cassandra/db/compaction/CompactionController.java
Patch:
@@ -133,8 +133,9 @@ public AbstractCompactedRow getCompactedRow(List<SSTableIdentityIterator> rows)
 
         if (rowSize > DatabaseDescriptor.getInMemoryCompactionLimit())
         {
-            logger.info(String.format("Compacting large row %s (%d bytes) incrementally (keyspace: %s, cf: %s)",
-                                      ByteBufferUtil.bytesToHex(rows.get(0).getKey().key), rowSize), cfs.table.name, cfs.columnFamily);
+            String keyString = cfs.metadata.getKeyValidator().getString(rows.get(0).getKey().key);
+            logger.info(String.format("Compacting large row %s/%s:%s (%d bytes) incrementally",
+                                      cfs.table.name, cfs.columnFamily, keyString, rowSize));
             return new LazilyCompactedRow(this, rows);
         }
         return new PrecompactedRow(this, rows);

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -32,7 +32,7 @@ public class Config
     /* Hashing strategy Random or OPHF */
     public String partitioner;
     
-    public Boolean auto_bootstrap = true;
+    public Boolean auto_bootstrap = false;
     public Boolean hinted_handoff_enabled = true;
     public Integer max_hint_window_in_ms = Integer.MAX_VALUE;
     

File: src/java/org/apache/cassandra/db/commitlog/CommitLogSegment.java
Patch:
@@ -212,7 +212,7 @@ String dirtyString()
         for (Integer cfId : cfLastWrite.keySet())
         {
             CFMetaData m = DatabaseDescriptor.getCFMetaData(cfId);
-            sb.append(m == null ? m.cfName : "<deleted>").append(" (").append(cfId).append("), ");
+            sb.append(m == null ? "<deleted>" : m.cfName).append(" (").append(cfId).append("), ");
         }
         return sb.toString();
     }

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -32,7 +32,7 @@ public class Config
     /* Hashing strategy Random or OPHF */
     public String partitioner;
     
-    public Boolean auto_bootstrap = false;
+    public Boolean auto_bootstrap = true;
     public Boolean hinted_handoff_enabled = true;
     public Integer max_hint_window_in_ms = Integer.MAX_VALUE;
     

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -417,7 +417,8 @@ public IAsyncResult sendRR(Message message, InetAddress to)
     public void stream(StreamHeader header, InetAddress to)
     {
         /* Streaming asynchronously on streamExector_ threads. */
-        if (DatabaseDescriptor.getEncryptionOptions().internode_encryption == EncryptionOptions.InternodeEncryption.all)
+        EncryptionOptions encryption = DatabaseDescriptor.getEncryptionOptions();
+        if (encryption != null && encryption.internode_encryption == EncryptionOptions.InternodeEncryption.all)
             streamExecutor_.execute(new SSLFileStreamTask(header, to));
         else
             streamExecutor_.execute(new FileStreamTask(header, to));

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -618,7 +618,7 @@ public Map<Range, List<String>> getRangeToRpcaddressMap(String keyspace)
             for (InetAddress endpoint: entry.getValue())
             {
                 if (endpoint.equals(FBUtilities.getLocalAddress()))
-                    rpcaddrs.add(DatabaseDescriptor.getRpcAddress().toString());
+                    rpcaddrs.add(DatabaseDescriptor.getRpcAddress().getHostAddress());
                 else
                     rpcaddrs.add(Gossiper.instance.getEndpointStateForEndpoint(endpoint).getApplicationState(ApplicationState.RPC_ADDRESS).value);
             }

File: src/java/org/apache/cassandra/io/compress/CompressedRandomAccessReader.java
Patch:
@@ -135,7 +135,7 @@ public CompressedRandomAccessReader(String dataFilePath, CompressionMetadata met
     {
         super(new File(dataFilePath), metadata.chunkLength, skipIOCache);
         this.metadata = metadata;
-        compressed = new byte[metadata.chunkLength];
+        compressed = new byte[Snappy.maxCompressedLength(metadata.chunkLength)];
         // can't use super.read(...) methods
         // that is why we are allocating special InputStream to read data from disk
         // from already open file descriptor

File: src/java/org/apache/cassandra/io/compress/CompressedSequentialWriter.java
Patch:
@@ -53,7 +53,7 @@ public CompressedSequentialWriter(File file, String indexFilePath, boolean skipI
         super(file, CHUNK_LENGTH, skipIOCache);
 
         // buffer for compression should be the same size as buffer itself
-        compressed = new byte[buffer.length];
+        compressed = new byte[Snappy.maxCompressedLength(buffer.length)];
 
         /* Index File (-CompressionInfo.db component) and it's header */
         metadataWriter = new CompressionMetadata.Writer(indexFilePath);
@@ -85,6 +85,7 @@ protected void flushData() throws IOException
         chunkCount++;
 
         // write data itself
+        assert compressedLength <= compressed.length;
         out.write(compressed, 0, compressedLength);
 
         // next chunk should be written right after current

File: src/java/org/apache/cassandra/db/compaction/CompactionIterator.java
Patch:
@@ -120,7 +120,7 @@ protected AbstractCompactedRow getReduced()
 
         try
         {
-            AbstractCompactedRow compactedRow = controller.getCompactedRow(rows);
+            AbstractCompactedRow compactedRow = controller.getCompactedRow(new ArrayList<SSTableIdentityIterator>(rows));
             if (compactedRow.isEmpty())
             {
                 controller.invalidateCachedRow(compactedRow.key);

File: test/unit/org/apache/cassandra/service/AntiEntropyServiceTestAbstract.java
Patch:
@@ -32,6 +32,7 @@
 import org.apache.cassandra.Util;
 import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.concurrent.StageManager;
+import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.compaction.PrecompactedRow;
 import org.apache.cassandra.dht.IPartitioner;
@@ -150,7 +151,8 @@ public void testValidatorAdd() throws Throwable
         validator.prepare(store);
 
         // add a row
-        validator.add(new PrecompactedRow(new DecoratedKey(mid, ByteBufferUtil.bytes("inconceivable!")), null));
+        validator.add(new PrecompactedRow(new DecoratedKey(mid, ByteBufferUtil.bytes("inconceivable!")),
+                                          new ColumnFamily(DatabaseDescriptor.getCFMetaData(tablename, cfname))));
         validator.completeTree();
 
         // confirm that the tree was validated

File: src/java/org/apache/cassandra/streaming/IncomingStreamReader.java
Patch:
@@ -117,7 +117,7 @@ private SSTableReader streamIn(DataInput input, PendingFile localFile, PendingFi
                 long bytesRead = 0;
                 while (bytesRead < length)
                 {
-                    in.reset();
+                    in.reset(0);
                     key = SSTableReader.decodeKey(StorageService.getPartitioner(), localFile.desc, ByteBufferUtil.readWithShortLength(in));
                     long dataSize = SSTableReader.readRowSize(in, localFile.desc);
                     ColumnFamily cf = null;

File: test/unit/org/apache/cassandra/db/DefsTest.java
Patch:
@@ -50,6 +50,7 @@
 import org.apache.cassandra.io.SerDeUtils;
 import org.apache.cassandra.io.sstable.Component;
 import org.apache.cassandra.io.sstable.Descriptor;
+import org.apache.cassandra.io.sstable.SSTableDeletingTask;
 import org.apache.cassandra.locator.OldNetworkTopologyStrategy;
 import org.apache.cassandra.locator.SimpleStrategy;
 import org.apache.cassandra.net.MessagingService;
@@ -811,7 +812,7 @@ public void testDropIndex() throws IOException, ExecutionException, InterruptedE
 
         // check
         assert cfs.getIndexedColumns().isEmpty();
-        ColumnFamilyStore.scrubDataDirectories("Keyspace6", "Indexed1");
+        SSTableDeletingTask.waitForDeletions();
         assert !new File(desc.filenameFor(Component.DATA)).exists();
     }
 

File: src/java/org/apache/cassandra/db/SystemTable.java
Patch:
@@ -404,9 +404,8 @@ public static NodeId getCurrentLocalNodeId()
      * table)
      * @param newNodeId the new current local node id to record
      */
-    public static void writeCurrentLocalNodeId(NodeId oldNodeId, NodeId newNodeId)
+    public static void writeCurrentLocalNodeId(NodeId oldNodeId, NodeId newNodeId, long now)
     {
-        long now = System.currentTimeMillis();
         ByteBuffer ip = ByteBuffer.wrap(FBUtilities.getLocalAddress().getAddress());
 
         ColumnFamily cf = ColumnFamily.create(Table.SYSTEM_TABLE, NODE_ID_CF);
@@ -441,7 +440,7 @@ public static List<NodeId.NodeIdRecord> getOldLocalNodeIds()
         ColumnFamily cf = table.getColumnFamilyStore(NODE_ID_CF).getColumnFamily(filter);
 
         NodeId previous = null;
-        for (IColumn c : cf.getReverseSortedColumns())
+        for (IColumn c : cf)
         {
             if (previous != null)
                 l.add(new NodeId.NodeIdRecord(previous, c.timestamp()));

File: src/java/org/apache/cassandra/db/compaction/LazilyCompactedRow.java
Patch:
@@ -193,7 +193,7 @@ protected IColumn getReduced()
             assert container != null;
             IColumn reduced = container.iterator().next();
             ColumnFamily purged = shouldPurge ? ColumnFamilyStore.removeDeleted(container, controller.gcBefore) : container;
-            if (purged != null && purged.metadata().getDefaultValidator().isCommutative())
+            if (shouldPurge && purged != null && purged.metadata().getDefaultValidator().isCommutative())
             {
                 CounterColumn.removeOldShards(purged, controller.gcBefore);
             }

File: src/java/org/apache/cassandra/db/compaction/PrecompactedRow.java
Patch:
@@ -82,8 +82,9 @@ public PrecompactedRow(CompactionController controller, List<SSTableIdentityIter
                 cf.addAll(thisCF);
             }
         }
-        compactedCf = controller.shouldPurge(key) ? ColumnFamilyStore.removeDeleted(cf, controller.gcBefore) : cf;
-        if (compactedCf != null && compactedCf.metadata().getDefaultValidator().isCommutative())
+        boolean shouldPurge = controller.shouldPurge(key);
+        compactedCf = shouldPurge ? ColumnFamilyStore.removeDeleted(cf, controller.gcBefore) : cf;
+        if (shouldPurge && compactedCf != null && compactedCf.metadata().getDefaultValidator().isCommutative())
         {
             CounterColumn.removeOldShards(compactedCf, controller.gcBefore);
         }

File: test/unit/org/apache/cassandra/SchemaLoader.java
Patch:
@@ -137,7 +137,8 @@ public static Collection<KSMetaData> schemaDefinition() throws ConfigurationExce
                                                  st,
                                                  bytes,
                                                  null)
-                                                 .defaultValidator(CounterColumnType.instance),
+                                                 .defaultValidator(CounterColumnType.instance)
+                                                 .mergeShardsChance(1.0),
                                   new CFMetaData(ks1,
                                                  "SuperCounter1",
                                                  su,

File: src/java/org/apache/cassandra/service/IResponseResolver.java
Patch:
@@ -43,4 +43,6 @@ public interface IResponseResolver<T> {
 
     public void preprocess(Message message);
     public Iterable<Message> getMessages();
+
+    public int getMaxLiveColumns();
 }

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -1715,7 +1715,7 @@ private void describeKeySpace(String keySpaceName, KsDef metadata) throws TExcep
                 sessionState.out.printf("      Columns sorted by: %s%s%n", cf_def.comparator_type, cf_def.column_type.equals("Super") ? "/" + cf_def.subcomparator_type : "");
                 sessionState.out.printf("      Row cache size / save period in seconds: %s/%s%n", cf_def.row_cache_size, cf_def.row_cache_save_period_in_seconds);
                 sessionState.out.printf("      Key cache size / save period in seconds: %s/%s%n", cf_def.key_cache_size, cf_def.key_cache_save_period_in_seconds);
-                sessionState.out.printf("      Memtable thresholds: %s/%s/%s (millions of ops/MB/minutes)%n",
+                sessionState.out.printf("      Memtable thresholds: %s/%s/%s (millions of ops/minutes/MB)%n",
                                 cf_def.memtable_operations_in_millions, cf_def.memtable_flush_after_mins, cf_def.memtable_throughput_in_mb);
                 sessionState.out.printf("      GC grace seconds: %s%n", cf_def.gc_grace_seconds);
                 sessionState.out.printf("      Compaction min/max thresholds: %s/%s%n", cf_def.min_compaction_threshold, cf_def.max_compaction_threshold);

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -1252,6 +1252,7 @@ private CfDef updateCfDefAttributes(Tree statement, CfDef cfDefToUpdate)
                 break;
             case KEY_VALIDATION_CLASS:
                 cfDef.setKey_validation_class(CliUtils.unescapeSQLString(mValue));
+                break;
             case COMPACTION_STRATEGY:
                 cfDef.setCompaction_strategy(CliUtils.unescapeSQLString(mValue));
                 break;

File: src/java/org/apache/cassandra/cache/FreeableMemory.java
Patch:
@@ -67,7 +67,7 @@ private void free()
     @Override
     protected void finalize()
     {
-        assert references.get() == 0;
+        assert references.get() <= 0;
         assert peer == 0;
     }
     

File: src/java/org/apache/cassandra/service/AntiEntropyService.java
Patch:
@@ -805,7 +805,8 @@ void performStreamingRepair() throws IOException
                 ColumnFamilyStore cfstore = Table.open(tablename).getColumnFamilyStore(cfname);
                 try
                 {
-                    Collection<SSTableReader> sstables = cfstore.getSSTables();
+                    // We acquire references for transferSSTables
+                    Collection<SSTableReader> sstables = cfstore.markCurrentSSTablesReferenced();
                     Callback callback = new Callback();
                     // send ranges to the remote node
                     StreamOutSession outsession = StreamOutSession.create(tablename, remote, callback);

File: src/java/org/apache/cassandra/net/IncomingTcpConnection.java
Patch:
@@ -75,8 +75,9 @@ public void run()
         }
         catch (IOException e)
         {
+            logger.debug("Incoming IOException", e);
             close();
-            throw new IOError(e);
+            return;
         }
 
         if (version > MessagingService.version_)

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -960,6 +960,7 @@ public synchronized String system_update_column_family(CfDef cf_def)
         CFMetaData oldCfm = DatabaseDescriptor.getCFMetaData(CFMetaData.getId(cf_def.keyspace, cf_def.name));
         if (oldCfm == null)
             throw new InvalidRequestException("Could not find column family definition to modify.");
+        CFMetaData.addDefaultIndexNames(cf_def);
         ThriftValidation.validateCfDef(cf_def, oldCfm);
         validateSchemaAgreement();
 

File: src/java/org/apache/cassandra/gms/EndpointState.java
Patch:
@@ -131,12 +131,12 @@ void isAGossiper(boolean value)
         isAGossiper_ = value;        
     }
 
-    public void setHasToken(boolean value)
+    void setHasToken(boolean value)
     {
         hasToken_ = value;
     }
 
-    public boolean hasToken()
+    boolean hasToken()
     {
         return hasToken_;
     }

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1127,7 +1127,7 @@ public void onJoin(InetAddress endpoint, EndpointState epState)
 
     public void onAlive(InetAddress endpoint, EndpointState state)
     {
-        if (!isClientMode && state.hasToken())
+        if (!isClientMode && StorageService.instance.getTokenMetadata().isMember(endpoint))
             deliverHints(endpoint);
     }
 

File: src/java/org/apache/cassandra/io/sstable/AbstractSSTableSimpleWriter.java
Patch:
@@ -56,7 +56,7 @@ protected SSTableWriter getWriter() throws IOException
             0, // We don't care about the bloom filter
             metadata,
             StorageService.getPartitioner(),
-            ReplayPosition.NONE);
+            SSTableMetadata.createCollector());
     }
 
     // find available generation and pick up filename from that

File: src/java/org/apache/cassandra/db/migration/UpdateKeyspace.java
Patch:
@@ -51,7 +51,8 @@ public UpdateKeyspace(KSMetaData ksm) throws ConfigurationException, IOException
         oldKsm = DatabaseDescriptor.getKSMetaData(ksm.name);
         if (oldKsm == null)
             throw new ConfigurationException(ksm.name + " cannot be updated because it doesn't exist.");
-        this.newKsm = new KSMetaData(ksm.name, ksm.strategyClass, ksm.strategyOptions, oldKsm.cfMetaData().values().toArray(new CFMetaData[]{}));
+
+        this.newKsm = new KSMetaData(ksm.name, ksm.strategyClass, ksm.strategyOptions, ksm.isDurableWrites(), oldKsm.cfMetaData().values().toArray(new CFMetaData[]{}));
         rm = makeDefinitionMutation(newKsm, oldKsm, newVersion);
     }
     
@@ -60,7 +61,6 @@ void applyModels() throws IOException
         DatabaseDescriptor.clearTableDefinition(oldKsm, newVersion);
         DatabaseDescriptor.setTableDefinition(newKsm, newVersion);
 
-
         Table table = Table.open(newKsm.name);
         try
         {

File: src/java/org/apache/cassandra/tools/BulkLoader.java
Patch:
@@ -164,7 +164,7 @@ private int mbPerSec(long bytes, long timeInMs)
 
     static class ExternalClient extends SSTableLoader.Client
     {
-        private final Map<String, Map<String, CFMetaData>> knownCfs = new HashMap<String, Map<String, CFMetaData>>();
+        private final Map<String, Set<String>> knownCfs = new HashMap<String, Set<String>>();
         private final SSTableLoader.OutputHandler outputHandler;
 
         public ExternalClient(SSTableLoader.OutputHandler outputHandler)

File: src/java/org/apache/cassandra/io/sstable/SSTableLoader.java
Patch:
@@ -101,7 +101,7 @@ public LoaderFuture stream() throws IOException
 
     public LoaderFuture stream(Set<InetAddress> toIgnore) throws IOException
     {
-        client.init();
+        client.init(keyspace);
 
         Collection<SSTableReader> sstables = openSSTables();
         if (sstables.isEmpty())
@@ -234,7 +234,7 @@ public static abstract class Client
          * This method is guaranted to be called before any other method of a
          * client.
          */
-        public abstract void init();
+        public abstract void init(String keyspace);
 
         /**
          * Stop the client.

File: test/unit/org/apache/cassandra/cli/CliTest.java
Patch:
@@ -53,6 +53,8 @@ public class CliTest extends CleanupHelper
         "get CF1 where world2 = long(15);",
         "get cF1 where world2 = long(15);",
         "get Cf1 where world2 = long(15);",
+        "del CF1[utf8('hello')][utf8('world')];",
+        "del CF1[hello][world2];",
         "set CF1['hello'][time_spent_uuid] = timeuuid(a8098c1a-f86e-11da-bd1a-00112444be1e);",
         "create column family CF2 with comparator=IntegerType;",
         "set CF2['key'][98349387493847748398334] = 'some text';",

File: src/java/org/apache/cassandra/db/SuperColumn.java
Patch:
@@ -138,7 +138,8 @@ public long maxTimestamp()
         long maxTimestamp = Long.MIN_VALUE;
         for (IColumn subColumn : getSubColumns())
             maxTimestamp = Math.max(maxTimestamp, subColumn.maxTimestamp());
-        return maxTimestamp;
+
+        return Math.max(maxTimestamp, getMarkedForDeleteAt());
     }
 
     public long mostRecentLiveChangeAt()

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -1352,7 +1352,7 @@ private void describeKeySpace(String keySpaceName, KsDef metadata) throws TExcep
                 sessionState.out.printf("      Row cache size / save period in seconds: %s/%s%n", cf_def.row_cache_size, cf_def.row_cache_save_period_in_seconds);
                 sessionState.out.printf("      Key cache size / save period in seconds: %s/%s%n", cf_def.key_cache_size, cf_def.key_cache_save_period_in_seconds);
                 sessionState.out.printf("      Memtable thresholds: %s/%s/%s (millions of ops/minutes/MB)%n",
-                                cf_def.memtable_operations_in_millions, cf_def.memtable_throughput_in_mb, cf_def.memtable_flush_after_mins);
+                                cf_def.memtable_operations_in_millions, cf_def.memtable_flush_after_mins, cf_def.memtable_throughput_in_mb);
                 sessionState.out.printf("      GC grace seconds: %s%n", cf_def.gc_grace_seconds);
                 sessionState.out.printf("      Compaction min/max thresholds: %s/%s%n", cf_def.min_compaction_threshold, cf_def.max_compaction_threshold);
                 sessionState.out.printf("      Read repair chance: %s%n", cf_def.read_repair_chance);

File: src/java/org/apache/cassandra/dht/OrderPreservingPartitioner.java
Patch:
@@ -188,7 +188,7 @@ public Map<Token, Float> describeOwnership(List<Token> sortedTokens)
                 for (Range r : sortedRanges)
                 {
                     // Looping over every KS:CF:Range, get the splits size and add it to the count
-                    allTokens.put(r.right, allTokens.get(r.right) + StorageService.instance.getSplits(ks, cfmd.cfName, r, 1).size());
+                    allTokens.put(r.right, allTokens.get(r.right) + StorageService.instance.getSplits(ks, cfmd.cfName, r, DatabaseDescriptor.getIndexInterval()).size());
                 }
             }
         }

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -631,8 +631,8 @@ public CompactionInfo getCompactionInfo()
             return new CompactionInfo(cfs.table.name,
                                       cfs.columnFamily,
                                       CompactionType.INDEX_BUILD,
-                                      iter.getTotalBytes(),
-                                      iter.getBytesRead());
+                                      iter.getBytesRead(),
+                                      iter.getTotalBytes());
         }
 
         public void build()

File: src/java/org/apache/cassandra/streaming/StreamOut.java
Patch:
@@ -176,7 +176,7 @@ private static List<PendingFile> createPendingFiles(Collection<SSTableReader> ss
             List<Pair<Long,Long>> sections = sstable.getPositionsForRanges(ranges);
             if (sections.isEmpty())
                 continue;
-            pending.add(new PendingFile(sstable, desc, SSTable.COMPONENT_DATA, sections, type));
+            pending.add(new PendingFile(sstable, desc, SSTable.COMPONENT_DATA, sections, type, sstable.estimatedKeys()));
         }
         logger.info("Stream context metadata {}, {} sstables.", pending, sstables.size());
         return pending;

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -902,10 +902,10 @@ private CfDef updateCfDefAttributes(Tree statement, CfDef cfDefToUpdate)
                 cfDef.setKey_cache_size(Double.parseDouble(mValue));
                 break;
             case READ_REPAIR_CHANCE:
-                double chance = Double.parseDouble(mValue) / 100;
+                double chance = Double.parseDouble(mValue);
 
                 if (chance > 1)
-                    throw new RuntimeException("Error: read_repair_chance / 100 should not be greater than 1.");
+                    throw new RuntimeException("Error: read_repair_chance should not be greater than 1.");
 
                 cfDef.setRead_repair_chance(chance);
                 break;

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -614,6 +614,8 @@ public static void applyImplicitDefaults(org.apache.cassandra.thrift.CfDef cf_de
     {
         if (!cf_def.isSetComment())
             cf_def.setComment("");
+        if (!cf_def.isSetReplicate_on_write())
+            cf_def.setReplicate_on_write(CFMetaData.DEFAULT_REPLICATE_ON_WRITE);
         if (!cf_def.isSetMin_compaction_threshold())
             cf_def.setMin_compaction_threshold(CFMetaData.DEFAULT_MIN_COMPACTION_THRESHOLD);
         if (!cf_def.isSetMax_compaction_threshold())

File: src/java/org/apache/cassandra/service/RangeSliceResponseResolver.java
Patch:
@@ -117,7 +117,9 @@ protected Row getReduced()
                         }
                     }
                 }
-                RowRepairResolver.maybeScheduleRepairs(resolved, table, key, versions, versionSources);
+                // resolved can be null even if versions doesn't have all nulls because of the call to removeDeleted in resolveSuperSet
+                if (resolved != null)
+                    RowRepairResolver.maybeScheduleRepairs(resolved, table, key, versions, versionSources);
                 versions.clear();
                 versionSources.clear();
                 return new Row(key, resolved);

File: src/java/org/apache/cassandra/service/RowRepairResolver.java
Patch:
@@ -78,7 +78,9 @@ public Row resolve() throws DigestMismatchException, IOException
             resolved = resolveSuperset(versions);
             if (logger.isDebugEnabled())
                 logger.debug("versions merged");
-            maybeScheduleRepairs(resolved, table, key, versions, endpoints);
+            // resolved can be null even if versions doesn't have all nulls because of the call to removeDeleted in resolveSuperSet
+            if (resolved != null)
+                maybeScheduleRepairs(resolved, table, key, versions, endpoints);
         }
         else
         {

File: src/java/org/apache/cassandra/service/RangeSliceResponseResolver.java
Patch:
@@ -117,7 +117,9 @@ protected Row getReduced()
                         }
                     }
                 }
-                RowRepairResolver.maybeScheduleRepairs(resolved, table, key, versions, versionSources);
+                // resolved can be null even if versions doesn't have all nulls because of the call to removeDeleted in resolveSuperSet
+                if (resolved != null)
+                    RowRepairResolver.maybeScheduleRepairs(resolved, table, key, versions, versionSources);
                 versions.clear();
                 versionSources.clear();
                 return new Row(key, resolved);

File: src/java/org/apache/cassandra/service/RowRepairResolver.java
Patch:
@@ -80,7 +80,9 @@ public Row resolve() throws DigestMismatchException, IOException
             resolved = resolveSuperset(versions);
             if (logger.isDebugEnabled())
                 logger.debug("versions merged");
-            maybeScheduleRepairs(resolved, table, key, versions, endpoints);
+            // resolved can be null even if versions doesn't have all nulls because of the call to removeDeleted in resolveSuperSet
+            if (resolved != null)
+                maybeScheduleRepairs(resolved, table, key, versions, endpoints);
         }
         else
         {

File: src/java/org/apache/cassandra/concurrent/DebuggableThreadPoolExecutor.java
Patch:
@@ -57,9 +57,9 @@ public DebuggableThreadPoolExecutor(int corePoolSize, long keepAliveTime, TimeUn
         super(corePoolSize, corePoolSize, keepAliveTime, unit, workQueue, threadFactory);
         allowCoreThreadTimeOut(true);
 
-        // preserve task serialization.  this is more complicated than it needs to be,
-        // since TPE rejects if queue.offer reports a full queue.  we'll just
-        // override this with a handler that retries until it gets in.  ugly, but effective.
+        // block task submissions until queue has room.
+        // this is fighting TPE's design a bit because TPE rejects if queue.offer reports a full queue.
+        // we'll just override this with a handler that retries until it gets in.  ugly, but effective.
         // (there is an extensive analysis of the options here at
         //  http://today.java.net/pub/a/today/2008/10/23/creating-a-notifying-blocking-thread-pool-executor.html)
         this.setRejectedExecutionHandler(new RejectedExecutionHandler()

File: examples/hadoop_word_count/src/WordCount.java
Patch:
@@ -137,7 +137,7 @@ private static Mutation getMutation(Text word, int sum)
         {
             Column c = new Column();
             c.setName(Arrays.copyOf(word.getBytes(), word.getLength()));
-            c.setValue(ByteBufferUtil.bytes(String.valueOf(sum));
+            c.setValue(ByteBufferUtil.bytes(String.valueOf(sum)));
             c.setTimestamp(System.currentTimeMillis());
 
             Mutation m = new Mutation();

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -1731,7 +1731,7 @@ private void describeKeySpace(String keySpaceName, KsDef metadata) throws TExcep
                 sessionState.out.printf("      Compaction Strategy: %s%n", cf_def.compaction_strategy);
                 if (!cf_def.compaction_strategy_options.isEmpty())
                 {
-                    sessionState.out.printf("      Compaction Strategy Options: %s%n", cf_def.compaction_strategy);
+                    sessionState.out.println("      Compaction Strategy Options:");
                     for (Map.Entry<String, String> e : cf_def.compaction_strategy_options.entrySet())
                         sessionState.out.printf("        %s: %s%n", e.getKey(), e.getValue());
                 }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -195,7 +195,9 @@ public void reload()
             rowCacheSaveInSeconds = new DefaultInteger(metadata.getRowCacheSavePeriodInSeconds());
         if (!keyCacheSaveInSeconds.isModified())
             keyCacheSaveInSeconds = new DefaultInteger(metadata.getKeyCacheSavePeriodInSeconds());
-        
+
+        compactionStrategy = metadata.createCompactionStrategyInstance(this);
+
         updateCacheSizes();
         scheduleCacheSaving(rowCacheSaveInSeconds.value(), keyCacheSaveInSeconds.value());
         

File: src/java/org/apache/cassandra/cache/InstrumentingCacheMBean.java
Patch:
@@ -25,7 +25,7 @@ public interface InstrumentingCacheMBean
 {
     public int getCapacity();
     public void setCapacity(int capacity);
-    public int size();
+    public int getSize();
 
     /** total request count since cache creation */
     public long getRequests();

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -450,7 +450,7 @@ public void printColumnFamilyStats(PrintStream outs)
                 if (keyCacheMBean.getCapacity() > 0)
                 {
                     outs.println("\t\tKey cache capacity: " + keyCacheMBean.getCapacity());
-                    outs.println("\t\tKey cache size: " + keyCacheMBean.size());
+                    outs.println("\t\tKey cache size: " + keyCacheMBean.getSize());
                     outs.println("\t\tKey cache hit rate: " + keyCacheMBean.getRecentHitRate());
                 }
                 else
@@ -462,7 +462,7 @@ public void printColumnFamilyStats(PrintStream outs)
                 if (rowCacheMBean.getCapacity() > 0)
                 {
                     outs.println("\t\tRow cache capacity: " + rowCacheMBean.getCapacity());
-                    outs.println("\t\tRow cache size: " + rowCacheMBean.size());
+                    outs.println("\t\tRow cache size: " + rowCacheMBean.getSize());
                     outs.println("\t\tRow cache hit rate: " + rowCacheMBean.getRecentHitRate());
                 }
                 else

File: src/java/org/apache/cassandra/service/AbstractWriteResponseHandler.java
Patch:
@@ -41,14 +41,16 @@ public abstract class AbstractWriteResponseHandler implements IWriteResponseHand
     protected final long startTime;
     protected final Collection<InetAddress> writeEndpoints;
     protected final Multimap<InetAddress, InetAddress> hintedEndpoints;
+    protected final Collection<InetAddress> pendingEndpoints;
     protected final ConsistencyLevel consistencyLevel;
 
-    protected AbstractWriteResponseHandler(Collection<InetAddress> writeEndpoints, Multimap<InetAddress, InetAddress> hintedEndpoints, ConsistencyLevel consistencyLevel)
+    protected AbstractWriteResponseHandler(Iterable<InetAddress> writeEndpoints, Multimap<InetAddress, InetAddress> hintedEndpoints, Iterable<InetAddress> pendingEndpoints, ConsistencyLevel consistencyLevel)
     {
         startTime = System.currentTimeMillis();
         this.consistencyLevel = consistencyLevel;
         this.hintedEndpoints = hintedEndpoints;
         this.writeEndpoints = writeEndpoints;
+        this.pendingEndpoints = pendingEndpoints;
     }
 
     public void get() throws TimeoutException

File: test/unit/org/apache/cassandra/locator/SimpleStrategyTest.java
Patch:
@@ -146,7 +146,7 @@ public void testGetEndpointsDuringBootstrap() throws UnknownHostException, Confi
 
             for (int i = 0; i < keyTokens.length; i++)
             {
-                Collection<InetAddress> endpoints = tmd.getWriteEndpoints(keyTokens[i], table, strategy.getNaturalEndpoints(keyTokens[i]));
+                Collection<InetAddress> endpoints = tmd.getWriteEndpoints(keyTokens[i], table, strategy.getNaturalEndpoints(keyTokens[i])).left;
                 assertTrue(endpoints.size() >= replicationFactor);
 
                 for (int j = 0; j < replicationFactor; j++)

File: test/unit/org/apache/cassandra/service/ConsistencyLevelTest.java
Patch:
@@ -23,6 +23,7 @@
 
 import java.net.InetAddress;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 import com.google.common.collect.HashMultimap;
@@ -95,7 +96,7 @@ public void testReadWriteConsistencyChecks() throws Exception
                         hintedNodes.put(hosts.get(j), hosts.get(j));
                     }
 
-                    IWriteResponseHandler writeHandler = strategy.getWriteResponseHandler(hosts, hintedNodes, c);
+                    IWriteResponseHandler writeHandler = strategy.getWriteResponseHandler(hosts, hintedNodes, Collections.<InetAddress>emptyList(), c);
 
                     IReadCommand command = new IReadCommand()
                     {

File: contrib/pig/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java
Patch:
@@ -357,12 +357,12 @@ public void putNext(Tuple t) throws ExecException, IOException
                Mutation mutation = new Mutation();
                if (DataType.findType(pair.get(1)) == DataType.BAG) // supercolumn
                {
-                   org.apache.cassandra.hadoop.avro.SuperColumn sc = new org.apache.cassandra.hadoop.avro.SuperColumn();
+                   org.apache.cassandra.thrift.SuperColumn sc = new org.apache.cassandra.thrift.SuperColumn();
                    sc.name = objToBB(pair.get(0));
-                   ArrayList<org.apache.cassandra.hadoop.avro.Column> columns = new ArrayList<org.apache.cassandra.hadoop.avro.Column>();
+                   ArrayList<org.apache.cassandra.thrift.Column> columns = new ArrayList<org.apache.cassandra.thrift.Column>();
                    for (Tuple subcol : (DefaultDataBag) pair.get(1))
                    {
-                       org.apache.cassandra.hadoop.avro.Column column = new org.apache.cassandra.hadoop.avro.Column();
+                       org.apache.cassandra.thrift.Column column = new org.apache.cassandra.thrift.Column();
                        column.name = objToBB(subcol.get(0));
                        column.value = objToBB(subcol.get(1));
                        column.setTimestamp(System.currentTimeMillis() * 1000);

File: drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraResultSet.java
Patch:
@@ -30,6 +30,7 @@ public interface CassandraResultSet extends ResultSet
      * @return the current row key
      */
     public byte[] getKey();
+    public TypedColumn getTypedKey();
 
     /** @return a BigInteger value for the given column offset*/
     public BigInteger getBigInteger(int i);

File: src/java/org/apache/cassandra/db/TruncateVerbHandler.java
Patch:
@@ -52,7 +52,8 @@ public void doVerb(Message message, String id)
 
             try
             {
-                Table.open(t.keyspace).truncate(t.columnFamily);
+                ColumnFamilyStore cfs = Table.open(t.keyspace).getColumnFamilyStore(t.columnFamily);
+                cfs.truncate().get();
             }
             catch (IOException e)
             {

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -646,7 +646,7 @@ Future<?> maybeSwitchMemtable(Memtable oldMemtable, final boolean writeCommitLog
 
             assert getMemtableThreadSafe() == oldMemtable;
             oldMemtable.freeze();
-            final ReplayPosition ctx = writeCommitLog ? CommitLog.instance.getContext() : null;
+            final ReplayPosition ctx = writeCommitLog ? CommitLog.instance.getContext() : ReplayPosition.NONE;
 
             // submit the memtable for any indexed sub-cfses, and our own.
             List<ColumnFamilyStore> icc = new ArrayList<ColumnFamilyStore>(indexedColumns.size());

File: src/java/org/apache/cassandra/dht/AbstractBounds.java
Patch:
@@ -101,7 +101,7 @@ public static List<AbstractBounds> normalize(Collection<? extends AbstractBounds
         {
             List<AbstractBounds> unwrapped = bound.unwrap();
             assert previous == null || previous.right.compareTo(unwrapped.get(0).left) <= 0 :
-                "Overlapping ranges passed to normalize: see CASSANDRA-2461: " + previous + " and " + unwrapped;
+                "Overlapping ranges passed to normalize: see CASSANDRA-2641: " + previous + " and " + unwrapped;
             output.addAll(unwrapped);
             previous = unwrapped.get(unwrapped.size() - 1);
         }

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -669,7 +669,7 @@ public void apply(org.apache.cassandra.db.migration.avro.CfDef cf_def) throws Co
         // validate
         if (!cf_def.keyspace.toString().equals(ksName))
             throw new ConfigurationException(String.format("Keyspace mismatch (found %s; expected %s)",
-                                                           cf_def.keyspace, tableName));
+                                                           cf_def.keyspace, ksName));
         if (!cf_def.name.toString().equals(cfName))
             throw new ConfigurationException(String.format("Column family mismatch (found %s; expected %s)",
                                                            cf_def.name, cfName));

File: src/java/org/apache/cassandra/db/marshal/IntegerType.java
Patch:
@@ -125,15 +125,14 @@ public int compare(ByteBuffer lhs, ByteBuffer rhs)
         return 0;
     }
 
-    @Override
     public String getString(ByteBuffer bytes)
     {
         if (bytes == null)
             return "null";
         if (bytes.remaining() == 0)
             return "empty";
 
-        return new java.math.BigInteger(TBaseHelper.byteBufferToByteArray(bytes)).toString(10);
+        return new java.math.BigInteger(ByteBufferUtil.getArray(bytes)).toString(10);
     }
 
     public ByteBuffer fromString(String source)

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -504,7 +504,7 @@ private AbstractType getFormatType(String compareWith)
         {
             try
             {
-                return FBUtilities.getComparator(compareWith);
+                return TypeParser.parse(compareWith);
             }
             catch (ConfigurationException ce)
             {

File: src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
Patch:
@@ -33,6 +33,7 @@
 import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.db.IColumn;
 import org.apache.cassandra.db.marshal.AbstractType;
+import org.apache.cassandra.db.marshal.TypeParser;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.thrift.*;
 import org.apache.cassandra.utils.FBUtilities;
@@ -198,8 +199,8 @@ private RowIterator()
                 int idx = cfnames.indexOf(cfName);
                 CfDef cf_def = ks_def.cf_defs.get(idx);
 
-                comparator = FBUtilities.getComparator(cf_def.comparator_type);
-                subComparator = cf_def.subcomparator_type == null ? null : FBUtilities.getComparator(cf_def.subcomparator_type);
+                comparator = TypeParser.parse(cf_def.comparator_type);
+                subComparator = cf_def.subcomparator_type == null ? null : TypeParser.parse(cf_def.subcomparator_type);
             }
             catch (ConfigurationException e)
             {

File: drivers/java/src/org/apache/cassandra/cql/jdbc/TypedColumn.java
Patch:
@@ -26,7 +26,7 @@
 
 import java.nio.ByteBuffer;
 
-class TypedColumn
+public class TypedColumn
 {
     private final Column rawColumn;
 

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -461,6 +461,7 @@ public static synchronized ColumnFamilyStore createColumnFamilyStore(Table table
      */
     public static void scrubDataDirectories(String table, String columnFamily)
     {
+        logger.info("Removing compacted SSTable files (see http://wiki.apache.org/cassandra/MemtableSSTable)");
         for (Map.Entry<Descriptor,Set<Component>> sstableFiles : files(table, columnFamily, true).entrySet())
         {
             Descriptor desc = sstableFiles.getKey();

File: src/java/org/apache/cassandra/io/sstable/SSTable.java
Patch:
@@ -156,7 +156,7 @@ public static boolean delete(Descriptor desc, Set<Component> components)
         {
             throw new IOError(e);
         }
-        logger.info("Deleted " + desc);
+        logger.debug("Deleted {}", desc);
         return true;
     }
 

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -268,7 +268,7 @@ else if (globalPosition.segment == segment)
                     {
                         // assuming version here. We've gone to lengths to make sure what gets written to the CL is in
                         // the current version.  so do make sure the CL is drained prior to upgrading a node.
-                        rm = RowMutation.serializer().deserialize(new DataInputStream(bufIn), MessagingService.version_);
+                        rm = RowMutation.serializer().deserialize(new DataInputStream(bufIn), MessagingService.version_, false);
                     }
                     catch (UnserializableColumnFamilyException ex)
                     {

File: src/java/org/apache/cassandra/io/sstable/SSTableReader.java
Patch:
@@ -488,12 +488,12 @@ public long getPosition(DecoratedKey decoratedKey, Operator op)
                     {
                         if (comparison == 0 && keyCache != null && keyCache.getCapacity() > 0)
                         {
-                            if (op == Operator.EQ)
-                                bloomFilterTracker.addTruePositive();
                             // store exact match for the key
                             if (decoratedKey.key != null)
                                 cacheKey(decoratedKey, dataPosition);
                         }
+                        if (op == Operator.EQ)
+                            bloomFilterTracker.addTruePositive();
                         return dataPosition;
                     }
                     if (v < 0)

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -602,7 +602,7 @@ else if (columnSpecCnt == 2)
             // setting value for output
             valueAsString = valueValidator.getString(ByteBuffer.wrap(columnValue));
             // updating column value validator class
-            updateColumnMetaData(cfDef, columnName, valueValidator.getClass().getName());
+            updateColumnMetaData(cfDef, columnName, valueValidator.toString());
         }
         else
         {
@@ -2159,7 +2159,7 @@ else if (validator instanceof BytesType)
             // performing ColumnDef local validator update
             if (withUpdate)
             {
-                updateColumnMetaData(columnFamily, columnName, validator.getClass().getName());
+                updateColumnMetaData(columnFamily, columnName, validator.toString());
             }
 
             return value;

File: src/java/org/apache/cassandra/config/ColumnDefinition.java
Patch:
@@ -79,7 +79,7 @@ public org.apache.cassandra.db.migration.avro.ColumnDef deflate()
     {
         org.apache.cassandra.db.migration.avro.ColumnDef cd = new org.apache.cassandra.db.migration.avro.ColumnDef();
         cd.name = name;
-        cd.validation_class = new Utf8(validator.getClass().getName());
+        cd.validation_class = new Utf8(validator.toString());
         cd.index_type = index_type == null ? null :
             Enum.valueOf(org.apache.cassandra.db.migration.avro.IndexType.class, index_type.name());
         cd.index_name = index_name == null ? null : new Utf8(index_name);

File: src/java/org/apache/cassandra/db/Memtable.java
Patch:
@@ -183,7 +183,7 @@ public void run()
                 }
                 if (newRatio > MAX_SANE_LIVE_RATIO)
                 {
-                    logger.warn("setting live ratio to maximum of 64 instead of {}, newRatio");
+                    logger.warn("setting live ratio to maximum of 64 instead of {}", newRatio);
                     newRatio = MAX_SANE_LIVE_RATIO;
                 }
                 cfs.liveRatio = Math.max(cfs.liveRatio, newRatio);

File: drivers/java/src/org/apache/cassandra/cql/jdbc/CResultSet.java
Patch:
@@ -375,7 +375,7 @@ public synchronized boolean next() throws SQLException
 
                 TypedColumn c = decoder.makeCol(keyspace, columnFamily, col);
                 values.add(c);
-                valueMap.put(decoder.colNameAsString(keyspace, columnFamily, col.getName()), c);
+                valueMap.put(decoder.colNameAsString(keyspace, columnFamily, col.name), c);
             }
             return !(values.isEmpty() && valueMap.isEmpty());
         } 

File: src/java/org/apache/cassandra/db/marshal/LexicalUUIDType.java
Patch:
@@ -27,7 +27,7 @@
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.UUIDGen;
 
-public class LexicalUUIDType extends AbstractType<UUID>
+public class LexicalUUIDType extends AbstractUUIDType
 {
     public static final LexicalUUIDType instance = new LexicalUUIDType();
 

File: src/java/org/apache/cassandra/db/marshal/TimeUUIDType.java
Patch:
@@ -31,7 +31,7 @@
 import org.apache.cassandra.utils.UUIDGen;
 import org.apache.commons.lang.time.DateUtils;
 
-public class TimeUUIDType extends AbstractType<UUID>
+public class TimeUUIDType extends AbstractUUIDType
 {
     public static final TimeUUIDType instance = new TimeUUIDType();
 

File: src/java/org/apache/cassandra/db/marshal/UUIDType.java
Patch:
@@ -43,7 +43,7 @@
  * @see "com.fasterxml.uuid.UUIDComparator"
  * 
  */
-public class UUIDType extends AbstractType<UUID>
+public class UUIDType extends AbstractUUIDType
 {
     public static final UUIDType instance = new UUIDType();
 

File: src/java/org/apache/cassandra/db/IFlushable.java
Patch:
@@ -24,7 +24,9 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 
+import org.apache.cassandra.db.commitlog.ReplayPosition;
+
 public interface IFlushable
 {
-    public void flushAndSignal(CountDownLatch condition, ExecutorService sorter, ExecutorService writer);
+    public void flushAndSignal(CountDownLatch condition, ExecutorService sorter, ExecutorService writer, ReplayPosition context);
 }

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -36,6 +36,7 @@
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.KSMetaData;
 import org.apache.cassandra.db.commitlog.CommitLog;
+import org.apache.cassandra.db.commitlog.ReplayPosition;
 import org.apache.cassandra.db.filter.QueryFilter;
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.dht.LocalToken;
@@ -748,7 +749,8 @@ public void truncate(String cfname) throws InterruptedException, ExecutionExcept
     }
 
     @Override
-    public String toString() {
+    public String toString()
+    {
         return getClass().getSimpleName() + "(name='" + name + "')";
     }
 }

File: test/unit/org/apache/cassandra/db/CompactionsPurgeTest.java
Patch:
@@ -223,7 +223,7 @@ public void testCompactionPurgeTombstonedRow() throws IOException, ExecutionExce
 
         // Check that the second insert did went in
         ColumnFamily cf = cfs.getColumnFamily(QueryFilter.getIdentityFilter(key, new QueryPath(cfName)));
-        assert cf.getColumnCount() == 10;
+        assertEquals(10, cf.getColumnCount());
         for (IColumn c : cf)
             assert !c.isMarkedForDelete();
     }

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -442,7 +442,7 @@ private static void ignoreObsoleteMutations(ColumnFamily cf, SortedSet<ByteBuffe
             if (bothDeleted || obsoleteRowTombstone || obsoleteColumn)
             {
                 if (logger.isDebugEnabled())
-                    logger.debug("skipping index update for obsolete mutation of " + cf.getComparator().getString(oldColumn.name()));
+                    logger.debug("skipping index update for obsolete mutation of " + cf.getComparator().getString(name));
                 iter.remove();
                 oldIndexedColumns.remove(name);
             }

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -441,6 +441,8 @@ private static void ignoreObsoleteMutations(ColumnFamily cf, SortedSet<ByteBuffe
                                                            || (oldColumn != null && oldColumn.reconcile(newColumn) == oldColumn));
             if (bothDeleted || obsoleteRowTombstone || obsoleteColumn)
             {
+                if (logger.isDebugEnabled())
+                    logger.debug("skipping index update for obsolete mutation of " + cf.getComparator().getString(oldColumn.name()));
                 iter.remove();
                 oldIndexedColumns.remove(name);
             }

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -188,7 +188,7 @@ public static void mutate(List<? extends IMutation> mutations, ConsistencyLevel
      * said write endpoint (deletaged to the actual WritePerformer) and wait for the
      * responses based on consistency level.
      *
-     * @param mutations the mutations to be applied
+     * @param mutation the mutation to be applied
      * @param consistency_level the consistency level for the write operation
      * @param performer the WritePerformer in charge of appliying the mutation
      * given the list of write endpoints (either standardWritePerformer for

File: src/java/org/apache/cassandra/db/CompactionManager.java
Patch:
@@ -523,7 +523,7 @@ int doCompactionWithoutSizeEstimation(ColumnFamilyStore cfs, Collection<SSTableR
 
         Table table = cfs.table;
         if (DatabaseDescriptor.isSnapshotBeforeCompaction())
-            table.snapshot("compact-" + cfs.columnFamily);
+            table.snapshot(System.currentTimeMillis() + "-" + "compact-" + cfs.columnFamily);
 
         // sanity check: all sstables must belong to the same cfs
         for (SSTableReader sstable : sstables)

File: src/java/org/apache/cassandra/io/util/BufferedRandomAccessFile.java
Patch:
@@ -343,7 +343,7 @@ public void seek(long newPosition) throws IOException
 
         current = newPosition;
 
-        if (newPosition >= bufferOffset + validBufferBytes || newPosition < bufferOffset)
+        if (newPosition > (bufferOffset + validBufferBytes) || newPosition < bufferOffset)
             reBuffer(); // this will set bufferEnd for us
     }
 

File: src/java/org/apache/cassandra/db/CompactionManager.java
Patch:
@@ -378,7 +378,7 @@ else if (!cfname.equals(p.left.cfname))
         submitUserDefined(cfs, descriptors, getDefaultGcBefore(cfs));
     }
 
-    Future<Object> submitUserDefined(final ColumnFamilyStore cfs, final Collection<Descriptor> dataFiles, final int gcBefore)
+    public Future<Object> submitUserDefined(final ColumnFamilyStore cfs, final Collection<Descriptor> dataFiles, final int gcBefore)
     {
         Callable<Object> callable = new Callable<Object>()
         {

File: test/unit/org/apache/cassandra/SchemaLoader.java
Patch:
@@ -188,6 +188,8 @@ public static Collection<KSMetaData> schemaDefinition()
                                   standardCFMD(ks_kcs, "Standard1")
                                               .keyCacheSize(0.5),
                                   standardCFMD(ks_kcs, "Standard2")
+                                              .keyCacheSize(1.0),
+                                  standardCFMD(ks_kcs, "Standard3")
                                               .keyCacheSize(1.0)));
 
         // RowCacheSpace

File: src/java/org/apache/cassandra/db/CompactionManager.java
Patch:
@@ -378,7 +378,7 @@ else if (!cfname.equals(p.left.cfname))
         submitUserDefined(cfs, descriptors, getDefaultGcBefore(cfs));
     }
 
-    private Future<Object> submitUserDefined(final ColumnFamilyStore cfs, final Collection<Descriptor> dataFiles, final int gcBefore)
+    Future<Object> submitUserDefined(final ColumnFamilyStore cfs, final Collection<Descriptor> dataFiles, final int gcBefore)
     {
         Callable<Object> callable = new Callable<Object>()
         {

File: src/java/org/apache/cassandra/service/IResponseResolver.java
Patch:
@@ -43,7 +43,4 @@ public interface IResponseResolver<T> {
 
     public void preprocess(Message message);
     public Iterable<Message> getMessages();
-
-    /** Potentially called by multiple response threads, so must be threadsafe. */
-    public int getMessageCount();
 }

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -276,9 +276,8 @@ private static void sendToHintedEndpoints(final RowMutation rm, Multimap<InetAdd
                 else
                     MessagingService.instance().sendOneWay(hintedMessage, destination);
             }
-
-            sendMessages(localDataCenter, dcMessages, responseHandler);
         }
+        sendMessages(localDataCenter, dcMessages, responseHandler);
     }
 
     /**

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -592,8 +592,8 @@ public static void main(String[] args) throws IOException, InterruptedException,
                 break;
 
             case SETCOMPACTIONTHROUGHPUT :
-                if (arguments.length != 2) { badUse("Missing value argument."); }
-                probe.setCompactionThroughput(Integer.valueOf(arguments[1]));
+                if (arguments.length != 1) { badUse("Missing value argument."); }
+                probe.setCompactionThroughput(Integer.valueOf(arguments[0]));
                 break;
 
             case REMOVETOKEN :

File: src/java/org/apache/cassandra/tools/SSTableImport.java
Patch:
@@ -278,7 +278,7 @@ private static int importUnsorted(JsonParser parser, ColumnFamily columnFamily,
 
         for (Map.Entry<DecoratedKey, String> rowKey : decoratedKeys.entrySet())
         {
-            if (columnFamily.getColumnFamilyType() == ColumnFamilyType.Super)
+            if (columnFamily.getType() == ColumnFamilyType.Super)
             {
                 addToSuperCF((Map<?, ?>) data.get(rowKey.getValue()), columnFamily);
             }
@@ -350,7 +350,7 @@ public static int importSorted(String jsonFile, ColumnFamily columnFamily, Strin
 
                 if (tokenName.equals("START_ARRAY"))
                 {
-                    if (columnFamily.getColumnFamilyType() == ColumnFamilyType.Super)
+                    if (columnFamily.getType() == ColumnFamilyType.Super)
                     {
                         throw new RuntimeException("Can't write Standard columns to the Super Column Family.");
                     }
@@ -360,7 +360,7 @@ public static int importSorted(String jsonFile, ColumnFamily columnFamily, Strin
                 }
                 else if (tokenName.equals("START_OBJECT"))
                 {
-                    if (columnFamily.getColumnFamilyType() == ColumnFamilyType.Standard)
+                    if (columnFamily.getType() == ColumnFamilyType.Standard)
                     {
                         throw new RuntimeException("Can't write Super columns to the Standard Column Family.");
                     }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -327,7 +327,7 @@ public Future<?> addIndex(final ColumnDefinition info)
         final CFMetaData indexedCfMetadata = CFMetaData.newIndexMetadata(metadata, info, columnComparator);
         ColumnFamilyStore indexedCfs = ColumnFamilyStore.createColumnFamilyStore(table,
                                                                                  indexedCfMetadata.cfName,
-                                                                                 new LocalPartitioner(metadata.getColumn_metadata().get(info.name).validator),
+                                                                                 new LocalPartitioner(metadata.getColumn_metadata().get(info.name).getValidator()),
                                                                                  indexedCfMetadata);
 
         // link in indexedColumns.  this means that writes will add new data to the index immediately,

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -29,9 +29,7 @@
 import javax.management.MBeanServer;
 import javax.management.ObjectName;
 
-import com.google.common.base.Charsets;
 import com.google.common.collect.HashMultimap;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimap;
 
 import org.apache.cassandra.db.commitlog.CommitLog;
@@ -2079,7 +2077,7 @@ public String exportSchema() throws IOException
                     rcd.index_name = cd.getIndexName();
                     rcd.index_type = cd.getIndexType();
                     rcd.name = ByteBufferUtil.string(cd.name);
-                    rcd.validator_class = cd.validator.getClass().getName();
+                    rcd.validator_class = cd.getValidator().getClass().getName();
                     rcf.column_metadata[j++] = rcd;
                 }
                 if (j == 0)

File: test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
Patch:
@@ -343,7 +343,7 @@ public void testIndexCreate() throws IOException, ConfigurationException, Interr
 
         ColumnFamilyStore cfs = table.getColumnFamilyStore("Indexed2");
         ColumnDefinition old = cfs.metadata.getColumn_metadata().get(ByteBufferUtil.bytes("birthdate"));
-        ColumnDefinition cd = new ColumnDefinition(old.name, old.validator.getClass().getName(), IndexType.KEYS, "birthdate_index");
+        ColumnDefinition cd = new ColumnDefinition(old.name, old.getValidator().getClass().getName(), IndexType.KEYS, "birthdate_index");
         Future<?> future = cfs.addIndex(cd);
         future.get();
         // we had a bug (CASSANDRA-2244) where index would get created but not flushed -- check for that

File: tools/stress/src/org/apache/cassandra/stress/operations/Inserter.java
Patch:
@@ -49,7 +49,7 @@ public void run(Cassandra.Client client) throws IOException
         {
             String columnName = ("C" + Integer.toString(i));
             ByteBuffer columnValue = values.get(i % values.size());
-            columns.add(new Column(ByteBufferUtil.bytes(columnName), columnValue, System.currentTimeMillis()));
+            columns.add(new Column(ByteBufferUtil.bytes(columnName)).setValue(columnValue).setTimestamp(System.currentTimeMillis()));
         }
 
         if (session.getColumnFamilyType() == ColumnFamilyType.Super)

File: src/java/org/apache/cassandra/service/DatacenterWriteResponseHandler.java
Patch:
@@ -84,9 +84,9 @@ public void response(Message message)
     public void assureSufficientLiveNodes() throws UnavailableException
     {
         int liveNodes = 0;
-        for (InetAddress destination : writeEndpoints)
+        for (InetAddress destination : hintedEndpoints.keySet())
         {
-            if (localdc.equals(snitch.getDatacenter(destination)))
+            if (localdc.equals(snitch.getDatacenter(destination)) && writeEndpoints.contains(destination))
                 liveNodes++;
         }
 

File: src/java/org/apache/cassandra/service/WriteResponseHandler.java
Patch:
@@ -100,6 +100,7 @@ public void assureSufficientLiveNodes() throws UnavailableException
             // ensure there are blockFor distinct living nodes (hints are ok).
             if (hintedEndpoints.keySet().size() < responses.get())
                 throw new UnavailableException();
+            return;
         }
 
         // count destinations that are part of the desired target set

File: src/java/org/apache/cassandra/db/marshal/AbstractType.java
Patch:
@@ -93,6 +93,8 @@ public int compare(ByteBuffer o1, ByteBuffer o2)
     }
     
     public abstract T compose(ByteBuffer bytes);
+    
+    public abstract ByteBuffer decompose(T value);
 
     /** get a string representation of a particular type. */
     public abstract String toString(T t);

File: test/unit/org/apache/cassandra/service/AntiEntropyServiceTestAbstract.java
Patch:
@@ -41,6 +41,7 @@
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.io.PrecompactedRow;
 import org.apache.cassandra.io.util.DataOutputBuffer;
+import org.apache.cassandra.gms.Gossiper;
 import org.apache.cassandra.locator.AbstractReplicationStrategy;
 import org.apache.cassandra.locator.TokenMetadata;
 import org.apache.cassandra.utils.FBUtilities;
@@ -102,6 +103,8 @@ public void prepare() throws Exception
         tmd.updateNormalToken(StorageService.getPartitioner().getMinimumToken(), REMOTE);
         assert tmd.isMember(REMOTE);
 
+        Gossiper.instance.initializeNodeUnsafe(REMOTE, 1);
+
         local_range = StorageService.instance.getLocalPrimaryRange();
         
         // random session id for each test

File: src/java/org/apache/cassandra/db/HintedHandOffManager.java
Patch:
@@ -281,13 +281,13 @@ private void deliverHintsToEndpoint(InetAddress endpoint) throws IOException, Di
     {
         try
         {
-            logger_.info("Checking remote schema before delivering hints");
+            logger_.debug("Checking remote schema before delivering hints");
             int waited = waitForSchemaAgreement(endpoint);
             // sleep a random amount to stagger handoff delivery from different replicas.
             // (if we had to wait, then gossiper randomness took care of that for us already.)
             if (waited == 0) {
                 int sleep = new Random().nextInt(60000);
-                logger_.info("Sleeping {}ms to stagger hint delivery", sleep);
+                logger_.debug("Sleeping {}ms to stagger hint delivery", sleep);
                 Thread.sleep(sleep);
             }
             if (!Gossiper.instance.getEndpointStateForEndpoint(endpoint).isAlive())

File: src/java/org/apache/cassandra/net/OutboundTcpConnection.java
Patch:
@@ -114,8 +114,8 @@ private void writeConnected(ByteBuffer bb)
         }
         catch (IOException e)
         {
-            logger.info("error writing to " + endpoint);
-            logger.debug("error was ", e);
+            if (logger.isDebugEnabled())
+                logger.debug("error writing to " + endpoint, e);
             disconnect();
         }
     }

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -36,6 +36,7 @@
 import org.apache.cassandra.db.CompactionManagerMBean;
 import org.apache.cassandra.db.marshal.*;
 import org.apache.cassandra.io.CompactionInfo;
+import org.apache.cassandra.io.CompactionType;
 import org.apache.cassandra.locator.SimpleSnitch;
 import org.apache.cassandra.service.StorageProxy;
 import org.apache.cassandra.thrift.*;
@@ -1638,7 +1639,7 @@ private void describeKeySpace(String keySpaceName, KsDef metadata) throws TExcep
                 for (CompactionInfo info : compactionManagerMBean.getCompactions())
                 {
                     // if ongoing compaction type is index build
-                    if (!info.getTaskType().contains("index build"))
+                    if (info.getTaskType() != CompactionType.INDEX_BUILD)
                         continue;
                     sessionState.out.printf("%nCurrently building index %s, completed %d of %d bytes.%n",
                                             info.getColumnFamily(),

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -40,6 +40,7 @@
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.dht.LocalToken;
 import org.apache.cassandra.io.CompactionInfo;
+import org.apache.cassandra.io.CompactionType;
 import org.apache.cassandra.io.sstable.ReducingKeyIterator;
 import org.apache.cassandra.io.sstable.SSTableDeletingReference;
 import org.apache.cassandra.io.sstable.SSTableReader;
@@ -614,7 +615,7 @@ public CompactionInfo getCompactionInfo()
         {
             return new CompactionInfo(cfs.table.name,
                                       cfs.columnFamily,
-                                      String.format("Secondary index build %s", cfs.columnFamily),
+                                      CompactionType.INDEX_BUILD,
                                       iter.getTotalBytes(),
                                       iter.getBytesRead());
         }

File: contrib/stress/src/org/apache/cassandra/contrib/stress/operations/IndexedRangeSlicer.java
Patch:
@@ -48,8 +48,8 @@ public void run(Cassandra.Client client) throws IOException
 
         int received = 0;
 
-        String startOffset = "0";
-        ByteBuffer value = values.get(index % values.size());
+        String startOffset = String.format(format, 0);
+        ByteBuffer value = values.get(1); // only C1 column is indexed
 
         IndexExpression expression = new IndexExpression(columnName, IndexOperator.EQ, value);
 

File: test/distributed/org/apache/cassandra/CountersTest.java
Patch:
@@ -72,7 +72,7 @@ public void tryPerformAction(ConsistencyLevel cl) throws Exception
         {
             ByteBuffer bname = ByteBuffer.wrap(name.getBytes());
             ColumnPath cpath = new ColumnPath(cf).setColumn(bname);
-            CounterColumn col = client.get_counter(key, cpath, cl).column;
+            CounterColumn col = client.get(key, cpath, cl).counter_column;
             assertEquals(bname, col.name);
             assertEquals(value.longValue(), col.value);
         }

File: test/distributed/org/apache/cassandra/MovementTest.java
Patch:
@@ -29,6 +29,7 @@
 
 import org.apache.cassandra.thrift.*;
 import org.apache.cassandra.tools.NodeProbe;
+import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.WrappedRunnable;
 
 import org.apache.cassandra.CassandraServiceController.Failure;

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -575,7 +575,7 @@ public List<KeySlice> get_range_slices(ColumnParent column_parent, SlicePredicat
         String keyspace = state().getKeyspace();
         state().hasColumnFamilyAccess(column_parent.column_family, Permission.READ);
 
-        CFMetaData metadata = ThriftValidation.validateColumnFamily(keyspace, column_parent.column_family, false);
+        CFMetaData metadata = ThriftValidation.validateColumnFamily(keyspace, column_parent.column_family);
         ThriftValidation.validateColumnParent(metadata, column_parent);
         ThriftValidation.validatePredicate(metadata, column_parent, predicate);
         ThriftValidation.validateKeyRange(range);

File: src/java/org/apache/cassandra/cql/CreateColumnFamilyStatement.java
Patch:
@@ -233,7 +233,7 @@ public CFMetaData getCFMetaData(String keyspace) throws InvalidRequestException
         try
         {
             // RPC uses BytesType as the default validator/comparator but BytesType expects hex for string terms, (not convenient).
-            AbstractType<?> comparator = DatabaseDescriptor.getComparator(comparators.get(getPropertyString(KW_COMPARATOR, "utf8")));
+            AbstractType<?> comparator = DatabaseDescriptor.getComparator(comparators.get(getPropertyString(KW_COMPARATOR, "text")));
             String validator = getPropertyString(KW_DEFAULTVALIDATION, "utf8");
 
             newCFMD = new CFMetaData(keyspace,

File: src/java/org/apache/cassandra/cql/Term.java
Patch:
@@ -104,6 +104,8 @@ public ByteBuffer getByteBuffer() throws InvalidRequestException
             case INTEGER: 
                 return IntegerType.instance.fromString(text);
             case UUID:
+                // we specifically want the Lexical class here, not "UUIDType," because we're supposed to have
+                // a uuid-shaped string here, and UUIDType also accepts integer or date strings (and turns them into version 1 uuids).
                 return LexicalUUIDType.instance.fromString(text);
         }
         

File: src/java/org/apache/cassandra/db/marshal/TimeUUIDType.java
Patch:
@@ -35,8 +35,8 @@ public class TimeUUIDType extends AbstractType<UUID>
 {
     
     public static final TimeUUIDType instance = new TimeUUIDType();
-    private Pattern regexPattern = Pattern.compile("[A-Fa-f0-9]{8}\\-[A-Fa-f0-9]{4}\\-[A-Fa-f0-9]{4}\\-[A-Fa-f0-9]{4}\\-[A-Fa-f0-9]{12}");
-    private static String[] iso8601Patterns = new String[] {
+    static final Pattern regexPattern = Pattern.compile("[A-Fa-f0-9]{8}\\-[A-Fa-f0-9]{4}\\-[A-Fa-f0-9]{4}\\-[A-Fa-f0-9]{4}\\-[A-Fa-f0-9]{12}");
+    static final String[] iso8601Patterns = new String[] {
         "yyyy-MM-dd HH:mm",
         "yyyy-MM-dd HH:mm:ss",
         "yyyy-MM-dd HH:mmZ",

File: test/unit/org/apache/cassandra/db/marshal/UUIDTypeTest.java
Patch:
@@ -150,7 +150,7 @@ public void testCompare(UUID u1, UUID u2, int expC)
         assertEquals("Expected " + describeCompare(u1, u2, expC) + ", got "
                 + describeCompare(u1, u2, c), expC, c);
 
-        if (u1.version() == 1)
+        if (u1.version() == 1 && u2.version() == 1)
             assertEquals(c, sign(TimeUUIDType.instance.compare(bytebuffer(u1), bytebuffer(u2))));
 
         logJdkUUIDCompareToVariance(u1, u2, c);

File: src/java/org/apache/cassandra/db/MeteredFlusher.java
Patch:
@@ -87,7 +87,7 @@ public int compare(ColumnFamilyStore o1, ColumnFamilyStore o2)
         }
         finally
         {
-            logger.debug("memtable memory usage is {} bytes with {} live", liveBytes + flushingBytes, liveBytes);
+            logger.trace("memtable memory usage is {} bytes with {} live", liveBytes + flushingBytes, liveBytes);
         }
     }
 

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -53,7 +53,7 @@ public final class CFMetaData
     public final static double DEFAULT_ROW_CACHE_SIZE = 0.0;
     public final static double DEFAULT_KEY_CACHE_SIZE = 200000;
     public final static double DEFAULT_READ_REPAIR_CHANCE = 1.0;
-    public final static boolean DEFAULT_REPLICATE_ON_WRITE = false;
+    public final static boolean DEFAULT_REPLICATE_ON_WRITE = true;
     public final static int DEFAULT_SYSTEM_MEMTABLE_THROUGHPUT_IN_MB = 8;
     public final static int DEFAULT_ROW_CACHE_SAVE_PERIOD_IN_SECONDS = 0;
     public final static int DEFAULT_KEY_CACHE_SAVE_PERIOD_IN_SECONDS = 4 * 3600;

File: src/java/org/apache/cassandra/utils/FBUtilities.java
Patch:
@@ -549,7 +549,7 @@ public static <T> T getInstance(String classname, String readable) throws Config
         T rval = null;
         try
         {
-            rval = (T) cls.getDeclaredMethod("getInstance").invoke(null, (Object) null);
+            rval = (T) cls.getDeclaredMethod("getInstance").invoke(new Object[] {null, null});
 
         }
         catch (NoSuchMethodException e)

File: src/java/org/apache/cassandra/cql/CreateColumnFamilyStatement.java
Patch:
@@ -35,6 +35,7 @@
 import org.apache.cassandra.db.ColumnFamilyType;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.thrift.InvalidRequestException;
+import org.apache.cassandra.utils.FBUtilities;
 
 /** A <code>CREATE COLUMNFAMILY</code> parsed from a CQL query statement. */
 public class CreateColumnFamilyStatement
@@ -257,7 +258,7 @@ public CFMetaData getCFMetaData(String keyspace) throws InvalidRequestException
                    .mergeShardsChance(0.0)
                    .columnMetadata(getColumns(comparator))
                    .keyValidator(DatabaseDescriptor.getComparator(comparators.get(getKeyType())))
-                   .rowCacheProvider(getPropertyString(KW_ROW_CACHE_PROVIDER, CFMetaData.DEFAULT_ROW_CACHE_PROVIDER));
+                   .rowCacheProvider(FBUtilities.newCacheProvider(getPropertyString(KW_ROW_CACHE_PROVIDER, CFMetaData.DEFAULT_ROW_CACHE_PROVIDER)));
         }
         catch (ConfigurationException e)
         {

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -55,6 +55,7 @@
 import org.apache.cassandra.service.StorageProxy;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.ByteBufferUtil;
+import org.apache.cassandra.utils.FBUtilities;
 import org.apache.thrift.TException;
 
 public class CassandraServer implements Cassandra.Iface
@@ -951,7 +952,7 @@ private CFMetaData convertToCFMetaData(CfDef cf_def) throws InvalidRequestExcept
         if (cf_def.isSetMemtable_throughput_in_mb()) { newCFMD.memSize(cf_def.memtable_throughput_in_mb); }
         if (cf_def.isSetMemtable_operations_in_millions()) { newCFMD.memOps(cf_def.memtable_operations_in_millions); }
         if (cf_def.isSetMerge_shards_chance()) { newCFMD.mergeShardsChance(cf_def.merge_shards_chance); }
-        if (cf_def.isSetRow_cache_provider()) { newCFMD.rowCacheProvider(cf_def.row_cache_provider); }
+        if (cf_def.isSetRow_cache_provider()) { newCFMD.rowCacheProvider(FBUtilities.newCacheProvider(cf_def.row_cache_provider)); }
 
         return newCFMD.comment(cf_def.comment)
                       .rowCacheSize(cf_def.row_cache_size)

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1223,8 +1223,8 @@ private ColumnFamily getTopLevelColumns(QueryFilter filter, int gcBefore)
                 {
                     returnCF.delete(iter.getColumnFamily());
                     iterators.add(iter);
+                    sstablesToIterate++;
                 }
-                sstablesToIterate++;
             }
 
             recentSSTablesPerRead.add(sstablesToIterate);

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -101,7 +101,7 @@ private static CFMetaData newSystemTable(String cfName, int cfId, String comment
      */
     public static int sizeMemtableThroughput()
     {
-        return (int) (Runtime.getRuntime().maxMemory() / (1048576 * 16));
+        return (int) (Runtime.getRuntime().maxMemory() / (1048576 * 32));
     }
 
     /**

File: src/java/org/apache/cassandra/cli/CliUserHelp.java
Patch:
@@ -55,7 +55,7 @@ protected enum ColumnFamilyArgument
     {{
         put(ColumnFamilyArgument.COLUMN_TYPE, "Super or Standard");
         put(ColumnFamilyArgument.COMMENT, "Human-readable column family description. Any string is acceptable");
-        put(ColumnFamilyArgument.COMPARATOR, "The class used as a comparator when sorting column names.\n                  Valid options include: AsciiType, BytesType, LexicalUUIDType,\n                  LongType, TimeUUIDType, and UTF8Type");
+        put(ColumnFamilyArgument.COMPARATOR, "The class used as a comparator when sorting column names.\n                  Valid options include: AsciiType, BytesType, LexicalUUIDType,\n                  LongType, IntegerType, TimeUUIDType, and UTF8Type");
         put(ColumnFamilyArgument.SUBCOMPARATOR, "Comparator for sorting subcolumn names, for Super columns only");
         put(ColumnFamilyArgument.MEMTABLE_OPERATIONS, "Flush memtables after this many operations (in millions)");
         put(ColumnFamilyArgument.MEMTABLE_THROUGHPUT, "... or after this many MB have been written");

File: src/java/org/apache/cassandra/db/marshal/AbstractType.java
Patch:
@@ -94,6 +94,9 @@ public int compare(ByteBuffer o1, ByteBuffer o2)
     
     public abstract T compose(ByteBuffer bytes);
 
+    /** get a string representation of a particular type. */
+    public abstract String toString(T t);
+    
     /** get a string representation of the bytes suitable for log messages */
     public abstract String getString(ByteBuffer bytes);
 

File: test/unit/org/apache/cassandra/service/AntiEntropyServiceTestAbstract.java
Patch:
@@ -208,6 +208,9 @@ public void testGetNeighborsTimesTwo() throws Throwable
     @Test
     public void testDifferencer() throws Throwable
     {
+        // this next part does some housekeeping so that cleanup in the differencer doesn't error out.
+        AntiEntropyService.RepairSession sess = AntiEntropyService.instance.getArtificialRepairSession(request,  tablename, cfname);
+        
         // generate a tree
         Validator validator = new Validator(request);
         validator.prepare(store);

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -730,6 +730,7 @@ public static org.apache.cassandra.db.migration.avro.CfDef convertToAvro(CFMetaD
         def.memtable_throughput_in_mb = cfm.memtableThroughputInMb;
         def.memtable_operations_in_millions = cfm.memtableOperationsInMillions;
         def.merge_shards_chance = cfm.mergeShardsChance;
+        def.key_validation_class = cfm.keyValidator.getClass().getName();
         List<org.apache.cassandra.db.migration.avro.ColumnDef> column_meta = new ArrayList<org.apache.cassandra.db.migration.avro.ColumnDef>(cfm.column_metadata.size());
         for (ColumnDefinition cd : cfm.column_metadata.values())
         {

File: interface/thrift/gen-java/org/apache/cassandra/thrift/Constants.java
Patch:
@@ -44,6 +44,6 @@
 
 public class Constants {
 
-  public static final String VERSION = "19.4.0";
+  public static final String VERSION = "19.5.0";
 
 }

File: src/java/org/apache/cassandra/db/RowIteratorFactory.java
Patch:
@@ -169,14 +169,14 @@ else if (colCollated.hasNext())
      */
     private static Iterator<Map.Entry<DecoratedKey, ColumnFamily>> memtableEntryIterator(Memtable memtable, DecoratedKey startWith)
     {
-        Table.flusherLock.readLock().lock();
+        Table.switchLock.readLock().lock();
         try
         {
             return memtable.getEntryIterator(startWith);
         }
         finally
         {
-            Table.flusherLock.readLock().unlock();
+            Table.switchLock.readLock().unlock();
         }
     }
 

File: contrib/client_only/src/ClientOnlyExample.java
Patch:
@@ -63,9 +63,9 @@ private static void testWriting() throws Exception
         // do some writing.
         for (int i = 0; i < 100; i++)
         {
-            RowMutation change = new RowMutation(KEYSPACE, ByteBuffer.wrap(("key" + i).getBytes()));
+            RowMutation change = new RowMutation(KEYSPACE, ByteBufferUtil.bytes(("key" + i)));
             ColumnPath cp = new ColumnPath(COLUMN_FAMILY).setColumn(("colb").getBytes());
-            change.add(new QueryPath(cp), ByteBuffer.wrap(("value" + i).getBytes()), 0);
+            change.add(new QueryPath(cp), ByteBufferUtil.bytes(("value" + i)), 0);
 
             // don't call change.apply().  The reason is that is makes a static call into Table, which will perform
             // local storage initialization, which creates local directories.
@@ -87,7 +87,7 @@ private static void testReading() throws Exception
         for (int i = 0; i < 100; i++)
         {
             List<ReadCommand> commands = new ArrayList<ReadCommand>();
-            SliceByNamesReadCommand readCommand = new SliceByNamesReadCommand(KEYSPACE, ByteBuffer.wrap(("key" + i).getBytes()),
+            SliceByNamesReadCommand readCommand = new SliceByNamesReadCommand(KEYSPACE, ByteBufferUtil.bytes(("key" + i)),
                                                                               new QueryPath(COLUMN_FAMILY, null, null), cols);
             readCommand.setDigestQuery(false);
             commands.add(readCommand);

File: contrib/stress/src/org/apache/cassandra/contrib/stress/Session.java
Patch:
@@ -28,6 +28,8 @@
 import org.apache.cassandra.db.ColumnFamilyType;
 import org.apache.cassandra.thrift.*;
 import org.apache.commons.lang.StringUtils;
+
+import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.thrift.protocol.TBinaryProtocol;
 import org.apache.thrift.transport.TFramedTransport;
 import org.apache.thrift.transport.TSocket;
@@ -372,7 +374,7 @@ public void createKeySpaces()
         standardCfDef.setComparator_type("AsciiType").setDefault_validation_class("BytesType");
         if (indexType != null)
         {
-            ColumnDef standardColumn = new ColumnDef(ByteBuffer.wrap("C1".getBytes()), "BytesType");
+            ColumnDef standardColumn = new ColumnDef(ByteBufferUtil.bytes("C1"), "BytesType");
             standardColumn.setIndex_type(indexType).setIndex_name("Idx1");
             standardCfDef.setColumn_metadata(Arrays.asList(standardColumn));
         }

File: contrib/stress/src/org/apache/cassandra/contrib/stress/operations/Inserter.java
Patch:
@@ -59,7 +59,7 @@ public void run(Cassandra.Client client) throws IOException
             for (int i = 0; i < session.getSuperColumns(); i++)
             {
                 String superColumnName = "S" + Integer.toString(i);
-                superColumns.add(new SuperColumn(ByteBuffer.wrap(superColumnName.getBytes()), columns));
+                superColumns.add(new SuperColumn(ByteBufferUtil.bytes(superColumnName), columns));
             }
         }
 

File: contrib/stress/src/org/apache/cassandra/contrib/stress/operations/Reader.java
Patch:
@@ -25,6 +25,8 @@
 import java.nio.ByteBuffer;
 import java.util.List;
 
+import static com.google.common.base.Charsets.UTF_8;
+
 public class Reader extends Operation
 {
     public Reader(int index)
@@ -63,7 +65,7 @@ private void runSuperColumnReader(SlicePredicate predicate, Cassandra.Client cli
         for (int j = 0; j < session.getSuperColumns(); j++)
         {
             String superColumn = 'S' + Integer.toString(j);
-            ColumnParent parent = new ColumnParent("Super1").setSuper_column(superColumn.getBytes());
+            ColumnParent parent = new ColumnParent("Super1").setSuper_column(superColumn.getBytes(UTF_8));
 
             long start = System.currentTimeMillis();
 

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -45,6 +45,7 @@
 import org.apache.cassandra.locator.*;
 import org.apache.cassandra.scheduler.IRequestScheduler;
 import org.apache.cassandra.scheduler.NoScheduler;
+import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.Pair;
 import org.yaml.snakeyaml.Loader;
@@ -613,7 +614,7 @@ else if (cf.compare_subcolumns_with != null)
                         throw new ConfigurationException("index_name cannot be set if index_type is not also set");
                     }
 
-                    ByteBuffer columnName = ByteBuffer.wrap(rcd.name.getBytes(Charsets.UTF_8));
+                    ByteBuffer columnName = ByteBufferUtil.bytes(rcd.name);
                     metadata.put(columnName, new ColumnDefinition(columnName, rcd.validator_class, rcd.index_type, rcd.index_name));
                 }
 

File: src/java/org/apache/cassandra/db/RowMutationVerbHandler.java
Patch:
@@ -25,7 +25,6 @@
 import java.net.UnknownHostException;
 import java.nio.ByteBuffer;
 
-import com.google.common.base.Charsets;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -61,7 +60,7 @@ public void doVerb(Message message, String id)
                 {
                     ByteBuffer addressBytes = ByteBufferUtil.readWithShortLength(dis);
                     if (logger_.isDebugEnabled())
-                        logger_.debug("Adding hint for " + InetAddress.getByName(ByteBufferUtil.string(addressBytes, Charsets.UTF_8)));
+                        logger_.debug("Adding hint for " + InetAddress.getByName(ByteBufferUtil.string(addressBytes)));
                     RowMutation hintedMutation = new RowMutation(Table.SYSTEM_TABLE, addressBytes);
                     hintedMutation.addHints(rm);
                     hintedMutation.apply();

File: src/java/org/apache/cassandra/db/marshal/AsciiType.java
Patch:
@@ -49,7 +49,7 @@ public String getString(ByteBuffer bytes)
 
     public ByteBuffer fromString(String source)
     {
-        return ByteBuffer.wrap(source.getBytes(Charsets.US_ASCII));
+        return ByteBufferUtil.bytes(source, Charsets.US_ASCII);
     }
 
     public void validate(ByteBuffer bytes) throws MarshalException

File: src/java/org/apache/cassandra/dht/CollatingOrderPreservingPartitioner.java
Patch:
@@ -25,8 +25,6 @@
 import java.util.Locale;
 import java.util.Map;
 
-import com.google.common.base.Charsets;
-
 import org.apache.cassandra.utils.ByteBufferUtil;
 
 public class CollatingOrderPreservingPartitioner extends AbstractByteOrderedPartitioner
@@ -41,7 +39,7 @@ public BytesToken getToken(ByteBuffer key)
         String skey;
         try
         {
-            skey = ByteBufferUtil.string(key, Charsets.UTF_8);
+            skey = ByteBufferUtil.string(key);
         }
         catch (CharacterCodingException e)
         {

File: src/java/org/apache/cassandra/dht/RandomPartitioner.java
Patch:
@@ -30,8 +30,6 @@
 import org.apache.cassandra.utils.GuidGenerator;
 import org.apache.cassandra.utils.Pair;
 
-import static com.google.common.base.Charsets.UTF_8;
-
 /**
  * This class generates a BigIntegerToken using MD5 hash.
  */
@@ -65,7 +63,7 @@ public DecoratedKey<BigIntegerToken> convertFromDiskFormat(ByteBuffer fromdisk)
         String token = null;
         try
         {
-            token = ByteBufferUtil.string(fromdisk, fromdisk.position(), splitPoint - fromdisk.position(), UTF_8);
+            token = ByteBufferUtil.string(fromdisk, fromdisk.position(), splitPoint - fromdisk.position());
         }
         catch (CharacterCodingException e)
         {

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -52,8 +52,6 @@
 import org.apache.cassandra.thrift.*;
 import org.apache.cassandra.utils.*;
 
-import static com.google.common.base.Charsets.UTF_8;
-
 public class StorageProxy implements StorageProxyMBean
 {
     private static final Logger logger = LoggerFactory.getLogger(StorageProxy.class);
@@ -258,7 +256,7 @@ private static void addHintHeader(Message message, InetAddress target) throws IO
         {
             dos.write(previousHints);
         }
-        ByteBufferUtil.writeWithShortLength(ByteBuffer.wrap(target.getHostAddress().getBytes(UTF_8)), dos);
+        ByteBufferUtil.writeWithShortLength(ByteBufferUtil.bytes(target.getHostAddress()), dos);
         message.setHeader(RowMutation.HINT, bos.toByteArray());
     }
 

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -2078,7 +2078,7 @@ public String exportSchema() throws IOException
                     RawColumnDefinition rcd = new RawColumnDefinition();
                     rcd.index_name = cd.getIndexName();
                     rcd.index_type = cd.getIndexType();
-                    rcd.name = ByteBufferUtil.string(cd.name, Charsets.UTF_8);
+                    rcd.name = ByteBufferUtil.string(cd.name);
                     rcd.validator_class = cd.validator.getClass().getName();
                     rcf.column_metadata[j++] = rcd;
                 }

File: test/unit/org/apache/cassandra/client/TestRingCache.java
Patch:
@@ -91,7 +91,7 @@ public static void main(String[] args) throws Throwable
 
         for (int nRows = minRow; nRows < maxRow; nRows++)
         {
-            ByteBuffer row = ByteBuffer.wrap((rowPrefix + nRows).getBytes());
+            ByteBuffer row = ByteBufferUtil.bytes((rowPrefix + nRows));
             ColumnPath col = new ColumnPath("Standard1").setSuper_column((ByteBuffer)null).setColumn("col1".getBytes());
             ColumnParent parent = new ColumnParent("Standard1").setSuper_column((ByteBuffer)null);
 

File: test/unit/org/apache/cassandra/db/CleanupTest.java
Patch:
@@ -51,7 +51,7 @@ public class CleanupTest extends CleanupHelper
     public static final String TABLE1 = "Keyspace1";
     public static final String CF1 = "Indexed1";
     public static final String CF2 = "Standard1";
-    public static final ByteBuffer COLUMN = ByteBuffer.wrap("birthdate".getBytes());
+    public static final ByteBuffer COLUMN = ByteBufferUtil.bytes("birthdate");
     public static final ByteBuffer VALUE = ByteBuffer.allocate(8);
     static
     {

File: test/unit/org/apache/cassandra/db/ColumnFamilyTest.java
Patch:
@@ -80,7 +80,7 @@ public void testManyColumns() throws IOException
         cf = ColumnFamily.serializer().deserialize(new DataInputStream(bufIn));
         for (String cName : map.navigableKeySet())
         {
-            ByteBuffer val = cf.getColumn(ByteBuffer.wrap(cName.getBytes())).value();
+            ByteBuffer val = cf.getColumn(ByteBufferUtil.bytes(cName)).value();
             assert new String(val.array(),val.position(),val.remaining()).equals(map.get(cName));
         }
         assert cf.getColumnNames().size() == map.size();

File: test/unit/org/apache/cassandra/db/CompactionsTest.java
Patch:
@@ -61,7 +61,7 @@ public void testCompactions() throws IOException, ExecutionException, Interrupte
             for (int i = 0; i < ROWS_PER_SSTABLE; i++) {
                 DecoratedKey key = Util.dk(String.valueOf(i % 2));
                 RowMutation rm = new RowMutation(TABLE1, key.key);
-                rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap(String.valueOf(i / 2).getBytes())), ByteBufferUtil.EMPTY_BYTE_BUFFER, j * ROWS_PER_SSTABLE + i);
+                rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes(String.valueOf(i / 2))), ByteBufferUtil.EMPTY_BYTE_BUFFER, j * ROWS_PER_SSTABLE + i);
                 rm.apply();
                 inserted.add(key);
             }

File: test/unit/org/apache/cassandra/db/NameSortTest.java
Patch:
@@ -64,15 +64,15 @@ private void testNameSort(int N) throws IOException, ExecutionException, Interru
 
         for (int i = 0; i < N; ++i)
         {
-            ByteBuffer key = ByteBuffer.wrap(Integer.toString(i).getBytes());
+            ByteBuffer key = ByteBufferUtil.bytes(Integer.toString(i));
             RowMutation rm;
 
             // standard
             for (int j = 0; j < 8; ++j)
             {
-                ByteBuffer bytes = ByteBuffer.wrap(j % 2 == 0 ? "a".getBytes() : "b".getBytes());
+                ByteBuffer bytes = j % 2 == 0 ? ByteBufferUtil.bytes("a") : ByteBufferUtil.bytes("b");
                 rm = new RowMutation("Keyspace1", key);
-                rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap(("Column-" + j).getBytes())), bytes, j);
+                rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes(("Column-" + j))), bytes, j);
                 rm.applyUnsafe();
             }
 

File: test/unit/org/apache/cassandra/db/RecoveryManager2Test.java
Patch:
@@ -33,6 +33,7 @@
 import org.apache.cassandra.CleanupHelper;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.db.commitlog.CommitLog;
+import org.apache.cassandra.utils.ByteBufferUtil;
 
 public class RecoveryManager2Test extends CleanupHelper
 {
@@ -73,7 +74,7 @@ public void testWithFlush() throws Exception
 
     private void insertRow(String cfname, String key) throws IOException
     {
-        RowMutation rm = new RowMutation("Keyspace1", ByteBuffer.wrap(key.getBytes()));
+        RowMutation rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes(key));
         ColumnFamily cf = ColumnFamily.create("Keyspace1", cfname);
         cf.addColumn(column("col1", "val1", 1L));
         rm.add(cf);

File: test/unit/org/apache/cassandra/db/RecoveryManagerTruncateTest.java
Patch:
@@ -89,11 +89,11 @@ private IColumn getFromTable(Table table, String cfName, String keyName, String
 			return null;
 		}
 		cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(
-		        Util.dk(keyName), new QueryPath(cfName), ByteBuffer.wrap(columnName.getBytes())));
+		        Util.dk(keyName), new QueryPath(cfName), ByteBufferUtil.bytes(columnName)));
 		if (cf == null)
 		{
 			return null;
 		}
-		return cf.getColumn(ByteBuffer.wrap(columnName.getBytes()));
+		return cf.getColumn(ByteBufferUtil.bytes(columnName));
 	}
 }

File: test/unit/org/apache/cassandra/db/RowIterationTest.java
Patch:
@@ -55,7 +55,7 @@ public void testRowIteration() throws IOException, ExecutionException, Interrupt
         for (int i = 0; i < ROWS_PER_SSTABLE; i++) {
             DecoratedKey key = Util.dk(String.valueOf(i));
             RowMutation rm = new RowMutation(TABLE1, key.key);
-            rm.add(new QueryPath("Super3", ByteBufferUtil.bytes("sc"), ByteBuffer.wrap(String.valueOf(i).getBytes())), ByteBuffer.wrap(new byte[ROWS_PER_SSTABLE * 10 - i * 2]), i);
+            rm.add(new QueryPath("Super3", ByteBufferUtil.bytes("sc"), ByteBufferUtil.bytes(String.valueOf(i))), ByteBuffer.wrap(new byte[ROWS_PER_SSTABLE * 10 - i * 2]), i);
             rm.apply();
             inserted.add(key);
         }

File: test/unit/org/apache/cassandra/db/TimeSortTest.java
Patch:
@@ -68,7 +68,7 @@ public void testTimeSort() throws IOException, ExecutionException, InterruptedEx
 
         for (int i = 900; i < 1000; ++i)
         {
-            RowMutation rm = new RowMutation("Keyspace1", ByteBuffer.wrap(Integer.toString(i).getBytes()));
+            RowMutation rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes(Integer.toString(i)));
             for (int j = 0; j < 8; ++j)
             {
                 rm.add(new QueryPath("StandardLong1", null, getBytes(j * 2)), ByteBufferUtil.bytes("a"), j * 2);

File: test/unit/org/apache/cassandra/io/LazilyCompactedRowTest.java
Patch:
@@ -150,7 +150,7 @@ public void testOneRowTwoColumns() throws IOException, ExecutionException, Inter
         Table table = Table.open("Keyspace1");
         ColumnFamilyStore cfs = table.getColumnFamilyStore("Standard1");
 
-        ByteBuffer key =ByteBuffer.wrap( "k".getBytes() );
+        ByteBuffer key = ByteBufferUtil.bytes("k");
         RowMutation rm = new RowMutation("Keyspace1", key);
         rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("c")), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
         rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("d")), ByteBufferUtil.EMPTY_BYTE_BUFFER, 0);
@@ -212,9 +212,9 @@ public void testManyRows() throws IOException, ExecutionException, InterruptedEx
         final int ROWS_PER_SSTABLE = 10;
         for (int j = 0; j < (DatabaseDescriptor.getIndexInterval() * 3) / ROWS_PER_SSTABLE; j++) {
             for (int i = 0; i < ROWS_PER_SSTABLE; i++) {
-                ByteBuffer key = ByteBuffer.wrap(String.valueOf(i % 2).getBytes());
+                ByteBuffer key = ByteBufferUtil.bytes(String.valueOf(i % 2));
                 RowMutation rm = new RowMutation("Keyspace1", key);
-                rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap(String.valueOf(i / 2).getBytes())), ByteBufferUtil.EMPTY_BYTE_BUFFER, j * ROWS_PER_SSTABLE + i);
+                rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes(String.valueOf(i / 2))), ByteBufferUtil.EMPTY_BYTE_BUFFER, j * ROWS_PER_SSTABLE + i);
                 rm.apply();
             }
             cfs.forceBlockingFlush();

File: test/unit/org/apache/cassandra/io/sstable/LegacySSTableTest.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.db.columniterator.SSTableNamesIterator;
 import org.apache.cassandra.utils.FBUtilities;
+import org.apache.cassandra.utils.ByteBufferUtil;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -99,7 +100,7 @@ public void testVersion(String version) throws Throwable
             SSTableReader reader = SSTableReader.open(getDescriptor(version));
             for (String keystring : TEST_DATA)
             {
-                ByteBuffer key = ByteBuffer.wrap(keystring.getBytes());
+                ByteBuffer key = ByteBufferUtil.bytes(keystring);
                 // confirm that the bloom filter does not reject any keys/names
                 DecoratedKey dk = reader.partitioner.decorateKey(key);
                 SSTableNamesIterator iter = new SSTableNamesIterator(reader, dk, FBUtilities.singleton(key));

File: test/unit/org/apache/cassandra/io/sstable/SSTableTest.java
Patch:
@@ -34,7 +34,7 @@ public class SSTableTest extends CleanupHelper
     @Test
     public void testSingleWrite() throws IOException {
         // write test data
-        ByteBuffer key = ByteBuffer.wrap(Integer.toString(1).getBytes());
+        ByteBuffer key = ByteBufferUtil.bytes(Integer.toString(1));
         ByteBuffer bytes = ByteBuffer.wrap(new byte[1024]);
         new Random().nextBytes(bytes.array());
 
@@ -64,7 +64,7 @@ public void testManyWrites() throws IOException {
         Map<ByteBuffer, ByteBuffer> map = new HashMap<ByteBuffer,ByteBuffer>();
         for (int i = 100; i < 1000; ++i)
         {
-            map.put(ByteBuffer.wrap(Integer.toString(i).getBytes()), ByteBuffer.wrap(("Avinash Lakshman is a good man: " + i).getBytes()));
+            map.put(ByteBufferUtil.bytes(Integer.toString(i)), ByteBufferUtil.bytes(("Avinash Lakshman is a good man: " + i)));
         }
 
         // write

File: test/unit/org/apache/cassandra/io/sstable/SSTableUtils.java
Patch:
@@ -29,6 +29,7 @@
 import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.db.IColumn;
 import org.apache.cassandra.io.util.DataOutputBuffer;
+import org.apache.cassandra.utils.ByteBufferUtil;
 
 public class SSTableUtils
 {
@@ -122,7 +123,7 @@ public SSTableReader write(Set<String> keys) throws IOException
             for (String key : keys)
             {
                 ColumnFamily cf = ColumnFamily.create(ksname, cfname);
-                cf.addColumn(new Column(ByteBuffer.wrap(key.getBytes()), ByteBuffer.wrap(key.getBytes()), 0));
+                cf.addColumn(new Column(ByteBufferUtil.bytes(key), ByteBufferUtil.bytes(key), 0));
                 map.put(key, cf);
             }
             return write(map);
@@ -135,8 +136,7 @@ public SSTableReader write(Map<String, ColumnFamily> entries) throws IOException
             {
                 DataOutputBuffer buffer = new DataOutputBuffer();
                 ColumnFamily.serializer().serializeWithIndexes(entry.getValue(), buffer);
-                map.put(ByteBuffer.wrap(entry.getKey().getBytes()),
-                        ByteBuffer.wrap(buffer.asByteArray()));
+                map.put(ByteBufferUtil.bytes(entry.getKey()), ByteBuffer.wrap(buffer.asByteArray()));
             }
             return writeRaw(map);
         }

File: test/unit/org/apache/cassandra/locator/SimpleStrategyTest.java
Patch:
@@ -36,6 +36,7 @@
 import org.apache.cassandra.dht.*;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.service.StorageServiceAccessor;
+import org.apache.cassandra.utils.ByteBufferUtil;
 
 import static org.junit.Assert.*;
 
@@ -68,7 +69,7 @@ public void testStringEndpoints() throws UnknownHostException, ConfigurationExce
         List<Token> keyTokens = new ArrayList<Token>();
         for (int i = 0; i < 5; i++) {
             endpointTokens.add(new StringToken(String.valueOf((char)('a' + i * 2))));
-            keyTokens.add(partitioner.getToken(ByteBuffer.wrap(String.valueOf((char)('a' + i * 2 + 1)).getBytes())));
+            keyTokens.add(partitioner.getToken(ByteBufferUtil.bytes(String.valueOf((char)('a' + i * 2 + 1)))));
         }
         verifyGetNaturalEndpoints(endpointTokens.toArray(new Token[0]), keyTokens.toArray(new Token[0]));
     }

File: test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java
Patch:
@@ -68,7 +68,7 @@ public void testTransferTable() throws Exception
         for (int i = 1; i <= 3; i++)
         {
             String key = "key" + i;
-            RowMutation rm = new RowMutation("Keyspace1", ByteBuffer.wrap(key.getBytes()));
+            RowMutation rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes(key));
             ColumnFamily cf = ColumnFamily.create(table.name, cfs.columnFamily);
             cf.addColumn(column(key, "v", 0));
             cf.addColumn(new Column(ByteBufferUtil.bytes("birthdate"), ByteBufferUtil.bytes((long) i), 0));
@@ -143,8 +143,8 @@ public void testTransferTableMultiple() throws Exception
         ColumnFamilyStore cfstore = Table.open(tablename).getColumnFamilyStore(cfname);
         List<Row> rows = Util.getRangeSlice(cfstore);
         assertEquals(6, rows.size());
-        assert rows.get(0).key.key.equals( ByteBufferUtil.bytes("test"));
-        assert rows.get(3).key.key.equals(ByteBuffer.wrap( "transfer1".getBytes() ));
+        assert rows.get(0).key.key.equals(ByteBufferUtil.bytes("test"));
+        assert rows.get(3).key.key.equals(ByteBufferUtil.bytes("transfer1"));
         assert rows.get(0).cf.getColumnsMap().size() == 1;
         assert rows.get(3).cf.getColumnsMap().size() == 1;
 

File: test/unit/org/apache/cassandra/tools/SSTableExportTest.java
Patch:
@@ -54,7 +54,7 @@ public class SSTableExportTest extends SchemaLoader
 {
     public String asHex(String str)
     {
-        return bytesToHex(ByteBuffer.wrap(str.getBytes()));
+        return bytesToHex(ByteBufferUtil.bytes(str));
     }
 
     @Test

File: test/unit/org/apache/cassandra/utils/ByteBufferUtilTest.java
Patch:
@@ -218,7 +218,7 @@ public void testIntBytesConversions()
     public void testDecode() throws IOException
     {
         ByteBuffer bytes = ByteBuffer.wrap(new byte[]{(byte)0xff, (byte)0xfe});
-        ByteBufferUtil.string(bytes, Charsets.UTF_8);
+        ByteBufferUtil.string(bytes);
     }
 
     @Test

File: test/unit/org/apache/cassandra/utils/KeyGenerator.java
Patch:
@@ -92,7 +92,7 @@ public boolean hasNext() {
         }
 
         public ByteBuffer next() {
-            return ByteBuffer.wrap(Integer.toString(i++).getBytes());
+            return ByteBufferUtil.bytes(Integer.toString(i++));
         }
 
         public void remove() {

File: src/java/org/apache/cassandra/utils/ByteBufferUtil.java
Patch:
@@ -363,9 +363,11 @@ public int read() throws IOException
             @Override
             public int read(byte[] bytes, int off, int len) throws IOException
             {
+                if (!copy.hasRemaining())
+                    return -1;
+
                 len = Math.min(len, copy.remaining());
                 copy.get(bytes, off, len);
-
                 return len;
             }
 

File: test/unit/org/apache/cassandra/db/RowCacheTest.java
Patch:
@@ -19,6 +19,7 @@
 package org.apache.cassandra.db;
 
 import java.util.Collection;
+import java.util.Set;
 
 import org.junit.Test;
 
@@ -133,7 +134,7 @@ public void testRowCacheLoad() throws Exception
         assert store.getRowCacheSize() == 0;
 
         // load the cache from disk
-        store.rowCache.readSaved();
+        store.initCaches();
         assert store.getRowCacheSize() == 100;
 
         for (int i = 0; i < 100; i++)

File: src/java/org/apache/cassandra/cql/QueryProcessor.java
Patch:
@@ -707,7 +707,9 @@ public static CqlResult process(String queryString, ClientState clientState)
                 else
                 {
                     columnDef = new ColumnDefinition(columnName,
-                                                     null,
+                                                     DatabaseDescriptor.getValueValidator(keyspace,
+                                                                                          createIdx.getColumnFamily(),
+                                                                                          columnName),
                                                      org.apache.cassandra.thrift.IndexType.KEYS,
                                                      createIdx.getIndexName());
                 }

File: src/java/org/apache/cassandra/cql/CreateColumnFamilyStatement.java
Patch:
@@ -210,8 +210,8 @@ public CFMetaData getCFMetaData(String keyspace) throws InvalidRequestException
         try
         {
             // RPC uses BytesType as the default validator/comparator but BytesType expects hex for string terms, (not convenient).
-            AbstractType<?> comparator = DatabaseDescriptor.getComparator(comparators.get(getPropertyString(KW_COMPARATOR, "ascii")));
-            String validator = getPropertyString(KW_DEFAULTVALIDATION, "ascii");
+            AbstractType<?> comparator = DatabaseDescriptor.getComparator(comparators.get(getPropertyString(KW_COMPARATOR, "utf8")));
+            String validator = getPropertyString(KW_DEFAULTVALIDATION, "utf8");
 
             newCFMD = new CFMetaData(keyspace,
                                      name,

File: src/java/org/apache/cassandra/db/CompactionManager.java
Patch:
@@ -372,8 +372,7 @@ public void disableAutoCompaction()
     {
         for (String ksname : DatabaseDescriptor.getNonSystemTables())
         {
-            Table ks = Table.open(ksname);
-            for (ColumnFamilyStore cfs : ks.columnFamilyStores.values())
+            for (ColumnFamilyStore cfs : Table.open(ksname).getColumnFamilyStores())
                 cfs.disableAutoCompaction();
         }
     }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1654,7 +1654,7 @@ private static boolean satisfies(ColumnFamily data, IndexClause clause, IndexExp
             IColumn column = data.getColumn(expression.column_name);
             if (column == null)
                 return false;
-            int v = data.getComparator().compare(column.value(), expression.value);
+            int v = data.metadata().getValueValidator(expression.column_name).compare(column.value(), expression.value);
             if (!satisfies(v, expression.op))
                 return false;
         }

File: drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraConnection.java
Patch:
@@ -50,7 +50,7 @@
 /**
  * Implementation class for {@link Connection}.
  */
-public class CassandraConnection implements Connection
+class CassandraConnection implements Connection
 {
     
     /** The cassandra con. */

File: drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraResultSetMetaData.java
Patch:
@@ -6,7 +6,7 @@
  * ResultSetMetaData give lots of nice detailed type inforamtion about column values.
  * This interface aims to do the same thing but distinguishes column names and values.
  */
-interface CassandraResultSetMetaData
+public interface CassandraResultSetMetaData
 {
     /** exposes row key */
     public byte[] getKey();

File: test/unit/org/apache/cassandra/SchemaLoader.java
Patch:
@@ -217,6 +217,6 @@ private static CFMetaData indexCFMD(String ksName, String cfName, final Boolean
     }
     private static CFMetaData jdbcCFMD(String ksName, String cfName, AbstractType comp)
     {
-        return new CFMetaData(ksName, cfName, ColumnFamilyType.Standard, comp, comp);
+        return new CFMetaData(ksName, cfName, ColumnFamilyType.Standard, comp, null).defaultValidator(comp);
     }
 }

File: test/unit/org/apache/cassandra/cli/CliTest.java
Patch:
@@ -181,13 +181,13 @@ public void testCli() throws IOException, TTransportException, ConfigurationExce
             }
             else if (statement.startsWith("set "))
             {
-                assertEquals(result, "Value inserted.\n");
+                assertEquals(result, "Value inserted." + System.getProperty("line.separator"));
             }
             else if (statement.startsWith("get "))
             {
                 if (statement.contains("where"))
                 {
-                    assertTrue(result.startsWith("-------------------\nRowKey:"));
+                    assertTrue(result.startsWith("-------------------" + System.getProperty("line.separator") + "RowKey:"));
                 }
                 else
                 {

File: src/java/org/apache/cassandra/concurrent/JMXConfigurableThreadPoolExecutor.java
Patch:
@@ -25,14 +25,13 @@ public class JMXConfigurableThreadPoolExecutor extends JMXEnabledThreadPoolExecu
 {
 
     public JMXConfigurableThreadPoolExecutor(int corePoolSize,
-                                             int maximumPoolSize, 
-        	                                 long keepAliveTime, 
+        	                                 long keepAliveTime,
         	                                 TimeUnit unit,
                                              BlockingQueue<Runnable> workQueue, 
                                              NamedThreadFactory threadFactory,
                                              String jmxPath)
     {
-        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, jmxPath);
+        super(corePoolSize, keepAliveTime, unit, workQueue, threadFactory, jmxPath);
     }
     
 }
\ No newline at end of file

File: src/java/org/apache/cassandra/concurrent/JMXConfigurableThreadPoolExecutorMBean.java
Patch:
@@ -20,9 +20,7 @@
 
 public interface JMXConfigurableThreadPoolExecutorMBean extends JMXEnabledThreadPoolExecutorMBean
 {
-
     void setCorePoolSize(int n);
 
     int getCorePoolSize();
-    
 }
\ No newline at end of file

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -112,6 +112,7 @@ public class Config
     public boolean compaction_preheat_key_cache = true;
 
     public boolean incremental_backups = false;
+    public int memtable_flush_queue_size = 4;
 
     public static enum CommitLogSync {
         periodic,

File: test/unit/org/apache/cassandra/concurrent/DebuggableThreadPoolExecutorTest.java
Patch:
@@ -35,7 +35,6 @@ public void testSerialization() throws InterruptedException
     {
         LinkedBlockingQueue<Runnable> q = new LinkedBlockingQueue<Runnable>(1);
         DebuggableThreadPoolExecutor executor = new DebuggableThreadPoolExecutor(1,
-                                                                                 1,
                                                                                  Integer.MAX_VALUE,
                                                                                  TimeUnit.MILLISECONDS,
                                                                                  q,

File: test/unit/org/apache/cassandra/AbstractSerializationsTester.java
Patch:
@@ -30,7 +30,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
-public class AbstractSerializationsTester extends SchemaLoader
+public class AbstractSerializationsTester extends CleanupHelper
 {
     protected static final String CUR_VER = System.getProperty("cassandra.version", "0.7");
     protected static final Map<String, Integer> VERSION_MAP = new HashMap<String, Integer> () 

File: drivers/java/src/org/apache/cassandra/cql/jdbc/TypedColumn.java
Patch:
@@ -1,6 +1,6 @@
 package org.apache.cassandra.cql.jdbc;
 
-public class TypedColumn<N, V>
+class TypedColumn<N, V>
 {
     public final N name;
     public final V value;

File: src/java/org/apache/cassandra/db/Memtable.java
Patch:
@@ -69,7 +69,7 @@ public Memtable(ColumnFamilyStore cfs)
 
         this.cfs = cfs;
         creationTime = System.currentTimeMillis();
-        THRESHOLD = cfs.getMemtableThroughputInMB() * 1024 * 1024;
+        THRESHOLD = cfs.getMemtableThroughputInMB() * 1024L * 1024L;
         THRESHOLD_COUNT = (long) (cfs.getMemtableOperationsInMillions() * 1024 * 1024);
     }
 

File: contrib/stress/src/org/apache/cassandra/contrib/stress/operations/IndexedRangeSlicer.java
Patch:
@@ -40,7 +40,7 @@ public void run(Cassandra.Client client) throws IOException
                                                                                       ByteBuffer.wrap(new byte[] {}),
                                                                                       false, session.getColumnsPerKey()));
 
-        List<String> values = super.generateValues();
+        List<ByteBuffer> values = super.generateValues();
         ColumnParent parent = new ColumnParent("Standard1");
         int expectedPerValue = session.getNumKeys() / values.size();
 
@@ -49,7 +49,7 @@ public void run(Cassandra.Client client) throws IOException
         int received = 0;
 
         String startOffset = "0";
-        ByteBuffer value = ByteBufferUtil.bytes(values.get(index % values.size()));
+        ByteBuffer value = values.get(index % values.size());
 
         IndexExpression expression = new IndexExpression(columnName, IndexOperator.EQ, value);
 

File: src/java/org/apache/cassandra/io/util/FileDataInput.java
Patch:
@@ -38,7 +38,7 @@ public interface FileDataInput extends DataInput, Closeable
 
     public void reset(FileMark mark) throws IOException;
 
-    public int bytesPastMark(FileMark mark);
+    public long bytesPastMark(FileMark mark);
 
     /**
      * Read length bytes from current file position

File: src/java/org/apache/cassandra/io/util/MappedFileDataInput.java
Patch:
@@ -76,7 +76,7 @@ public FileMark mark()
         return new MappedFileDataInputMark(position);
     }
 
-    public int bytesPastMark(FileMark mark)
+    public long bytesPastMark(FileMark mark)
     {
         assert mark instanceof MappedFileDataInputMark;
         assert position >= ((MappedFileDataInputMark) mark).position;

File: contrib/stress/src/org/apache/cassandra/contrib/stress/operations/Inserter.java
Patch:
@@ -39,7 +39,7 @@ public Inserter(int index)
 
     public void run(Cassandra.Client client) throws IOException
     {
-        List<String> values  = generateValues();
+        List<ByteBuffer> values = generateValues();
         List<Column> columns = new ArrayList<Column>();
         List<SuperColumn> superColumns = new ArrayList<SuperColumn>();
 
@@ -49,8 +49,7 @@ public void run(Cassandra.Client client) throws IOException
         for (int i = 0; i < session.getColumnsPerKey(); i++)
         {
             String columnName = ("C" + Integer.toString(i));
-            ByteBuffer columnValue = ByteBufferUtil.bytes(values.get(i % values.size()));
-
+            ByteBuffer columnValue = values.get(i % values.size());
             columns.add(new Column(ByteBufferUtil.bytes(columnName), columnValue, System.currentTimeMillis()));
         }
 

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -313,7 +313,7 @@ public void addIndex(final ColumnDefinition info)
         AbstractType columnComparator = (rowPartitioner instanceof OrderPreservingPartitioner || rowPartitioner instanceof ByteOrderedPartitioner)
                                         ? BytesType.instance
                                         : new LocalByPartionerType(StorageService.getPartitioner());
-        final CFMetaData indexedCfMetadata = CFMetaData.newIndexMetadata(table.name, columnFamily, info, columnComparator);
+        final CFMetaData indexedCfMetadata = CFMetaData.newIndexMetadata(metadata, info, columnComparator);
         ColumnFamilyStore indexedCfs = ColumnFamilyStore.createColumnFamilyStore(table,
                                                                                  indexedCfMetadata.cfName,
                                                                                  new LocalPartitioner(metadata.getColumn_metadata().get(info.name).validator),

File: drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraResultSet.java
Patch:
@@ -25,6 +25,7 @@
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.net.URL;
+import java.nio.ByteBuffer;
 import java.sql.Array;
 import java.sql.Blob;
 import java.sql.Clob;
@@ -360,7 +361,7 @@ public byte getByte(String arg0) throws SQLException
      */
     public byte[] getBytes(int index) throws SQLException
     {
-        return values.get(index) != null ? (byte[])values.get(index).getValue() : null;
+        return values.get(index) != null ? ((ByteBuffer)values.get(index).getValue()).array() : null;
     }
 
     /**
@@ -371,7 +372,7 @@ public byte[] getBytes(int index) throws SQLException
     public byte[] getBytes(String name) throws SQLException
     {
         String nameAsString = decoder.colNameAsString(keyspace, columnFamily, name);
-        return valueMap.get(nameAsString) != null ? (byte[])valueMap.get(nameAsString) : null;
+        return valueMap.get(nameAsString) != null ? ((ByteBuffer)valueMap.get(nameAsString)).array() : null;
     }
 
     /**

File: drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraStatement.java
Patch:
@@ -248,7 +248,7 @@ public ResultSet executeQuery(String query) throws SQLException
         }
         catch (InvalidRequestException e)
         {
-            throw new SQLException(e.getMessage());
+            throw new SQLException(e.getWhy());
         }
         catch (UnavailableException e)
         {

File: src/java/org/apache/cassandra/cql/Term.java
Patch:
@@ -209,6 +209,8 @@ else if (type == CqlParser.INTEGER)
             return INTEGER;
         else if (type == CqlParser.UNICODE)
             return UNICODE;
+        else if (type == CqlParser.UUID)
+            return UUID;
         
         // FIXME: handled scenario that should never occur.
         return null;

File: src/java/org/apache/cassandra/db/CompactionManager.java
Patch:
@@ -927,7 +927,7 @@ public void run()
             return executor.submit(runnable);
     }
     
-    public Future<SSTableReader> submitSSTableBuild(Descriptor desc)
+    public Future<SSTableReader> submitSSTableBuild(final Descriptor desc)
     {
         // invalid descriptions due to missing or dropped CFS are handled by SSTW and StreamInSession.
         final SSTableWriter.Builder builder = SSTableWriter.createBuilder(desc);
@@ -938,7 +938,7 @@ public SSTableReader call() throws IOException
                 compactionLock.lock();
                 try
                 {
-                    executor.beginCompaction(builder.cfs.columnFamily, builder);
+                    executor.beginCompaction(desc.cfname, builder);
                     return builder.build();
                 }
                 finally

File: drivers/java/src/org/apache/cassandra/cql/driver/Connection.java
Patch:
@@ -64,7 +64,7 @@ public class Connection
     // todo: encapsulate.
     public String curKeyspace;
     public String curColumnFamily;
-    public SchemaDecoder decoder;
+    public ColumnDecoder decoder;
     
     /**
      * Create a new <code>Connection</code> instance.
@@ -137,7 +137,7 @@ public CqlResult execute(String queryStr, Compression compress)
     throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
         if (decoder == null)
-            decoder = new SchemaDecoder(client.describe_keyspaces());
+            decoder = new ColumnDecoder(client.describe_keyspaces());
         
         Matcher isKeyspace = KeyspacePattern.matcher(queryStr);
         if (isKeyspace.matches())

File: drivers/java/src/org/apache/cassandra/cql/driver/Results.java
Patch:
@@ -3,11 +3,11 @@
 
 public class Results
 {
-    private final SchemaDecoder decoder;
+    private final ColumnDecoder decoder;
     private final String keyspace;
     private final String columnFamily;
     
-    public Results(SchemaDecoder decoder, String keyspace, String columnFamily) 
+    public Results(ColumnDecoder decoder, String keyspace, String columnFamily) 
     {
         this.decoder = decoder;
         this.keyspace = keyspace;

File: drivers/java/src/org/apache/cassandra/cql/driver/jdbc/CassandraStatement.java
Patch:
@@ -171,11 +171,11 @@ public boolean execute(String query) throws SQLException
         } 
         catch (InvalidRequestException e)
         {
-            throw new SQLException(e.getMessage());
+            throw new SQLException(e.getWhy());
         }
         catch (UnavailableException e)
         {
-            throw new SQLException(e.getMessage());
+            throw new SQLException("Cassandra was unavialable", e);
         }
         catch (TimedOutException e)
         {

File: src/java/org/apache/cassandra/db/CounterMutation.java
Patch:
@@ -126,7 +126,7 @@ public RowMutation makeReplicationMutation() throws IOException
         {
             Table table = Table.open(readCommand.table);
             Row row = readCommand.getRow(table);
-            if (null == row)
+            if (row == null || row.cf == null)
                 continue;
             AbstractType defaultValidator = row.cf.metadata().getDefaultValidator();
             if (defaultValidator.isCommutative())

File: src/java/org/apache/cassandra/db/CompactionManager.java
Patch:
@@ -629,7 +629,7 @@ private void doScrub(ColumnFamilyStore cfs) throws IOException
                     }
                     else
                     {
-                        logger.warn("Row is unreadable; skipping to next");
+                        logger.warn("Row at " + dataStart + " is unreadable; skipping to next");
                         if (currentIndexKey != null)
                             dataFile.seek(nextRowPositionFromIndex);
                         badRows++;

File: src/java/org/apache/cassandra/io/sstable/IndexHelper.java
Patch:
@@ -110,7 +110,7 @@ public static Filter defreezeBloomFilter(FileDataInput file, long maxSize, boole
     {
         int size = file.readInt();
         if (size > maxSize || size <= 0)
-            throw new EOFException("bloom filter claims to be longer than entire row size");
+            throw new EOFException("bloom filter claims to be " + size + " bytes, longer than entire row size " + maxSize);
         ByteBuffer bytes = file.readBytes(size);
 
         DataInputStream stream = new DataInputStream(ByteBufferUtil.inputStream(bytes));

File: test/unit/org/apache/cassandra/db/marshal/RoundTripTest.java
Patch:
@@ -87,6 +87,7 @@ public void testTimeUUID()
         c.set(Calendar.MINUTE, 0);
         c.set(Calendar.SECOND, 0);
         c.set(Calendar.MILLISECOND, 0);
+        c.set(Calendar.ZONE_OFFSET, -6 * 1000 * 60 * 60);
         Long ts = new Long(1299564000000L);
         assert ts.equals(c.getTimeInMillis()) : c.getTimeInMillis();
         

File: src/java/org/apache/cassandra/db/marshal/TimeUUIDType.java
Patch:
@@ -152,7 +152,7 @@ else if (source.matches("^\\d+$"))
             }
             catch (NumberFormatException e)
             {
-                throw new MarshalException(String.format("unable to make version 1 UUID from '%s'"), e);
+                throw new MarshalException(String.format("unable to make version 1 UUID from '%s'", source), e);
             }
         }
         // Last chance, attempt to parse as date-time string
@@ -165,7 +165,7 @@ else if (source.matches("^\\d+$"))
             }
             catch (ParseException e1)
             {
-                throw new MarshalException(String.format("unable to coherce '%s' to version 1 UUID"), e1);
+                throw new MarshalException(String.format("unable to coerce '%s' to version 1 UUID", source), e1);
             }
         }
             

File: src/java/org/apache/cassandra/db/marshal/AbstractType.java
Patch:
@@ -99,7 +99,7 @@ public int compare(ByteBuffer o1, ByteBuffer o2)
 
     /** get a byte representation of the given string.
      *  defaults to unsupportedoperation so people deploying custom Types can update at their leisure. */
-    public ByteBuffer fromString(String source)
+    public ByteBuffer fromString(String source) throws MarshalException
     {
         throw new UnsupportedOperationException();
     }

File: src/java/org/apache/cassandra/db/marshal/IntegerType.java
Patch:
@@ -130,7 +130,7 @@ public String getString(ByteBuffer bytes)
         return new java.math.BigInteger(TBaseHelper.byteBufferToByteArray(bytes)).toString(10);
     }
 
-    public ByteBuffer fromString(String source)
+    public ByteBuffer fromString(String source) throws MarshalException
     {
         BigInteger integerType;
 
@@ -140,7 +140,7 @@ public ByteBuffer fromString(String source)
         }
         catch (Exception e)
         {
-            throw new RuntimeException("'" + source + "' could not be translated into an IntegerType.");
+            throw new MarshalException(String.format("unable to make int from '%s'", source), e);
         }
 
         return ByteBuffer.wrap(integerType.toByteArray());

File: src/java/org/apache/cassandra/db/marshal/LongType.java
Patch:
@@ -70,7 +70,7 @@ public String getString(ByteBuffer bytes)
         return String.valueOf(bytes.getLong(bytes.position()));
     }
 
-    public ByteBuffer fromString(String source)
+    public ByteBuffer fromString(String source) throws MarshalException
     {
         long longType;
 
@@ -80,7 +80,7 @@ public ByteBuffer fromString(String source)
         }
         catch (Exception e)
         {
-            throw new RuntimeException("'" + source + "' could not be translated into a LongType.");
+            throw new MarshalException(String.format("unable to make long from '%s'", source), e);
         }
 
         return ByteBufferUtil.bytes(longType);

File: src/java/org/apache/cassandra/db/marshal/BytesType.java
Patch:
@@ -24,6 +24,7 @@
 import java.nio.ByteBuffer;
 
 import org.apache.cassandra.utils.ByteBufferUtil;
+import org.apache.cassandra.utils.FBUtilities;
 
 public class BytesType extends AbstractType
 {
@@ -48,7 +49,7 @@ public String getString(ByteBuffer bytes)
 
     public ByteBuffer fromString(String source)
     {
-        return ByteBuffer.wrap(source.getBytes());
+        return ByteBuffer.wrap(FBUtilities.hexToBytes(source));
     }
 
     public void validate(ByteBuffer bytes) throws MarshalException

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1334,8 +1334,8 @@ private ColumnFamily getTopLevelColumns(QueryFilter filter, int gcBefore)
                     {
                         returnCF.delete(iter.getColumnFamily());
                         iterators.add(iter);
+                        sstablesToIterate++;
                     }
-                    sstablesToIterate++;
                 }
             }
             else
@@ -1350,8 +1350,8 @@ private ColumnFamily getTopLevelColumns(QueryFilter filter, int gcBefore)
                     {
                         returnCF.delete(iter.getColumnFamily());
                         iterators.add(iter);
+                        sstablesToIterate++;
                     }
-                    sstablesToIterate++;
                 }
 
                 /* add the memtables being flushed */

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -49,7 +49,7 @@ public class NodeCmd
     private static final Pair<String, String> PORT_OPT = new Pair<String, String>("p", "port");
     private static final Pair<String, String> USERNAME_OPT = new Pair<String, String>("u",  "username");
     private static final Pair<String, String> PASSWORD_OPT = new Pair<String, String>("pw", "password");
-    private static final int DEFAULT_PORT = 8080;
+    private static final int DEFAULT_PORT = 7199;
 
     private static ToolOptions options = null;
 

File: src/java/org/apache/cassandra/avro/AvroValidation.java
Patch:
@@ -203,7 +203,7 @@ static void validateRange(String keyspace, String cfName, ByteBuffer superName,
         if (range.count < 0)
             throw newInvalidRequestException("Ranges require a non-negative count.");
 
-        Comparator<ByteBuffer> orderedComparator = range.reversed ? comparator.getReverseComparator() : comparator;
+        Comparator<ByteBuffer> orderedComparator = range.reversed ? comparator.reverseComparator : comparator;
         if (range.start.remaining() > 0 && range.finish.remaining() > 0 && orderedComparator.compare(range.start, range.finish) > 0)
             throw newInvalidRequestException("range finish must come after start in the order of traversal");
     }

File: src/java/org/apache/cassandra/db/filter/NamesQueryFilter.java
Patch:
@@ -26,7 +26,6 @@
 import java.util.Iterator;
 import java.util.SortedSet;
 
-import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.columniterator.IColumnIterator;
 import org.apache.cassandra.db.columniterator.SSTableNamesIterator;
@@ -88,6 +87,6 @@ public void collectReducedColumns(IColumnContainer container, Iterator<IColumn>
 
     public Comparator<IColumn> getColumnComparator(AbstractType comparator)
     {
-        return QueryFilter.getColumnComparator(comparator);
+        return comparator.columnComparator;
     }
 }

File: src/java/org/apache/cassandra/thrift/ThriftValidation.java
Patch:
@@ -207,7 +207,7 @@ public static void validateRange(String keyspace, ColumnParent column_parent, Sl
         if (range.count < 0)
             throw new InvalidRequestException("get_slice requires non-negative count");
 
-        Comparator<ByteBuffer> orderedComparator = range.isReversed() ? comparator.getReverseComparator() : comparator;
+        Comparator<ByteBuffer> orderedComparator = range.isReversed() ? comparator.reverseComparator : comparator;
         if (range.start.remaining() > 0
             && range.finish.remaining() > 0
             && orderedComparator.compare(range.start, range.finish) > 0)

File: src/java/org/apache/cassandra/service/DatacenterSyncWriteResponseHandler.java
Patch:
@@ -61,7 +61,7 @@ protected DatacenterSyncWriteResponseHandler(Collection<InetAddress> writeEndpoi
     {
         // Response is been managed by the map so make it 1 for the superclass.
         super(writeEndpoints, hintedEndpoints, consistencyLevel);
-        assert consistencyLevel == ConsistencyLevel.LOCAL_QUORUM;
+        assert consistencyLevel == ConsistencyLevel.EACH_QUORUM;
 
         strategy = (NetworkTopologyStrategy) Table.open(table).getReplicationStrategy();
 

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -172,7 +172,7 @@ public static void recover(File[] clogs) throws IOException
 
         for (File file : clogs)
         {
-            int bufferSize = (int)Math.min(file.length(), 32 * 1024 * 1024);
+            int bufferSize = (int) Math.min(Math.max(file.length(), 1), 32 * 1024 * 1024);
             BufferedRandomAccessFile reader = new BufferedRandomAccessFile(new File(file.getAbsolutePath()), "r", bufferSize, true);
 
             try

File: src/java/org/apache/cassandra/io/sstable/Descriptor.java
Patch:
@@ -76,8 +76,8 @@ public Descriptor(String version, File directory, String ksname, String cfname,
         hasStringsInBloomFilter = version.compareTo("c") < 0;
         hasIntRowSize = version.compareTo("d") < 0;
         hasEncodedKeys = version.compareTo("e") < 0;
-        isLatestVersion = version.compareTo(CURRENT_VERSION) == 0;
         usesOldBloomFilter = version.compareTo("f") < 0;
+        isLatestVersion = version.compareTo(CURRENT_VERSION) == 0;
     }
 
     public String filenameFor(Component component)

File: src/java/org/apache/cassandra/io/sstable/SSTableReader.java
Patch:
@@ -587,7 +587,7 @@ public ICompactSerializer2<IColumn> getColumnSerializer()
     {
         return metadata.cfType == ColumnFamilyType.Standard
                ? Column.serializer()
-               : SuperColumn.serializer(getColumnComparator());
+               : SuperColumn.serializer(metadata.subcolumnComparator);
     }
 
     /**

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -56,7 +56,7 @@ public final class CFMetaData
     public final static int DEFAULT_GC_GRACE_SECONDS = 864000;
     public final static int DEFAULT_MIN_COMPACTION_THRESHOLD = 4;
     public final static int DEFAULT_MAX_COMPACTION_THRESHOLD = 32;
-    public final static int DEFAULT_MEMTABLE_LIFETIME_IN_MINS = 60;
+    public final static int DEFAULT_MEMTABLE_LIFETIME_IN_MINS = 60 * 24;
     public final static int DEFAULT_MEMTABLE_THROUGHPUT_IN_MB = sizeMemtableThroughput();
     public final static double DEFAULT_MEMTABLE_OPERATIONS_IN_MILLIONS = sizeMemtableOperations(DEFAULT_MEMTABLE_THROUGHPUT_IN_MB);
 

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -56,7 +56,7 @@ public final class CFMetaData
     public final static int DEFAULT_GC_GRACE_SECONDS = 864000;
     public final static int DEFAULT_MIN_COMPACTION_THRESHOLD = 4;
     public final static int DEFAULT_MAX_COMPACTION_THRESHOLD = 32;
-    public final static int DEFAULT_MEMTABLE_LIFETIME_IN_MINS = 60;
+    public final static int DEFAULT_MEMTABLE_LIFETIME_IN_MINS = 60 * 24;
     public final static int DEFAULT_MEMTABLE_THROUGHPUT_IN_MB = sizeMemtableThroughput();
     public final static double DEFAULT_MEMTABLE_OPERATIONS_IN_MILLIONS = sizeMemtableOperations(DEFAULT_MEMTABLE_THROUGHPUT_IN_MB);
 

File: src/java/org/apache/cassandra/db/BinaryMemtable.java
Patch:
@@ -125,7 +125,8 @@ private List<DecoratedKey> getSortedKeys()
     private SSTableReader writeSortedContents(List<DecoratedKey> sortedKeys) throws IOException
     {
         logger.info("Writing " + this);
-        SSTableWriter writer = cfs.createFlushWriter(sortedKeys.size());
+        String path = cfs.getFlushPath();
+        SSTableWriter writer = new SSTableWriter(path, sortedKeys.size(), cfs.metadata, cfs.partitioner);
 
         for (DecoratedKey key : sortedKeys)
         {

File: src/java/org/apache/cassandra/db/Memtable.java
Patch:
@@ -155,7 +155,7 @@ public String contents()
     private SSTableReader writeSortedContents() throws IOException
     {
         logger.info("Writing " + this);
-        SSTableWriter writer = cfs.createFlushWriter(columnFamilies.size());
+        SSTableWriter writer = new SSTableWriter(cfs.getFlushPath(), columnFamilies.size(), cfs.metadata, cfs.partitioner);
 
         for (Map.Entry<DecoratedKey, ColumnFamily> entry : columnFamilies.entrySet())
             writer.append(entry.getKey(), entry.getValue());

File: src/java/org/apache/cassandra/tools/SSTableImport.java
Patch:
@@ -31,7 +31,6 @@
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.dht.IPartitioner;
-import org.apache.cassandra.io.sstable.Descriptor;
 import org.apache.cassandra.io.sstable.SSTableWriter;
 import org.codehaus.jackson.type.TypeReference;
 
@@ -209,7 +208,7 @@ private static int importUnsorted(JsonParser parser, ColumnFamily columnFamily,
         Map<?, ?> data = parser.readValueAs(new TypeReference<Map<?, ?>>() {});
 
         keyCountToImport = (keyCountToImport == null) ? data.size() : keyCountToImport;
-        SSTableWriter writer = new SSTableWriter(ssTablePath, keyCountToImport, DatabaseDescriptor.getCFMetaData(Descriptor.fromFilename(ssTablePath)), partitioner);
+        SSTableWriter writer = new SSTableWriter(ssTablePath, keyCountToImport);
 
         System.out.printf("Importing %s keys...%n", keyCountToImport);
 
@@ -281,7 +280,7 @@ public static int importSorted(String jsonFile, ColumnFamily columnFamily, Strin
         System.out.printf("Importing %s keys...%n", keyCountToImport);
 
         parser = getParser(jsonFile); // renewing parser
-        SSTableWriter writer = new SSTableWriter(ssTablePath, keyCountToImport, DatabaseDescriptor.getCFMetaData(Descriptor.fromFilename(ssTablePath)), partitioner);
+        SSTableWriter writer = new SSTableWriter(ssTablePath, keyCountToImport);
 
         int lineNumber = 1;
         DecoratedKey prevStoredKey = null;

File: src/java/org/apache/cassandra/db/columniterator/IndexedSliceReader.java
Patch:
@@ -146,8 +146,6 @@ private class IndexedBlockFetcher implements BlockFetcher
             file.readInt(); // column count
             this.mark = file.mark();
             curRangeIndex = IndexHelper.indexFor(startColumn, indexes, comparator, reversed);
-            if (reversed && curRangeIndex == indexes.size())
-                curRangeIndex--;
         }
 
         public boolean getNextBlock() throws IOException

File: src/java/org/apache/cassandra/db/columniterator/SSTableNamesIterator.java
Patch:
@@ -160,7 +160,7 @@ private void readIndexedColumns(CFMetaData metadata, FileDataInput file, SortedS
 
         /* get the various column ranges we have to read */
         AbstractType comparator = metadata.comparator;
-        SortedSet<IndexHelper.IndexInfo> ranges = new TreeSet<IndexHelper.IndexInfo>(IndexHelper.getComparator(comparator));
+        SortedSet<IndexHelper.IndexInfo> ranges = new TreeSet<IndexHelper.IndexInfo>(IndexHelper.getComparator(comparator, false));
         for (ByteBuffer name : filteredColumnNames)
         {
             int index = IndexHelper.indexFor(name, indexList, comparator, false);

File: src/java/org/apache/cassandra/io/sstable/CacheWriter.java
Patch:
@@ -89,8 +89,10 @@ public void saveCache() throws IOException
         {
             out.close();
         }
+
+        path.delete(); // ignore error if it didn't exist
         if (!tmpFile.renameTo(path))
-            throw new IOException("Unable to rename cache to " + path);
+            throw new IOException("Unable to rename " + tmpFile + " to " + path);
         logger.info(String.format("Saved %s (%d items) in %d ms",
                                   path.getName(), keys.size(), (System.currentTimeMillis() - start)));
     }

File: src/java/org/apache/cassandra/tools/SSTableExport.java
Patch:
@@ -194,6 +194,8 @@ private static void serializeRow(SSTableReader reader, SSTableIdentityIterator r
 
             if (columnCount < PAGE_SIZE)
                 break;
+
+            out.print(",");
         }
 
         out.print(isSuperCF ? "}" : "]");

File: src/java/org/apache/cassandra/io/LazilyCompactedRow.java
Patch:
@@ -94,7 +94,7 @@ public LazilyCompactedRow(ColumnFamilyStore cfStore, List<SSTableIdentityIterato
 
     public void write(DataOutput out) throws IOException
     {
-        if (rows.size() == 1 && !shouldPurge)
+        if (rows.size() == 1 && !shouldPurge && rows.get(0).sstable.descriptor.isLatestVersion)
         {
             SSTableIdentityIterator row = rows.get(0);
             out.writeLong(row.dataSize);

File: src/java/org/apache/cassandra/io/PrecompactedRow.java
Patch:
@@ -67,7 +67,7 @@ public PrecompactedRow(ColumnFamilyStore cfStore, List<SSTableIdentityIterator>
         }
         boolean shouldPurge = major || !cfStore.isKeyInRemainingSSTables(key, sstables);
 
-        if (rows.size() > 1 || shouldPurge)
+        if (rows.size() > 1 || shouldPurge || !rows.get(0).sstable.descriptor.isLatestVersion)
         {
             ColumnFamily cf = null;
             for (SSTableIdentityIterator row : rows)

File: test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java
Patch:
@@ -183,7 +183,7 @@ public void testTransferOfMultipleColumnFamilies() throws Exception
         }
 
         StreamOutSession session = StreamOutSession.create(keyspace, LOCAL, null);
-        StreamOut.transferSSTables(session, ssTableReaders, ranges);
+        StreamOut.transferSSTables(session, ssTableReaders, ranges, OperationType.BOOTSTRAP);
 
         session.await();
 

File: src/java/org/apache/cassandra/db/filter/QueryPath.java
Patch:
@@ -71,7 +71,7 @@ public static QueryPath column(ByteBuffer columnName)
     @Override
     public String toString()
     {
-        return "QueryPath(" +
+        return getClass().getSimpleName() + "(" +
                "columnFamilyName='" + columnFamilyName + '\'' +
                ", superColumnName='" + superColumnName + '\'' +
                ", columnName='" + columnName + '\'' +

File: contrib/stress/src/org/apache/cassandra/contrib/stress/Session.java
Patch:
@@ -162,7 +162,7 @@ public Session(String[] arguments) throws IllegalArgumentException
                 STDev = Float.parseFloat(cmd.getOptionValue("s"));
 
             if (cmd.hasOption("r"))
-                random = Boolean.parseBoolean(cmd.getOptionValue("r"));
+                random = true;
 
             if (cmd.hasOption("f"))
             {

File: contrib/stress/src/org/apache/cassandra/contrib/stress/util/OperationThread.java
Patch:
@@ -125,7 +125,9 @@ private byte[] generateGaussKey()
     private double nextGaussian(int mu, float sigma)
     {
         Random random = Stress.randomizer;
+
         Double currentState = nextGaussian;
+        nextGaussian = null;
 
         if (currentState == null)
         {

File: src/java/org/apache/cassandra/db/RowMutation.java
Patch:
@@ -193,7 +193,7 @@ public void apply() throws IOException
     /**
      * Apply without touching the commitlog. For testing.
      */
-    public void 2applyUnsafe() throws IOException
+    public void applyUnsafe() throws IOException
     {
         Table.open(table_).apply(this, getSerializedBuffer(), false);
     }

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -2093,6 +2093,7 @@ private void validateSchemaIsSettled(String currentVersionId)
                 inAgreement = true;
                 break; // all nodes are in agreement no need to loop
             }
+            start = System.currentTimeMillis();
         }
 
         if (!inAgreement)

File: src/java/org/apache/cassandra/service/RepairCallback.java
Patch:
@@ -66,7 +66,7 @@ public T get() throws TimeoutException, DigestMismatchException, IOException
             throw new AssertionError(ex);
         }
 
-        return resolver.isDataPresent() ? resolver.resolve() : null;
+        return resolver.getMessageCount() > 0 ? resolver.resolve() : null;
     }
 
     public void response(Message message)

File: src/java/org/apache/cassandra/db/CounterMutation.java
Patch:
@@ -175,7 +175,7 @@ public void apply() throws IOException
             ColumnFamilyStore cfs = table.getColumnFamilyStore(cf.id());
             for (IColumn column : cf_.getColumnsMap().values())
             {
-                cf.addColumn(column.localCopy(null)); // TODO fix this
+                cf.addColumn(column.localCopy(cfs));
             }
             rm.add(cf);
         }

File: src/java/org/apache/cassandra/db/CounterMutation.java
Patch:
@@ -167,10 +167,12 @@ public void apply() throws IOException
         // We need to transform all CounterUpdateColumn to CounterColumn and we need to deepCopy. Both are done 
         // below since CUC.asCounterColumn() does a deep copy.
         RowMutation rm = new RowMutation(rowMutation.getTable(), ByteBufferUtil.clone(rowMutation.key()));
+        Table table = Table.open(rm.getTable());
 
         for (ColumnFamily cf_ : rowMutation.getColumnFamilies())
         {
             ColumnFamily cf = cf_.cloneMeShallow();
+            ColumnFamilyStore cfs = table.getColumnFamilyStore(cf.id());
             for (IColumn column : cf_.getColumnsMap().values())
             {
                 cf.addColumn(column.localCopy(null)); // TODO fix this

File: test/unit/org/apache/cassandra/db/TableTest.java
Patch:
@@ -48,7 +48,6 @@
 
 public class TableTest extends CleanupHelper
 {
-    private static final DecoratedKey KEY2 = Util.dk("key2");
     private static final DecoratedKey TEST_KEY = Util.dk("key1");
     private static final DecoratedKey TEST_SLICE_KEY = Util.dk("key1-slicerange");
 
@@ -396,11 +395,13 @@ public void testGetSliceFromLarge() throws Throwable
         cfStore.forceBlockingFlush();
 
         validateSliceLarge(cfStore);
+
         // compact so we have a big row with more than the minimum index count
         if (cfStore.getSSTables().size() > 1)
         {
             CompactionManager.instance.performMajor(cfStore);
         }
+        // verify that we do indeed have multiple index entries
         SSTableReader sstable = cfStore.getSSTables().iterator().next();
         long position = sstable.getPosition(key, SSTableReader.Operator.EQ);
         BufferedRandomAccessFile file = new BufferedRandomAccessFile(sstable.getFilename(), "r");
@@ -410,6 +411,7 @@ public void testGetSliceFromLarge() throws Throwable
         IndexHelper.skipBloomFilter(file);
         ArrayList<IndexHelper.IndexInfo> indexes = IndexHelper.deserializeIndex(file);
         assert indexes.size() > 2;
+
         validateSliceLarge(cfStore);
     }
 

File: src/java/org/apache/cassandra/db/migration/DropColumnFamily.java
Patch:
@@ -48,7 +48,7 @@ public DropColumnFamily(String tableName, String cfName) throws ConfigurationExc
         
         KSMetaData ksm = DatabaseDescriptor.getTableDefinition(tableName);
         if (ksm == null)
-            throw new ConfigurationException("Keyspace does not already exist.");
+            throw new ConfigurationException("No such keyspace: " + tableName);
         else if (!ksm.cfMetaData().containsKey(cfName))
             throw new ConfigurationException("CF is not defined in that keyspace.");
         

File: src/java/org/apache/cassandra/db/migration/RenameColumnFamily.java
Patch:
@@ -53,7 +53,7 @@ public RenameColumnFamily(String tableName, String oldName, String newName) thro
         
         KSMetaData ksm = DatabaseDescriptor.getTableDefinition(tableName);
         if (ksm == null)
-            throw new ConfigurationException("Keyspace does not already exist.");
+            throw new ConfigurationException("No such keyspace: " + tableName);
         if (!ksm.cfMetaData().containsKey(oldName))
             throw new ConfigurationException("CF is not defined in that keyspace.");
         if (ksm.cfMetaData().containsKey(newName))

File: src/java/org/apache/cassandra/db/migration/UpdateColumnFamily.java
Patch:
@@ -44,7 +44,7 @@ public UpdateColumnFamily(org.apache.cassandra.db.migration.avro.CfDef cf_def) t
         
         KSMetaData ksm = DatabaseDescriptor.getTableDefinition(cf_def.keyspace.toString());
         if (ksm == null)
-            throw new ConfigurationException("Keyspace does not already exist.");
+            throw new ConfigurationException("No such keyspace: " + cf_def.keyspace.toString());
         
         CFMetaData oldCfm = DatabaseDescriptor.getCFMetaData(CFMetaData.getId(cf_def.keyspace.toString(), cf_def.name.toString()));
         

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -222,7 +222,8 @@ private static void sendToHintedEndpoints(final RowMutation rm, Multimap<InetAdd
                 // unhinted writes
                 if (destination.equals(FBUtilities.getLocalAddress()))
                 {
-                    insertLocal(rm, responseHandler);
+                    if (insertLocalMessages)
+                        insertLocal(rm, responseHandler);
                 }
                 else
                 {

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1149,7 +1149,7 @@ else if (!column.name().hasArray() || !column.value().hasArray())
                 }
             }
 
-            // TFFT resuses the underlying buffer for the key
+            // avoid keeping a permanent reference to the original key buffer
             ssTables.getRowCache().put(new DecoratedKey(key.token, ByteBufferUtil.clone(key.key)), cached);
         }
         return cached;

File: src/java/org/apache/cassandra/net/CachingMessageProducer.java
Patch:
@@ -4,12 +4,12 @@
 import java.util.HashMap;
 import java.util.Map;
 
-public class CacheingMessageProducer implements MessageProducer
+public class CachingMessageProducer implements MessageProducer
 {
     private final MessageProducer prod;
     private final Map<Integer, Message> messages = new HashMap<Integer, Message>();
 
-    public CacheingMessageProducer(MessageProducer prod)
+    public CachingMessageProducer(MessageProducer prod)
     {
         this.prod = prod;    
     }

File: src/java/org/apache/cassandra/service/MigrationManager.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 
-import org.apache.cassandra.net.CacheingMessageProducer;
+import org.apache.cassandra.net.CachingMessageProducer;
 import org.apache.cassandra.net.MessageProducer;
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.slf4j.Logger;
@@ -94,7 +94,7 @@ else if (theirVersion.timestamp() > myVersion.timestamp())
     /** actively announce my version to a set of hosts via rpc.  They may culminate with them sending me migrations. */
     public static void announce(final UUID version, Set<InetAddress> hosts)
     {
-        MessageProducer prod = new CacheingMessageProducer(new MessageProducer() {
+        MessageProducer prod = new CachingMessageProducer(new MessageProducer() {
             public Message getMessage(int protocolVersion) throws IOException
             {
                 return makeVersionMessage(version, protocolVersion);

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -434,9 +434,11 @@ void doStatusCheck()
                         epState.setHasToken(true);
                     else
                     {
-                        logger_.info("FatClient " + endpoint + " has been silent for " + FatClientTimeout_ + "ms, removing from gossip");
                         if (!justRemovedEndpoints_.containsKey(endpoint)) // if the node was decommissioned, it will have been removed but still appear as a fat client
+                        {
+                            logger_.info("FatClient " + endpoint + " has been silent for " + FatClientTimeout_ + "ms, removing from gossip");
                             removeEndpoint(endpoint); // after quarantine justRemoveEndpoints will remove the state
+                        }
                     }
                 }
 

File: contrib/stress/src/org/apache/cassandra/contrib/stress/Session.java
Patch:
@@ -125,7 +125,7 @@ public Session(String[] arguments) throws IllegalArgumentException
                 columnSize = Integer.parseInt(cmd.getOptionValue("S"));
 
             if (cmd.hasOption("C"))
-                cardinality = Integer.parseInt(cmd.getOptionValue("t"));
+                cardinality = Integer.parseInt(cmd.getOptionValue("C"));
 
             if (cmd.hasOption("d"))
                 nodes = cmd.getOptionValue("d").split(",");

File: src/java/org/apache/cassandra/net/sink/IMessageSink.java
Patch:
@@ -24,5 +24,5 @@
 
 public interface IMessageSink
 {
-    public Message handleMessage(Message message, InetAddress to);
+    public Message handleMessage(Message message, String id, InetAddress to);
 }

File: src/java/org/apache/cassandra/io/util/ColumnSortedMap.java
Patch:
@@ -22,6 +22,7 @@
 
 
 import java.io.DataInput;
+import java.io.IOError;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.*;
@@ -242,7 +243,7 @@ private IColumn deserializeNext()
         }
         catch (IOException e)
         {
-            return null;
+            throw new IOError(e);
         }
     }
 
@@ -263,7 +264,7 @@ public Entry<ByteBuffer, IColumn> next()
         {
             public IColumn setValue(IColumn value)
             {
-                return null;
+                throw new UnsupportedOperationException();
             }
 
             public IColumn getValue()

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -63,6 +63,7 @@
 
 public final class MessagingService implements MessagingServiceMBean
 {
+    public static final int VERSION_07 = 1;
     public static final int version_ = 2;
     //TODO: make this parameter dynamic somehow.  Not sure if config is appropriate.
     private SerializerType serializerType_ = SerializerType.BINARY;

File: src/java/org/apache/cassandra/streaming/OperationType.java
Patch:
@@ -23,6 +23,8 @@
  */
 public enum OperationType
 {
+    // TODO: the only types of operation that are currently distinguised are AES and everything else.  There is no
+    // sense in having the other types (yet).
     AES,
     BOOTSTRAP,
     UNBOOTSTRAP,

File: test/unit/org/apache/cassandra/streaming/SerializationsTest.java
Patch:
@@ -62,7 +62,7 @@ private void testPendingFileWrite() throws IOException
         out.close();
     }
     
-    @Test @Ignore
+    @Test
     public void testPendingFileRead() throws IOException
     {
         if (EXECUTE_WRITES)
@@ -96,7 +96,7 @@ private void testStreamHeaderWrite() throws IOException
         out.close();
     }
     
-    @Test @Ignore
+    @Test
     public void testStreamHeaderRead() throws IOException
     {
         if (EXECUTE_WRITES)
@@ -160,7 +160,7 @@ private void testStreamRequestMessageWrite() throws IOException
         out.close();
     }
     
-    @Test @Ignore
+    @Test
     public void testStreamRequestMessageRead() throws IOException
     {
         if (EXECUTE_WRITES)

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -50,7 +50,7 @@ public final class CFMetaData
     public final static double DEFAULT_KEY_CACHE_SIZE = 200000;
     public final static double DEFAULT_READ_REPAIR_CHANCE = 1.0;
     public final static int DEFAULT_ROW_CACHE_SAVE_PERIOD_IN_SECONDS = 0;
-    public final static int DEFAULT_KEY_CACHE_SAVE_PERIOD_IN_SECONDS = 3600;
+    public final static int DEFAULT_KEY_CACHE_SAVE_PERIOD_IN_SECONDS = 4 * 3600;
     public final static int DEFAULT_GC_GRACE_SECONDS = 864000;
     public final static int DEFAULT_MIN_COMPACTION_THRESHOLD = 4;
     public final static int DEFAULT_MAX_COMPACTION_THRESHOLD = 32;

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -430,9 +430,11 @@ private void doStatusCheck()
                         epState.setHasToken(true);
                     else
                     {
-                        logger.info("FatClient " + endpoint + " has been silent for " + FatClientTimeout + "ms, removing from gossip");
                         if (!justRemovedEndpoints.containsKey(endpoint)) // if the node was decommissioned, it will have been removed but still appear as a fat client
+                        {
+                            logger.info("FatClient " + endpoint + " has been silent for " + FatClientTimeout + "ms, removing from gossip");
                             removeEndpoint(endpoint); // after quarantine justRemoveEndpoints will remove the state
+                        }
                     }
                 }
 

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -676,9 +676,9 @@ private void applyNewStates(InetAddress addr, EndpointState localState, Endpoint
         int oldVersion = localState.getHeartBeatState().getHeartBeatVersion();
         Map<ApplicationState, VersionedValue> localAppStateMap = localState.getApplicationStateMap();
 
-        localState.setHeartBeatState(remoteHbState);
+        localState.setHeartBeatState(remoteState.getHeartBeatState());
         if (logger.isTraceEnabled())
-            logger.trace("Updating heartbeat state generation to " + remoteHbState.getGeneration() + " from " + localHbState.getGeneration() + " for " + addr);
+            logger.trace("Updating heartbeat state version to " + localState.getHeartBeatState().getHeartBeatVersion() + " from " + oldVersion + " for " + addr + " ...");
 
         for (Entry<ApplicationState, VersionedValue> remoteEntry : remoteState.getApplicationStateMap().entrySet())
         {

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1604,7 +1604,7 @@ private void leaveRing()
         Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.left(getLocalToken()));
         try
         {
-            Thread.sleep(2 * Gossiper.intervalInMillis_);
+            Thread.sleep(2 * Gossiper.intervalInMillis);
         }
         catch (InterruptedException e)
         {

File: src/java/org/apache/cassandra/db/DefinitionsUpdateResponseVerbHandler.java
Patch:
@@ -72,6 +72,8 @@ else if (DatabaseDescriptor.getDefsVersion().timestamp() > version.timestamp())
                                 try
                                 {
                                     m.apply();
+                                    // update gossip, but don't contact nodes directly
+                                    m.passiveAnnounce();
                                 }
                                 catch (ConfigurationException ex)
                                 {

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1602,9 +1602,10 @@ private void leaveRing()
         calculatePendingRanges();
 
         Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.left(getLocalToken()));
+        logger_.info("Announcing that I have left the ring for " + RING_DELAY + "ms");
         try
         {
-            Thread.sleep(2 * Gossiper.intervalInMillis_);
+            Thread.sleep(RING_DELAY);
         }
         catch (InterruptedException e)
         {

File: src/java/org/apache/cassandra/net/ResponseVerbHandler.java
Patch:
@@ -37,7 +37,10 @@ public void doVerb(Message message)
         double age = System.currentTimeMillis() - MessagingService.instance().getRegisteredCallbackAge(messageId);
         Pair<InetAddress, IMessageCallback> pair = MessagingService.instance().removeRegisteredCallback(messageId);
         if (pair == null)
+        {
+            logger_.debug("Callback already removed for {}", messageId);
             return;
+        }
 
         IMessageCallback cb = pair.right;
         MessagingService.instance().maybeAddLatency(cb, message.getFrom(), age);

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -546,7 +546,6 @@ public static List<Row> getRangeSlice(RangeSliceCommand command, ConsistencyLeve
                 {
                     DatabaseDescriptor.getEndpointSnitch().sortByProximity(FBUtilities.getLocalAddress(), liveEndpoints);
                     RangeSliceCommand c2 = new RangeSliceCommand(command.keyspace, command.column_family, command.super_column, command.predicate, range, command.max_keys);
-                    Message message = c2.getMessage();
 
                     // collect replies and resolve according to consistency level
                     RangeSliceResponseResolver resolver = new RangeSliceResponseResolver(command.keyspace, liveEndpoints);
@@ -555,6 +554,7 @@ public static List<Row> getRangeSlice(RangeSliceCommand command, ConsistencyLeve
                     // TODO bail early if live endpoints can't satisfy requested consistency level
                     for (InetAddress endpoint : liveEndpoints) 
                     {
+                        Message message = c2.getMessage();
                         MessagingService.instance().sendRR(message, endpoint, handler);
                         if (logger.isDebugEnabled())
                             logger.debug("reading " + c2 + " from " + message.getMessageId() + "@" + endpoint);

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -381,7 +381,6 @@ private static List<Row> fetchRows(List<ReadCommand> commands, ConsistencyLevel
 
             // We lazy-construct the digest Message object since it may not be necessary if we
             // are doing a local digest read, or no digest reads at all.
-            Message digestMessage = null;
             for (InetAddress digestPoint : endpoints.subList(1, endpoints.size()))
             {
                 if (digestPoint.equals(FBUtilities.getLocalAddress()))
@@ -392,8 +391,7 @@ private static List<Row> fetchRows(List<ReadCommand> commands, ConsistencyLevel
                 }
                 else
                 {
-                    if (digestMessage == null)
-                        digestMessage = digestCommand.makeReadMessage();
+                    Message digestMessage = digestCommand.makeReadMessage();
                     if (logger.isDebugEnabled())
                         logger.debug("reading digest for " + command + " from " + digestMessage.getMessageId() + "@" + digestPoint);
                     MessagingService.instance().sendRR(digestMessage, digestPoint, handler);

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -149,6 +149,9 @@ public enum Verb
 
     public static final RetryingScheduledThreadPoolExecutor scheduledTasks = new RetryingScheduledThreadPoolExecutor("ScheduledTasks");
 
+    /* This abstraction maintains the token/endpoint metadata information */
+    private TokenMetadata tokenMetadata_ = new TokenMetadata();
+
     private static IPartitioner partitioner_ = DatabaseDescriptor.getPartitioner();
     public static VersionedValue.VersionedValueFactory valueFactory = new VersionedValue.VersionedValueFactory(partitioner_);
     
@@ -168,9 +171,6 @@ public Range getLocalPrimaryRange()
         return getPrimaryRangeForEndpoint(FBUtilities.getLocalAddress());
     }
 
-    /* This abstraction maintains the token/endpoint metadata information */
-    private TokenMetadata tokenMetadata_ = new TokenMetadata();
-
     private Set<InetAddress> replicatingNodes = Collections.synchronizedSet(new HashSet<InetAddress>());
     private CassandraDaemon daemon;
 

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -374,19 +374,19 @@ else if (conf.memtable_flush_writers == null)
         }
         catch (UnknownHostException e)
         {
-            logger.error("Fatal error: " + e.getMessage());
+            logger.error("Fatal configuration error ", e);
             System.err.println("Unable to start with unknown hosts configured.  Use IP addresses instead of hostnames.");
             System.exit(2);
         }
         catch (ConfigurationException e)
         {
-            logger.error("Fatal error: " + e.getMessage());
+            logger.error("Fatal configuration error", e);
             System.err.println("Bad configuration; unable to start server");
             System.exit(1);
         }
         catch (YAMLException e)
         {
-            logger.error("Fatal error: " + e.getMessage());
+            logger.error("Fatal configuration error error", e);
             System.err.println("Bad configuration; unable to start server");
             System.exit(1);
         }

File: src/java/org/apache/cassandra/io/sstable/SSTableDeletingReference.java
Patch:
@@ -23,9 +23,11 @@
 import java.io.IOException;
 import java.lang.ref.PhantomReference;
 import java.lang.ref.ReferenceQueue;
+import java.util.Collections;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
+import com.google.common.collect.Sets;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -91,8 +93,7 @@ public void run()
                 }
             }
             // let the remainder be cleaned up by delete
-            components.remove(Component.DATA);
-            SSTable.delete(desc, components);
+            SSTable.delete(desc, Sets.difference(components, Collections.singleton(Component.DATA)));
             tracker.spaceReclaimed(size);
         }
     }

File: src/java/org/apache/cassandra/cql/QueryProcessor.java
Patch:
@@ -328,6 +328,8 @@ public static CqlResult process(String queryString, ClientState clientState)
         
         CqlResult avroResult = new CqlResult();
         
+        logger.debug("CQL statement type: {}", statement.type.toString());
+        
         switch (statement.type)
         {
             case SELECT:

File: src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordWriter.java
Patch:
@@ -40,7 +40,7 @@
 import org.apache.thrift.TException;
 import org.apache.thrift.transport.TSocket;
 
-import static org.apache.cassandra.io.SerDeUtils.copy;
+import org.apache.cassandra.utils.ByteBufferUtil;
 
 /**
  * The <code>ColumnFamilyRecordWriter</code> maps the output &lt;key, value&gt;
@@ -169,7 +169,7 @@ private Mutation avroToThrift(org.apache.cassandra.avro.Mutation amut)
             org.apache.cassandra.avro.SlicePredicate apred = amut.deletion.predicate;
             if (amut.deletion.super_column != null)
                 // super column
-                deletion.setSuper_column(copy(amut.deletion.super_column));
+                deletion.setSuper_column(ByteBufferUtil.getArray(amut.deletion.super_column));
             else if (apred.column_names != null)
             {
                 // column names

File: contrib/circuit/src/org/apache/cassandra/contrib/circuit/RingModel.java
Patch:
@@ -41,7 +41,7 @@
  */
 public class RingModel
 {
-    public static final int defaultPort = 8080;
+    public static final int defaultPort = 7199;
     private static final String fmtUrl = "service:jmx:rmi:///jndi/rmi://%s:%d/jmxrmi";
     private static final String ssObjName = "org.apache.cassandra.service:type=StorageService";
 

File: src/java/org/apache/cassandra/cli/CliSessionState.java
Patch:
@@ -38,7 +38,7 @@ public class CliSessionState
     public String  keyspace;      // cassandra keyspace user is authenticating
     public boolean batch = false; // enable/disable batch processing mode
     public String  filename = ""; // file to read commands from
-    public int     jmxPort = 8080;// JMX service port
+    public int     jmxPort = 7199;// JMX service port
     public boolean verbose = false; // verbose output
     public int     schema_mwt;    // Schema migration wait time (secs.)
     /*

File: src/java/org/apache/cassandra/tools/ClusterCmd.java
Patch:
@@ -31,7 +31,7 @@ public class ClusterCmd {
     private static final String HOST_OPT_SHORT = "h";
     private static final String PORT_OPT_LONG = "port";
     private static final String PORT_OPT_SHORT = "p";
-    private static final int defaultPort = 8080;
+    private static final int defaultPort = 7199;
     private static Options options = null;
     private CommandLine cmd = null;
     private NodeProbe probe;

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -49,7 +49,7 @@ public class NodeCmd {
     private static final String USERNAME_OPT_SHORT = "u";
     private static final String PASSWORD_OPT_LONG = "password";
     private static final String PASSWORD_OPT_SHORT = "pw";
-    private static final int defaultPort = 8080;
+    private static final int defaultPort = 7199;
     private static Options options = null;
     
     private NodeProbe probe;

File: src/java/org/apache/cassandra/tools/NodeProbe.java
Patch:
@@ -62,7 +62,7 @@ public class NodeProbe
 {
     private static final String fmtUrl = "service:jmx:rmi:///jndi/rmi://%s:%d/jmxrmi";
     private static final String ssObjName = "org.apache.cassandra.db:type=StorageService";
-    private static final int defaultPort = 8080;
+    private static final int defaultPort = 7199;
     final String host;
     final int port;
     private String username;

File: test/distributed/org/apache/cassandra/CassandraServiceController.java
Patch:
@@ -71,7 +71,7 @@ public class CassandraServiceController
         LoggerFactory.getLogger(CassandraServiceController.class);
 
     protected static int CLIENT_PORT    = 9160;
-    protected static int JMX_PORT       = 8080;
+    protected static int JMX_PORT       = 7199;
 
     private static final CassandraServiceController INSTANCE =
         new CassandraServiceController();

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -332,8 +332,8 @@ public void printColumnFamilyStats(PrintStream outs)
         {
             String tableName = entry.getKey();
             List<ColumnFamilyStoreMBean> columnFamilies = entry.getValue();
-            int tableReadCount = 0;
-            int tableWriteCount = 0;
+            long tableReadCount = 0;
+            long tableWriteCount = 0;
             int tablePendingTasks = 0;
             double tableTotalReadTime = 0.0f;
             double tableTotalWriteTime = 0.0f;

File: src/java/org/apache/cassandra/db/RowMutationVerbHandler.java
Patch:
@@ -90,7 +90,7 @@ public void doVerb(Message message)
     private void forwardToLocalNodes(Message message, byte[] forwardBytes) throws UnknownHostException
     {
         // remove fwds from message to avoid infinite loop
-        message.setHeader(RowMutation.FORWARD_HEADER, null);
+        message.removeHeader(RowMutation.FORWARD_HEADER);
 
         int bytesPerInetAddress = FBUtilities.getLocalAddress().getAddress().length;
         assert forwardBytes.length >= bytesPerInetAddress;
@@ -110,7 +110,7 @@ private void forwardToLocalNodes(Message message, byte[] forwardBytes) throws Un
 
             // Send the original message to the address specified by the FORWARD_HINT
             // Let the response go back to the coordinator
-            MessagingService.instance().sendOneWay(message, message.getFrom());
+            MessagingService.instance().sendOneWay(message, address);
 
             offset += bytesPerInetAddress;
         }

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -234,10 +234,9 @@ private static void sendMessages(String localDataCenter, Map<String, Multimap<Me
                 Message message = messages.getKey();
                 Iterator<InetAddress> iter = messages.getValue().iterator();
                 assert iter.hasNext();
-                
+
                 // First endpoint in list is the destination for this group
                 InetAddress target = iter.next();
-            
 
                 // Add all the other destinations that are bound for the same dataCenter as a header in the primary message.
                 while (iter.hasNext())
@@ -382,7 +381,7 @@ private static List<Row> fetchRows(List<ReadCommand> commands, ConsistencyLevel
             {
                 Message message = command.makeReadMessage();
                 if (logger.isDebugEnabled())
-                    logger.debug("reading digest for " + command + " from " + message.getMessageId() + "@" + dataPoint);
+                    logger.debug("reading data for " + command + " from " + message.getMessageId() + "@" + dataPoint);
                 MessagingService.instance().sendRR(message, dataPoint, handler);
             }
 

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -169,7 +169,7 @@ public Range getLocalPrimaryRange()
     /* This abstraction maintains the token/endpoint metadata information */
     private TokenMetadata tokenMetadata_ = new TokenMetadata();
 
-    private Set<InetAddress> replicatingNodes = new Collections.synchronizedSet(new HashSet<InetAddress>());
+    private Set<InetAddress> replicatingNodes = Collections.synchronizedSet(new HashSet<InetAddress>());
     private InetAddress removingNode;
 
     /* Are we starting this node in bootstrap mode? */

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -444,6 +444,8 @@ private void setMode(String m, boolean log)
         operationMode = m;
         if (log)
             logger_.info(m);
+        else
+            logger_.debug(m);
     }
 
     private void bootstrap(Token token) throws IOException

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -101,8 +101,9 @@ static URL getStorageConfigURL() throws ConfigurationException
         try
         {
             url = new URL(configUrl);
+            url.openStream(); // catches well-formed but bogus URLs
         }
-        catch (MalformedURLException e)
+        catch (Exception e)
         {
             ClassLoader loader = DatabaseDescriptor.class.getClassLoader();
             url = loader.getResource(configUrl);
@@ -373,6 +374,7 @@ else if (conf.memtable_flush_writers == null)
         }
         catch (UnknownHostException e)
         {
+            e.printStackTrace();
             logger.error("Fatal error: " + e.getMessage());
             System.err.println("Unable to start with unknown hosts configured.  Use IP addresses instead of hostnames.");
             System.exit(2);

File: contrib/bmt_example/CassandraBulkLoader.java
Patch:
@@ -62,6 +62,7 @@
 import com.google.common.base.Charsets;
 
 import org.apache.cassandra.config.CFMetaData;
+import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.Column;
 import org.apache.cassandra.db.ColumnFamily;
@@ -112,7 +113,7 @@ public void configure(JobConf job) {
             {
                 StorageService.instance.initClient();
             }
-            catch (IOException e)
+            catch (Exception e)
             {
                 throw new RuntimeException(e);
             }

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -43,6 +43,7 @@
 import org.apache.cassandra.io.DeletionService;
 import org.apache.cassandra.io.util.BufferedRandomAccessFile;
 import org.apache.cassandra.io.util.FileUtils;
+import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.WrappedRunnable;
 
@@ -298,7 +299,7 @@ public static void recover(File[] clogs) throws IOException
                     if (logger.isDebugEnabled())
                         logger.debug(String.format("replaying mutation for %s.%s: %s",
                                                     rm.getTable(),
-                                                    rm.key(),
+                                                    ByteBufferUtil.bytesToHex(rm.key()),
                                                     "{" + StringUtils.join(rm.getColumnFamilies(), ", ") + "}"));
                     final Table table = Table.open(rm.getTable());
                     tablesRecovered.add(table);

File: contrib/stress/src/org/apache/cassandra/contrib/stress/tests/IndexedRangeSlicer.java
Patch:
@@ -19,6 +19,7 @@
 
 import org.apache.cassandra.contrib.stress.util.OperationThread;
 import org.apache.cassandra.thrift.*;
+import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 
 import java.nio.ByteBuffer;
@@ -102,11 +103,11 @@ public void run()
     private int getMaxKey(List<KeySlice> keySlices)
     {
         byte[] firstKey = keySlices.get(0).getKey();
-        int maxKey = FBUtilities.byteBufferToInt(ByteBuffer.wrap(firstKey));
+        int maxKey = ByteBufferUtil.toInt(ByteBuffer.wrap(firstKey));
 
         for (KeySlice k : keySlices)
         {
-            int currentKey = FBUtilities.byteBufferToInt(ByteBuffer.wrap(k.getKey()));
+            int currentKey = ByteBufferUtil.toInt(ByteBuffer.wrap(k.getKey()));
 
             if (currentKey > maxKey)
             {

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -282,7 +282,7 @@ public boolean isInitialized()
         return initialized; 
     }
 
-    public synchronized void initClient() throws IOException
+    public synchronized void initClient() throws IOException, ConfigurationException
     {
         if (initialized)
         {

File: test/unit/org/apache/cassandra/locator/DynamicEndpointSnitchTest.java
Patch:
@@ -23,6 +23,7 @@
 import java.net.InetAddress;
 import java.util.ArrayList;
 
+import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.service.StorageService;
 import org.junit.Test;
 
@@ -31,7 +32,7 @@
 public class DynamicEndpointSnitchTest
 {
     @Test
-    public void testSnitch() throws InterruptedException, IOException
+    public void testSnitch() throws InterruptedException, IOException, ConfigurationException
     {
         // do this because SS needs to be initialized before DES can work properly.
         StorageService.instance.initClient();

File: test/unit/org/apache/cassandra/service/RemoveTest.java
Patch:
@@ -32,6 +32,7 @@
 import org.apache.cassandra.CleanupHelper;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.concurrent.Stage;
+import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.RandomPartitioner;
 import org.apache.cassandra.dht.Token;
@@ -58,7 +59,7 @@ public class RemoveTest extends CleanupHelper
     List<InetAddress> hosts;
 
     @Before
-    public void setup() throws IOException
+    public void setup() throws IOException, ConfigurationException
     {
         tmd.clearUnsafe();
         IPartitioner partitioner = new RandomPartitioner();

File: test/unit/org/apache/cassandra/service/StorageServiceClientTest.java
Patch:
@@ -20,6 +20,7 @@
 package org.apache.cassandra.service;
 
 import org.apache.cassandra.CleanupHelper;
+import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.junit.Test;
 import static org.junit.Assert.assertTrue;
@@ -31,7 +32,7 @@
 public class StorageServiceClientTest
 {
     @Test
-    public void testClientOnlyMode() throws IOException
+    public void testClientOnlyMode() throws IOException, ConfigurationException
     {
         CleanupHelper.mkdirs();
         CleanupHelper.cleanup();

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -877,6 +877,7 @@ public boolean isKeyInRemainingSSTables(DecoratedKey key, Set<SSTable> sstablesT
      */
     public void addSSTable(SSTableReader sstable)
     {
+        assert sstable.getColumnFamilyName().equals(columnFamily);
         ssTables.add(Arrays.asList(sstable));
         CompactionManager.instance.submitMinorIfNeeded(this);
     }

File: src/java/org/apache/cassandra/db/SystemTable.java
Patch:
@@ -307,7 +307,7 @@ public static boolean isBootstrapped()
         if (cf == null)
             return false;
         IColumn c = cf.getColumn(BOOTSTRAP);
-        return c.value().get(0) == 1;
+        return c.value().get(c.value().position()) == 1;
     }
 
     public static void setBootstrapped(boolean isBootstrapped)

File: src/java/org/apache/cassandra/io/sstable/SSTableReader.java
Patch:
@@ -295,9 +295,9 @@ private void load(boolean recreatebloom, Set<DecoratedKey> keysToLoadInCache) th
                     break;
 
                 boolean shouldAddEntry = indexSummary.shouldAddEntry();
-                ByteBuffer key = (ByteBuffer) ((shouldAddEntry || cacheLoading || recreatebloom)
+                ByteBuffer key = (shouldAddEntry || cacheLoading || recreatebloom)
                              ? ByteBufferUtil.readWithShortLength(input)
-                             : ByteBufferUtil.skipShortLength(input));
+                             : ByteBufferUtil.skipShortLength(input);
                 long dataPosition = input.readLong();
                 if (key != null)
                 {

File: src/java/org/apache/cassandra/utils/ByteBufferUtil.java
Patch:
@@ -305,7 +305,7 @@ public static ByteBuffer readWithShortLength(DataInput in) throws IOException
      * @return null
      * @throws IOException if an I/O error occurs.
      */
-    public static void skipShortLength(DataInput in) throws IOException
+    public static ByteBuffer skipShortLength(DataInput in) throws IOException
     {
         int skip = readShortLength(in);
         while (skip > 0)
@@ -314,6 +314,7 @@ public static void skipShortLength(DataInput in) throws IOException
             if (skipped == 0) throw new EOFException();
             skip -= skipped;
         }
+        return null;
     }
 
     private static ByteBuffer read(DataInput in, int length) throws IOException

File: src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
Patch:
@@ -195,7 +195,7 @@ private static void writeStatistics(Descriptor desc, EstimatedHistogram rowSizes
     {
         DataOutputStream out = new DataOutputStream(new FileOutputStream(desc.filenameFor(SSTable.COMPONENT_STATS)));
         EstimatedHistogram.serializer.serialize(rowSizes, out);
-        EstimatedHistogram.serializer.serialize(rowSizes, out);
+        EstimatedHistogram.serializer.serialize(columnnCounts, out);
         out.close();
     }
 

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -427,6 +427,7 @@ public static CFMetaData inflate(org.apache.cassandra.avro.CfDef cf)
         Integer memtable_flush_after_mins = cf.memtable_flush_after_mins == null ? DEFAULT_MEMTABLE_LIFETIME_IN_MINS : cf.memtable_flush_after_mins;
         Integer memtable_throughput_in_mb = cf.memtable_throughput_in_mb == null ? DEFAULT_MEMTABLE_THROUGHPUT_IN_MB : cf.memtable_throughput_in_mb;
         Double memtable_operations_in_millions = cf.memtable_operations_in_millions == null ? DEFAULT_MEMTABLE_OPERATIONS_IN_MILLIONS : cf.memtable_operations_in_millions;
+        Boolean replicate_on_write = cf.replicate_on_write == null ? Boolean.FALSE : cf.replicate_on_write;
 
         return new CFMetaData(cf.keyspace.toString(),
                               cf.name.toString(),
@@ -437,7 +438,7 @@ public static CFMetaData inflate(org.apache.cassandra.avro.CfDef cf)
                               cf.row_cache_size,
                               cf.key_cache_size,
                               cf.read_repair_chance,
-                              cf.replicate_on_write,
+                              replicate_on_write,
                               cf.gc_grace_seconds,
                               validator,
                               minct,

File: src/java/org/apache/cassandra/cql/QueryProcessor.java
Patch:
@@ -83,7 +83,7 @@ private static List<org.apache.cassandra.db.Row> getSlice(String keyspace, Selec
 
         try
         {
-            rows = StorageProxy.readProtocol(commands, select.getConsistencyLevel());
+            rows = StorageProxy.read(commands, select.getConsistencyLevel());
         }
         catch (TimeoutException e)
         {

File: src/java/org/apache/cassandra/db/DefsTable.java
Patch:
@@ -89,7 +89,7 @@ public static synchronized Collection<KSMetaData> loadFromStorage(UUID version)
             throw new RuntimeException("Cannot read system table! Are you upgrading a pre-release version?");
 
         ByteBuffer value = avroschema.value();
-        Schema schema = Schema.parse(ByteBufferUtil.string(value, value.position(), value.remaining()));
+        Schema schema = Schema.parse(ByteBufferUtil.string(value));
 
         // deserialize keyspaces using schema
         Collection<KSMetaData> keyspaces = new ArrayList<KSMetaData>();

File: src/java/org/apache/cassandra/db/HintedHandOffManager.java
Patch:
@@ -183,8 +183,8 @@ private static String[] getTableAndCFNames(ByteBuffer joined)
             throw new RuntimeException("Corrupted hint name " + ByteBufferUtil.string(joined));
 
         return new String[] {
-                                ByteBufferUtil.string(joined, joined.position(), index),
-                                ByteBufferUtil.string(joined, index + 1, joined.limit())
+                                ByteBufferUtil.string(joined, joined.position(), index - joined.position()),
+                                ByteBufferUtil.string(joined, index + 1, joined.limit() - (index + 1))
                             };
     }
             

File: src/java/org/apache/cassandra/dht/RandomPartitioner.java
Patch:
@@ -61,7 +61,7 @@ public DecoratedKey<BigIntegerToken> convertFromDiskFormat(ByteBuffer fromdisk)
         assert splitPoint != -1;
 
         // and decode the token and key
-        String token = ByteBufferUtil.string(fromdisk, fromdisk.position(), splitPoint, UTF_8);
+        String token = ByteBufferUtil.string(fromdisk, fromdisk.position(), splitPoint - fromdisk.position(), UTF_8);
         ByteBuffer key = fromdisk.duplicate();
         key.position(splitPoint + 1);
         return new DecoratedKey<BigIntegerToken>(new BigIntegerToken(token), key);

File: src/java/org/apache/cassandra/utils/ByteBufferUtil.java
Patch:
@@ -110,7 +110,7 @@ public static String string(ByteBuffer buffer, int offset, int length)
     public static String string(ByteBuffer buffer, int offset, int length, Charset charset)
     {
         if (buffer.hasArray())
-            return new String(buffer.array(), buffer.arrayOffset() + offset, length + buffer.arrayOffset(), charset);
+            return new String(buffer.array(), buffer.arrayOffset() + offset, length, charset);
 
         byte[] buff = getArray(buffer, offset, length);
         return new String(buff, charset);

File: contrib/word_count/src/WordCount.java
Patch:
@@ -134,8 +134,7 @@ public void reduce(Text word, Iterable<IntWritable> values, Context context) thr
         private static Mutation getMutation(Text word, int sum)
         {
             Column c = new Column();
-            byte[] wordBytes = word.getBytes();
-            c.name = ByteBuffer.wrap(Arrays.copyOf(wordBytes, wordBytes.length));
+            c.name = ByteBuffer.wrap(Arrays.copyOf(word.getBytes(), word.getLength()));
             c.value = ByteBuffer.wrap(String.valueOf(sum).getBytes());
             c.timestamp = System.currentTimeMillis() * 1000;
 

File: src/java/org/apache/cassandra/db/ColumnSerializer.java
Patch:
@@ -84,7 +84,7 @@ public Column deserialize(DataInput dis) throws IOException
         {
             long timestampOfLastDelete = dis.readLong();
             ByteBuffer pc = FBUtilities.readShortByteArray(dis);
-            byte[] partitionedCounter = Arrays.copyOfRange(pc.array(), pc.position() + pc.arrayOffset(), pc.limit());
+            byte[] partitionedCounter = ByteBufferUtil.getArray(pc);
             long timestamp = dis.readLong();
             ByteBuffer value = FBUtilities.readByteArray(dis);
             return new CounterColumn(name, value, timestamp, partitionedCounter, timestampOfLastDelete);

File: src/java/org/apache/cassandra/db/CounterColumn.java
Patch:
@@ -110,8 +110,8 @@ public IColumn diff(IColumn column)
     @Override
     public void updateDigest(MessageDigest digest)
     {
-        digest.update(name.array(),name.position()+name.arrayOffset(),name.remaining());
-        digest.update(value.array(),value.position()+name.arrayOffset(),value.remaining());
+        digest.update(name.duplicate());
+        digest.update(value.duplicate());
         digest.update(FBUtilities.toByteArray(timestamp));
         digest.update(partitionedCounter);
         digest.update(FBUtilities.toByteArray(timestampOfLastDelete));

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -242,7 +242,7 @@ private static void sendMessages(String localDataCenter, Map<String, Multimap<Me
                     {
                         // direct write to local DC
                         assert message.getHeader(RowMutation.FORWARD_HEADER) == null;
-                        MessagingService.instance().sendOneWay(message, target);
+                        MessagingService.instance().sendOneWay(message, destination);
                     }
                     else
                     {

File: src/java/org/apache/cassandra/config/KSMetaData.java
Patch:
@@ -28,7 +28,7 @@
 import org.apache.avro.util.Utf8;
 import org.apache.cassandra.io.SerDeUtils;
 import org.apache.cassandra.locator.AbstractReplicationStrategy;
-import org.apache.cassandra.locator.SimpleStrategy;
+import org.apache.cassandra.locator.NetworkTopologyStrategy;
 
 public final class KSMetaData
 {
@@ -41,7 +41,7 @@ public final class KSMetaData
     public KSMetaData(String name, Class<? extends AbstractReplicationStrategy> strategyClass, Map<String, String> strategyOptions, int replicationFactor, CFMetaData... cfDefs)
     {
         this.name = name;
-        this.strategyClass = strategyClass == null ? SimpleStrategy.class : strategyClass;
+        this.strategyClass = strategyClass == null ? NetworkTopologyStrategy.class : strategyClass;
         this.strategyOptions = strategyOptions;
         this.replicationFactor = replicationFactor;
         Map<String, CFMetaData> cfmap = new HashMap<String, CFMetaData>();

File: src/java/org/apache/cassandra/config/KSMetaData.java
Patch:
@@ -28,7 +28,7 @@
 import org.apache.avro.util.Utf8;
 import org.apache.cassandra.io.SerDeUtils;
 import org.apache.cassandra.locator.AbstractReplicationStrategy;
-import org.apache.cassandra.locator.SimpleStrategy;
+import org.apache.cassandra.locator.NetworkTopologyStrategy;
 
 public final class KSMetaData
 {
@@ -41,7 +41,7 @@ public final class KSMetaData
     public KSMetaData(String name, Class<? extends AbstractReplicationStrategy> strategyClass, Map<String, String> strategyOptions, int replicationFactor, CFMetaData... cfDefs)
     {
         this.name = name;
-        this.strategyClass = strategyClass == null ? SimpleStrategy.class : strategyClass;
+        this.strategyClass = strategyClass == null ? NetworkTopologyStrategy.class : strategyClass;
         this.strategyOptions = strategyOptions;
         this.replicationFactor = replicationFactor;
         Map<String, CFMetaData> cfmap = new HashMap<String, CFMetaData>();

File: src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
Patch:
@@ -382,6 +382,7 @@ protected long doIndexing() throws IOException
 
                 rows++;
             }
+            writeStatistics(desc, rowSizes, columnCounts);
             return rows;
         }
     }
@@ -451,6 +452,7 @@ protected long doIndexing() throws IOException
 
                 dfile.sync();
             }
+            writeStatistics(desc, rowSizes, columnCounts);
 
             if (writeRowPosition != readRowPosition)
             {

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -628,11 +628,11 @@ public void apply(org.apache.cassandra.avro.CfDef cf_def) throws ConfigurationEx
         // validate
         if (!cf_def.id.equals(cfId))
             throw new ConfigurationException("ids do not match.");
-        if (!cf_def.keyspace.equals(tableName))
+        if (!cf_def.keyspace.toString().equals(tableName))
             throw new ConfigurationException("keyspaces do not match.");
-        if (!cf_def.name.equals(cfName))
+        if (!cf_def.name.toString().equals(cfName))
             throw new ConfigurationException("names do not match.");
-        if (!cf_def.column_type.equals(cfType.name()))
+        if (!cf_def.column_type.toString().equals(cfType.name()))
             throw new ConfigurationException("types do not match.");
         if (comparator != DatabaseDescriptor.getComparator(cf_def.comparator_type))
             throw new ConfigurationException("comparators do not match.");

File: src/java/org/apache/cassandra/db/CompactionManager.java
Patch:
@@ -798,6 +798,7 @@ public EchoedRow(SSTableIdentityIterator row)
 
         public void write(DataOutput out) throws IOException
         {
+            out.writeLong(row.dataSize);
             row.echoData(out);
         }
 

File: contrib/stress/src/org/apache/cassandra/contrib/stress/Session.java
Patch:
@@ -164,7 +164,7 @@ public Session(String[] arguments) throws IllegalArgumentException
                 columnFamilyType = ColumnFamilyType.valueOf(cmd.getOptionValue("y"));
 
             if (cmd.hasOption("k"))
-                ignoreErrors = Boolean.parseBoolean(cmd.getOptionValue("k"));
+                ignoreErrors = true;
 
             if (cmd.hasOption("i"))
                 progressInterval = Integer.parseInt(cmd.getOptionValue("i"));

File: contrib/stress/src/org/apache/cassandra/contrib/stress/util/OperationThread.java
Patch:
@@ -101,15 +101,15 @@ private byte[] generateRandomKey()
      */
     private byte[] generateGaussKey()
     {
-        String format = "%0" + session.getTotalKeysLength() + "f";
+        String format = "%0" + session.getTotalKeysLength() + "d";
 
         for (;;)
         {
             double token = nextGaussian(session.getMean(), session.getSigma());
 
             if (0 <= token && token < session.getNumKeys())
             {
-                return String.format(format, token).getBytes();
+                return String.format(format, (int) token).getBytes();
             }
         }
     }

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -50,7 +50,7 @@ public final class CFMetaData
     public final static double DEFAULT_ROW_CACHE_SIZE = 0.0;
     public final static double DEFAULT_KEY_CACHE_SIZE = 200000;
     public final static double DEFAULT_READ_REPAIR_CHANCE = 1.0;
-    public final static boolean DEFAULT_REPLICATE_ON_WRITE = true;
+    public final static boolean DEFAULT_REPLICATE_ON_WRITE = false;
     public final static int DEFAULT_ROW_CACHE_SAVE_PERIOD_IN_SECONDS = 0;
     public final static int DEFAULT_KEY_CACHE_SAVE_PERIOD_IN_SECONDS = 3600;
     public final static int DEFAULT_GC_GRACE_SECONDS = 864000;

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -376,7 +376,7 @@ private void executeGet(Tree statement)
         ByteBuffer key = getKeyAsBytes(columnFamily, columnFamilySpec.getChild(1));
         int columnSpecCnt = CliCompiler.numColumnSpecifiers(columnFamilySpec);
         CfDef cfDef = getCfDef(columnFamily);
-        boolean isSuper = cfDef.comparator_type.equals("Super");
+        boolean isSuper = cfDef.column_type.equals("Super");
         
         byte[] superColumnName = null;
         ByteBuffer columnName;

File: test/unit/org/apache/cassandra/cli/CliTest.java
Patch:
@@ -108,6 +108,9 @@ public class CliTest extends CleanupHelper
         "drop column family cF8;",
         "create keyspace TESTIN;",
         "drop keyspace tesTIN;",
+        "create column family myCF with column_type='Super' and comparator='UTF8Type' AND subcomparator='UTF8Type';",
+        "set myCF['key']['scName']['firstname'] = 'John';",
+        "get myCF['key']['scName']",
         "use TestKEYSpace;",
     };
     

File: src/java/org/apache/cassandra/concurrent/DebuggableThreadPoolExecutor.java
Patch:
@@ -28,7 +28,7 @@
 
 public class DebuggableThreadPoolExecutor extends ThreadPoolExecutor
 {
-    protected static Logger logger = LoggerFactory.getLogger(JMXEnabledThreadPoolExecutor.class);
+    protected static Logger logger = LoggerFactory.getLogger(DebuggableThreadPoolExecutor.class);
 
     public DebuggableThreadPoolExecutor(String threadPoolName, int priority)
     {

File: src/java/org/apache/cassandra/hadoop/ColumnFamilyInputFormat.java
Patch:
@@ -73,7 +73,7 @@
  */
 public class ColumnFamilyInputFormat extends InputFormat<ByteBuffer, SortedMap<ByteBuffer, IColumn>>
 {
-    private static final Logger logger = LoggerFactory.getLogger(StorageService.class);
+    private static final Logger logger = LoggerFactory.getLogger(ColumnFamilyInputFormat.class);
     
     private String keyspace;
     private String cfName;

File: src/java/org/apache/cassandra/service/RangeSliceVerbHandler.java
Patch:
@@ -32,7 +32,7 @@
 public class RangeSliceVerbHandler implements IVerbHandler
 {
 
-    private static final Logger logger = LoggerFactory.getLogger(IndexScanVerbHandler.class);
+    private static final Logger logger = LoggerFactory.getLogger(RangeSliceVerbHandler.class);
 
     public void doVerb(Message message)
     {

File: src/java/org/apache/cassandra/service/MigrationManager.java
Patch:
@@ -108,7 +108,8 @@ public static void announce(UUID version, Set<InetAddress> hosts)
         for (InetAddress host : hosts)
             MessagingService.instance.sendOneWay(msg, host);
         // this is for notifying nodes as they arrive in the cluster.
-        Gossiper.instance.addLocalApplicationState(ApplicationState.SCHEMA, StorageService.valueFactory.migration(version));
+        if (!StorageService.instance.isClientMode())
+            Gossiper.instance.addLocalApplicationState(ApplicationState.SCHEMA, StorageService.valueFactory.migration(version));
     }
 
     /**

File: src/java/org/apache/cassandra/cli/CliUserHelp.java
Patch:
@@ -181,8 +181,8 @@ protected void printCmdHelp(Tree statement, CliSessionState state)
                 state.out.println("create column family Bar with column_type = 'Super' and comparator = 'AsciiType'");
                 state.out.println("      and rows_cached = 10000;");
                 state.out.println("create column family Baz with comparator = 'LongType' and rows_cached = 10000;");
-                state.out.print("create column family Foo with comparator=LongType and column_metadata=");
-                state.out.print("[{ column_name:Test, validation_class:IntegerType, index_type:0, index_name:IdxName");
+                state.out.print("create column family Foo with comparator=UTF8Type and column_metadata=");
+                state.out.print("[{ column_name:test, validation_class:IntegerType, index_type:0, index_name:TextIdx");
                 state.out.println("}, { column_name:'other name', validation_class:LongType }];");
                 break;
 

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -369,7 +369,7 @@ private static List<Row> strongRead(List<ReadCommand> commands, ConsistencyLevel
             catch (DigestMismatchException ex)
             {
                 AbstractReplicationStrategy rs = Table.open(command.table).getReplicationStrategy();
-                QuorumResponseHandler<Row> handler = rs.getQuorumResponseHandler(new ReadResponseResolver(command.table), ConsistencyLevel.QUORUM);
+                QuorumResponseHandler<Row> handler = rs.getQuorumResponseHandler(new ReadResponseResolver(command.table), consistency_level);
                 if (logger.isDebugEnabled())
                     logger.debug("Digest mismatch:", ex);
                 Message messageRepair = command.makeReadMessage();

File: test/unit/org/apache/cassandra/cli/CliTest.java
Patch:
@@ -36,7 +36,7 @@ public class CliTest extends CleanupHelper
     // please add new statements here so they could be auto-runned by this test.
     private String[] statements = {
         "use TestKeySpace;",
-        "create column family CF1 with comparator=UTF8Type and column_metadata=[{ column_name:world, validation_class:IntegerType, index_type:0, index_name:IdxName }, { column_name:world2, validation_class:LongType, index_type:0, index_name:LongIdxName}];",
+        "create column family CF1 with comparator=UTF8Type and column_metadata=[{ column_name:world, validation_class:IntegerType, index_type:0, index_name:IdxName }, { column_name:world2, validation_class:LongType, index_type:KEYS, index_name:LongIdxName}];",
         "set CF1[hello][world] = 123848374878933948398384;",
         "get CF1[hello][world];",
         "set CF1[hello][world2] = 15;",

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -468,7 +468,7 @@ private void executeGetWithConditions(Tree statement)
             return;
 
         IndexClause clause = new IndexClause();
-        String columnFamily = statement.getChild(0).getText();
+        String columnFamily = CliCompiler.getColumnFamily(statement, keyspacesMap.get(keySpace).cf_defs);
         // ^(CONDITIONS ^(CONDITION $column $value) ...)
         Tree conditions = statement.getChild(1);
         

File: test/unit/org/apache/cassandra/cli/CliTest.java
Patch:
@@ -41,6 +41,8 @@ public class CliTest extends CleanupHelper
         "get CF1[hello][world];",
         "set CF1[hello][world2] = 15;",
         "get CF1 where world2 = long(15);",
+        "get cF1 where world2 = long(15);",
+        "get Cf1 where world2 = long(15);",
         "set CF1['hello'][time_spent_uuid] = timeuuid(a8098c1a-f86e-11da-bd1a-00112444be1e);",
         "create column family CF2 with comparator=IntegerType;",
         "set CF2['key'][98349387493847748398334] = 'some text';",

File: src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
Patch:
@@ -125,10 +125,9 @@ public IWriteResponseHandler getWriteResponseHandler(Collection<InetAddress> wri
         return WriteResponseHandler.create(writeEndpoints, hintedEndpoints, consistencyLevel, table);
     }
 
-    // instance method so test subclasses can override it
-    int getReplicationFactor()
+    public int getReplicationFactor()
     {
-       return DatabaseDescriptor.getReplicationFactor(table);
+        return DatabaseDescriptor.getTableDefinition(table).replicationFactor;
     }
 
     /**

File: src/java/org/apache/cassandra/service/QuorumResponseHandler.java
Patch:
@@ -25,6 +25,7 @@
 import java.io.IOException;
 
 import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.db.Table;
 import org.apache.cassandra.net.IAsyncCallback;
 import org.apache.cassandra.net.Message;
 import org.apache.cassandra.net.MessagingService;
@@ -110,9 +111,9 @@ public int determineBlockFor(ConsistencyLevel consistencyLevel, String table)
             case ANY:
                 return 1;
             case QUORUM:
-                return (DatabaseDescriptor.getReplicationFactor(table) / 2) + 1;
+                return (Table.open(table).getReplicationStrategy().getReplicationFactor() / 2) + 1;
             case ALL:
-                return DatabaseDescriptor.getReplicationFactor(table);
+                return Table.open(table).getReplicationStrategy().getReplicationFactor();
             default:
                 throw new UnsupportedOperationException("invalid consistency level: " + table.toString());
         }

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1738,7 +1738,7 @@ public void removeToken(String tokenString)
         for (String table : DatabaseDescriptor.getNonSystemTables())
         {
             // if the replication factor is 1 the data is lost so we shouldn't wait for confirmation
-            if (DatabaseDescriptor.getReplicationFactor(table) == 1)
+            if (Table.open(table).getReplicationStrategy().getReplicationFactor() == 1)
                 continue;
 
             // get all ranges that change ownership (that is, a node needs

File: src/java/org/apache/cassandra/service/WriteResponseHandler.java
Patch:
@@ -26,6 +26,7 @@
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.Multimap;
 import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.db.Table;
 import org.apache.cassandra.net.Message;
 import org.apache.cassandra.thrift.ConsistencyLevel;
 import org.apache.cassandra.thrift.UnavailableException;
@@ -93,9 +94,9 @@ protected int determineBlockFor(String table)
         }
         // at most one node per range can bootstrap at a time, and these will be added to the write until
         // bootstrap finishes (at which point we no longer need to write to the old ones).
-        assert 1 <= blockFor && blockFor <= 2 * DatabaseDescriptor.getReplicationFactor(table)
+        assert 1 <= blockFor && blockFor <= 2 * Table.open(table).getReplicationStrategy().getReplicationFactor()
             : String.format("invalid response count %d for replication factor %d",
-                            blockFor, DatabaseDescriptor.getReplicationFactor(table));
+                            blockFor, Table.open(table).getReplicationStrategy().getReplicationFactor());
         return blockFor;
     }
 

File: test/unit/org/apache/cassandra/dht/BootStrapperTest.java
Patch:
@@ -33,6 +33,7 @@
 
 import com.google.common.collect.Multimap;
 
+import org.apache.cassandra.db.Table;
 import org.apache.cassandra.gms.ApplicationState;
 import org.apache.cassandra.gms.IFailureDetectionEventListener;
 import org.apache.cassandra.gms.IFailureDetector;
@@ -146,7 +147,7 @@ public void testSourceTargetComputation() throws UnknownHostException
         final int[] clusterSizes = new int[] { 1, 3, 5, 10, 100};
         for (String table : DatabaseDescriptor.getNonSystemTables())
         {
-            int replicationFactor = DatabaseDescriptor.getReplicationFactor(table);
+            int replicationFactor = Table.open(table).getReplicationStrategy().getReplicationFactor();
             for (int clusterSize : clusterSizes)
                 if (clusterSize >= replicationFactor)
                     testSourceTargetComputation(table, clusterSize, replicationFactor);

File: test/unit/org/apache/cassandra/locator/SimpleStrategyTest.java
Patch:
@@ -94,7 +94,7 @@ private void verifyGetNaturalEndpoints(Token[] endpointTokens, Token[] keyTokens
             for (int i = 0; i < keyTokens.length; i++)
             {
                 List<InetAddress> endpoints = strategy.getNaturalEndpoints(keyTokens[i]);
-                assertEquals(DatabaseDescriptor.getReplicationFactor(table), endpoints.size());
+                assertEquals(strategy.getReplicationFactor(), endpoints.size());
                 List<InetAddress> correctEndpoints = new ArrayList<InetAddress>();
                 for (int j = 0; j < endpoints.size(); j++)
                     correctEndpoints.add(hosts.get((i + j + 1) % hosts.size()));
@@ -140,7 +140,7 @@ public void testGetEndpointsDuringBootstrap() throws UnknownHostException, Confi
 
             StorageService.calculatePendingRanges(strategy, table);
 
-            int replicationFactor = DatabaseDescriptor.getReplicationFactor(table);
+            int replicationFactor = strategy.getReplicationFactor();
 
             for (int i = 0; i < keyTokens.length; i++)
             {

File: test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java
Patch:
@@ -171,7 +171,7 @@ public void testManualRepair() throws Throwable
     public void testGetNeighborsPlusOne() throws Throwable
     {
         // generate rf+1 nodes, and ensure that all nodes are returned
-        Set<InetAddress> expected = addTokens(1 + DatabaseDescriptor.getReplicationFactor(tablename));
+        Set<InetAddress> expected = addTokens(1 + Table.open(tablename).getReplicationStrategy().getReplicationFactor());
         expected.remove(FBUtilities.getLocalAddress());
         assertEquals(expected, AntiEntropyService.getNeighbors(tablename));
     }
@@ -182,7 +182,7 @@ public void testGetNeighborsTimesTwo() throws Throwable
         TokenMetadata tmd = StorageService.instance.getTokenMetadata();
 
         // generate rf*2 nodes, and ensure that only neighbors specified by the ARS are returned
-        addTokens(2 * DatabaseDescriptor.getReplicationFactor(tablename));
+        addTokens(2 * Table.open(tablename).getReplicationStrategy().getReplicationFactor());
         AbstractReplicationStrategy ars = Table.open(tablename).getReplicationStrategy();
         Set<InetAddress> expected = new HashSet<InetAddress>();
         for (Range replicaRange : ars.getAddressRanges().get(FBUtilities.getLocalAddress()))

File: test/unit/org/apache/cassandra/service/MoveTest.java
Patch:
@@ -92,7 +92,7 @@ public void newTestWriteEndpointsDuringLeave() throws Exception
             strategy = getStrategy(table, tmd);
             for (Token token : keyTokens)
             {
-                int replicationFactor = DatabaseDescriptor.getReplicationFactor(table);
+                int replicationFactor = strategy.getReplicationFactor();
 
                 HashSet<InetAddress> actual = new HashSet<InetAddress>(tmd.getWriteEndpoints(token, table, strategy.calculateNaturalEndpoints(token, tmd)));
                 HashSet<InetAddress> expected = new HashSet<InetAddress>();
@@ -217,7 +217,7 @@ public void testSimultaneousMove() throws UnknownHostException, ConfigurationExc
             }
 
             // just to be sure that things still work according to the old tests, run them:
-            if (DatabaseDescriptor.getReplicationFactor(table) != 3)
+            if (strategy.getReplicationFactor() != 3)
                 continue;
             // tokens 5, 15 and 25 should go three nodes
             for (int i=0; i<3; ++i)
@@ -334,7 +334,7 @@ public void testSimultaneousMove() throws UnknownHostException, ConfigurationExc
                 assertTrue(expectedEndpoints.get(table).get(keyTokens.get(i)).containsAll(endpoints));
             }
 
-            if (DatabaseDescriptor.getReplicationFactor(table) != 3)
+            if (strategy.getReplicationFactor() != 3)
                 continue;
             // leave this stuff in to guarantee the old tests work the way they were supposed to.
             // tokens 5, 15 and 25 should go three nodes

File: src/java/org/apache/cassandra/net/OutboundTcpConnection.java
Patch:
@@ -113,6 +113,7 @@ private void writeConnected(ByteBuffer bb)
         catch (IOException e)
         {
             logger.info("error writing to " + endpoint);
+            logger.debug("error was ", e);
             disconnect();
         }
     }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -594,7 +594,7 @@ public String getColumnFamilyName()
      */
     public String getFlushPath()
     {
-        long guessedSize = 2 * memsize.value() * 1024*1024; // 2* adds room for keys, column indexes
+        long guessedSize = 2L * memsize.value() * 1024*1024; // 2* adds room for keys, column indexes
         String location = DatabaseDescriptor.getDataFileLocationForTable(table.name, guessedSize);
         if (location == null)
             throw new RuntimeException("Insufficient disk space to flush");

File: src/java/org/apache/cassandra/db/Memtable.java
Patch:
@@ -296,6 +296,6 @@ void clearUnsafe()
 
     public boolean isExpired()
     {
-        return System.currentTimeMillis() > creationTime + cfs.getMemtableFlushAfterMins() * 60 * 1000;
+        return System.currentTimeMillis() > creationTime + cfs.getMemtableFlushAfterMins() * 60 * 1000L;
     }
 }

File: src/java/org/apache/cassandra/concurrent/StageManager.java
Patch:
@@ -47,7 +47,7 @@ public class StageManager
         // the rest are all single-threaded
         stages.put(Stage.STREAM, new JMXEnabledThreadPoolExecutor(Stage.STREAM));
         stages.put(Stage.GOSSIP, new JMXEnabledThreadPoolExecutor(Stage.GOSSIP));
-        stages.put(Stage.ANTIENTROPY, new JMXEnabledThreadPoolExecutor(Stage.ANTIENTROPY));
+        stages.put(Stage.ANTI_ENTROPY, new JMXEnabledThreadPoolExecutor(Stage.ANTI_ENTROPY));
         stages.put(Stage.MIGRATION, new JMXEnabledThreadPoolExecutor(Stage.MIGRATION));
         stages.put(Stage.MISC, new JMXEnabledThreadPoolExecutor(Stage.MISC));
     }

File: src/java/org/apache/cassandra/service/AntiEntropyService.java
Patch:
@@ -216,7 +216,7 @@ private void rendezvous(TreeRequest request, MerkleTree tree)
         for (Differencer differencer : differencers)
         {
             logger.info("Queueing comparison " + differencer);
-            StageManager.getStage(Stage.ANTIENTROPY).execute(differencer);
+            StageManager.getStage(Stage.ANTI_ENTROPY).execute(differencer);
         }
     }
 
@@ -406,7 +406,7 @@ public void complete()
                 for (MerkleTree.RowHash minrow : minrows)
                     range.addHash(minrow);
 
-            StageManager.getStage(Stage.ANTIENTROPY).submit(this);
+            StageManager.getStage(Stage.ANTI_ENTROPY).submit(this);
             logger.debug("Validated " + validated + " rows into AEService tree for " + request);
         }
         

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -181,8 +181,8 @@ public enum Verb
         put(Verb.STREAM_REQUEST, Stage.STREAM);
         put(Verb.RANGE_SLICE, Stage.READ);
         put(Verb.BOOTSTRAP_TOKEN, Stage.MISC);
-        put(Verb.TREE_REQUEST, Stage.ANTIENTROPY);
-        put(Verb.TREE_RESPONSE, Stage.ANTIENTROPY);
+        put(Verb.TREE_REQUEST, Stage.ANTI_ENTROPY);
+        put(Verb.TREE_RESPONSE, Stage.ANTI_ENTROPY);
         put(Verb.GOSSIP_DIGEST_ACK, Stage.GOSSIP);
         put(Verb.GOSSIP_DIGEST_ACK2, Stage.GOSSIP);
         put(Verb.GOSSIP_DIGEST_SYN, Stage.GOSSIP);

File: test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java
Patch:
@@ -19,7 +19,6 @@
 package org.apache.cassandra.service;
 
 import java.net.InetAddress;
-import java.nio.ByteBuffer;
 import java.util.*;
 import java.util.concurrent.Callable;
 import java.util.concurrent.TimeUnit;
@@ -47,7 +46,6 @@
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.MerkleTree;
 
-import static com.google.common.base.Charsets.UTF_8;
 import static org.apache.cassandra.service.AntiEntropyService.*;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
@@ -244,7 +242,7 @@ Set<InetAddress> addTokens(int max) throws Throwable
 
     void flushAES() throws Exception
     {
-        final ThreadPoolExecutor stage = StageManager.getStage(Stage.ANTIENTROPY);
+        final ThreadPoolExecutor stage = StageManager.getStage(Stage.ANTI_ENTROPY);
         final Callable noop = new Callable<Object>()
         {
             public Boolean call()

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -462,7 +462,10 @@ public static void scrubDataDirectories(String table, String columnFamily)
             Set<Component> components = sstableFiles.getValue();
 
             if (components.contains(Component.COMPACTED_MARKER) || desc.temporary)
+            {
                 SSTable.delete(desc, components);
+                continue;
+            }
 
             File dataFile = new File(desc.filenameFor(Component.DATA));
             if (components.contains(Component.DATA) && dataFile.length() > 0)

File: src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
Patch:
@@ -140,8 +140,6 @@ public Multimap<InetAddress, InetAddress> getHintedEndpoints(Collection<InetAddr
     {
         Multimap<InetAddress, InetAddress> map = HashMultimap.create(targets.size(), 1);
 
-        IEndpointSnitch endpointSnitch = DatabaseDescriptor.getEndpointSnitch();
-
         // first, add the live endpoints
         for (InetAddress ep : targets)
         {
@@ -168,7 +166,7 @@ public Multimap<InetAddress, InetAddress> getHintedEndpoints(Collection<InetAddr
 
             InetAddress destination = map.isEmpty()
                                     ? localAddress
-                                    : endpointSnitch.getSortedListByProximity(localAddress, map.keySet()).get(0);
+                                    : snitch.getSortedListByProximity(localAddress, map.keySet()).get(0);
             map.put(destination, ep);
         }
 

File: src/java/org/apache/cassandra/io/sstable/SSTableDeletingReference.java
Patch:
@@ -90,9 +90,9 @@ public void run()
                     return;
                 }
             }
-            // let the remainder be cleaned up by conditionalDelete
+            // let the remainder be cleaned up by delete
             components.remove(Component.DATA);
-            SSTable.conditionalDelete(desc, components);
+            SSTable.delete(desc, components);
             tracker.spaceReclaimed(size);
         }
     }

File: src/java/org/apache/cassandra/db/RowIteratorFactory.java
Patch:
@@ -107,7 +107,7 @@ public boolean apply(IColumnIterator row)
         // reduce rows from all sources into a single row
         ReducingIterator<IColumnIterator, Row> reduced = new ReducingIterator<IColumnIterator, Row>(collated)
         {
-            private final int gcBefore = (int) (System.currentTimeMillis() / 1000) - cfs.metadata.gcGraceSeconds;
+            private final int gcBefore = (int) (System.currentTimeMillis() / 1000) - cfs.metadata.getGcGraceSeconds();
             private final List<IColumnIterator> colIters = new ArrayList<IColumnIterator>();
             private DecoratedKey key;
 

File: src/java/org/apache/cassandra/db/RowMutation.java
Patch:
@@ -41,7 +41,6 @@
 import org.apache.cassandra.thrift.Deletion;
 import org.apache.cassandra.thrift.Mutation;
 import org.apache.cassandra.utils.FBUtilities;
-import org.apache.commons.lang.ArrayUtils;
 import org.apache.commons.lang.StringUtils;
 
 public class RowMutation
@@ -105,7 +104,7 @@ void addHints(RowMutation rm) throws IOException
         {
             ByteBuffer combined = HintedHandOffManager.makeCombinedName(rm.getTable(), cf.metadata().cfName);
             QueryPath path = new QueryPath(HintedHandOffManager.HINTS_CF, rm.key(), combined);
-            add(path, FBUtilities.EMPTY_BYTE_BUFFER, System.currentTimeMillis(), cf.metadata().gcGraceSeconds);
+            add(path, FBUtilities.EMPTY_BYTE_BUFFER, System.currentTimeMillis(), cf.metadata().getGcGraceSeconds());
         }
     }
 

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -464,7 +464,7 @@ private void discardCompletedSegmentsInternal(CommitLogSegment.CommitLogContext
             }
 
             header.turnOff(id);
-            if (header.isSafeToDelete())
+            if (header.isSafeToDelete() && iter.hasNext())
             {
                 logger.info("Discarding obsolete commit log:" + segment);
                 segment.close();

File: src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
Patch:
@@ -259,6 +259,8 @@ public Builder(Descriptor desc)
 
         public SSTableReader build() throws IOException
         {
+            if (cfs.isInvalid())
+                return null;
             File ifile = new File(desc.filenameFor(SSTable.COMPONENT_INDEX));
             File ffile = new File(desc.filenameFor(SSTable.COMPONENT_FILTER));
             assert !ifile.exists();

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -598,7 +598,7 @@ static List<AbstractBounds> getRestrictedRanges(final AbstractBounds queryRange)
     private static boolean randomlyReadRepair(ReadCommand command)
     {
         CFMetaData cfmd = DatabaseDescriptor.getTableMetaData(command.table).get(command.getColumnFamilyName());
-        return cfmd.readRepairChance > random.nextDouble();
+        return cfmd.getReadRepairChance() > random.nextDouble();
     }
 
     public long getReadOperations()

File: src/java/org/apache/cassandra/streaming/StreamInSession.java
Patch:
@@ -136,6 +136,8 @@ public void closeIfFinished() throws IOException
                 try
                 {
                     SSTableReader sstable = future.get();
+                    if (sstable == null)
+                        continue;
                     cfs.addSSTable(sstable);
                     sstables.add(sstable);
                 }

File: test/long/org/apache/cassandra/db/LongCompactionSpeedTest.java
Patch:
@@ -95,7 +95,7 @@ protected void testCompaction(int sstableCount, int rowsPerSSTable, int colsPerR
         Thread.sleep(1000);
 
         long start = System.currentTimeMillis();
-        CompactionManager.instance.doCompaction(store, sstables, (int) (System.currentTimeMillis() / 1000) - DatabaseDescriptor.getCFMetaData(TABLE1, "Standard1").gcGraceSeconds);
+        CompactionManager.instance.doCompaction(store, sstables, (int) (System.currentTimeMillis() / 1000) - DatabaseDescriptor.getCFMetaData(TABLE1, "Standard1").getGcGraceSeconds());
         System.out.println(String.format("%s: sstables=%d rowsper=%d colsper=%d: %d ms",
                                          this.getClass().getName(),
                                          sstableCount,

File: test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
Patch:
@@ -312,7 +312,7 @@ public void testIndexCreate() throws IOException, ConfigurationException, Interr
         rm.apply();
 
         ColumnFamilyStore cfs = table.getColumnFamilyStore("Indexed2");
-        ColumnDefinition old = cfs.metadata.column_metadata.get(ByteBufferUtil.bytes("birthdate"));
+        ColumnDefinition old = cfs.metadata.getColumn_metadata().get(ByteBufferUtil.bytes("birthdate"));
         ColumnDefinition cd = new ColumnDefinition(old.name, old.validator.getClass().getName(), IndexType.KEYS, "birthdate_index");
         cfs.addIndex(cd);
         while (!SystemTable.isIndexBuilt("Keyspace1", cfs.getIndexedColumnFamilyStore(ByteBufferUtil.bytes("birthdate")).columnFamily))

File: test/unit/org/apache/cassandra/io/sstable/SSTableWriterTest.java
Patch:
@@ -81,6 +81,7 @@ public void testRecoverAndOpen() throws IOException, ExecutionException, Interru
         FileUtils.deleteWithConfirm(orig.descriptor.filenameFor(Component.FILTER));
 
         SSTableReader sstr = CompactionManager.instance.submitSSTableBuild(orig.descriptor).get();
+        assert sstr != null;
         ColumnFamilyStore cfs = Table.open("Keyspace1").getColumnFamilyStore("Indexed1");
         cfs.addSSTable(sstr);
         cfs.buildSecondaryIndexes(cfs.getSSTables(), cfs.getIndexedColumns());

File: src/java/org/apache/cassandra/avro/CassandraServer.java
Patch:
@@ -700,8 +700,8 @@ public CharSequence system_update_column_family(CfDef cf_def) throws AvroRemoteE
         
         try
         {
-            CFMetaData newCfm = oldCfm.apply(cf_def);
-            UpdateColumnFamily update = new UpdateColumnFamily(oldCfm, newCfm);
+            oldCfm.apply(cf_def);
+            UpdateColumnFamily update = new UpdateColumnFamily(CFMetaData.convertToThrift(cf_def));
             applyMigrationOnStage(update);
             return DatabaseDescriptor.getDefsVersion().toString();
         }

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -968,7 +968,8 @@ public static KSMetaData getTableDefinition(String table)
     // process of mutating an individual keyspace, rather than setting manually here.
     public static void setTableDefinition(KSMetaData ksm, UUID newVersion)
     {
-        tables.put(ksm.name, ksm);
+        if (ksm != null)
+            tables.put(ksm.name, ksm);
         DatabaseDescriptor.defsVersion = newVersion;
     }
     

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1995,8 +1995,8 @@ public String exportSchema() throws IOException
                 for (ColumnDefinition cd : cfm.getColumn_metadata().values())
                 {
                     RawColumnDefinition rcd = new RawColumnDefinition();
-                    rcd.index_name = cd.index_name;
-                    rcd.index_type = cd.index_type;
+                    rcd.index_name = cd.getIndexName();
+                    rcd.index_type = cd.getIndexType();
                     rcd.name = ByteBufferUtil.string(cd.name, Charsets.UTF_8);
                     rcd.validator_class = cd.validator.getClass().getName();
                     rcf.column_metadata[j++] = rcd;

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -857,8 +857,8 @@ public String system_update_column_family(CfDef cf_def) throws InvalidRequestExc
         
         try
         {
-            CFMetaData newCfm = oldCfm.apply(cf_def);
-            UpdateColumnFamily update = new UpdateColumnFamily(oldCfm, newCfm);
+            // ideally, apply() would happen on the stage with the
+            UpdateColumnFamily update = new UpdateColumnFamily(cf_def);
             applyMigrationOnStage(update);
             return DatabaseDescriptor.getDefsVersion().toString();
         }

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -417,7 +417,7 @@ public synchronized void initServer() throws IOException, org.apache.cassandra.c
             {
                 isBootstrapMode = false;
                 SystemTable.setBootstrapped(true);
-                tokenMetadata_.updateNormalToken(token, FBUtilities.getLocalAddress());
+                setToken(token);
                 Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.normal(token));
                 setMode("Normal", false);
             }

File: test/unit/org/apache/cassandra/tools/SSTableImportTest.java
Patch:
@@ -26,6 +26,7 @@
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.ColumnFamily;
+import org.apache.cassandra.db.DeletedColumn;
 import org.apache.cassandra.db.IColumn;
 import org.apache.cassandra.db.filter.QueryFilter;
 import org.apache.cassandra.db.filter.QueryPath;
@@ -55,6 +56,7 @@ public void testImportSimpleCf() throws IOException, ParseException
         QueryFilter qf = QueryFilter.getNamesFilter(Util.dk("rowA"), new QueryPath("Standard1", null, null), ByteBufferUtil.bytes("colAA"));
         ColumnFamily cf = qf.getSSTableColumnIterator(reader).getColumnFamily();
         assert cf.getColumn(ByteBufferUtil.bytes("colAA")).value().equals(ByteBuffer.wrap(hexToBytes("76616c4141")));
+        assert !(cf.getColumn(ByteBufferUtil.bytes("colAA")) instanceof DeletedColumn);
     }
 
     @Test

File: src/java/org/apache/cassandra/db/DefinitionsUpdateResponseVerbHandler.java
Patch:
@@ -31,7 +31,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.io.ByteArrayInputStream;
 import java.io.IOError;
 import java.io.IOException;
 import java.util.Collection;
@@ -51,7 +50,7 @@ public void doVerb(final Message message)
             Collection<Column> cols = MigrationManager.makeColumns(message);
             for (Column col : cols)
             {
-                final UUID version = UUIDGen.makeType1UUID(col.name());
+                final UUID version = UUIDGen.getUUID(col.name());
                 if (version.timestamp() > DatabaseDescriptor.getDefsVersion().timestamp())
                 {
                     final Migration m = Migration.deserialize(col.value());

File: src/java/org/apache/cassandra/db/marshal/TimeUUIDType.java
Patch:
@@ -24,7 +24,7 @@
 import java.nio.ByteBuffer;
 import java.util.UUID;
 
-import org.apache.cassandra.utils.FBUtilities;
+import org.apache.cassandra.utils.UUIDGen;
 
 public class TimeUUIDType extends AbstractType
 {
@@ -80,7 +80,7 @@ public String getString(ByteBuffer bytes)
         {
             throw new MarshalException("UUIDs must be exactly 16 bytes");
         }
-        UUID uuid = LexicalUUIDType.getUUID(bytes);
+        UUID uuid = UUIDGen.getUUID(bytes);
         if (uuid.version() != 1)
         {
             throw new MarshalException("TimeUUID only makes sense with version 1 UUIDs");

File: src/java/org/apache/cassandra/db/migration/Migration.java
Patch:
@@ -179,7 +179,7 @@ public static UUID getLastMigrationId()
         if (cf == null || cf.getColumnNames().size() == 0)
             return null;
         else
-            return UUIDGen.makeType1UUID(cf.getColumn(LAST_MIGRATION_KEY).value());
+            return UUIDGen.getUUID(cf.getColumn(LAST_MIGRATION_KEY).value());
     }
     
     /** keep in mind that applyLive might happen on another machine */
@@ -277,8 +277,8 @@ public static Migration deserialize(ByteBuffer bytes) throws IOException
         }
         
         // super inflate
-        migration.lastVersion = UUIDGen.makeType1UUID(ByteBuffer.wrap(mi.old_version.bytes()));
-        migration.newVersion = UUIDGen.makeType1UUID(ByteBuffer.wrap(mi.new_version.bytes()));
+        migration.lastVersion = UUIDGen.getUUID(ByteBuffer.wrap(mi.old_version.bytes()));
+        migration.newVersion = UUIDGen.getUUID(ByteBuffer.wrap(mi.new_version.bytes()));
         try
         {
             migration.rm = RowMutation.serializer().deserialize(SerDeUtils.createDataInputStream(mi.row_mutation));

File: test/unit/org/apache/cassandra/db/DefsTest.java
Patch:
@@ -24,7 +24,6 @@
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
@@ -159,7 +158,7 @@ public void testMigrations() throws IOException, ConfigurationException
         int i = 0;
         for (IColumn col : serializedMigrations)
         {
-            UUID version = UUIDGen.makeType1UUID(col.name());
+            UUID version = UUIDGen.getUUID(col.name());
             reconstituded[i] = Migration.deserialize(col.value());
             assert version.equals(reconstituded[i].getVersion());
             i++;

File: test/unit/org/apache/cassandra/utils/UUIDTests.java
Patch:
@@ -55,7 +55,7 @@ public void testDecomposeAndRaw() throws UnknownHostException
     {
         UUID a = UUIDGen.makeType1UUIDFromHost(InetAddress.getByName("127.0.0.1"));
         byte[] decomposed = UUIDGen.decompose(a);
-        UUID b = UUIDGen.makeType1UUID(ByteBuffer.wrap(decomposed));
+        UUID b = UUIDGen.getUUID(ByteBuffer.wrap(decomposed));
         assert a.equals(b);
     }
 
@@ -67,7 +67,7 @@ public void testTimeUUIDType() throws UnknownHostException
         ByteBuffer second = ByteBuffer.wrap(UUIDGen.decompose(UUIDGen.makeType1UUIDFromHost(InetAddress.getByName("127.0.0.1"))));
         assert comp.compare(first, second) < 0;
         assert comp.compare(second, first) > 0;
-        ByteBuffer sameAsFirst = ByteBuffer.wrap(UUIDGen.decompose(UUIDGen.makeType1UUID(first)));
+        ByteBuffer sameAsFirst = ByteBuffer.wrap(UUIDGen.decompose(UUIDGen.getUUID(first)));
         assert comp.compare(first, sameAsFirst) == 0;
     }
 

File: test/unit/org/apache/cassandra/cli/CliTest.java
Patch:
@@ -125,7 +125,7 @@ public void testCli() throws IOException, TTransportException, ConfigurationExce
             CliMain.processStatement(statement);
             String result = outStream.toString();
             // System.out.println("Result:\n" + result);
-            assertEquals("", errStream.toString());
+            assertEquals(errStream.toString() + " processing " + statement, "", errStream.toString());
             if (statement.startsWith("drop ") || statement.startsWith("create ") || statement.startsWith("update "))
             {
                 assertTrue(result.matches("(.{8})-(.{4})-(.{4})-(.{4})-(.{12})\n"));

File: src/java/org/apache/cassandra/db/RowIteratorFactory.java
Patch:
@@ -135,7 +135,7 @@ protected Row getReduced()
                 if (cached != null)
                 {
                     QueryFilter keyFilter = new QueryFilter(key, filter.path, filter.filter);
-                    returnCF = cfs.filterColumnFamily(cached, keyFilter, cfs.metadata.gcGraceSeconds);
+                    returnCF = cfs.filterColumnFamily(cached, keyFilter, gcBefore);
                 }
                 else
                 {

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1450,6 +1450,8 @@ public InetAddress findSuitableEndpoint(String table, ByteBuffer key) throws IOE
     {
         List<InetAddress> endpoints = getNaturalEndpoints(table, key);
         DatabaseDescriptor.getEndpointSnitch().sortByProximity(FBUtilities.getLocalAddress(), endpoints);
+        if (logger_.isDebugEnabled())
+            logger_.debug("Sorted endpoints are " + StringUtils.join(endpoints, ","));
         for (InetAddress endpoint : endpoints)
         {
             if (FailureDetector.instance.isAlive(endpoint))

File: src/java/org/apache/cassandra/db/ReadVerbHandler.java
Patch:
@@ -93,7 +93,8 @@ public void doVerb(Message message)
 
             Message response = message.getReply(FBUtilities.getLocalAddress(), bytes);
             if (logger_.isDebugEnabled())
-              logger_.debug("Read key " + command.key + "; sending response to " + message.getMessageId() + "@" + message.getFrom());
+              logger_.debug(String.format("Read key %s; sending response to %s@%s",
+                                          FBUtilities.bytesToHex(command.key), message.getMessageId(), message.getFrom()));
             MessagingService.instance.sendOneWay(response, message.getFrom());
 
             /* Do read repair if header of the message says so */

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -507,7 +507,6 @@ private static List<Memtable> applyIndexUpdates(ByteBuffer key,
             {
                 cfi.addColumn(new Column(key, FBUtilities.EMPTY_BYTE_BUFFER, column.timestamp()));
             }
-            System.out.println(cfi.toString());
             if (logger.isDebugEnabled())
                 logger.debug("applying index row {}:{}", valueKey, cfi);
             Memtable fullMemtable = cfs.getIndexedColumnFamilyStore(columnName).apply(valueKey, cfi);

File: src/java/org/apache/cassandra/db/ColumnFamily.java
Patch:
@@ -355,7 +355,7 @@ public String toString()
     {
         StringBuilder sb = new StringBuilder("ColumnFamily(");
         CFMetaData cfm = metadata();
-        sb.append(cfm == null ? "-deleted-" : cfm.cfName);
+        sb.append(cfm == null ? "<anonymous>" : cfm.cfName);
 
         if (isMarkedForDelete())
             sb.append(" -deleted at " + getMarkedForDeleteAt() + "-");

File: src/java/org/apache/cassandra/db/marshal/LocalByPartionerType.java
Patch:
@@ -23,6 +23,7 @@
 
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.Token;
+import org.apache.cassandra.utils.FBUtilities;
 
 /** for sorting columns representing row keys in the row ordering as determined by a partitioner.
  * Not intended for user-defined CFs, and will in fact error out if used with such. */
@@ -37,7 +38,7 @@ public LocalByPartionerType(IPartitioner<T> partitioner)
 
     public String getString(ByteBuffer bytes)
     {
-        return null;
+        return FBUtilities.bytesToHex(bytes);
     }
 
     public int compare(ByteBuffer o1, ByteBuffer o2)

File: test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
Patch:
@@ -238,7 +238,8 @@ public void testIndexDeletions() throws IOException
 
         // verify that it's not being indexed under the deletion column value either
         IColumn deletion = rm.getColumnFamilies().iterator().next().iterator().next();
-        IndexExpression expr0 = new IndexExpression(ByteBufferUtil.bytes("birthdate"), IndexOperator.EQ, deletion.value());
+        ByteBuffer deletionLong = FBUtilities.toByteBuffer((long) FBUtilities.byteBufferToInt(deletion.value()));
+        IndexExpression expr0 = new IndexExpression(ByteBufferUtil.bytes("birthdate"), IndexOperator.EQ, deletionLong);
         IndexClause clause0 = new IndexClause(Arrays.asList(expr0), FBUtilities.EMPTY_BYTE_BUFFER, 100);
         rows = cfs.scan(clause0, range, filter);
         assert rows.isEmpty();

File: src/java/org/apache/cassandra/dht/Range.java
Patch:
@@ -195,6 +195,8 @@ private static Set<Range> intersectionOneWrapping(Range wrapping, Range other)
 
     public AbstractBounds createFrom(Token token)
     {
+        if (token.equals(left))
+            return null;
         return new Range(left, token);
     }
 

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -583,7 +583,8 @@ static List<AbstractBounds> getRestrictedRanges(final AbstractBounds queryRange)
                 // no more splits
                 break;
             Pair<AbstractBounds,AbstractBounds> splits = remainder.split(token);
-            ranges.add(splits.left);
+            if (splits.left != null)
+                ranges.add(splits.left);
             remainder = splits.right;
         }
         if (remainder != null)

File: test/unit/org/apache/cassandra/service/StorageProxyTest.java
Patch:
@@ -96,6 +96,8 @@ public void testGRRWrapped() throws Throwable
         // full wraps
         testGRR(range("0", "0"), range("0", "1"), range("1", "6"), range("6", ""), range("", "0"));
         testGRR(range("", ""), range("", "1"), range("1", "6"), range("6", ""));
+        // wrap on member token
+        testGRR(range("6", "6"), range("6", ""), range("", "1"), range("1", "6"));
         // end wrapped
         testGRR(range("5", ""), range("5", "6"), range("6", ""));
     }

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -156,7 +156,7 @@ public void executeCLIStatement(String statement)
                 case CliParser.NODE_SHOW_VERSION:
                     executeShowVersion();
                     break;
-                case CliParser.NODE_SHOW_TABLES:
+                case CliParser.NODE_SHOW_KEYSPACES:
                     executeShowKeySpaces();
                     break;
                 case CliParser.NODE_DESCRIBE_TABLE:

File: src/java/org/apache/cassandra/cli/CliUserHelp.java
Patch:
@@ -119,7 +119,7 @@ protected void printCmdHelp(Tree statement, CliSessionState state)
                 state.out.println("Displays the API version number.");
                 break;
 
-            case CliParser.NODE_SHOW_TABLES:
+            case CliParser.NODE_SHOW_KEYSPACES:
                 state.out.println("show keyspaces\n");
                 state.out.println("Displays a list of the keyspaces available on the currently connected cluster.");
                 break;

File: src/java/org/apache/cassandra/avro/AvroValidation.java
Patch:
@@ -68,7 +68,7 @@ static void validateKeyspace(String keyspace) throws KeyspaceNotDefinedException
     }
     
     // FIXME: could use method in ThriftValidation
-    static ColumnFamilyType validateColumnFamily(String keyspace, String columnFamily) throws InvalidRequestException
+    public static ColumnFamilyType validateColumnFamily(String keyspace, String columnFamily) throws InvalidRequestException
     {
         if (columnFamily.isEmpty())
             throw newInvalidRequestException("non-empty columnfamily is required");

File: src/java/org/apache/cassandra/cql/CQLStatement.java
Patch:
@@ -1,4 +1,3 @@
-package org.apache.cassandra.cql;
 /*
  * 
  * Licensed to the Apache Software Foundation (ASF) under one
@@ -19,7 +18,7 @@
  * under the License.
  * 
  */
-
+package org.apache.cassandra.cql;
 
 public class CQLStatement
 {

File: src/java/org/apache/cassandra/cql/StatementType.java
Patch:
@@ -1,4 +1,3 @@
-package org.apache.cassandra.cql;
 /*
  * 
  * Licensed to the Apache Software Foundation (ASF) under one
@@ -19,7 +18,7 @@
  * under the License.
  * 
  */
-
+package org.apache.cassandra.cql;
 
 public enum StatementType
 {

File: src/java/org/apache/cassandra/db/marshal/IntegerType.java
Patch:
@@ -21,6 +21,8 @@
 
 import java.nio.ByteBuffer;
 
+import org.apache.thrift.TBaseHelper;
+
 public final class IntegerType extends AbstractType
 {
     public static final IntegerType instance = new IntegerType();
@@ -118,6 +120,6 @@ public String getString(ByteBuffer bytes)
         if (bytes.remaining() == 0)
             return "empty";
 
-        return new java.math.BigInteger(bytes.array()).toString(10);
+        return new java.math.BigInteger(TBaseHelper.byteBufferToByteArray(bytes)).toString(10);
     }
 }

File: src/java/org/apache/cassandra/db/ExpiringColumn.java
Patch:
@@ -82,8 +82,8 @@ public int size()
     @Override
     public void updateDigest(MessageDigest digest)
     {
-        digest.update(name());
-        digest.update(value());
+        digest.update(name.array(), name.position()+name.arrayOffset(), name.remaining());
+        digest.update(value.array(), value.position()+value.arrayOffset(), value.remaining());
         DataOutputBuffer buffer = new DataOutputBuffer();
         try
         {

File: src/java/org/apache/cassandra/db/HintedHandOffManager.java
Patch:
@@ -175,9 +175,9 @@ public static ByteBuffer makeCombinedName(String tableName, String columnFamily)
     private static String[] getTableAndCFNames(ByteBuffer joined)
     {
         int index;
-        index = ArrayUtils.lastIndexOf(joined.array(), SEPARATOR.getBytes()[0],joined.position()+joined.arrayOffset());
-        if (index < 1)
-            throw new RuntimeException("Corrupted hint name " + joined.toString());
+        index = ArrayUtils.lastIndexOf(joined.array(), SEPARATOR.getBytes()[0],joined.limit()+joined.arrayOffset());
+        if (index == -1 || index < (joined.position() + joined.arrayOffset() + 1))
+            throw new RuntimeException("Corrupted hint name " + new String(joined.array(), joined.arrayOffset() + joined.position(), joined.remaining()));
         String[] parts = new String[2];
         parts[0] = new String(ArrayUtils.subarray(joined.array(), joined.position()+joined.arrayOffset(), index));
         parts[1] = new String(ArrayUtils.subarray(joined.array(), index+1, joined.limit()+joined.arrayOffset()));

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -1949,7 +1949,7 @@ private void printSliceList(CfDef columnFamilyDef, List<KeySlice> slices)
         for (KeySlice ks : slices)
         {
             css_.out.printf("-------------------\n");
-            css_.out.printf("RowKey: %s\n", new String(ks.key.array(),ks.key.position(),ks.key.remaining(), Charsets.UTF_8));
+            css_.out.printf("RowKey: %s\n", ByteBufferUtil.string(ks.key, Charsets.UTF_8));
 
             Iterator<ColumnOrSuperColumn> iterator = ks.getColumnsIterator();
 

File: src/java/org/apache/cassandra/db/ReadResponse.java
Patch:
@@ -88,7 +88,7 @@ class ReadResponseSerializer implements ICompactSerializer<ReadResponse>
 	public void serialize(ReadResponse rm, DataOutputStream dos) throws IOException
 	{
         dos.writeInt(rm.digest().remaining());
-        dos.write(rm.digest().array(),rm.digest().position()+rm.digest().arrayOffset(),rm.digest().remaining());
+        dos.write(rm.digest().array(), rm.digest().position() + rm.digest().arrayOffset(), rm.digest().remaining());
         dos.writeBoolean(rm.isDigestQuery());
         
         if( !rm.isDigestQuery() && rm.row() != null )

File: src/java/org/apache/cassandra/service/ReadResponseResolver.java
Patch:
@@ -202,7 +202,7 @@ public boolean isDataPresent(Collection<Message> responses)
             ReadResponse result = results.get(message);
             if (result == null)
                 continue; // arrived concurrently
-            if (result.isDigestQuery())
+            if (!result.isDigestQuery())
                 return true;
         }
         return false;

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -575,7 +575,7 @@ Future<?> maybeSwitchMemtable(Memtable oldMemtable, final boolean writeCommitLog
 
             assert memtable == oldMemtable;
             memtable.freeze();
-            final CommitLogSegment.CommitLogContext ctx = writeCommitLog ? CommitLog.instance().getContext() : null;
+            final CommitLogSegment.CommitLogContext ctx = writeCommitLog ? CommitLog.instance.getContext() : null;
             logger.info("switching in a fresh Memtable for " + columnFamily + " at " + ctx);
 
             // submit the memtable for any indexed sub-cfses, and our own.
@@ -605,7 +605,7 @@ public void runMayThrow() throws InterruptedException, IOException
                     {
                         // if we're not writing to the commit log, we are replaying the log, so marking
                         // the log header with "you can discard anything written before the context" is not valid
-                        CommitLog.instance().discardCompletedSegments(metadata.cfId, ctx);
+                        CommitLog.instance.discardCompletedSegments(metadata.cfId, ctx);
                     }
                 }
             });

File: src/java/org/apache/cassandra/db/commitlog/BatchCommitLogExecutorService.java
Patch:
@@ -95,7 +95,7 @@ private void processWithSyncBatch() throws Exception
         // now sync and set the tasks' values (which allows thread calling get() to proceed)
         try
         {
-            CommitLog.instance().sync();
+            CommitLog.instance.sync();
         }
         catch (IOException e)
         {

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -339,8 +339,6 @@ public synchronized void initServer() throws IOException, org.apache.cassandra.c
         initialized = true;
         isClientMode = false;
 
-        DatabaseDescriptor.createAllDirectories();
-
         try
         {
             GCInspector.instance.start();

File: test/unit/org/apache/cassandra/CleanupHelper.java
Patch:
@@ -24,6 +24,7 @@
 import org.junit.BeforeClass;
 
 import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.db.commitlog.CommitLog;
 import org.apache.cassandra.io.util.FileUtils;
 
 import org.slf4j.Logger;
@@ -39,6 +40,7 @@ public static void cleanupAndLeaveDirs() throws IOException
         mkdirs();
         cleanup();
         mkdirs();
+        CommitLog.instance.resetUnsafe(); // cleanup screws w/ CommitLog, this brings it back to safe state
     }
 
     public static void cleanup() throws IOException

File: test/unit/org/apache/cassandra/db/RecoveryManager2Test.java
Patch:
@@ -62,6 +62,7 @@ public void testWithFlush() throws Exception
 
         logger.debug("begin manual replay");
         // replay the commit log (nothing should be replayed since everything was flushed)
+        CommitLog.instance.resetUnsafe();
         CommitLog.recover();
 
         // since everything that was flushed was removed (i.e. clearUnsafe)

File: test/unit/org/apache/cassandra/db/RecoveryManager3Test.java
Patch:
@@ -31,6 +31,7 @@
 import org.apache.cassandra.Util;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.commitlog.CommitLog;
+import org.apache.cassandra.io.util.FileUtils;
 
 import static org.apache.cassandra.Util.column;
 import static org.apache.cassandra.db.TableTest.assertColumns;
@@ -66,10 +67,10 @@ public void testMissingHeader() throws IOException, ExecutionException, Interrup
         for (File file : new File(DatabaseDescriptor.getCommitLogLocation()).listFiles())
         {
             if (file.getName().endsWith(".header"))
-                if (!file.delete())
-                    throw new AssertionError();
+                FileUtils.deleteWithConfirm(file);
         }
 
+        CommitLog.instance.resetUnsafe(); // disassociate segments from live CL
         CommitLog.recover();
 
         assertColumns(Util.getColumnFamily(table1, dk, "Standard1"), "col1");

File: test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
Patch:
@@ -63,6 +63,7 @@ public void testOne() throws IOException, ExecutionException, InterruptedExcepti
         table1.getColumnFamilyStore("Standard1").clearUnsafe();
         table2.getColumnFamilyStore("Standard3").clearUnsafe();
 
+        CommitLog.instance.resetUnsafe(); // disassociate segments from live CL
         CommitLog.recover();
 
         assertColumns(Util.getColumnFamily(table1, dk, "Standard1"), "col1");

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -569,6 +569,9 @@ Future<?> maybeSwitchMemtable(Memtable oldMemtable, final boolean writeCommitLog
         {
             if (oldMemtable.isFrozen())
                 return null;
+            
+            if (DatabaseDescriptor.getCFMetaData(metadata.cfId) == null)
+                return null; // column family was dropped. no point in flushing.
 
             assert memtable == oldMemtable;
             memtable.freeze();

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -58,7 +58,7 @@ public class Table
 
     /**
      * accesses to CFS.memtable should acquire this for thread safety.
-     * only Table.maybeSwitchMemtable should aquire the writeLock; see that method for the full explanation.
+     * Table.maybeSwitchMemtable should aquire the writeLock; see that method for the full explanation.
      */
     static final ReentrantReadWriteLock flusherLock = new ReentrantReadWriteLock(true);
 

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -273,6 +273,7 @@ public void run()
         flushTask = StorageService.scheduledTasks.scheduleWithFixedDelay(runnable, minCheckMs, minCheckMs, TimeUnit.MILLISECONDS);
     }
     
+    // best invoked on the compaction mananger.
     public void dropCf(Integer cfId) throws IOException
     {
         assert columnFamilyStores.containsKey(cfId);

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1353,9 +1353,9 @@ public List<Row> scan(IndexClause clause, AbstractBounds range, IFilter dataFilt
                 if (rows.size() == clause.count)
                     break outer;
             }
-            startKey = dataKey;
-            if (n < clause.count)
+            if (n < clause.count || Arrays.equals(startKey, dataKey))
                 break;
+            startKey = dataKey;
         }
 
         return rows;

File: src/java/org/apache/cassandra/io/CompactionIterator.java
Patch:
@@ -163,6 +163,6 @@ public long getBytesRead()
 
     public String getTaskType()
     {
-        return "Compaction";
+        return major ? "Major" : "Minor";
     }
 }

File: src/java/org/apache/cassandra/avro/CassandraServer.java
Patch:
@@ -1027,7 +1027,7 @@ public Void truncate(CharSequence columnFamily) throws AvroRemoteException, Inva
 
         try
         {
-            state().hasColumnFamilyAccess((String)columnFamily, Permission.WRITE);
+            state().hasColumnFamilyAccess(columnFamily.toString(), Permission.WRITE);
             schedule();
             StorageProxy.truncateBlocking(state().getKeyspace(), columnFamily.toString());
         }

File: src/java/org/apache/cassandra/cli/CliCompiler.java
Patch:
@@ -77,9 +77,10 @@ public static CommonTree compileQuery(String query)
         }
         catch(Exception e)
         {
-            System.err.println("Exception " + e.getMessage());
-            e.printStackTrace(System.err);
+            // if there was an exception we don't want to process request any further
+            throw new RuntimeException(e.getMessage(), e);
         }
+        
         return queryTree;
     }
     /*

File: src/java/org/apache/cassandra/cli/CliMain.java
Patch:
@@ -241,7 +241,8 @@ private static void processCLIStmt(String query)
         }
         catch (Exception e)
         {
-            css_.err.println("Exception " + e.getMessage());
+            css_.err.println((e.getCause() == null) ? e.getMessage() : e.getCause().getMessage());
+            
             if (css_.debug)
                 e.printStackTrace(css_.err);
             
@@ -286,7 +287,7 @@ public static void main(String args[]) throws IOException
             }
             catch (IOException exp)
             {
-                css_.err.printf("Unable to open %s for writing%n", historyFile);
+                css_.err.printf("Unable to open %s for writing %n", historyFile);
             }
         }
         else

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -396,7 +396,7 @@ public synchronized void initServer() throws IOException
             if (DatabaseDescriptor.getNonSystemTables().size() > 0)
             {
                 bootstrap(token);
-                assert !isBootstrapMode; // bootstrap will block until finishec
+                assert !isBootstrapMode; // bootstrap will block until finished
             }
             else
             {

File: src/java/org/apache/cassandra/streaming/StreamOutSession.java
Patch:
@@ -172,7 +172,8 @@ public void begin()
         PendingFile first = files.isEmpty() ? null : files.values().iterator().next();
         currentFile = first == null ? null : first.getFilename();
         StreamHeader header = new StreamHeader(table, getSessionId(), first, files.values());
-        logger.info("Streaming files {} to {}", StringUtils.join(files.values(), ","), getHost());
+        logger.info("Streaming to {}", getHost());
+        logger.debug("Files are {}", StringUtils.join(files.values(), ","));
         MessagingService.instance.stream(header, getHost());
     }
 }

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -811,6 +811,7 @@ private void executeAddColumnFamily(CommonTree ast) throws TException, InvalidRe
 
             case GC_GRACE_SECONDS:
                 cfDef.setGc_grace_seconds(Integer.parseInt(mValue));
+                break;
 
             default:
                 //must match one of the above or we'd throw an exception at the valueOf statement above.

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -505,9 +505,8 @@ public static Collection<KSMetaData> readTablesFromYaml() throws ConfigurationEx
             {
                 throw new ConfigurationException("Missing replica_placement_strategy directive for " + keyspace.name);
             }
-            String strategyClassName = keyspace.replica_placement_strategy.replace("RackUnawareStrategy", "SimpleStrategy")
-                                                                          .replace("RackAwareStrategy", "OldNetworkTopologyStrategy");
-            Class<AbstractReplicationStrategy> strategyClass = FBUtilities.<AbstractReplicationStrategy>classForName(strategyClassName, "replication-strategy");
+            String strategyClassName = KSMetaData.convertOldStrategyName(keyspace.replica_placement_strategy);
+            Class<AbstractReplicationStrategy> strategyClass = FBUtilities.classForName(strategyClassName, "replication-strategy");
             
             /* Data replication factor */
             if (keyspace.replication_factor == null)

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -119,7 +119,7 @@ public enum Verb
         put(Verb.RANGE_SLICE, Stage.READ);
         put(Verb.BOOTSTRAP_TOKEN, Stage.MISC);
         put(Verb.TREE_REQUEST, Stage.AE_SERVICE);
-        put(Verb.TREE_RESPONSE, Stage.RESPONSE);
+        put(Verb.TREE_RESPONSE, Stage.AE_SERVICE);
         put(Verb.GOSSIP_DIGEST_ACK, Stage.GOSSIP);
         put(Verb.GOSSIP_DIGEST_ACK2, Stage.GOSSIP);
         put(Verb.GOSSIP_DIGEST_SYN, Stage.GOSSIP);

File: src/java/org/apache/cassandra/auth/SimpleAuthenticator.java
Patch:
@@ -29,6 +29,7 @@
 
 import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.thrift.AuthenticationException;
+import org.apache.cassandra.utils.FBUtilities;
 
 public class SimpleAuthenticator implements IAuthenticator
 {
@@ -106,7 +107,7 @@ public AuthenticatedUser authenticate(Map<? extends CharSequence,? extends CharS
                     authenticated = password.equals(props.getProperty(username));
                     break;
                 case MD5:
-                    authenticated = MessageDigest.isEqual(password.getBytes(), MessageDigest.getInstance("MD5").digest(props.getProperty(username).getBytes()));
+                    authenticated = MessageDigest.isEqual(MessageDigest.getInstance("MD5").digest(password.getBytes()), FBUtilities.hexToBytes(props.getProperty(username)));
                     break;
                 default:
                     throw new RuntimeException("Unknown PasswordMode " + mode);

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -431,7 +431,7 @@ private void startBootstrap(Token token) throws IOException
     {
         isBootstrapMode = true;
         SystemTable.updateToken(token); // DON'T use setToken, that makes us part of the ring locally which is incorrect until we are done bootstrapping
-        Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.normal(token));
+        Gossiper.instance.addLocalApplicationState(ApplicationState.STATUS, valueFactory.bootstrapping(token));
         setMode("Joining: sleeping " + RING_DELAY + " ms for pending range setup", true);
         try
         {

File: src/java/org/apache/cassandra/service/WriteResponseHandler.java
Patch:
@@ -101,7 +101,8 @@ protected int determineBlockFor(String table)
         // at most one node per range can bootstrap at a time, and these will be added to the write until
         // bootstrap finishes (at which point we no longer need to write to the old ones).
         assert 1 <= blockFor && blockFor <= 2 * DatabaseDescriptor.getReplicationFactor(table)
-            : "invalid response count " + blockFor;
+            : String.format("invalid response count %d for replication factor %d",
+                            blockFor, DatabaseDescriptor.getReplicationFactor(table));
         return blockFor;
     }
 

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -78,7 +78,7 @@ public class Config
     /* Size of the memtable in memory before it is dumped */
     public Integer memtable_throughput_in_mb = (int) (Runtime.getRuntime().maxMemory() / 1048576 / 8);
     /* Number of objects in millions in the memtable before it is dumped */
-    public Double memtable_operations_in_millions = memtable_throughput_in_mb / 64 * 0.3;
+    public Double memtable_operations_in_millions = memtable_throughput_in_mb / 64.0 * 0.3;
     
     /* if the size of columns or super-columns are more than this, indexing will kick in */
     public Integer column_index_size_in_kb = 64;

File: src/java/org/apache/cassandra/db/CompactionManager.java
Patch:
@@ -220,7 +220,7 @@ int doCompaction(ColumnFamilyStore cfs, Collection<SSTableReader> sstables, int
     {
         // The collection of sstables passed may be empty (but not null); even if
         // it is not empty, it may compact down to nothing if all rows are deleted.
-        Table table = cfs.getTable();
+        Table table = cfs.table;
         if (DatabaseDescriptor.isSnapshotBeforeCompaction())
             table.snapshot("compact-" + cfs.columnFamily);
         logger.info("Compacting [" + StringUtils.join(sstables, ",") + "]");
@@ -324,7 +324,7 @@ private static long getMaxDataAge(Collection<SSTableReader> sstables)
     private List<SSTableReader> doAntiCompaction(ColumnFamilyStore cfs, Collection<SSTableReader> sstables, Collection<Range> ranges, InetAddress target)
             throws IOException
     {
-        Table table = cfs.getTable();
+        Table table = cfs.table;
         logger.info("AntiCompacting [" + StringUtils.join(sstables, ",") + "]");
         // Calculate the expected compacted filesize
         long expectedRangeFileSize = cfs.getExpectedCompactedFileSize(sstables) / 2;
@@ -396,7 +396,7 @@ private List<SSTableReader> doAntiCompaction(ColumnFamilyStore cfs, Collection<S
     private void doCleanupCompaction(ColumnFamilyStore cfs) throws IOException
     {
         Collection<SSTableReader> originalSSTables = cfs.getSSTables();
-        List<SSTableReader> sstables = doAntiCompaction(cfs, originalSSTables, StorageService.instance.getLocalRanges(cfs.getTable().name), null);
+        List<SSTableReader> sstables = doAntiCompaction(cfs, originalSSTables, StorageService.instance.getLocalRanges(cfs.table.name), null);
         if (!sstables.isEmpty())
         {
             cfs.replaceCompactedSSTables(originalSSTables, sstables);

File: src/java/org/apache/cassandra/db/Memtable.java
Patch:
@@ -194,7 +194,7 @@ public boolean isClean()
 
     public String getTableName()
     {
-        return cfs.getTable().name;
+        return cfs.table.name;
     }
 
     /**

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -936,8 +936,8 @@ private CFMetaData convertToCFMetaData(CfDef cf_def) throws InvalidRequestExcept
                               cf_def.read_repair_chance,
                               cf_def.isSetGc_grace_seconds() ? cf_def.gc_grace_seconds : CFMetaData.DEFAULT_GC_GRACE_SECONDS,
                               DatabaseDescriptor.getComparator(cf_def.default_validation_class),
-                              cf_def.min_compaction_threshold,
-                              cf_def.max_compaction_threshold,
+                              cf_def.isSetMin_compaction_threshold() ? cf_def.min_compaction_threshold : CFMetaData.DEFAULT_MIN_COMPACTION_THRESHOLD,
+                              cf_def.isSetMax_compaction_threshold() ? cf_def.max_compaction_threshold : CFMetaData.DEFAULT_MAX_COMPACTION_THRESHOLD,
                               ColumnDefinition.fromColumnDef(cf_def.column_metadata));
     }
 

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -718,7 +718,7 @@ private void executeAddKeyspace(CommonTree ast) throws TException, InvalidReques
 
         //defaults
         String replicaPlacementStrategy = "org.apache.cassandra.locator.SimpleStrategy";
-        int replicationFactor = 2;
+        int replicationFactor = 1;
 
         /*
          * first value is the keyspace name, after that it is all key=value

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -450,7 +450,6 @@ public void runMayThrow() throws InterruptedException, IOException
                     {
                         // if we're not writing to the commit log, we are replaying the log, so marking
                         // the log header with "you can discard anything written before the context" is not valid
-                        logger.debug("Discarding {}", metadata.cfId);
                         CommitLog.instance().discardCompletedSegments(metadata.cfId, ctx);
                     }
                 }

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -302,7 +302,7 @@ public void runMayThrow() throws IOException
                                     // null means the cf has been dropped
                                     continue;
 
-                                if (finalHeader == null || (finalHeader.isDirty(columnFamily.id()) && entryLocation >= finalHeader.getPosition(columnFamily.id())))
+                                if (finalHeader == null || (finalHeader.isDirty(columnFamily.id()) && entryLocation > finalHeader.getPosition(columnFamily.id())))
                                     newRm.add(columnFamily);
                             }
                             if (!newRm.isEmpty())
@@ -338,7 +338,6 @@ public void runMayThrow() throws IOException
         for (Table table : tablesRecovered)
             futures.addAll(table.flush());
         FBUtilities.waitOnFutures(futures);
-        logger.info("Recovery complete");
     }
 
     private CommitLogSegment currentSegment()

File: interface/thrift/gen-java/org/apache/cassandra/thrift/Constants.java
Patch:
@@ -42,6 +42,6 @@
 
 public class Constants {
 
-  public static final String VERSION = "14.0.0";
+  public static final String VERSION = "15.0.0";
 
 }

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -944,7 +944,7 @@ private CFMetaData convertToCFMetaData(CfDef cf_def) throws InvalidRequestExcept
                               cfType,
                               clockType,
                               DatabaseDescriptor.getComparator(cf_def.comparator_type),
-                              cf_def.subcomparator_type.length() == 0 ? null : DatabaseDescriptor.getComparator(cf_def.subcomparator_type),
+                              cf_def.subcomparator_type == null ? null : DatabaseDescriptor.getComparator(cf_def.subcomparator_type),
                               reconciler,
                               cf_def.comment,
                               cf_def.row_cache_size,

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -134,6 +134,7 @@ public enum Verb
     {{
         put(Verb.MUTATION, Stage.MUTATION);
         put(Verb.BINARY, Stage.MUTATION);
+        put(Verb.READ_REPAIR, Stage.MUTATION);
         put(Verb.READ, Stage.READ);
         put(Verb.READ_RESPONSE, Stage.RESPONSE);
         put(Verb.STREAM_STATUS, Stage.MISC); // TODO does this really belong on misc? I've just copied old behavior here

File: src/java/org/apache/cassandra/service/QuorumResponseHandler.java
Patch:
@@ -109,7 +109,7 @@ public int determineBlockFor(ConsistencyLevel consistencyLevel, String table)
             case ANY:
                 return 1;
             case QUORUM:
-                return (DatabaseDescriptor.getQuorum(table)/ 2) + 1;
+                return (DatabaseDescriptor.getReplicationFactor(table) / 2) + 1;
             case ALL:
                 return DatabaseDescriptor.getReplicationFactor(table);
             default:

File: src/java/org/apache/cassandra/avro/CassandraServer.java
Patch:
@@ -41,6 +41,7 @@
 import org.apache.avro.ipc.AvroRemoteException;
 import org.apache.avro.util.Utf8;
 import org.apache.cassandra.avro.InvalidRequestException;
+import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.db.migration.DropKeyspace;
 import org.apache.cassandra.db.migration.RenameKeyspace;
 import org.apache.cassandra.db.migration.UpdateColumnFamily;
@@ -573,7 +574,7 @@ private static void deleteColumnOrSuperColumnToRowMutation(RowMutation rm, Strin
     // InvalidRequestException. atypical failures will throw a RuntimeException.
     private static void applyMigrationOnStage(final Migration m) throws InvalidRequestException
     {
-        Future f = StageManager.getStage(StageManager.MIGRATION_STAGE).submit(new Callable()
+        Future f = StageManager.getStage(Stage.MIGRATION).submit(new Callable()
         {
             public Object call() throws Exception
             {

File: src/java/org/apache/cassandra/db/DefinitionsUpdateResponseVerbHandler.java
Patch:
@@ -18,6 +18,7 @@
 
 package org.apache.cassandra.db;
 
+import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.concurrent.StageManager;
 import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
@@ -55,7 +56,7 @@ public void doVerb(final Message message)
                 {
                     final Migration m = Migration.deserialize(col.value());
                     assert m.getVersion().equals(version);
-                    StageManager.getStage(StageManager.MIGRATION_STAGE).submit(new WrappedRunnable()
+                    StageManager.getStage(Stage.MIGRATION).submit(new WrappedRunnable()
                     {
                         @Override
                         protected void runMayThrow() throws Exception

File: src/java/org/apache/cassandra/db/IndexScanCommand.java
Patch:
@@ -22,6 +22,7 @@
 import java.io.*;
 import java.util.Arrays;
 
+import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.concurrent.StageManager;
 import org.apache.cassandra.dht.AbstractBounds;
 import org.apache.cassandra.io.ICompactSerializer2;
@@ -67,7 +68,7 @@ public Message getMessage()
             throw new IOError(e);
         }
         return new Message(FBUtilities.getLocalAddress(),
-                           StageManager.READ_STAGE,
+                           Stage.READ,
                            StorageService.Verb.INDEX_SCAN,
                            Arrays.copyOf(dob.getData(), dob.getLength()));
     }

File: src/java/org/apache/cassandra/db/RangeSliceCommand.java
Patch:
@@ -36,6 +36,7 @@
 
 package org.apache.cassandra.db;
 
+import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.concurrent.StageManager;
 
 import org.apache.cassandra.dht.AbstractBounds;
@@ -90,7 +91,7 @@ public Message getMessage() throws IOException
         DataOutputBuffer dob = new DataOutputBuffer();
         serializer.serialize(this, dob);
         return new Message(FBUtilities.getLocalAddress(),
-                           StageManager.READ_STAGE,
+                           Stage.READ,
                            StorageService.Verb.RANGE_SLICE,
                            Arrays.copyOf(dob.getData(), dob.getLength()));
     }

File: src/java/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -25,6 +25,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
+import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.io.ICompactSerializer;
 import org.apache.cassandra.net.Message;
 import org.apache.cassandra.service.StorageService;
@@ -52,7 +53,7 @@ public Message makeReadMessage() throws IOException
         ByteArrayOutputStream bos = new ByteArrayOutputStream();
         DataOutputStream dos = new DataOutputStream(bos);
         ReadCommand.serializer().serialize(this, dos);
-        return new Message(FBUtilities.getLocalAddress(), StageManager.READ_STAGE, StorageService.Verb.READ, bos.toByteArray());
+        return new Message(FBUtilities.getLocalAddress(), Stage.READ, StorageService.Verb.READ, bos.toByteArray());
     }
 
     public final QueryPath queryPath;

File: src/java/org/apache/cassandra/db/RowMutation.java
Patch:
@@ -28,6 +28,7 @@
 import org.apache.commons.lang.ArrayUtils;
 import org.apache.commons.lang.StringUtils;
 
+import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.io.ICompactSerializer;
 import org.apache.cassandra.net.Message;
@@ -215,7 +216,7 @@ public Message makeRowMutationMessage(StorageService.Verb verb) throws IOExcepti
         ByteArrayOutputStream bos = new ByteArrayOutputStream();
         DataOutputStream dos = new DataOutputStream(bos);
         serializer().serialize(this, dos);
-        return new Message(FBUtilities.getLocalAddress(), StageManager.MUTATION_STAGE, verb, bos.toByteArray());
+        return new Message(FBUtilities.getLocalAddress(), Stage.MUTATION, verb, bos.toByteArray());
     }
 
     public static RowMutation getRowMutationFromMutations(String keyspace, byte[] key, Map<String, List<Mutation>> cfmap)

File: src/java/org/apache/cassandra/db/RowMutationMessage.java
Patch:
@@ -25,6 +25,7 @@
 
 import javax.xml.bind.annotation.XmlElement;
 
+import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.io.ICompactSerializer;
 import org.apache.cassandra.net.Message;
 import org.apache.cassandra.service.StorageService;
@@ -51,7 +52,7 @@ public Message makeRowMutationMessage(StorageService.Verb verb) throws IOExcepti
         ByteArrayOutputStream bos = new ByteArrayOutputStream();
         DataOutputStream dos = new DataOutputStream( bos );
         RowMutationMessage.serializer().serialize(this, dos);
-        return new Message(FBUtilities.getLocalAddress(), StageManager.MUTATION_STAGE, verb, bos.toByteArray());
+        return new Message(FBUtilities.getLocalAddress(), Stage.MUTATION, verb, bos.toByteArray());
     }
     
     @XmlElement(name="RowMutation")

File: src/java/org/apache/cassandra/db/Truncation.java
Patch:
@@ -23,6 +23,7 @@
 import java.io.DataOutputStream;
 import java.io.IOException;
 
+import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.concurrent.StageManager;
 import org.apache.cassandra.io.ICompactSerializer;
 import org.apache.cassandra.io.util.DataOutputBuffer;
@@ -73,7 +74,7 @@ public Message makeTruncationMessage() throws IOException
         ByteArrayOutputStream bos = new ByteArrayOutputStream();
         DataOutputStream dos = new DataOutputStream(bos);
         serializer().serialize(this, dos);
-        return new Message(FBUtilities.getLocalAddress(), StageManager.MUTATION_STAGE, StorageService.Verb.TRUNCATE,
+        return new Message(FBUtilities.getLocalAddress(), Stage.MUTATION, StorageService.Verb.TRUNCATE,
                 bos.toByteArray());
     }
 

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -18,6 +18,7 @@
 
 package org.apache.cassandra.db.commitlog;
 
+import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.concurrent.StageManager;
 import org.apache.cassandra.config.DatabaseDescriptor;
@@ -310,7 +311,7 @@ public void runMayThrow() throws IOException
                             }
                         }
                     };
-                    futures.add(StageManager.getStage(StageManager.MUTATION_STAGE).submit(runnable));
+                    futures.add(StageManager.getStage(Stage.MUTATION).submit(runnable));
                     if (futures.size() > MAX_OUTSTANDING_REPLAY_COUNT)
                     {
                         FBUtilities.waitOnFutures(futures);

File: src/java/org/apache/cassandra/dht/BootStrapper.java
Patch:
@@ -30,6 +30,7 @@
 
  import org.apache.commons.lang.ArrayUtils;
 
+ import org.apache.cassandra.concurrent.Stage;
  import org.apache.cassandra.locator.TokenMetadata;
  import org.apache.cassandra.locator.AbstractReplicationStrategy;
  import org.apache.cassandra.net.*;
@@ -171,7 +172,7 @@ Multimap<Range, InetAddress> getRangesWithSources(String table)
 
     static Token<?> getBootstrapTokenFrom(InetAddress maxEndpoint)
     {
-        Message message = new Message(FBUtilities.getLocalAddress(), "", StorageService.Verb.BOOTSTRAP_TOKEN, ArrayUtils.EMPTY_BYTE_ARRAY);
+        Message message = new Message(FBUtilities.getLocalAddress(), Stage.MISC, StorageService.Verb.BOOTSTRAP_TOKEN, ArrayUtils.EMPTY_BYTE_ARRAY);
         BootstrapTokenCallback btc = new BootstrapTokenCallback();
         MessagingService.instance.sendRR(message, maxEndpoint, btc);
         return btc.getToken();

File: src/java/org/apache/cassandra/service/ConsistencyChecker.java
Patch:
@@ -32,6 +32,7 @@
 
 import org.apache.commons.lang.StringUtils;
 
+import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.concurrent.StageManager;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.ColumnFamily;
@@ -164,7 +165,7 @@ public DataRepairHandler(Row localRow, int responseCount, IResponseResolver<Row>
             ReadResponse.serializer().serialize(readResponse, out);
             byte[] bytes = new byte[out.getLength()];
             System.arraycopy(out.getData(), 0, bytes, 0, bytes.length);
-            responses_.add(new Message(FBUtilities.getLocalAddress(), StageManager.RESPONSE_STAGE, StorageService.Verb.READ_RESPONSE, bytes));
+            responses_.add(new Message(FBUtilities.getLocalAddress(), Stage.RESPONSE, StorageService.Verb.READ_RESPONSE, bytes));
         }
 
         // synchronized so the " == majority" is safe

File: src/java/org/apache/cassandra/streaming/FileStatus.java
Patch:
@@ -26,6 +26,7 @@
 import java.io.DataOutputStream;
 import java.io.IOException;
 
+import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.io.ICompactSerializer;
 import org.apache.cassandra.net.Message;
 import org.apache.cassandra.service.StorageService;
@@ -94,7 +95,7 @@ public Message makeStreamStatusMessage() throws IOException
         ByteArrayOutputStream bos = new ByteArrayOutputStream();
         DataOutputStream dos = new DataOutputStream( bos );
         FileStatus.serializer().serialize(this, dos);
-        return new Message(FBUtilities.getLocalAddress(), "", StorageService.Verb.STREAM_STATUS, bos.toByteArray());
+        return new Message(FBUtilities.getLocalAddress(), Stage.MISC, StorageService.Verb.STREAM_STATUS, bos.toByteArray());
     }
 
     private static class FileStatusSerializer implements ICompactSerializer<FileStatus>

File: src/java/org/apache/cassandra/streaming/StreamRequestMessage.java
Patch:
@@ -27,6 +27,7 @@
 import java.util.Collection;
 import java.util.List;
 
+import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.concurrent.StageManager;
 import org.apache.cassandra.dht.AbstractBounds;
 import org.apache.cassandra.dht.Range;
@@ -96,7 +97,7 @@ Message makeMessage()
         {
             throw new IOError(e);
         }
-        return new Message(FBUtilities.getLocalAddress(), StageManager.STREAM_STAGE, StorageService.Verb.STREAM_REQUEST, bos.toByteArray() );
+        return new Message(FBUtilities.getLocalAddress(), Stage.STREAM, StorageService.Verb.STREAM_REQUEST, bos.toByteArray() );
     }
 
     public String toString()

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -25,6 +25,7 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeoutException;
 
+import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.db.migration.Migration;
 import org.apache.cassandra.db.migration.UpdateColumnFamily;
 import org.apache.cassandra.db.migration.UpdateKeyspace;
@@ -636,7 +637,7 @@ private void release()
     // InvalidRequestException. atypical failures will throw a RuntimeException.
     private static void applyMigrationOnStage(final Migration m) throws InvalidRequestException
     {
-        Future f = StageManager.getStage(StageManager.MIGRATION_STAGE).submit(new Callable()
+        Future f = StageManager.getStage(Stage.MIGRATION).submit(new Callable()
         {
             public Object call() throws Exception
             {

File: test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java
Patch:
@@ -31,6 +31,7 @@
 
 import org.apache.cassandra.CleanupHelper;
 import org.apache.cassandra.Util;
+import org.apache.cassandra.concurrent.Stage;
 import org.apache.cassandra.concurrent.StageManager;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.*;
@@ -240,7 +241,7 @@ Set<InetAddress> addTokens(int max) throws Throwable
 
     void flushAES() throws Exception
     {
-        final ThreadPoolExecutor stage = StageManager.getStage(StageManager.AE_SERVICE_STAGE);
+        final ThreadPoolExecutor stage = StageManager.getStage(Stage.AE_SERVICE);
         final Callable noop = new Callable<Object>()
         {
             public Boolean call()

File: src/java/org/apache/cassandra/tools/NodeCmd.java
Patch:
@@ -248,9 +248,9 @@ public void printColumnFamilyStats(PrintStream outs)
         // get a list of column family stores
         Iterator<Map.Entry<String, ColumnFamilyStoreMBean>> cfamilies = probe.getColumnFamilyStoreMBeanProxies();
 
-        for (;cfamilies.hasNext();)
+        while (cfamilies.hasNext())
         {
-            Map.Entry<String, ColumnFamilyStoreMBean> entry = cfamilies.next();
+            Entry<String, ColumnFamilyStoreMBean> entry = cfamilies.next();
             String tableName = entry.getKey();
             ColumnFamilyStoreMBean cfsProxy = entry.getValue();
 

File: src/java/org/apache/cassandra/tools/NodeProbe.java
Patch:
@@ -425,7 +425,7 @@ class ColumnFamilyStoreMBeanIterator implements Iterator<Map.Entry<String, Colum
     public ColumnFamilyStoreMBeanIterator(MBeanServerConnection mbeanServerConn)
     throws MalformedObjectNameException, NullPointerException, IOException
     {
-        ObjectName query = new ObjectName("org.apache.cassandra.db:type=ColumnFamilyStores,*");
+        ObjectName query = new ObjectName("org.apache.cassandra.db:type=ColumnFamilies,*");
         resIter = mbeanServerConn.queryNames(query, null).iterator();
         this.mbeanServerConn = mbeanServerConn;
     }

File: src/java/org/apache/cassandra/io/sstable/SSTable.java
Patch:
@@ -64,8 +64,8 @@ public abstract class SSTable
     public static final String TEMPFILE_MARKER = "tmp";
 
     public static List<String> components = Collections.unmodifiableList(Arrays.asList(COMPONENT_FILTER, COMPONENT_INDEX, COMPONENT_DATA));
-    protected EstimatedHistogram estimatedRowSize = new EstimatedHistogram(130);
-    protected EstimatedHistogram estimatedColumnCount = new EstimatedHistogram(112);
+    protected EstimatedHistogram estimatedRowSize = new EstimatedHistogram(150);
+    protected EstimatedHistogram estimatedColumnCount = new EstimatedHistogram(114);
 
     protected SSTable(String filename, CFMetaData metadata, IPartitioner partitioner)
     {

File: test/unit/org/apache/cassandra/utils/EstimatedHistogramTest.java
Patch:
@@ -33,8 +33,8 @@ public void testFindingCorrectBuckets()
         histogram.add(0L);
         assertEquals(1, histogram.get(false)[0]);
 
-        histogram.add(33282687);
-        assertEquals(1, histogram.get(false)[histogram.buckets.length()-1]);
+        histogram.add(23282687);
+        assertEquals(1, histogram.get(false)[histogram.buckets.length() - 2]);
 
         histogram.add(1);
         assertEquals(1, histogram.get(false)[1]);

File: interface/thrift/gen-java/org/apache/cassandra/thrift/Constants.java
Patch:
@@ -42,6 +42,6 @@
 
 public class Constants {
 
-  public static final String VERSION = "12.0.0";
+  public static final String VERSION = "12.1.0";
 
 }

File: src/java/org/apache/cassandra/config/RawColumnFamily.java
Patch:
@@ -44,5 +44,6 @@ public class RawColumnFamily
     public double read_repair_chance = CFMetaData.DEFAULT_READ_REPAIR_CHANCE;
     public boolean preload_row_cache = CFMetaData.DEFAULT_PRELOAD_ROW_CACHE;
     public int gc_grace_seconds = CFMetaData.DEFAULT_GC_GRACE_SECONDS;
+    public String default_validation_class;
     public RawColumnDefinition[] column_metadata = new RawColumnDefinition[0];
 }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -215,6 +215,7 @@ private ColumnFamilyStore(String table, String columnFamilyName, IPartitioner pa
                                                           0,
                                                           0,
                                                           CFMetaData.DEFAULT_GC_GRACE_SECONDS,
+                                                          BytesType.instance,
                                                           Collections.<byte[], ColumnDefinition>emptyMap());
             ColumnFamilyStore indexedCfs = ColumnFamilyStore.createColumnFamilyStore(table, 
                                                                                      indexedCfName,

File: src/java/org/apache/cassandra/thrift/CassandraServer.java
Patch:
@@ -968,6 +968,7 @@ private CFMetaData convertToCFMetaData(CfDef cf_def) throws InvalidRequestExcept
                               cf_def.key_cache_size,
                               cf_def.read_repair_chance,
                               cf_def.isSetGc_grace_seconds() ? cf_def.gc_grace_seconds : CFMetaData.DEFAULT_GC_GRACE_SECONDS,
+                              DatabaseDescriptor.getComparator(cf_def.default_validation_class),
                               ColumnDefinition.fromColumnDef(cf_def.column_metadata));
     }
 

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -66,6 +66,7 @@ public class Config
     public Integer thrift_max_message_length_in_mb = 16;
     public Integer thrift_framed_transport_size_in_mb = 15;
     public Boolean snapshot_before_compaction = false;
+    public Integer compaction_thread_priority = Thread.MIN_PRIORITY;
     
     public Integer binary_memtable_throughput_in_mb = 256;
     /* Number of minutes to keep a memtable in memory */

File: src/java/org/apache/cassandra/db/CompactionManager.java
Patch:
@@ -642,9 +642,7 @@ private static class CompactionExecutor extends DebuggableThreadPoolExecutor
 
         public CompactionExecutor()
         {
-            super("CompactionExecutor", System.getProperty("cassandra.compaction.priority") == null
-                                        ? Thread.NORM_PRIORITY
-                                        : Integer.parseInt(System.getProperty("cassandra.compaction.priority")));
+            super("CompactionExecutor", DatabaseDescriptor.getCompactionThreadPriority());
         }
 
         @Override

File: src/java/org/apache/cassandra/db/migration/AddColumnFamily.java
Patch:
@@ -83,6 +83,8 @@ public void applyModels() throws IOException
         }
         Table.open(cfm.tableName); // make sure it's init-ed w/ the old definitions first, since we're going to call initCf on the new one manually
         DatabaseDescriptor.setTableDefinition(ksm, newVersion);
+        // these definitions could have come from somewhere else.
+        CFMetaData.fixMaxId();
         if (!clientMode)
             Table.open(ksm.name).initCf(cfm.cfId, cfm.cfName);
 

File: src/java/org/apache/cassandra/io/sstable/SSTable.java
Patch:
@@ -133,7 +133,6 @@ public static boolean deleteIfCompacted(String dataFilename)
                 FileUtils.deleteWithConfirm(new File(SSTable.indexFilename(dataFilename)));
                 FileUtils.deleteWithConfirm(new File(SSTable.filterFilename(dataFilename)));
                 FileUtils.deleteWithConfirm(new File(SSTable.compactedFilename(dataFilename)));
-                StatisticsTable.deleteSSTableStatistics(dataFilename);
             }
             catch (IOException e)
             {

File: contrib/word_count/src/WordCount.java
Patch:
@@ -127,7 +127,8 @@ public int run(String[] args) throws Exception
             job.setInputFormatClass(ColumnFamilyInputFormat.class);
             FileOutputFormat.setOutputPath(job, new Path(OUTPUT_PATH_PREFIX + i));
 
-            ConfigHelper.setThriftContact(job.getConfiguration(), "localhost",  9160);
+            ConfigHelper.setRpcPort(job.getConfiguration(), "9160");
+            ConfigHelper.setInitialAddress(job.getConfiguration(), "localhost");
             ConfigHelper.setInputColumnFamily(job.getConfiguration(), KEYSPACE, COLUMN_FAMILY);
             SlicePredicate predicate = new SlicePredicate().setColumn_names(Arrays.asList(columnName.getBytes()));
             ConfigHelper.setInputSlicePredicate(job.getConfiguration(), predicate);

File: src/java/org/apache/cassandra/io/sstable/SSTableWriter.java
Patch:
@@ -57,7 +57,7 @@ public SSTableWriter(String filename, long keyCount, CFMetaData metadata, IParti
     {
         super(filename, metadata, partitioner);
         iwriter = new IndexWriter(desc, partitioner, keyCount);
-        dbuilder = SegmentedFile.getBuilder();
+        dbuilder = SegmentedFile.getBuilder(DatabaseDescriptor.getDiskAccessMode());
         dataFile = new BufferedRandomAccessFile(getFilename(), "rw", DatabaseDescriptor.getInMemoryCompactionLimit());
     }
 
@@ -344,7 +344,7 @@ static class IndexWriter
             this.desc = desc;
             this.partitioner = part;
             indexFile = new BufferedRandomAccessFile(desc.filenameFor(SSTable.COMPONENT_INDEX), "rw", 8 * 1024 * 1024);
-            builder = SegmentedFile.getBuilder();
+            builder = SegmentedFile.getBuilder(DatabaseDescriptor.getIndexAccessMode());
             summary = new IndexSummary();
             bf = BloomFilter.getFilter(keyCount, 15);
         }

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1767,6 +1767,7 @@ public String exportSchema() throws IOException
                 rcf.keys_cached = cfm.keyCacheSize;
                 rcf.preload_row_cache = cfm.preloadRowCache;
                 rcf.read_repair_chance = cfm.readRepairChance;
+                rcf.gc_grace_seconds = cfm.gcGraceSeconds;
                 rcf.reconciler = cfm.reconciler.getClass().getName();
                 rcf.rows_cached = cfm.rowCacheSize;
                 rcf.column_metadata = new RawColumnDefinition[cfm.column_metadata.size()];

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -143,6 +143,8 @@ public void executeCLIStmt(String stmt) throws TException, NotFoundException, In
                     break;
                 default:
                     css_.err.println("Invalid Statement (Type: " + ast.getType() + ")");
+                    if (css_.batch)
+                        System.exit(2);
                     break;
             }
         }

File: src/java/org/apache/cassandra/cli/CliSessionState.java
Patch:
@@ -33,7 +33,8 @@ public class CliSessionState
     public boolean debug = false; // print stack traces when errors occur in the CLI
     public String  username;      // cassandra login name (if SimpleAuthenticator is used)
     public String  password;      // cassandra login password (if SimpleAuthenticator is used)
-    public String  keyspace;      // cassandra keyspace user is authenticating 			
+    public String  keyspace;      // cassandra keyspace user is authenticating
+    public boolean batch = false; // enable/disable batch processing mode
     /*
      * Streams to read/write from
      */

File: src/java/org/apache/cassandra/cli/CliMain.java
Patch:
@@ -232,14 +232,13 @@ private static void processCLIStmt(String query)
         {
             css_.err.println(ire.why);
             if (css_.debug)
-                ire.printStackTrace();
+                ire.printStackTrace(css_.err);
         }
         catch (Exception e)
         {
             css_.err.println("Exception " + e.getMessage());
             if (css_.debug)
-                e.printStackTrace();
-
+                e.printStackTrace(css_.err);
         }
     }
 

File: test/unit/org/apache/cassandra/hadoop/ColumnFamilyOutputFormatTest.java
Patch:
@@ -127,7 +127,7 @@ private void setupCassandra() throws TException, InvalidRequestException
         /* Establish a thrift connection to the cassandra instance */
         TSocket socket = new TSocket(DatabaseDescriptor.getListenAddress().getHostName(), DatabaseDescriptor.getRpcPort());
         TTransport transport = new TFramedTransport(socket);
-        TBinaryProtocol binaryProtocol = new TBinaryProtocol(transport, false, false);
+        TBinaryProtocol binaryProtocol = new TBinaryProtocol(transport);
         Cassandra.Client cassandraClient = new Cassandra.Client(binaryProtocol);
         transport.open();
         thriftClient = cassandraClient;

File: src/java/org/apache/cassandra/thrift/CassandraDaemon.java
Patch:
@@ -153,7 +153,7 @@ public void uncaughtException(Thread t, Throwable e)
         logger.info(String.format("Binding thrift service to %s:%s", listenAddr, listenPort));
 
         // Protocol factory
-        TProtocolFactory tProtocolFactory = new TBinaryProtocol.Factory(false, 
+        TProtocolFactory tProtocolFactory = new TBinaryProtocol.Factory(true, 
                                                                         true, 
                                                                         DatabaseDescriptor.getThriftMaxMessageLength());
         

File: src/java/org/apache/cassandra/config/Config.java
Patch:
@@ -43,7 +43,9 @@ public class Config {
     
     public String rpc_address;
     public Integer rpc_port = 9160;
-    public Boolean thrift_framed_transport = false;
+
+    public Integer thrift_max_message_length_in_mb = 16;
+    public Integer thrift_framed_transport_size_in_mb = 15;
     public Boolean snapshot_before_compaction = false;
     
     public Integer binary_memtable_throughput_in_mb = 256;

File: src/java/org/apache/cassandra/config/Converter.java
Patch:
@@ -185,9 +185,10 @@ private static void loadPreviousConfig(String config) throws ConfigurationExcept
                 conf.rpc_port = Integer.parseInt(port);
             
             String framedRaw = xmlUtils.getNodeValue("/Storage/ThriftFramedTransport");
-            if (framedRaw != null)
+            if (framedRaw != null && Boolean.valueOf(framedRaw))
             {
-                conf.thrift_framed_transport = Boolean.valueOf(framedRaw);
+                conf.thrift_framed_transport_size_in_mb = 15;
+                System.out.println("TFramedTransport will have a maximum frame size of 15MB");
             }
             
             conf.endpoint_snitch = xmlUtils.getNodeValue("/Storage/EndpointSnitch");

File: interface/thrift/gen-java/org/apache/cassandra/thrift/Constants.java
Patch:
@@ -42,6 +42,6 @@
 
 public class Constants {
 
-  public static final String VERSION = "8.2.0";
+  public static final String VERSION = "8.3.0";
 
 }

File: src/java/org/apache/cassandra/config/CFMetaData.java
Patch:
@@ -316,7 +316,7 @@ public int hashCode()
             .toHashCode();
     }
 
-    private static int nextId() 
+    private static int nextId()
     {
         return idGen.getAndIncrement();
     }

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -110,7 +110,7 @@ static String getStorageConfigPath() throws ConfigurationException
             configFileName = getStorageConfigPath();
             
             if (logger.isDebugEnabled())
-                logger.debug("Loading settings from " + configFileName);
+                logger.info("Loading settings from " + configFileName);
             
             InputStream input = new FileInputStream(new File(configFileName));
             org.yaml.snakeyaml.constructor.Constructor constructor = new org.yaml.snakeyaml.constructor.Constructor(Config.class);

File: src/java/org/apache/cassandra/config/KSMetaData.java
Patch:
@@ -48,7 +48,7 @@ public KSMetaData(String name, Class<? extends AbstractReplicationStrategy> stra
         Map<String, CFMetaData> cfmap = new HashMap<String, CFMetaData>();
         for (CFMetaData cfm : cfDefs)
             cfmap.put(cfm.cfName, cfm);
-        this.cfMetaData = Collections.<String, CFMetaData>unmodifiableMap(cfmap);
+        this.cfMetaData = Collections.unmodifiableMap(cfmap);
     }
     
     public boolean equals(Object obj)

File: src/java/org/apache/cassandra/db/migration/AddColumnFamily.java
Patch:
@@ -92,10 +92,11 @@ public void applyModels() throws IOException
         {
             throw new IOException(ex);
         }
+        Table.open(cfm.tableName); // make sure it's init-ed w/ the old definitions first, since we're going to call initCf on the new one manually
+        DatabaseDescriptor.setTableDefinition(ksm, newVersion);
         if (!clientMode)
             Table.open(ksm.name).initCf(cfm.cfId, cfm.cfName);
-        DatabaseDescriptor.setTableDefinition(ksm, newVersion);
-        
+
         if (!clientMode)
             // force creation of a new commit log segment.
             CommitLog.instance().forceNewSegment();

File: src/java/org/apache/cassandra/service/RangeSliceVerbHandler.java
Patch:
@@ -32,7 +32,7 @@
 public class RangeSliceVerbHandler implements IVerbHandler
 {
 
-    private static final Logger logger = LoggerFactory.getLogger(RangeSliceVerbHandler.class);
+    private static final Logger logger = LoggerFactory.getLogger(IndexScanVerbHandler.class);
 
     public void doVerb(Message message)
     {

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -115,7 +115,7 @@ public enum Verb
         DEFINITIONS_UPDATE_RESPONSE,
         TRUNCATE,
         SCHEMA_CHECK,
-        ;
+        INDEX_SCAN;
         // remember to add new verbs at the end, since we serialize by ordinal
     }
     public static final Verb[] VERBS = Verb.values();
@@ -223,6 +223,7 @@ public StorageService()
         MessagingService.instance.registerVerbHandlers(Verb.READ_REPAIR, new ReadRepairVerbHandler());
         MessagingService.instance.registerVerbHandlers(Verb.READ, new ReadVerbHandler());
         MessagingService.instance.registerVerbHandlers(Verb.RANGE_SLICE, new RangeSliceVerbHandler());
+        MessagingService.instance.registerVerbHandlers(Verb.INDEX_SCAN, new IndexScanVerbHandler());
         // see BootStrapper for a summary of how the bootstrap verbs interact
         MessagingService.instance.registerVerbHandlers(Verb.BOOTSTRAP_TOKEN, new BootStrapper.BootstrapTokenVerbHandler());
         MessagingService.instance.registerVerbHandlers(Verb.STREAM_REQUEST, new StreamRequestVerbHandler() );

File: src/java/org/apache/cassandra/config/ColumnFamily.java
Patch:
@@ -18,5 +18,5 @@ public class ColumnFamily {
     public double keys_cached = CFMetaData.DEFAULT_KEY_CACHE_SIZE; 
     public double read_repair_chance = CFMetaData.DEFAULT_READ_REPAIR_CHANCE;
     public boolean preload_row_cache = CFMetaData.DEFAULT_PRELOAD_ROW_CACHE;
-    public Map<byte[], ColumnDefinition> column_metata = Collections.emptyMap();
+    public RawColumnDefinition[] column_metadata = new RawColumnDefinition[0];
 }

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -80,7 +80,7 @@ public class Table
     /* Table name. */
     public final String name;
     /* ColumnFamilyStore per column family */
-    private final Map<Integer, ColumnFamilyStore> columnFamilyStores = new HashMap<Integer, ColumnFamilyStore>();
+    public final Map<Integer, ColumnFamilyStore> columnFamilyStores = new HashMap<Integer, ColumnFamilyStore>(); // TODO make private again
     // cache application CFs since Range queries ask for them a _lot_
     private SortedSet<String> applicationColumnFamilies;
     private final TimerTask flushTask;
@@ -279,7 +279,8 @@ public void dropCf(Integer cfId) throws IOException
     /** adds a cf to internal structures, ends up creating disk files). */
     public void initCf(Integer cfId, String cfName)
     {
-        assert !columnFamilyStores.containsKey(cfId) : cfId;
+        assert !columnFamilyStores.containsKey(cfId) : String.format("tried to init %s as %s, but already used by %s",
+                                                                     cfName, cfId, columnFamilyStores.get(cfId));
         columnFamilyStores.put(cfId, ColumnFamilyStore.createColumnFamilyStore(name, cfName));
     }
     

File: test/unit/org/apache/cassandra/config/ColumnDefinitionTest.java
Patch:
@@ -2,14 +2,16 @@
 
 import org.junit.Test;
 
+import org.apache.cassandra.thrift.IndexType;
+
 public class ColumnDefinitionTest
 {
     @Test
     public void testSerializeDeserialize() throws Exception
     {
         ColumnDefinition cd0 = new ColumnDefinition("TestColumnDefinitionName0".getBytes("UTF8"),
                                                     "BytesType",
-                                                    "random index type 0",
+                                                    IndexType.KEYS,
                                                     "random index name 0");
 
         ColumnDefinition cd1 = new ColumnDefinition("TestColumnDefinition1".getBytes("UTF8"),

File: test/unit/org/apache/cassandra/db/DefsTest.java
Patch:
@@ -76,7 +76,7 @@ public void addNewCfToBogusTable() throws InterruptedException
             throw new AssertionError("Unexpected exception.");
         }
     }
-    
+
     @Test
     public void testMigrations() throws IOException, ConfigurationException
     {
@@ -85,7 +85,7 @@ public void testMigrations() throws IOException, ConfigurationException
         UUID ver0 = UUIDGen.makeType1UUIDFromHost(FBUtilities.getLocalAddress());
         DefsTable.dumpToStorage(ver0);
         assert DatabaseDescriptor.getDefsVersion().equals(prior);
-        
+
         // add a cf.
         CFMetaData newCf1 = new CFMetaData("Keyspace1", "MigrationCf_1", ColumnFamilyType.Standard, ClockType.Timestamp, UTF8Type.instance, null, new TimestampReconciler(), "Migration CF ", 0, false, 1.0, 0, Collections.<byte[], ColumnDefinition>emptyMap());
         Migration m1 = new AddColumnFamily(newCf1);

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -46,7 +46,6 @@
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.locator.AbstractReplicationStrategy;
 import org.apache.cassandra.locator.IEndpointSnitch;
-import org.apache.cassandra.service.ColumnValidator;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.Pair;
@@ -1081,8 +1080,8 @@ public static boolean hintedHandoffEnabled()
         return conf.hinted_handoff_enabled;
     }
 
-    public static ColumnValidator getColumnValidator(String keyspace, String cf, byte[] column)
+    public static AbstractType getValueValidator(String keyspace, String cf, byte[] column)
     {
-        return getCFMetaData(keyspace, cf).getColumnValidator(column);
+        return getCFMetaData(keyspace, cf).getValueValidator(column);
     }
 }

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -586,13 +586,13 @@ public static AbstractType getComparator(String compareWith) throws Configuratio
         }
         catch (NoSuchFieldException e)
         {
-            ConfigurationException ex = new ConfigurationException(e.getMessage());
+            ConfigurationException ex = new ConfigurationException("Invalid comparator: must define a public static instance field.");
             ex.initCause(e);
             throw ex;
         }
         catch (IllegalAccessException e)
         {
-            ConfigurationException ex = new ConfigurationException(e.getMessage());
+            ConfigurationException ex = new ConfigurationException("Invalid comparator: must define a public static instance field.");
             ex.initCause(e);
             throw ex;
         }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -371,7 +371,7 @@ public void runMayThrow() throws InterruptedException, IOException
                         // if we're not writing to the commit log, we are replaying the log, so marking
                         // the log header with "you can discard anything written before the context" is not valid
                         final int cfId = DatabaseDescriptor.getTableMetaData(table_).get(columnFamily_).cfId;
-                        logger_.info("Discarding " + cfId);
+                        logger_.debug("Discarding {}", cfId);
                         CommitLog.instance().discardCompletedSegments(cfId, ctx);
                     }
                 }

File: src/java/org/apache/cassandra/io/util/FileDataInput.java
Patch:
@@ -33,9 +33,9 @@ public interface FileDataInput extends DataInput, Closeable
 
     public long bytesRemaining() throws IOException;
 
-    public void mark();
+    public FileMark mark();
 
-    public void reset() throws IOException;
+    public void reset(FileMark mark) throws IOException;
 
-    public int bytesPastMark();
+    public int bytesPastMark(FileMark mark);
 }

File: test/unit/org/apache/cassandra/io/sstable/SSTableUtils.java
Patch:
@@ -52,9 +52,9 @@ public static File tempSSTableFile(String tablename, String cfname) throws IOExc
         File tabledir = new File(tempdir, tablename);
         tabledir.mkdir();
         tabledir.deleteOnExit();
-        File datafile = new File(new Descriptor(tabledir, tablename, cfname, 0,
-                                                        false).filenameFor("Data.db"));
-        assert datafile.createNewFile();
+        File datafile = new File(new Descriptor(tabledir, tablename, cfname, 0, false).filenameFor("Data.db"));
+        if (!datafile.createNewFile())
+            throw new IOException("unable to create file " + datafile);
         datafile.deleteOnExit();
         return datafile;
     }

File: src/java/org/apache/cassandra/db/IColumn.java
Patch:
@@ -40,7 +40,6 @@ public interface IColumn
     public IColumn getSubColumn(byte[] columnName);
     public void addColumn(IColumn column);
     public IColumn diff(IColumn column);
-    public int getObjectCount();
     public void updateDigest(MessageDigest digest);
     public int getLocalDeletionTime(); // for tombstone GC, so int is sufficient granularity
     public String getString(AbstractType comparator);

File: src/java/org/apache/cassandra/locator/AbstractRackAwareSnitch.java
Patch:
@@ -1,4 +1,3 @@
-package org.apache.cassandra.locator;
 /*
  *
  * Licensed to the Apache Software Foundation (ASF) under one
@@ -20,6 +19,7 @@
  *
  */
 
+package org.apache.cassandra.locator;
 
 import java.net.InetAddress;
 import java.net.UnknownHostException;
@@ -29,7 +29,7 @@
  * An endpoint snitch tells Cassandra information about network topology that it can use to route
  * requests more efficiently.
  */
-public abstract class AbstractRackAwareSnitch implements IEndpointSnitch
+public abstract class AbstractRackAwareSnitch extends AbstractEndpointSnitch
 {
     /**
      * Return the rack for which an endpoint resides in

File: contrib/bmt_example/CassandraBulkLoader.java
Patch:
@@ -53,6 +53,7 @@
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.db.clock.TimestampReconciler;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.dht.BigIntegerToken;
@@ -234,6 +235,7 @@ public static Message createMessage(String Keyspace, byte[] Key, String CFName,
                                             ClockType.Timestamp,
                                             DatabaseDescriptor.getComparator(Keyspace, CFName),
                                             DatabaseDescriptor.getSubComparator(Keyspace, CFName),
+                                            new TimestampReconciler(),
                                             CFMetaData.getId(Keyspace, CFName));
         
         for(ColumnFamily cf : ColumnFamiles) {

File: src/java/org/apache/cassandra/config/KSMetaData.java
Patch:
@@ -108,10 +108,9 @@ public static KSMetaData deserialize(InputStream in) throws IOException
             {
                 cfMetaData[i] = CFMetaData.deserialize(din);
             }
-            catch (IOException ex)
+            catch (ConfigurationException e)
             {
-                System.err.println(name);
-                throw ex;
+                throw new IOException(e);
             }
         }
 

File: src/java/org/apache/cassandra/db/DefsTable.java
Patch:
@@ -18,6 +18,7 @@
 
 package org.apache.cassandra.db;
 
+import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.KSMetaData;
 import org.apache.cassandra.db.commitlog.CommitLog;

File: src/java/org/apache/cassandra/db/SystemTable.java
Patch:
@@ -119,7 +119,7 @@ public static synchronized StorageMetadata initMetadata() throws IOException
         /* Read the system table to retrieve the storage ID and the generation */
         IPartitioner p = StorageService.getPartitioner();
         Table table = Table.open(Table.SYSTEM_TABLE);
-        SortedSet<byte[]> columns = new TreeSet<byte[]>(new BytesType());
+        SortedSet<byte[]> columns = new TreeSet<byte[]>(BytesType.instance);
         columns.add(TOKEN);
         columns.add(GENERATION);
         columns.add(CLUSTERNAME);

File: test/unit/org/apache/cassandra/config/DatabaseDescriptorTest.java
Patch:
@@ -38,7 +38,7 @@ public void testShouldHaveConfigFileNameAvailable()
     }
 
     @Test
-    public void testCFMetaDataSerialization() throws IOException
+    public void testCFMetaDataSerialization() throws IOException, ConfigurationException
     {
         // test serialization of all defined test CFs.
         for (String table : DatabaseDescriptor.getNonSystemTables())

File: test/unit/org/apache/cassandra/db/RowTest.java
Patch:
@@ -46,10 +46,10 @@ public void testDiffColumnFamily()
     @Test
     public void testDiffSuperColumn()
     {
-        SuperColumn sc1 = new SuperColumn("one".getBytes(), new AsciiType(), ClockType.Timestamp);
+        SuperColumn sc1 = new SuperColumn("one".getBytes(), AsciiType.instance, ClockType.Timestamp);
         sc1.addColumn(column("subcolumn", "A", new TimestampClock(0)));
 
-        SuperColumn sc2 = new SuperColumn("one".getBytes(), new AsciiType(), ClockType.Timestamp);
+        SuperColumn sc2 = new SuperColumn("one".getBytes(), AsciiType.instance, ClockType.Timestamp);
         sc2.markForDeleteAt(0, new TimestampClock(0));
 
         SuperColumn scDiff = (SuperColumn)sc1.diff(sc2);

File: test/unit/org/apache/cassandra/db/SuperColumnTest.java
Patch:
@@ -28,7 +28,7 @@ public class SuperColumnTest
 {   
     @Test
     public void testMissingSubcolumn() {
-    	SuperColumn sc = new SuperColumn("sc1".getBytes(), new LongType(), ClockType.Timestamp);
+    	SuperColumn sc = new SuperColumn("sc1".getBytes(), LongType.instance, ClockType.Timestamp);
     	sc.addColumn(new Column(getBytes(1), "value".getBytes(), new TimestampClock(1)));
     	assertNotNull(sc.getSubColumn(getBytes(1)));
     	assertNull(sc.getSubColumn(getBytes(2)));

File: test/unit/org/apache/cassandra/db/TableTest.java
Patch:
@@ -497,7 +497,7 @@ public void testGetSliceFromSuperBasic() throws Throwable
 
         RowMutation rm = new RowMutation("Keyspace1", ROW.key);
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Super1");
-        SuperColumn sc = new SuperColumn("sc1".getBytes(), new LongType(), ClockType.Timestamp);
+        SuperColumn sc = new SuperColumn("sc1".getBytes(), LongType.instance, ClockType.Timestamp);
         sc.addColumn(new Column(getBytes(1), "val1".getBytes(), new TimestampClock(1L)));
         cf.addColumn(sc);
         rm.add(cf);

File: test/unit/org/apache/cassandra/db/TimeSortTest.java
Patch:
@@ -105,7 +105,7 @@ public void testTimeSort() throws IOException, ExecutionException, InterruptedEx
             column = iter.next();
             assert Arrays.equals(column.name(), getBytes(j));
         }
-        TreeSet<byte[]> columnNames = new TreeSet<byte[]>(new LongType());
+        TreeSet<byte[]> columnNames = new TreeSet<byte[]>(LongType.instance);
         columnNames.add(getBytes(10));
         columnNames.add(getBytes(0));
         cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(Util.dk("900"), new QueryPath("StandardLong1"), columnNames));

File: test/unit/org/apache/cassandra/utils/UUIDTests.java
Patch:
@@ -61,7 +61,7 @@ public void testDecomposeAndRaw() throws UnknownHostException
     @Test
     public void testTimeUUIDType() throws UnknownHostException
     {
-        TimeUUIDType comp = new TimeUUIDType();
+        TimeUUIDType comp = TimeUUIDType.instance;
         byte[] first = UUIDGen.decompose(UUIDGen.makeType1UUIDFromHost(InetAddress.getByName("127.0.0.1")));
         byte[] second = UUIDGen.decompose(UUIDGen.makeType1UUIDFromHost(InetAddress.getByName("127.0.0.1")));
         assert comp.compare(first, second) < 0;

File: src/java/org/apache/cassandra/db/RowMutation.java
Patch:
@@ -295,12 +295,12 @@ private static void addColumnOrSuperColumnToRowMutation(RowMutation rm, String c
         {
             for (org.apache.cassandra.thrift.Column column : cosc.super_column.columns)
             {
-                rm.add(new QueryPath(cfName, cosc.super_column.name, column.name), column.value, column.timestamp);
+                rm.add(new QueryPath(cfName, cosc.super_column.name, column.name), column.value, column.timestamp, column.ttl);
             }
         }
         else
         {
-            rm.add(new QueryPath(cfName, null, cosc.column.name), cosc.column.value, cosc.column.timestamp);
+            rm.add(new QueryPath(cfName, null, cosc.column.name), cosc.column.value, cosc.column.timestamp, cosc.column.ttl);
         }
     }
 

File: src/java/org/apache/cassandra/avro/CassandraServer.java
Patch:
@@ -195,7 +195,7 @@ private GenericArray<ColumnOrSuperColumn> avronateColumns(Collection<IColumn> co
         if (reverseOrder)
             Collections.reverse(avroColumns);
         
-        // FIXME: Teach GenericData.Array how to reverse so that this iteration isn't necessary.
+        // FIXME: update for AVRO-540 when upgrading to Avro 1.4.0
         GenericArray<ColumnOrSuperColumn> avroArray = new GenericData.Array<ColumnOrSuperColumn>(avroColumns.size(), Schema.createArray(ColumnOrSuperColumn.SCHEMA$));
         for (ColumnOrSuperColumn cosc : avroColumns)
             avroArray.add(cosc);
@@ -217,8 +217,8 @@ private GenericArray<ColumnOrSuperColumn> avronateSuperColumns(Collection<IColum
         
         if (reverseOrder)
             Collections.reverse(avroSuperColumns);
-        
-        // FIXME: Teach GenericData.Array how to reverse so that this iteration isn't necessary.
+
+        // FIXME: update for AVRO-540 when upgrading to Avro 1.4.0
         GenericArray<ColumnOrSuperColumn> avroArray = new GenericData.Array<ColumnOrSuperColumn>(avroSuperColumns.size(), Schema.createArray(ColumnOrSuperColumn.SCHEMA$));
         for (ColumnOrSuperColumn cosc : avroSuperColumns)
             avroArray.add(cosc);

File: src/java/org/apache/cassandra/avro/AvroValidation.java
Patch:
@@ -114,9 +114,9 @@ static void validateColumnParent(String keyspace, ColumnParent parent) throws In
     {
         validateKeyspace(keyspace);
         String cfName = parent.column_family.toString();
-        String cfType = validateColumnFamily(keyspace, cfName);
+        ColumnFamilyType cfType = validateColumnFamily(keyspace, cfName);
         
-        if (cfType.equals("Standard"))
+        if (cfType == ColumnFamilyType.Standard)
             if (parent.super_column != null)
                 throw newInvalidRequestException("super column specified for standard column family");
         if (parent.super_column != null)

File: src/java/org/apache/cassandra/avro/CassandraServer.java
Patch:
@@ -499,7 +499,7 @@ public Void system_add_keyspace(KsDef ksDef) throws AvroRemoteException, Invalid
                 CFMetaData cfmeta = new CFMetaData(
                         cfDef.keyspace.toString(),
                         cfDef.name.toString(),
-                        ColumnFamily.getColumnType(cfDef.column_type.toString()),
+                        ColumnFamilyType.create(cfDef.column_type.toString()),
                         DatabaseDescriptor.getComparator(cfDef.comparator_type.toString()),
                         subComparator.length() == 0 ? null : DatabaseDescriptor.getComparator(subComparator),
                         cfDef.comment.toString(), 

File: src/java/org/apache/cassandra/avro/CassandraServer.java
Patch:
@@ -416,7 +416,7 @@ private static void deleteColumnOrSuperColumnToRowMutation(RowMutation rm, Strin
         {
             for (ByteBuffer col : del.predicate.column_names)
             {
-                if (del.super_column == null && DatabaseDescriptor.getColumnFamilyType(rm.getTable(), cfName).equals("Super"))
+                if (del.super_column == null && DatabaseDescriptor.getColumnFamilyType(rm.getTable(), cfName) == ColumnFamilyType.Super)
                     rm.delete(new QueryPath(cfName, col.array()), del.timestamp);
                 else
                     rm.delete(new QueryPath(cfName, del.super_column.array(), col.array()), del.timestamp);

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -205,7 +205,7 @@ private void executeDelete(CommonTree ast) throws TException, InvalidRequestExce
             return;
         }
             
-        isSuper = keyspacesMap.get(keySpace).get(columnFamily).get("Type").equals("Super") ? true : false;
+        isSuper = keyspacesMap.get(keySpace).get(columnFamily).get("Type").equals("Super");
      
         if ((columnSpecCnt < 0) || (columnSpecCnt > 2))
         {
@@ -322,7 +322,7 @@ private void executeGet(CommonTree ast) throws TException, NotFoundException, In
             return;
         }
         
-        boolean isSuper = keyspacesMap.get(keySpace).get(columnFamily).get("Type").equals("Super") ? true : false;
+        boolean isSuper = keyspacesMap.get(keySpace).get(columnFamily).get("Type").equals("Super");
         
         byte[] superColumnName = null;
         byte[] columnName = null;

File: src/java/org/apache/cassandra/config/ColumnFamily.java
Patch:
@@ -1,8 +1,10 @@
 package org.apache.cassandra.config;
 
+import org.apache.cassandra.db.ColumnFamilyType;
+
 public class ColumnFamily {
     public String name;            
-    public String column_type;
+    public ColumnFamilyType column_type;
     public String compare_with;
     public String compare_subcolumns_with;
     public String comment;

File: src/java/org/apache/cassandra/config/Converter.java
Patch:
@@ -13,6 +13,7 @@
 
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.XMLUtils;
+import org.apache.cassandra.db.ColumnFamilyType;
 import org.w3c.dom.NodeList;
 import org.w3c.dom.Node;
 import org.xml.sax.SAXException;
@@ -67,10 +68,10 @@ private static List<Keyspace> readTablesFromXml(XMLUtils xmlUtils) throws Config
                     ks.column_families[j] = new ColumnFamily();
                     ks.column_families[j].name = XMLUtils.getAttributeValue(columnFamily, "Name");
                     String xqlCF = xqlTable + "ColumnFamily[@Name='" + ks.column_families[j].name + "']/";
-                    ks.column_families[j].column_type = XMLUtils.getAttributeValue(columnFamily, "ColumnType");
+                    ks.column_families[j].column_type = ColumnFamilyType.create(XMLUtils.getAttributeValue(columnFamily, "ColumnType"));
                     ks.column_families[j].compare_with = XMLUtils.getAttributeValue(columnFamily, "CompareWith");
                     
-                    if (ks.column_families[j].column_type != null && ks.column_families[j].column_type.equals("Super"))
+                    if (ks.column_families[j].column_type != null && ks.column_families[j].column_type == ColumnFamilyType.Super)
                         ks.column_families[j].compare_subcolumns_with = XMLUtils.getAttributeValue(columnFamily, "CompareSubcolumnsWith");
                     
                     if ((value = XMLUtils.getAttributeValue(columnFamily, "KeysCached")) != null)

File: src/java/org/apache/cassandra/db/RowMutation.java
Patch:
@@ -310,7 +310,7 @@ private static void deleteColumnOrSuperColumnToRowMutation(RowMutation rm, Strin
         {
             for(byte[] c : del.predicate.column_names)
             {
-                if (del.super_column == null && DatabaseDescriptor.getColumnFamilyType(rm.table_, cfName).equals("Super"))
+                if (del.super_column == null && DatabaseDescriptor.getColumnFamilyType(rm.table_, cfName) == ColumnFamilyType.Super)
                     rm.delete(new QueryPath(cfName, c), del.timestamp);
                 else
                     rm.delete(new QueryPath(cfName, del.super_column, c), del.timestamp);

File: src/java/org/apache/cassandra/io/sstable/SSTableReader.java
Patch:
@@ -275,7 +275,8 @@ public ColumnFamily makeColumnFamily()
 
     public ICompactSerializer2<IColumn> getColumnSerializer()
     {
-        return DatabaseDescriptor.getColumnFamilyType(getTableName(), getColumnFamilyName()).equals("Standard")
+        ColumnFamilyType cfType = DatabaseDescriptor.getColumnFamilyType(getTableName(), getColumnFamilyName());
+        return cfType == ColumnFamilyType.Standard
                ? Column.serializer()
                : SuperColumn.serializer(getColumnComparator());
     }

File: src/java/org/apache/cassandra/tools/SSTableImport.java
Patch:
@@ -25,6 +25,7 @@
 import org.apache.cassandra.db.ColumnFamily;
 import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.db.SuperColumn;
+import org.apache.cassandra.db.ColumnFamilyType;
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.io.util.DataOutputBuffer;
@@ -142,7 +143,7 @@ public static void importJson(String jsonFile, String keyspace, String cf, Strin
     throws IOException, ParseException
     {
         ColumnFamily cfamily = ColumnFamily.create(keyspace, cf);
-        String cfType = cfamily.type();    // Super or Standard
+        ColumnFamilyType cfType = cfamily.getColumnFamilyType();    // Super or Standard
         IPartitioner<?> partitioner = DatabaseDescriptor.getPartitioner();
         DataOutputBuffer dob = new DataOutputBuffer();
         
@@ -159,7 +160,7 @@ public static void importJson(String jsonFile, String keyspace, String cf, Strin
 
             for (Map.Entry<DecoratedKey, String> rowKey : decoratedKeys.entrySet())
             {
-                if (cfType.equals("Super"))
+                if (cfType == ColumnFamilyType.Super)
                     addToSuperCF((JSONObject)json.get(rowKey.getValue()), cfamily);
                 else
                     addToStandardCF((JSONArray)json.get(rowKey.getValue()), cfamily);

File: src/java/org/apache/cassandra/avro/AvroValidation.java
Patch:
@@ -185,6 +185,7 @@ static void validateSlicePredicate(String keyspace, String cfName, byte[] superN
 
     static void validateDeletion(String keyspace, String  cfName, Deletion del) throws InvalidRequestException
     {
+        validateColumnFamily(keyspace, cfName);
         if (del.super_column == null && del.predicate == null)
             throw newInvalidRequestException("A Deletion must have a SuperColumn, a SlicePredicate, or both.");
 

File: src/java/org/apache/cassandra/thrift/ThriftValidation.java
Patch:
@@ -260,6 +260,7 @@ else if (del != null)
 
     public static void validateDeletion(String keyspace, String cfName, Deletion del) throws InvalidRequestException
     {
+        validateColumnFamily(keyspace, cfName);
         if (del.predicate != null)
         {
             validateSlicePredicate(keyspace, cfName, del.super_column, del.predicate);

File: contrib/javautils/src/test/java/org/apache/cassandra/contrib/utils/service/CassandraServiceTest.java
Patch:
@@ -88,7 +88,7 @@ public void testInProcessCassandraServer()
             NotFoundException, AuthenticationException, AuthorizationException {
         Cassandra.Client client = getClient();
 
-        client.login("Keyspace1", null);
+        client.login(null);
 
         String key_user_id = "1";
         long timestamp = System.currentTimeMillis();   

File: test/unit/org/apache/cassandra/client/TestRingCache.java
Patch:
@@ -104,7 +104,7 @@ public static void main(String[] args) throws Throwable
 
             // now, read the row back directly from the host owning the row locally
             tester.setup(endpoints.get(0).getHostAddress(), DatabaseDescriptor.getRpcPort());
-            tester.thriftClient.login(keyspace, new AuthenticationRequest(new HashMap<String,String>()));
+            tester.thriftClient.set_keyspace(keyspace);
             tester.thriftClient.insert(row, parent, new Column("col1".getBytes(), "val1".getBytes(), 1), ConsistencyLevel.ONE);
             Column column = tester.thriftClient.get(row, col, ConsistencyLevel.ONE).column;
             System.out.println("read row " + new String(row) + " " + new String(column.name) + ":" + new String(column.value) + ":" + column.timestamp);

File: test/unit/org/apache/cassandra/service/EmbeddedCassandraServiceTest.java
Patch:
@@ -96,7 +96,7 @@ public void testEmbeddedCassandraService() throws AuthenticationException, Autho
             UnavailableException, TimedOutException, TException, NotFoundException
     {
         Cassandra.Client client = getClient();
-        client.login("Keyspace1", new AuthenticationRequest(new HashMap<String, String>()));
+        client.set_keyspace("Keyspace1");
 
         byte[] key_user_id = "1".getBytes();
 

File: interface/thrift/gen-java/org/apache/cassandra/thrift/AuthenticationException.java
Patch:
@@ -45,7 +45,7 @@
 import org.apache.thrift.protocol.*;
 
 /**
- * invalid authentication request (user does not exist or credentials invalid)
+ * invalid authentication request (invalid keyspace, user does not exist, or credentials invalid)
  */
 public class AuthenticationException extends Exception implements TBase<AuthenticationException._Fields>, java.io.Serializable, Cloneable, Comparable<AuthenticationException> {
   private static final TStruct STRUCT_DESC = new TStruct("AuthenticationException");

File: src/java/org/apache/cassandra/db/migration/AddColumnFamily.java
Patch:
@@ -69,7 +69,7 @@ private KSMetaData makeNewKeyspaceDefinition(KSMetaData ksm)
     {
         List<CFMetaData> newCfs = new ArrayList<CFMetaData>(ksm.cfMetaData().values());
         newCfs.add(cfm);
-        return new KSMetaData(ksm.name, ksm.strategyClass, ksm.replicationFactor, ksm.snitch, newCfs.toArray(new CFMetaData[newCfs.size()]));
+        return new KSMetaData(ksm.name, ksm.strategyClass, ksm.replicationFactor, newCfs.toArray(new CFMetaData[newCfs.size()]));
     }
     
     public void applyModels()

File: src/java/org/apache/cassandra/db/migration/DropColumnFamily.java
Patch:
@@ -81,7 +81,7 @@ private KSMetaData makeNewKeyspaceDefinition(KSMetaData ksm)
         List<CFMetaData> newCfs = new ArrayList<CFMetaData>(ksm.cfMetaData().values());
         newCfs.remove(cfm);
         assert newCfs.size() == ksm.cfMetaData().size() - 1;
-        return new KSMetaData(ksm.name, ksm.strategyClass, ksm.replicationFactor, ksm.snitch, newCfs.toArray(new CFMetaData[newCfs.size()]));
+        return new KSMetaData(ksm.name, ksm.strategyClass, ksm.replicationFactor, newCfs.toArray(new CFMetaData[newCfs.size()]));
     }
 
     @Override

File: src/java/org/apache/cassandra/db/migration/RenameColumnFamily.java
Patch:
@@ -91,7 +91,7 @@ private KSMetaData makeNewKeyspaceDefinition(KSMetaData ksm)
         assert newCfs.size() == ksm.cfMetaData().size() - 1;
         CFMetaData newCfm = CFMetaData.rename(oldCfm, newName);
         newCfs.add(newCfm);
-        return new KSMetaData(ksm.name, ksm.strategyClass, ksm.replicationFactor, ksm.snitch, newCfs.toArray(new CFMetaData[newCfs.size()]));
+        return new KSMetaData(ksm.name, ksm.strategyClass, ksm.replicationFactor, newCfs.toArray(new CFMetaData[newCfs.size()]));
     }
 
     @Override

File: src/java/org/apache/cassandra/dht/BootStrapper.java
Patch:
@@ -156,7 +156,7 @@ Multimap<Range, InetAddress> getRangesWithSources(String table)
             {
                 if (range.contains(myRange))
                 {
-                    List<InetAddress> preferred = DatabaseDescriptor.getEndPointSnitch(table).getSortedListByProximity(address, rangeAddresses.get(range));
+                    List<InetAddress> preferred = DatabaseDescriptor.getEndPointSnitch().getSortedListByProximity(address, rangeAddresses.get(range));
                     myRangeAddresses.putAll(myRange, preferred);
                     break;
                 }

File: src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
Patch:
@@ -75,11 +75,11 @@ public ArrayList<InetAddress> getNaturalEndpoints(Token token, String table)
      * as the destination, it is a "hinted" write, and will need to be sent to
      * the ultimate target when it becomes alive again.
      */
-    public Multimap<InetAddress, InetAddress> getHintedEndpoints(String table, Collection<InetAddress> targets)
+    public Multimap<InetAddress, InetAddress> getHintedEndpoints(Collection<InetAddress> targets)
     {
         Multimap<InetAddress, InetAddress> map = HashMultimap.create(targets.size(), 1);
 
-        IEndPointSnitch endPointSnitch = DatabaseDescriptor.getEndPointSnitch(table);
+        IEndPointSnitch endPointSnitch = DatabaseDescriptor.getEndPointSnitch();
 
         // first, add the live endpoints
         for (InetAddress ep : targets)

File: src/java/org/apache/cassandra/service/DatacenterSyncWriteResponseHandler.java
Patch:
@@ -49,7 +49,7 @@ public DatacenterSyncWriteResponseHandler(Map<String, Integer> responseCounts, S
         // Response is been managed by the map so make it 1 for the superclass.
         super(1, table);
         this.responseCounts = responseCounts;
-        endPointSnitch = (DatacenterEndPointSnitch) DatabaseDescriptor.getEndPointSnitch(table);
+        endPointSnitch = (DatacenterEndPointSnitch) DatabaseDescriptor.getEndPointSnitch();
     }
 
     @Override

File: src/java/org/apache/cassandra/service/DatacenterWriteResponseHandler.java
Patch:
@@ -50,7 +50,7 @@ public DatacenterWriteResponseHandler(int blockFor, String table)
         // Response is been managed by the map so the waitlist size really doesnt matter.
         super(blockFor, table);
         this.blockFor = new AtomicInteger(blockFor);
-        endpointsnitch = (DatacenterEndPointSnitch) DatabaseDescriptor.getEndPointSnitch(table);
+        endpointsnitch = (DatacenterEndPointSnitch) DatabaseDescriptor.getEndPointSnitch();
         localEndpoint = FBUtilities.getLocalAddress();
     }
 

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -106,7 +106,7 @@ public static void mutate(List<RowMutation> mutations)
                     AbstractReplicationStrategy rs = ss.getReplicationStrategy(table);
 
                     List<InetAddress> naturalEndpoints = ss.getNaturalEndpoints(table, rm.key());
-                    Multimap<InetAddress,InetAddress> hintedEndpoints = rs.getHintedEndpoints(table, naturalEndpoints);
+                    Multimap<InetAddress,InetAddress> hintedEndpoints = rs.getHintedEndpoints(naturalEndpoints);
                     Message unhintedMessage = null; // lazy initialize for non-local, unhinted writes
 
                     // 3 cases:
@@ -195,7 +195,7 @@ public static void mutateBlocking(List<RowMutation> mutations, ConsistencyLevel
 
                 List<InetAddress> naturalEndpoints = ss.getNaturalEndpoints(table, rm.key());
                 Collection<InetAddress> writeEndpoints = rs.getWriteEndpoints(StorageService.getPartitioner().getToken(rm.key()), table, naturalEndpoints);
-                Multimap<InetAddress, InetAddress> hintedEndpoints = rs.getHintedEndpoints(table, writeEndpoints);
+                Multimap<InetAddress, InetAddress> hintedEndpoints = rs.getHintedEndpoints(writeEndpoints);
                 int blockFor = determineBlockFor(writeEndpoints.size(), consistency_level);
 
                 // avoid starting a write we know can't achieve the required consistency
@@ -675,7 +675,7 @@ private static List<Pair<AbstractBounds, List<InetAddress>>> getRestrictedRanges
             if (endpoints.size() < responseCount)
                 throw new UnavailableException();
 
-            DatabaseDescriptor.getEndPointSnitch(keyspace).sortByProximity(FBUtilities.getLocalAddress(), endpoints);
+            DatabaseDescriptor.getEndPointSnitch().sortByProximity(FBUtilities.getLocalAddress(), endpoints);
             List<InetAddress> endpointsForCL = endpoints.subList(0, responseCount);
             Set<AbstractBounds> restrictedRanges = queryRange.restrictTo(nodeRange);
             for (AbstractBounds range : restrictedRanges)

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -274,7 +274,7 @@ public static AbstractReplicationStrategy getReplicationStrategy(TokenMetadata t
         try
         {
             Constructor<? extends AbstractReplicationStrategy> constructor = cls.getConstructor(parameterTypes);
-            replicationStrategy = constructor.newInstance(tokenMetadata, DatabaseDescriptor.getEndPointSnitch(table));
+            replicationStrategy = constructor.newInstance(tokenMetadata, DatabaseDescriptor.getEndPointSnitch());
         }
         catch (Exception e)
         {
@@ -801,7 +801,7 @@ private void restoreReplicaCount(InetAddress endPoint)
                 // find alive sources for our new ranges
                 for (Range myNewRange : myNewRanges)
                 {
-                    List<InetAddress> sources = DatabaseDescriptor.getEndPointSnitch(table).getSortedListByProximity(myAddress, rangeAddresses.get(myNewRange));
+                    List<InetAddress> sources = DatabaseDescriptor.getEndPointSnitch().getSortedListByProximity(myAddress, rangeAddresses.get(myNewRange));
 
                     assert (!sources.contains(myAddress));
 
@@ -1219,7 +1219,7 @@ public List<InetAddress> getLiveNaturalEndpoints(String table, Token token)
     public InetAddress findSuitableEndPoint(String table, byte[] key) throws IOException, UnavailableException
     {
         List<InetAddress> endpoints = getNaturalEndpoints(table, key);
-        DatabaseDescriptor.getEndPointSnitch(table).sortByProximity(FBUtilities.getLocalAddress(), endpoints);
+        DatabaseDescriptor.getEndPointSnitch().sortByProximity(FBUtilities.getLocalAddress(), endpoints);
         for (InetAddress endpoint : endpoints)
         {
             if (FailureDetector.instance.isAlive(endpoint))

File: test/unit/org/apache/cassandra/db/DefsTest.java
Patch:
@@ -283,7 +283,7 @@ public void addNewKS() throws ConfigurationException, IOException, ExecutionExce
     {
         DecoratedKey dk = Util.dk("key0");
         CFMetaData newCf = new CFMetaData("NewKeyspace1", "AddedStandard1", "Standard", new UTF8Type(), null, "A new cf for a new ks", 0, 0);
-        KSMetaData newKs = new KSMetaData(newCf.tableName, RackAwareStrategy.class, 5, new EndPointSnitch(), newCf);
+        KSMetaData newKs = new KSMetaData(newCf.tableName, RackAwareStrategy.class, 5, newCf);
         
         int segmentCount = CommitLog.instance().getSegmentCount();
         new AddKeyspace(newKs).apply();

File: contrib/word_count/src/WordCountSetup.java
Patch:
@@ -47,7 +47,7 @@ public static void main(String[] args) throws Exception
 
         // text1: 1 row, 1 word
         columnName = "text1".getBytes();
-        rm = new RowMutation(WordCount.KEYSPACE, "Key0");
+        rm = new RowMutation(WordCount.KEYSPACE, "Key0".getBytes());
         cf = ColumnFamily.create(WordCount.KEYSPACE, WordCount.COLUMN_FAMILY);
         cf.addColumn(new Column(columnName, "word1".getBytes(), 0));
         rm.add(cf);
@@ -56,7 +56,7 @@ public static void main(String[] args) throws Exception
 
         // text2: 1 row, 2 words
         columnName = "text2".getBytes();
-        rm = new RowMutation(WordCount.KEYSPACE, "Key0");
+        rm = new RowMutation(WordCount.KEYSPACE, "Key0".getBytes());
         cf = ColumnFamily.create(WordCount.KEYSPACE, WordCount.COLUMN_FAMILY);
         cf.addColumn(new Column(columnName, "word1 word2".getBytes(), 0));
         rm.add(cf);
@@ -67,7 +67,7 @@ public static void main(String[] args) throws Exception
         columnName = "text3".getBytes();
         for (int i = 0; i < 1000; i++)
         {
-            rm = new RowMutation(WordCount.KEYSPACE, "Key" + i);
+            rm = new RowMutation(WordCount.KEYSPACE, ("Key" + i).getBytes());
             cf = ColumnFamily.create(WordCount.KEYSPACE, WordCount.COLUMN_FAMILY);
             cf.addColumn(new Column(columnName, "word1".getBytes(), 0));
             rm.add(cf);

File: src/java/org/apache/cassandra/auth/IAuthenticator.java
Patch:
@@ -21,6 +21,7 @@
  */
 
 
+import org.apache.cassandra.config.DatabaseDescriptor.ConfigurationException;
 import org.apache.cassandra.thrift.AccessLevel;
 import org.apache.cassandra.thrift.AuthenticationException;
 import org.apache.cassandra.thrift.AuthenticationRequest;
@@ -29,4 +30,6 @@
 public interface IAuthenticator
 {
     public AccessLevel login(String keyspace, AuthenticationRequest auth_request) throws AuthenticationException, AuthorizationException;
+
+    public void validateConfiguration() throws ConfigurationException;
 }

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -249,6 +249,8 @@ else if (diskAccessMode == DiskAccessMode.mmap_index_only)
                     throw new ConfigurationException("Invalid authenticator class " + authenticatorClassName);
                 }
             }
+
+            authenticator.validateConfiguration();
             
             /* Hashing strategy */
             String partitionerClassName = xmlUtils.getNodeValue("/Storage/Partitioner");

File: src/java/org/apache/cassandra/service/ConsistencyChecker.java
Patch:
@@ -49,7 +49,7 @@
 
 class ConsistencyChecker implements Runnable
 {
-    private static Logger logger_ = LoggerFactory.getLogger(ConsistencyManager.class);
+    private static Logger logger_ = LoggerFactory.getLogger(ConsistencyChecker.class);
     private static ExpiringMap<String, String> readRepairTable_ = new ExpiringMap<String, String>(DatabaseDescriptor.getRpcTimeout());
 
     private final String table_;

File: src/java/org/apache/cassandra/db/BinaryMemtable.java
Patch:
@@ -68,7 +68,7 @@ boolean isThresholdViolated()
      * the memtable. This version will respect the threshold and flush
      * the memtable to disk when the size exceeds the threshold.
     */
-    void put(String key, byte[] buffer) throws IOException
+    void put(String key, byte[] buffer)
     {
         if (isThresholdViolated())
         {

File: src/java/org/apache/cassandra/db/commitlog/CommitLog.java
Patch:
@@ -309,7 +309,7 @@ private CommitLogSegment currentSegment()
         return segments.getLast();
     }
     
-    public CommitLogSegment.CommitLogContext getContext() throws IOException
+    public CommitLogSegment.CommitLogContext getContext()
     {
         Callable<CommitLogSegment.CommitLogContext> task = new Callable<CommitLogSegment.CommitLogContext>()
         {

File: src/java/org/apache/cassandra/db/filter/NamesQueryFilter.java
Patch:
@@ -64,7 +64,7 @@ public ColumnIterator getMemColumnIterator(Memtable memtable, ColumnFamily cf, A
         return memtable.getNamesIterator(cf, this);
     }
 
-    public ColumnIterator getSSTableColumnIterator(SSTableReader sstable) throws IOException
+    public ColumnIterator getSSTableColumnIterator(SSTableReader sstable)
     {
         return new SSTableNamesIterator(sstable, key, columns);
     }

File: src/java/org/apache/cassandra/db/filter/QueryFilter.java
Patch:
@@ -57,7 +57,7 @@ public ColumnIterator getMemColumnIterator(Memtable memtable, AbstractType compa
      * returns an iterator that returns columns from the given SSTable
      * matching the Filter criteria in sorted order.
      */
-    public abstract ColumnIterator getSSTableColumnIterator(SSTableReader sstable) throws IOException;
+    public abstract ColumnIterator getSSTableColumnIterator(SSTableReader sstable);
 
     /**
      * collects columns from reducedColumns into returnCF.  Termination is determined

File: src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
Patch:
@@ -68,7 +68,7 @@ public ColumnIterator getMemColumnIterator(Memtable memtable, ColumnFamily cf, A
         return memtable.getSliceIterator(cf, this, comparator);
     }
 
-    public ColumnIterator getSSTableColumnIterator(SSTableReader sstable) throws IOException
+    public ColumnIterator getSSTableColumnIterator(SSTableReader sstable)
     {
         Predicate<IColumn> predicate = (bitmasks == null || bitmasks.isEmpty())
                                        ? Predicates.<IColumn>alwaysTrue()

File: src/java/org/apache/cassandra/avro/AvroValidation.java
Patch:
@@ -130,7 +130,7 @@ static void validateColumnOrSuperColumn(String keyspace, String cfName, ColumnOr
     throws InvalidRequestException
     {
         if (cosc.column != null)
-            AvroValidation.validateColumnPath(keyspace, newColumnPath(cfName, cosc.super_column.name, cosc.column.name));
+            AvroValidation.validateColumnPath(keyspace, newColumnPath(cfName, null, cosc.column.name));
 
         if (cosc.super_column != null)
             for (Column c : cosc.super_column.columns)

File: src/java/org/apache/cassandra/avro/RecordFactory.java
Patch:
@@ -71,6 +71,7 @@ static ColumnOrSuperColumn newColumnOrSuperColumn(SuperColumn superColumn)
     static ColumnPath newColumnPath(String cfName, ByteBuffer superColumn, ByteBuffer column)
     {
         ColumnPath cPath = new ColumnPath();
+        cPath.column_family = new Utf8(cfName);
         cPath.super_column = superColumn;
         cPath.column = column;
         return cPath;

File: test/unit/org/apache/cassandra/tools/SSTableExportTest.java
Patch:
@@ -78,8 +78,9 @@ public void testEnumeratekeys() throws IOException
         char[] buf = new char[(int) temp.length()];
         file.read(buf);
         String output = new String(buf);
-        
-        assert output.equals("rowA\nrowB\n");
+
+        String sep = System.getProperty("line.separator");
+        assert output.equals("rowA" + sep + "rowB" + sep) : output;
     }
 
     @Test

File: src/java/org/apache/cassandra/db/RangeSliceCommand.java
Patch:
@@ -59,7 +59,7 @@
 
 public class RangeSliceCommand
 {
-    private static final SliceCommandSerializer serializer = new SliceCommandSerializer();
+    private static final RangeSliceCommandSerializer serializer = new RangeSliceCommandSerializer();
     
     public final String keyspace;
 
@@ -117,7 +117,7 @@ public static RangeSliceCommand read(Message message) throws IOException
     }
 }
 
-class SliceCommandSerializer implements ICompactSerializer<RangeSliceCommand>
+class RangeSliceCommandSerializer implements ICompactSerializer<RangeSliceCommand>
 {
     public void serialize(RangeSliceCommand sliceCommand, DataOutputStream dos) throws IOException
     {

File: src/java/org/apache/cassandra/gms/EndPointState.java
Patch:
@@ -91,7 +91,6 @@ public Map<String, ApplicationState> getApplicationStateMap()
     
     void addApplicationState(String key, ApplicationState appState)
     {
-        assert !StorageService.instance.isClientMode();
         applicationState_.put(key, appState);        
     }
     

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -851,8 +851,9 @@ public void start(InetAddress localEndPoint, int generationNbr)
         gossipTimer_.schedule( new GossipTimerTask(), Gossiper.intervalInMillis_, Gossiper.intervalInMillis_);
     }
 
-    public synchronized void addApplicationState(String key, ApplicationState appState)
+    public synchronized void addLocalApplicationState(String key, ApplicationState appState)
     {
+        assert !StorageService.instance.isClientMode();
         EndPointState epState = endPointStateMap_.get(localEndPoint_);
         assert epState != null;
         epState.addApplicationState(key, appState);

File: src/java/org/apache/cassandra/service/LoadDisseminator.java
Patch:
@@ -34,6 +34,6 @@ public void run()
         String diskUtilization = String.valueOf(StorageService.instance.getLoad());
         if (logger_.isDebugEnabled())
           logger_.debug("Disseminating load info ...");
-        Gossiper.instance.addApplicationState(LoadDisseminator.loadInfo_, new ApplicationState(diskUtilization));
+        Gossiper.instance.addLocalApplicationState(LoadDisseminator.loadInfo_, new ApplicationState(diskUtilization));
     }
 }

File: test/unit/org/apache/cassandra/dht/BootStrapperTest.java
Patch:
@@ -110,6 +110,7 @@ public boolean isAlive(InetAddress ep)
             public void report(InetAddress ep) { throw new UnsupportedOperationException(); }
             public void registerFailureDetectionEventListener(IFailureDetectionEventListener listener) { throw new UnsupportedOperationException(); }
             public void unregisterFailureDetectionEventListener(IFailureDetectionEventListener listener) { throw new UnsupportedOperationException(); }
+            public void remove(InetAddress ep) { throw new UnsupportedOperationException(); }
         };
         Multimap<InetAddress, Range> temp = BootStrapper.getWorkMap(res, mockFailureDetector);
         assertEquals(1, temp.keySet().size());

File: src/java/org/apache/cassandra/net/IncomingTcpConnection.java
Patch:
@@ -57,7 +57,7 @@ public void run()
             catch (EOFException e)
             {
                 if (logger.isTraceEnabled())
-                    logger.trace("error reading from socket; closing", e);
+                    logger.trace("eof reading from socket; closing", e);
                 break;
             }
             catch (IOException e)

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -126,7 +126,7 @@ public byte[] hash(String type, byte data[])
     /** called by failure detection code to notify that housekeeping should be performed on downed sockets. */
     public void convict(InetAddress ep)
     {
-        logger_.debug("Resetting pool for " + ep);
+        logger_.trace("Resetting pool for " + ep);
         getConnectionPool(ep).reset();
     }
 

File: src/java/org/apache/cassandra/service/StorageServiceMBean.java
Patch:
@@ -148,6 +148,4 @@ public interface StorageServiceMBean
 
     /** set the logging level at runtime */
     public void setLog4jLevel(String classQualifier, String level);
-    
-    public List<InetAddress> getLiveNaturalEndpoints(String key);
 }

File: src/java/org/apache/cassandra/db/ColumnFamily.java
Patch:
@@ -242,7 +242,7 @@ public void delete(int localtime, long timestamp)
 
     public void delete(ColumnFamily cf2)
     {
-        FBUtilities.atomicSetMax(localDeletionTime, cf2.getLocalDeletionTime());
+        FBUtilities.atomicSetMax(localDeletionTime, cf2.getLocalDeletionTime()); // do this first so we won't have a column that's "deleted" but has no local deletion time
         FBUtilities.atomicSetMax(markedForDeleteAt, cf2.getMarkedForDeleteAt());
     }
 

File: src/java/org/apache/cassandra/db/SuperColumn.java
Patch:
@@ -183,6 +183,7 @@ public void putColumn(IColumn column)
         {
         	addColumn(subColumn);
         }
+        FBUtilities.atomicSetMax(localDeletionTime, column.getLocalDeletionTime()); // do this first so we won't have a column that's "deleted" but has no local deletion time
         FBUtilities.atomicSetMax(markedForDeleteAt, column.getMarkedForDeleteAt());
     }
 

File: src/java/org/apache/cassandra/db/marshal/AbstractType.java
Patch:
@@ -82,7 +82,7 @@ public String getColumnsString(Collection<IColumn> columns)
         StringBuilder builder = new StringBuilder();
         for (IColumn column : columns)
         {
-            builder.append(getString(column.name())).append(",");
+            builder.append(column.getString(this)).append(",");
         }
         return builder.toString();
     }

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -965,7 +965,7 @@ public static double getKeysCachedFraction(String tableName, String columnFamily
     public static double getRowsCachedFraction(String tableName, String columnFamilyName)
     {
         Double v = tableRowsCachedFractions_.get(Pair.create(tableName, columnFamilyName));
-        return v == null ? 0.01 : v;
+        return v == null ? 0 : v;
     }
 
     private static class ConfigurationException extends Exception

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -103,9 +103,9 @@ public static enum DiskAccessMode {
     /* Number of minutes to keep a memtable in memory */
     private static int memtableLifetimeMs_ = 60 * 60 * 1000;
     /* Size of the memtable in memory before it is dumped */
-    private static int memtableThroughput_ = 128;
+    private static int memtableThroughput_ = 64;
     /* Number of objects in millions in the memtable before it is dumped */
-    private static double memtableOperations_ = 1;
+    private static double memtableOperations_ = 0.1;
     /* 
      * This parameter enables or disables consistency checks. 
      * If set to false the read repairs are disable for very

File: src/java/org/apache/cassandra/io/SSTableReader.java
Patch:
@@ -395,7 +395,7 @@ public PositionSize getPosition(DecoratedKey decoratedKey) throws IOException
         FileDataInput input;
         if (indexBuffers == null)
         {
-            input = new BufferedRandomAccessFile(path, "r");
+            input = new BufferedRandomAccessFile(indexFilename(), "r");
             ((BufferedRandomAccessFile)input).seek(p);
         }
         else

File: src/java/org/apache/cassandra/db/RangeSliceCommand.java
Patch:
@@ -37,6 +37,7 @@
 package org.apache.cassandra.db;
 
 import org.apache.cassandra.concurrent.StageManager;
+import org.apache.cassandra.glue.ThriftGlue;
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.io.ICompactSerializer;
 import org.apache.cassandra.net.Message;
@@ -164,7 +165,7 @@ public RangeSliceCommand deserialize(DataInputStream dis) throws IOException
         DecoratedKey finishKey = DecoratedKey.serializer().deserialize(dis);
         int max_keys = dis.readInt();
         return new RangeSliceCommand(keyspace,
-                                     new ColumnParent(column_family, super_column),
+                                     ThriftGlue.createColumnParent(column_family, super_column),
                                      pred,
                                      startKey,
                                      finishKey,

File: src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
Patch:
@@ -29,6 +29,7 @@
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.gms.FailureDetector;
+import org.apache.cassandra.service.ConsistencyLevel;
 import org.apache.cassandra.service.IResponseResolver;
 import org.apache.cassandra.service.QuorumResponseHandler;
 import org.apache.cassandra.service.WriteResponseHandler;
@@ -56,7 +57,7 @@ public abstract class AbstractReplicationStrategy
 
     public abstract ArrayList<InetAddress> getNaturalEndpoints(Token token, TokenMetadata metadata);
     
-    public WriteResponseHandler getWriteResponseHandler(int blockFor, int consistency_level)
+    public WriteResponseHandler getWriteResponseHandler(int blockFor, ConsistencyLevel consistency_level)
     {
         return new WriteResponseHandler(blockFor);
     }

File: src/java/org/apache/cassandra/locator/DatacenterShardStategy.java
Patch:
@@ -183,6 +183,7 @@ private ArrayList<InetAddress> getNaturalEndpointsInternal(Token searchToken, To
                 {
                     doneDataCenterItr = true;
                 }
+                
                 // Now try to find one on a different rack
                 if (!bOtherRack)
                 {
@@ -227,7 +228,7 @@ private ArrayList<InetAddress> getNaturalEndpointsInternal(Token searchToken, To
      * return a DCQRH with a map of all the DC rep facor.
      */
     @Override
-    public WriteResponseHandler getWriteResponseHandler(int blockFor, int consistency_level)
+    public WriteResponseHandler getWriteResponseHandler(int blockFor, ConsistencyLevel consistency_level)
     {
         if (consistency_level == ConsistencyLevel.DCQUORUM)
         {

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1410,7 +1410,7 @@ public void removeToken(String tokenString)
         Gossiper.instance().addApplicationState(MOVE_STATE, new ApplicationState(STATE_LEFT + Delimiter + REMOVE_TOKEN + Delimiter + token.toString()));
     }
 
-    public WriteResponseHandler getWriteResponseHandler(int blockFor, int consistency_level)
+    public WriteResponseHandler getWriteResponseHandler(int blockFor, ConsistencyLevel consistency_level)
     {
         return replicationStrategy_.getWriteResponseHandler(blockFor, consistency_level);
     }

File: contrib/bmt_example/CassandraBulkLoader.java
Patch:
@@ -57,7 +57,7 @@
 import org.apache.cassandra.db.RowMutation;
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.dht.BigIntegerToken;
-import org.apache.cassandra.io.DataOutputBuffer;
+import org.apache.cassandra.io.util.DataOutputBuffer;
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 
@@ -218,7 +218,7 @@ public static void runJob(String[] args)
     public static Message createMessage(String Keyspace, String Key, String CFName, List<ColumnFamily> ColumnFamiles)
     {
         ColumnFamily baseColumnFamily;
-        DataOutputBuffer bufOut = new org.apache.cassandra.io.DataOutputBuffer();
+        DataOutputBuffer bufOut = new DataOutputBuffer();
         RowMutation rm;
         Message message;
         Column column;

File: src/java/org/apache/cassandra/io/SSTableReader.java
Patch:
@@ -166,7 +166,7 @@ public static SSTableReader open(String dataFileName, IPartitioner partitioner,
         assert openedFiles.get(dataFileName) == null;
 
         long start = System.currentTimeMillis();
-        SSTableReader sstable = new SSTableReader(dataFileName, partitioner)
+        SSTableReader sstable = new SSTableReader(dataFileName, partitioner);
         sstable.loadIndexFile();
         sstable.loadBloomFilter();
         if (cacheFraction > 0)

File: test/unit/org/apache/cassandra/db/OneCompactionTest.java
Patch:
@@ -28,8 +28,9 @@
 
 import static junit.framework.Assert.assertEquals;
 import org.apache.cassandra.db.filter.QueryPath;
+import org.apache.cassandra.CleanupHelper;
 
-public class OneCompactionTest
+public class OneCompactionTest extends CleanupHelper
 {
     private void testCompaction(String columnFamilyName, int insertsPerTable) throws IOException, ExecutionException, InterruptedException
     {

File: test/unit/org/apache/cassandra/db/RemoveColumnFamilyTest.java
Patch:
@@ -26,8 +26,9 @@
 import static junit.framework.Assert.assertNull;
 import org.apache.cassandra.db.filter.IdentityQueryFilter;
 import org.apache.cassandra.db.filter.QueryPath;
+import org.apache.cassandra.CleanupHelper;
 
-public class RemoveColumnFamilyTest
+public class RemoveColumnFamilyTest extends CleanupHelper
 {
     @Test
     public void testRemoveColumnFamily() throws IOException, ExecutionException, InterruptedException

File: test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush1Test.java
Patch:
@@ -26,8 +26,9 @@
 import static junit.framework.Assert.assertNull;
 import org.apache.cassandra.db.filter.IdentityQueryFilter;
 import org.apache.cassandra.db.filter.QueryPath;
+import org.apache.cassandra.CleanupHelper;
 
-public class RemoveColumnFamilyWithFlush1Test
+public class RemoveColumnFamilyWithFlush1Test extends CleanupHelper
 {
     @Test
     public void testRemoveColumnFamilyWithFlush1() throws IOException, ExecutionException, InterruptedException

File: test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush2Test.java
Patch:
@@ -26,8 +26,9 @@
 import static junit.framework.Assert.assertNull;
 import org.apache.cassandra.db.filter.IdentityQueryFilter;
 import org.apache.cassandra.db.filter.QueryPath;
+import org.apache.cassandra.CleanupHelper;
 
-public class RemoveColumnFamilyWithFlush2Test
+public class RemoveColumnFamilyWithFlush2Test extends CleanupHelper
 {
     @Test
     public void testRemoveColumnFamilyWithFlush2() throws IOException, ExecutionException, InterruptedException

File: test/unit/org/apache/cassandra/db/RemoveColumnTest.java
Patch:
@@ -27,8 +27,9 @@
 import org.apache.cassandra.db.filter.IdentityQueryFilter;
 import org.apache.cassandra.db.filter.NamesQueryFilter;
 import org.apache.cassandra.db.filter.QueryPath;
+import org.apache.cassandra.CleanupHelper;
 
-public class RemoveColumnTest
+public class RemoveColumnTest extends CleanupHelper
 {
     @Test
     public void testRemoveColumn() throws IOException, ExecutionException, InterruptedException

File: test/unit/org/apache/cassandra/db/RemoveSubColumnTest.java
Patch:
@@ -28,8 +28,9 @@
 import org.apache.cassandra.db.filter.QueryPath;
 import static org.apache.cassandra.Util.addMutation;
 import static org.apache.cassandra.Util.getBytes;
+import org.apache.cassandra.CleanupHelper;
 
-public class RemoveSubColumnTest
+public class RemoveSubColumnTest extends CleanupHelper
 {
     @Test
     public void testRemoveSubColumn() throws IOException, ExecutionException, InterruptedException

File: test/unit/org/apache/cassandra/db/RemoveSuperColumnTest.java
Patch:
@@ -33,9 +33,10 @@
 import static org.apache.cassandra.Util.addMutation;
 import static org.apache.cassandra.Util.getBytes;
 import org.apache.cassandra.Util;
+import org.apache.cassandra.CleanupHelper;
 import static junit.framework.Assert.assertNotNull;
 
-public class RemoveSuperColumnTest
+public class RemoveSuperColumnTest extends CleanupHelper
 {
     @Test
     public void testRemoveSuperColumn() throws IOException, ExecutionException, InterruptedException

File: src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
Patch:
@@ -91,11 +91,11 @@ public Collection<InetAddress> getWriteEndpoints(Token token, Collection<InetAdd
 
         List<InetAddress> endpoints = new ArrayList<InetAddress>(naturalEndpoints);
 
-        for (Map.Entry<Range, Collection<InetAddress>> entry : tokenMetadata_.getPendingRanges().entrySet())
+        for (Map.Entry<Range, InetAddress> entry : tokenMetadata_.getPendingRanges().entrySet())
         {
             if (entry.getKey().contains(token))
             {
-                endpoints.addAll(entry.getValue());
+                endpoints.add(entry.getValue());
             }
         }
 

File: src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
Patch:
@@ -91,11 +91,11 @@ public Collection<InetAddress> getWriteEndpoints(Token token, Collection<InetAdd
 
         List<InetAddress> endpoints = new ArrayList<InetAddress>(naturalEndpoints);
 
-        for (Map.Entry<Range, InetAddress> entry : tokenMetadata_.getPendingRanges().entrySet())
+        for (Map.Entry<Range, Collection<InetAddress>> entry : tokenMetadata_.getPendingRanges().entrySet())
         {
             if (entry.getKey().contains(token))
             {
-                endpoints.add(entry.getValue());
+                endpoints.addAll(entry.getValue());
             }
         }
 

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -145,7 +145,7 @@ public void run()
                     Message hintedMessage = rm.makeRowMutationMessage();
                     hintedMessage.addHeader(RowMutation.HINT, target.getAddress());
                     if (logger.isDebugEnabled())
-                        logger.debug("insert writing key " + rm.key() + " to " + unhintedMessage.getMessageId() + "@" + hintedTarget + " for " + target);
+                        logger.debug("insert writing key " + rm.key() + " to " + hintedMessage.getMessageId() + "@" + hintedTarget + " for " + target);
                     MessagingService.instance().sendOneWay(hintedMessage, hintedTarget);
                 }
             }

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -180,7 +180,7 @@ private void finishBootstrapping()
         SystemTable.setBootstrapped(true);
         setToken(getLocalToken());
         Gossiper.instance().addApplicationState(StorageService.STATE_NORMAL, new ApplicationState(partitioner_.getTokenFactory().toString(getLocalToken())));
-        logger_.info("Bootstrap completed! Now serving reads.");
+        logger_.info("Bootstrap/move completed! Now serving reads.");
     }
 
     /** This method updates the local token on disk  */

File: src/java/org/apache/cassandra/cli/CliClient.java
Patch:
@@ -224,7 +224,7 @@ private void doSlice(String keyspace, String key, String columnFamily, byte[] su
             else
             {
                 Column column = cosc.column;
-                css_.out.printf("=> (column=%s, value=%s; timestamp=%d)\n", new String(column.name, "UTF-8"),
+                css_.out.printf("=> (column=%s, value=%s, timestamp=%d)\n", new String(column.name, "UTF-8"),
                                 new String(column.value, "UTF-8"), column.timestamp);
             }
         }

File: src/java/org/apache/cassandra/db/Column.java
Patch:
@@ -132,7 +132,7 @@ public long getMarkedForDeleteAt()
         return timestamp;
     }
 
-    public long mostRecentChangeAt()
+    public long mostRecentLiveChangeAt()
     {
         return timestamp;
     }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1117,7 +1117,7 @@ public ColumnFamily getColumnFamily(QueryFilter filter, int gcBefore) throws IOE
             if (filter.path.superColumnName != null)
             {
                 QueryFilter nameFilter = new NamesQueryFilter(filter.key, new QueryPath(columnFamily_), filter.path.superColumnName);
-                ColumnFamily cf = getColumnFamilyInternal(nameFilter, getDefaultGCBefore());
+                ColumnFamily cf = getColumnFamilyInternal(nameFilter, gcBefore);
                 if (cf == null || cf.getColumnCount() == 0)
                     return cf;
 

File: src/java/org/apache/cassandra/db/IColumn.java
Patch:
@@ -30,7 +30,7 @@ public interface IColumn
 
     public boolean isMarkedForDelete();
     public long getMarkedForDeleteAt();
-    public long mostRecentChangeAt();
+    public long mostRecentLiveChangeAt();
     public byte[] name();
     public int size();
     public int serializedSize();

File: src/java/org/apache/cassandra/db/filter/NamesQueryFilter.java
Patch:
@@ -86,7 +86,7 @@ public void collectReducedColumns(IColumnContainer container, Iterator<IColumn>
         while (reducedColumns.hasNext())
         {
             IColumn column = reducedColumns.next();
-            if (!column.isMarkedForDelete() || column.getLocalDeletionTime() > gcBefore)
+            if (QueryFilter.isRelevant(column, container, gcBefore))
                 container.addColumn(column);
         }
     }

File: test/unit/org/apache/cassandra/db/RemoveSuperColumnTest.java
Patch:
@@ -153,7 +153,7 @@ public void testRemoveSuperColumnWithNewData() throws IOException, ExecutionExce
     private void validateRemoveWithNewData() throws IOException
     {
         ColumnFamilyStore store = Table.open("Keyspace1").getColumnFamilyStore("Super2");
-        ColumnFamily resolved = store.getColumnFamily(new NamesQueryFilter("key1", new QueryPath("Super2", "SC1".getBytes()), getBytes(2)));
+        ColumnFamily resolved = store.getColumnFamily(new NamesQueryFilter("key1", new QueryPath("Super2", "SC1".getBytes()), getBytes(2)), Integer.MAX_VALUE);
         Collection<IColumn> subColumns = resolved.getSortedColumns().iterator().next().getSubColumns();
         assert subColumns.size() == 1;
         assert subColumns.iterator().next().timestamp() == 2;

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -122,7 +122,7 @@ public synchronized static Gossiper instance()
         return gossiper_;
     }
 
-    private Timer gossipTimer_ = new Timer(false);
+    private Timer gossipTimer_;
     private InetAddress localEndPoint_;
     private long aVeryLongTime_;
     private Random random_ = new Random();
@@ -144,6 +144,7 @@ public synchronized static Gossiper instance()
 
     private Gossiper()
     {
+        gossipTimer_ = new Timer(false);
         aVeryLongTime_ = 259200 * 1000;
         /* register with the Failure Detector for receiving Failure detector events */
         FailureDetector.instance().registerFailureDetectionEventListener(this);
@@ -834,6 +835,7 @@ public synchronized void addApplicationState(String key, ApplicationState appSta
     public void stop()
     {
         gossipTimer_.cancel();
+        gossipTimer_ = new Timer(false); // makes the Gossiper reentrant.
     }
 }
 

File: src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
Patch:
@@ -31,6 +31,7 @@
 import org.apache.cassandra.gms.FailureDetector;
 import org.apache.cassandra.service.IResponseResolver;
 import org.apache.cassandra.service.QuorumResponseHandler;
+import org.apache.cassandra.service.WriteResponseHandler;
 import org.apache.cassandra.utils.FBUtilities;
 
 /**
@@ -55,9 +56,9 @@ public abstract class AbstractReplicationStrategy
 
     public abstract ArrayList<InetAddress> getNaturalEndpoints(Token token, TokenMetadata metadata);
     
-    public <T> QuorumResponseHandler<T> getResponseHandler(IResponseResolver<T> responseResolver, int blockFor, int consistency_level)
+    public WriteResponseHandler getWriteResponseHandler(int blockFor, int consistency_level)
     {
-        return new QuorumResponseHandler<T>(blockFor, responseResolver);
+        return new WriteResponseHandler(blockFor);
     }
 
     public ArrayList<InetAddress> getNaturalEndpoints(Token token)

File: src/java/org/apache/cassandra/service/DatacenterQuorumResponseHandler.java
Patch:
@@ -16,16 +16,16 @@
  * provided in the input map. it will block till we recive response from (DC, n)
  * nodes.
  */
-public class DatacenterQuorumResponseHandler<T> extends QuorumResponseHandler<T>
+public class DatacenterQuorumResponseHandler extends WriteResponseHandler
 {
     private int blockFor;
     private IEndPointSnitch endpointsnitch;
     private InetAddress localEndpoint;
 
-    public DatacenterQuorumResponseHandler(int blockFor, IResponseResolver<T> responseResolver)
+    public DatacenterQuorumResponseHandler(int blockFor)
     {
         // Response is been managed by the map so the waitlist size really doesnt matter.
-        super(blockFor, responseResolver);
+        super(blockFor);
         this.blockFor = blockFor;
         endpointsnitch = DatabaseDescriptor.getEndPointSnitch();
         localEndpoint = FBUtilities.getLocalAddress();

File: src/java/org/apache/cassandra/service/DatacenterQuorumSyncResponseHandler.java
Patch:
@@ -15,15 +15,15 @@
  * provided in the input map. it will block till we recive response from
  * n nodes in each of our data centers.
  */
-public class DatacenterQuorumSyncResponseHandler<T> extends QuorumResponseHandler<T>
+public class DatacenterQuorumSyncResponseHandler extends WriteResponseHandler
 {
     private final Map<String, Integer> dcResponses = new HashMap<String, Integer>();
     private final Map<String, Integer> responseCounts;
 
-    public DatacenterQuorumSyncResponseHandler(Map<String, Integer> responseCounts, IResponseResolver<T> responseResolver)
+    public DatacenterQuorumSyncResponseHandler(Map<String, Integer> responseCounts)
     {
         // Response is been managed by the map so make it 1 for the superclass.
-        super(1, responseResolver);
+        super(1);
         this.responseCounts = responseCounts;
     }
 

File: src/java/org/apache/cassandra/service/ReadResponseResolver.java
Patch:
@@ -47,7 +47,7 @@
  */
 public class ReadResponseResolver implements IResponseResolver<Row>
 {
-	private static Logger logger_ = Logger.getLogger(WriteResponseResolver.class);
+	private static Logger logger_ = Logger.getLogger(ReadResponseResolver.class);
 
 	/*
 	 * This method for resolving read data should look at the timestamps of each

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -1037,9 +1037,9 @@ public void run()
         unbootstrap(finishMoving);
     }
 
-    public <T> QuorumResponseHandler<T> getResponseHandler(IResponseResolver<T> responseResolver, int blockFor, int consistency_level)
+    public WriteResponseHandler getWriteResponseHandler(int blockFor, int consistency_level)
     {
-        return replicationStrategy_.getResponseHandler(responseResolver, blockFor, consistency_level);
+        return replicationStrategy_.getWriteResponseHandler(blockFor, consistency_level);
     }
 
     public AbstractReplicationStrategy getReplicationStrategy()

File: src/java/org/apache/cassandra/io/SSTable.java
Patch:
@@ -132,7 +132,8 @@ public String getFilename()
     /** @return full paths to all the files associated w/ this SSTable */
     public List<String> getAllFilenames()
     {
-        return Arrays.asList(getFilename(), indexFilename(), filterFilename());
+        // TODO streaming relies on the -Data (getFilename) file to be last, this is clunky
+        return Arrays.asList(indexFilename(), filterFilename(), getFilename());
     }
 
     public String getColumnFamilyName()

File: src/java/org/apache/cassandra/io/Streaming.java
Patch:
@@ -83,9 +83,9 @@ private static void transferOneTable(InetAddress target, List<String> fileList,
         {
             File file = new File(filename);
             streamContexts[i++] = new StreamContextManager.StreamContext(file.getAbsolutePath(), file.length(), table);
-            if (logger.isDebugEnabled())
-              logger.debug("Stream context metadata " + streamContexts[i]);
         }
+        if (logger.isDebugEnabled())
+          logger.debug("Stream context metadata " + StringUtils.join(streamContexts, ", "));
 
         StreamManager.instance(target).addFilesToStream(streamContexts);
         StreamInitiateMessage biMessage = new StreamInitiateMessage(streamContexts);

File: src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
Patch:
@@ -66,6 +66,8 @@ public ColumnIterator getSSTableColumnIterator(SSTableReader sstable) throws IOE
 
     public SuperColumn filterSuperColumn(SuperColumn superColumn, int gcBefore)
     {
+        // we clone shallow, then add, under the theory that generally we're interested in a relatively small number of subcolumns.
+        // this may be a poor assumption.
         SuperColumn scFiltered = superColumn.cloneMeShallow();
         Iterator<IColumn> subcolumns;
         if (reversed)

File: test/unit/org/apache/cassandra/db/RemoveSuperColumnTest.java
Patch:
@@ -100,8 +100,8 @@ private void validateRemoveTwoSources() throws IOException
     {
         ColumnFamilyStore store = Table.open("Keyspace1").getColumnFamilyStore("Super1");
         ColumnFamily resolved = store.getColumnFamily(new NamesQueryFilter("key1", new QueryPath("Super1"), "SC1".getBytes()));
-        assert resolved.getSortedColumns().iterator().next().getMarkedForDeleteAt() == 1;
-        assert resolved.getSortedColumns().iterator().next().getSubColumns().size() == 0;
+        assert resolved.getSortedColumns().iterator().next().getMarkedForDeleteAt() == 1 : resolved;
+        assert resolved.getSortedColumns().iterator().next().getSubColumns().size() == 0 : resolved;
         assertNull(ColumnFamilyStore.removeDeleted(resolved, Integer.MAX_VALUE));
         assertNull(store.getColumnFamily(new NamesQueryFilter("key1", new QueryPath("Super1"), "SC1".getBytes()), Integer.MAX_VALUE));
         assertNull(store.getColumnFamily(new IdentityQueryFilter("key1", new QueryPath("Super1")), Integer.MAX_VALUE));

File: src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
Patch:
@@ -58,7 +58,7 @@ public abstract class AbstractReplicationStrategy
 
     public abstract ArrayList<InetAddress> getNaturalEndpoints(Token token, TokenMetadata metadata);
     
-    public <T> QuorumResponseHandler<T> getResponseHandler(IResponseResolver<T> responseResolver, int blockFor, int consistency_level) throws InvalidRequestException
+    public <T> QuorumResponseHandler<T> getResponseHandler(IResponseResolver<T> responseResolver, int blockFor, int consistency_level)
     {
         return new QuorumResponseHandler<T>(blockFor, responseResolver);
     }

File: src/java/org/apache/cassandra/locator/DatacenterShardStategy.java
Patch:
@@ -200,7 +200,6 @@ private ArrayList<InetAddress> getNaturalEndpointsInternal(Token searchToken, To
      */
     @Override
     public <T> QuorumResponseHandler<T> getResponseHandler(IResponseResolver<T> responseResolver, int blockFor, int consistency_level)
-    throws InvalidRequestException
     {
         if (consistency_level == ConsistencyLevel.DCQUORUM)
         {

File: src/java/org/apache/cassandra/service/DatacenterQuorumResponseHandler.java
Patch:
@@ -24,7 +24,6 @@ public class DatacenterQuorumResponseHandler<T> extends QuorumResponseHandler<T>
     private InetAddress localEndpoint;
 
     public DatacenterQuorumResponseHandler(int blockFor, IResponseResolver<T> responseResolver)
-    throws InvalidRequestException
     {
         // Response is been managed by the map so the waitlist size really doesnt matter.
         super(blockFor, responseResolver);

File: src/java/org/apache/cassandra/service/DatacenterQuorumSyncResponseHandler.java
Patch:
@@ -21,7 +21,6 @@ public class DatacenterQuorumSyncResponseHandler<T> extends QuorumResponseHandle
     private final Map<String, Integer> responseCounts;
 
     public DatacenterQuorumSyncResponseHandler(Map<String, Integer> responseCounts, IResponseResolver<T> responseResolver)
-    throws InvalidRequestException
     {
         // Response is been managed by the map so make it 1 for the superclass.
         super(1, responseResolver);

File: src/java/org/apache/cassandra/service/QuorumResponseHandler.java
Patch:
@@ -44,7 +44,7 @@ public class QuorumResponseHandler<T> implements IAsyncCallback
     private IResponseResolver<T> responseResolver_;
     private long startTime_;
 
-    public QuorumResponseHandler(int responseCount, IResponseResolver<T> responseResolver) throws InvalidRequestException
+    public QuorumResponseHandler(int responseCount, IResponseResolver<T> responseResolver)
     {
         assert 1 <= responseCount && responseCount <= DatabaseDescriptor.getReplicationFactor()
             : "invalid response count " + responseCount;

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -868,7 +868,7 @@ public List<String> getSplits(int splits)
         return tokens;
     }
 
-    public <T> QuorumResponseHandler<T> getResponseHandler(IResponseResolver<T> responseResolver, int blockFor, int consistency_level) throws InvalidRequestException, UnavailableException
+    public <T> QuorumResponseHandler<T> getResponseHandler(IResponseResolver<T> responseResolver, int blockFor, int consistency_level)
     {
         return replicationStrategy_.getResponseHandler(responseResolver, blockFor, consistency_level);
     }

File: test/unit/org/apache/cassandra/dht/BootStrapperTest.java
Patch:
@@ -50,7 +50,7 @@ private void testSourceTargetComputation(int numOldNodes) throws UnknownHostExce
 
         generateFakeEndpoints(numOldNodes);
         
-        Token myToken = StorageService.getPartitioner().getDefaultToken();
+        Token myToken = StorageService.getPartitioner().getRandomToken();
         InetAddress myEndpoint = InetAddress.getByName("127.0.0.1");
 
         TokenMetadata tmd = ss.getTokenMetadata();
@@ -94,7 +94,7 @@ private void generateFakeEndpoints(int numOldNodes) throws UnknownHostException
         for (int i = 1; i <= numOldNodes; i++)
         {
             // leave .1 for myEndpoint
-            tmd.update(p.getDefaultToken(), InetAddress.getByName("127.0.0." + (i + 1)));
+            tmd.update(p.getRandomToken(), InetAddress.getByName("127.0.0." + (i + 1)));
         }
     }
 }
\ No newline at end of file

File: src/java/org/apache/cassandra/locator/TokenMetadata.java
Patch:
@@ -114,7 +114,8 @@ public void update(Token token, InetAddress endpoint)
     public Token getToken(InetAddress endpoint)
     {
         assert endpoint != null;
-
+        assert isMember(endpoint); // don't want to return nulls
+        
         lock.readLock().lock();
         try
         {
@@ -126,7 +127,7 @@ public Token getToken(InetAddress endpoint)
         }
     }
     
-    public boolean isKnownEndPoint(InetAddress endpoint)
+    public boolean isMember(InetAddress endpoint)
     {
         assert endpoint != null;
 

File: src/java/org/apache/cassandra/locator/DatacenterEndPointSnitch.java
Patch:
@@ -49,7 +49,6 @@ public class DatacenterEndPointSnitch implements IEndPointSnitch
     public DatacenterEndPointSnitch() throws IOException,
                                              ParserConfigurationException, SAXException
     {
-        super();
         xmlUtils = new XMLUtils(DEFAULT_RACK_CONFIG_FILE);
         reloadConfiguration();
     }

File: src/java/org/apache/cassandra/dht/BootStrapper.java
Patch:
@@ -182,7 +182,7 @@ public void startBootstrap() throws IOException
             {
                 Token<?> t = getBootstrapTokenFrom(maxEndpoint);
                 logger.info("Setting token to " + t + " to assume load from " + maxEndpoint);
-                ss.updateToken(t);
+                ss.setToken(t);
             }
         }
 
@@ -193,7 +193,7 @@ public void run()
                 // Mark as not bootstrapping to calculate ranges correctly
                 for (int i=0; i< targets.size(); i++)
                 {
-                    tokenMetadata.update(tokens[i], targets.get(i), false);
+                    tokenMetadata.setBootstrapping(targets.get(i), false);
                 }
 
                 Map<Range, List<BootstrapSourceTarget>> rangesWithSourceTarget = getRangesWithSourceTarget();
@@ -210,7 +210,7 @@ public void run()
                 }
             }
         }).start();
-        Gossiper.instance().addApplicationState(StorageService.BOOTSTRAP_MODE, new ApplicationState(""));
+        Gossiper.instance().addApplicationState(StorageService.MODE, new ApplicationState(StorageService.MODE_MOVING));
     }
 
     public static class BootstrapTokenVerbHandler implements IVerbHandler

File: src/java/org/apache/cassandra/service/TokenUpdateVerbHandler.java
Patch:
@@ -38,10 +38,8 @@ public void doVerb(Message message)
         bufIn.reset(body, body.length);
         try
         {
-            /* Deserialize to get the token for this endpoint. */
             Token token = Token.serializer().deserialize(bufIn);
-            logger_.info("Updating the token to [" + token + "]");
-            StorageService.instance().updateToken(token);
+            StorageService.instance().setAndBroadcastToken(token);
         }
         catch (IOException ex)
         {

File: test/unit/org/apache/cassandra/locator/RackUnawareStrategyTest.java
Patch:
@@ -118,7 +118,8 @@ public void testGetEndpointsDuringBootstrap() throws UnknownHostException
         //Add bootstrap node id=6
         Token bsToken = new BigIntegerToken(String.valueOf(25));
         InetAddress bootstrapEndPoint = InetAddress.getByName("127.0.0.6");
-        tmd.update(bsToken, bootstrapEndPoint, true);
+        tmd.setBootstrapping(bootstrapEndPoint, true);
+        tmd.update(bsToken, bootstrapEndPoint);
         
         for (int i = 0; i < keyTokens.length; i++)
         {

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -140,7 +140,7 @@ public static void insert(RowMutation rm)
     public static void insertBlocking(RowMutation rm, int consistency_level) throws UnavailableException
     {
         long startTime = System.currentTimeMillis();
-        Message message = null;
+        Message message;
         try
         {
             message = rm.makeRowMutationMessage();
@@ -299,7 +299,7 @@ public static List<Row> readProtocol(List<ReadCommand> commands, int consistency
             for (ReadCommand command: commands)
             {
                 List<InetAddress> endpoints = StorageService.instance().getNaturalEndpoints(command.key);
-                boolean foundLocal = Arrays.asList(endpoints).contains(FBUtilities.getLocalAddress());
+                boolean foundLocal = endpoints.contains(FBUtilities.getLocalAddress());
                 //TODO: Throw InvalidRequest if we're in bootstrap mode?
                 if (foundLocal && !StorageService.instance().isBootstrapMode())
                 {
@@ -389,7 +389,7 @@ private static List<Row> strongRead(List<ReadCommand> commands) throws IOExcepti
 
         for (QuorumResponseHandler<Row> quorumResponseHandler: quorumResponseHandlers)
         {
-            Row row = null;
+            Row row;
             ReadCommand command = commands.get(commandIndex);
             try
             {

File: src/java/org/apache/cassandra/db/BinaryMemtable.java
Patch:
@@ -144,7 +144,7 @@ public SSTableReader writeSortedContents(List<DecoratedKey> sortedKeys) throws I
             assert bytes.length > 0;
             writer.append(key, bytes);
         }
-        SSTableReader sstable = writer.closeAndOpenReader();
+        SSTableReader sstable = writer.closeAndOpenReader(DatabaseDescriptor.getKeysCachedFraction(table_));
         logger_.info("Completed flushing " + writer.getFilename());
         return sstable;
     }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -814,7 +814,7 @@ List<SSTableReader> doFileAntiCompaction(Collection<SSTableReader> sstables, Col
 
         if (writer != null)
         {
-            results.add(writer.closeAndOpenReader());
+            results.add(writer.closeAndOpenReader(DatabaseDescriptor.getKeysCachedFraction(table_)));
             String format = "AntiCompacted to %s.  %d/%d bytes for %d keys.  Time: %dms.";
             long dTime = System.currentTimeMillis() - startTime;
             logger_.info(String.format(format, writer.getFilename(), getTotalBytes(sstables), results.get(0).length(), totalkeysWritten, dTime));
@@ -890,7 +890,7 @@ int doFileCompaction(Collection<SSTableReader> sstables, int gcBefore) throws IO
             ci.close();
         }
 
-        SSTableReader ssTable = writer.closeAndOpenReader();
+        SSTableReader ssTable = writer.closeAndOpenReader(DatabaseDescriptor.getKeysCachedFraction(table_));
         ssTables_.add(ssTable);
         ssTables_.markCompacted(sstables);
         CompactionManager.instance().submit(ColumnFamilyStore.this);

File: src/java/org/apache/cassandra/db/Memtable.java
Patch:
@@ -217,8 +217,8 @@ public SSTableReader writeSortedContents(List<DecoratedKey> sortedKeys) throws I
             /* Now write the key and value to disk */
             writer.append(key, buffer);
         }
-        buffer.close();
-        SSTableReader ssTable = writer.closeAndOpenReader();
+
+        SSTableReader ssTable = writer.closeAndOpenReader(DatabaseDescriptor.getKeysCachedFraction(table_));
         isFlushed_ = true;
         logger_.info("Completed flushing " + ssTable.getFilename());
         return ssTable;

File: test/unit/org/apache/cassandra/io/SSTableTest.java
Patch:
@@ -42,7 +42,7 @@ public void testSingleWrite() throws IOException {
 
         String key = Integer.toString(1);
         writer.append(writer.partitioner.decorateKey(key), bytes);
-        SSTableReader ssTable = writer.closeAndOpenReader();
+        SSTableReader ssTable = writer.closeAndOpenReader(0.01);
 
         // verify
         verifySingle(ssTable, bytes, key);
@@ -82,7 +82,7 @@ public void testManyWrites() throws IOException {
         {
             writer.append(writer.partitioner.decorateKey(key), map.get(key));
         }
-        SSTableReader ssTable = writer.closeAndOpenReader();
+        SSTableReader ssTable = writer.closeAndOpenReader(0.01);
 
         // verify
         verifyMany(ssTable, map);

File: src/java/org/apache/cassandra/db/marshal/BytesType.java
Patch:
@@ -34,6 +34,6 @@ public int compare(byte[] o1, byte[] o2)
 
     public String getString(byte[] bytes)
     {
-        return Arrays.toString(bytes);
+        return FBUtilities.bytesToHex(bytes);
     }
 }

File: src/java/org/apache/cassandra/dht/BootStrapper.java
Patch:
@@ -37,6 +37,7 @@
  import org.apache.commons.lang.ArrayUtils;
 
  import org.apache.cassandra.locator.TokenMetadata;
+ import org.apache.cassandra.locator.AbstractReplicationStrategy;
  import org.apache.cassandra.net.*;
  import org.apache.cassandra.net.io.StreamContextManager;
  import org.apache.cassandra.net.io.IStreamComplete;
@@ -208,6 +209,7 @@ public static void startBootstrap() throws IOException
 
             if (!maxEndpoint.equals(StorageService.getLocalStorageEndPoint()))
             {
+                StorageService.instance().retrofitPorts(Arrays.asList(maxEndpoint));
                 Token<?> t = getBootstrapTokenFrom(maxEndpoint);
                 logger_.info("Setting token to " + t + " to assume load from " + maxEndpoint.getHost());
                 ss.updateToken(t);

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -95,7 +95,7 @@ public void run()
     final static String GOSSIP_DIGEST_ACK_VERB = "GAV";
     /* GA2V - abbreviation for GOSSIP-DIGEST-ACK2-VERB */
     final static String GOSSIP_DIGEST_ACK2_VERB = "GA2V";
-    final static int intervalInMillis_ = 1000;
+    public final static int intervalInMillis_ = 1000;
     private static Logger logger_ = Logger.getLogger(Gossiper.class);
     static Gossiper gossiper_;
 
@@ -522,6 +522,8 @@ synchronized EndPointState getStateForVersionBiggerThan(EndPoint forEndpoint, in
                     {
                         reqdEndPointState = new EndPointState(epState.getHeartBeatState());
                     }
+                    if (logger_.isTraceEnabled())
+                        logger_.trace("Adding state " + key + ": " + appState.getState());
                     reqdEndPointState.addApplicationState(key, appState);
                 }
             }

File: src/java/org/apache/cassandra/locator/AbstractReplicationStrategy.java
Patch:
@@ -73,7 +73,7 @@ public Map<EndPoint, EndPoint> getHintedStorageEndPoints(Token token)
      * This method changes the ports of the endpoints from
      * the control port to the storage ports.
     */
-    protected void retrofitPorts(List<EndPoint> eps)
+    public void retrofitPorts(List<EndPoint> eps)
     {
         for ( EndPoint ep : eps )
         {

File: src/java/org/apache/cassandra/service/StorageLoadBalancer.java
Patch:
@@ -351,8 +351,9 @@ public Map<EndPoint, Double> getLoadInfo()
 
     public void startBroadcasting()
     {
-        /* starts a load timer thread */
-        loadTimer_.schedule(new LoadDisseminator(), BROADCAST_INTERVAL, BROADCAST_INTERVAL);
+        // send the first broadcast "right away" (i.e., in 2 gossip heartbeats, when we should have someone to talk to);
+        // after that send every BROADCAST_INTERVAL.
+        loadTimer_.schedule(new LoadDisseminator(), 2 * Gossiper.intervalInMillis_, BROADCAST_INTERVAL);
     }
 
     /** wait for node information to be available.  if the rest of the cluster just came up,

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1011,7 +1011,6 @@ public Iterator<String> memtableKeyIterator() throws ExecutionException, Interru
         }
     }
 
-    /** not threadsafe.  caller must have lock_ acquired. */
     public Collection<SSTableReader> getSSTables()
     {
         return ssTables_.getSSTables();

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1325,5 +1325,6 @@ public void snapshot(String snapshotName) throws IOException
     void clearUnsafe()
     {
         memtable_.clearUnsafe();
+        ssTables_.clearUnsafe();
     }
 }

File: src/java/org/apache/cassandra/db/ColumnSerializer.java
Patch:
@@ -41,8 +41,8 @@ public static void writeName(byte[] name, DataOutput out) throws IOException
     public static byte[] readName(DataInput in) throws IOException
     {
         int length = 0;
-        length |= (in.readByte() << 8);
-        length |= in.readByte();
+        length |= (in.readByte() & 0xFF) << 8;
+        length |= in.readByte() & 0xFF;
         byte[] bytes = new byte[length];
         in.readFully(bytes);
         return bytes;

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1361,7 +1361,7 @@ public void remove()
         }
 
         Iterator<String> collated = IteratorUtils.collatedIterator(comparator, iterators);
-        Iterable<String> reduced = new ReducingIterator<String>(collated) {
+        Iterable<String> reduced = new ReducingIterator<String, String>(collated) {
             String current;
 
             public void reduce(String current)

File: src/java/org/apache/cassandra/db/filter/QueryFilter.java
Patch:
@@ -82,7 +82,7 @@ public void collectCollatedColumns(final ColumnFamily returnCF, Iterator<IColumn
     {
         // define a 'reduced' iterator that merges columns w/ the same name, which
         // greatly simplifies computing liveColumns in the presence of tombstones.
-        ReducingIterator<IColumn> reduced = new ReducingIterator<IColumn>(collatedColumns)
+        ReducingIterator<IColumn, IColumn> reduced = new ReducingIterator<IColumn, IColumn>(collatedColumns)
         {
             ColumnFamily curCF = returnCF.cloneMeShallow();
 

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -95,7 +95,7 @@ public static EndPoint getLocalControlEndPoint()
         return udpAddr_;
     }
 
-    public static IPartitioner getPartitioner() {
+    public static IPartitioner<?> getPartitioner() {
         return partitioner_;
     }
 

File: test/unit/org/apache/cassandra/db/CompactionsTest.java
Patch:
@@ -51,7 +51,7 @@ public void testCompactions() throws IOException, ExecutionException, Interrupte
                 inserted.add(key);
             }
             store.forceBlockingFlush();
-            assertEquals(table.getColumnFamilyStore("Standard1").getKeyRange("", "", 10000).keys.size(), inserted.size());
+            assertEquals(inserted.size(), table.getColumnFamilyStore("Standard1").getKeyRange("", "", 10000).keys.size());
         }
         while (true)
         {
@@ -63,6 +63,6 @@ public void testCompactions() throws IOException, ExecutionException, Interrupte
         {
             store.doCompaction(2, store.getSSTables().size());
         }
-        assertEquals(table.getColumnFamilyStore("Standard1").getKeyRange("", "", 10000).keys.size(), inserted.size());
+        assertEquals(inserted.size(), table.getColumnFamilyStore("Standard1").getKeyRange("", "", 10000).keys.size());
     }
 }

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -514,6 +514,8 @@ public static void shutdown()
             messageDeserializerExecutor_.shutdownNow();
             streamExecutor_.shutdownNow();
 
+            StageManager.shutdown();
+            
             /* shut down the cachetables */
             taskCompletionMap_.shutdown();
             callbackMap_.shutdown();

File: src/java/org/apache/cassandra/service/ReadResponseResolver.java
Patch:
@@ -145,7 +145,8 @@ public Row resolve(List<Message> responses) throws DigestMismatchException
             RowMutationMessage rowMutationMessage = new RowMutationMessage(rowMutation);
 	        ReadRepairManager.instance().schedule(endPoints.get(i),rowMutationMessage);
 		}
-        logger_.info("resolve: " + (System.currentTimeMillis() - startTime) + " ms.");
+        if (logger_.isDebugEnabled())
+            logger_.debug("resolve: " + (System.currentTimeMillis() - startTime) + " ms.");
 		return retRow;
 	}
 

File: src/java/org/apache/cassandra/db/BinaryMemtable.java
Patch:
@@ -175,7 +175,7 @@ void flush() throws IOException
                 writer.append(key, bytes);
             }
         }
-        cfStore.addSSTable(writer.closeAndOpenReader());
+        cfStore.storeLocation(writer.closeAndOpenReader());
         columnFamilies_.clear();       
     }
 }

File: src/java/org/apache/cassandra/db/Memtable.java
Patch:
@@ -214,7 +214,7 @@ public int compare(String o1, String o2)
         }
         SSTableReader ssTable = writer.closeAndOpenReader();
         cfStore.onMemtableFlush(cLogCtx);
-        cfStore.addSSTable(ssTable);
+        cfStore.storeLocation(ssTable);
         buffer.close();
         isFlushed_ = true;
         logger_.info("Completed flushing " + this);

File: src/java/org/apache/cassandra/db/BinaryMemtable.java
Patch:
@@ -175,7 +175,7 @@ void flush() throws IOException
                 writer.append(key, bytes);
             }
         }
-        cfStore.storeLocation(writer.closeAndOpenReader(DatabaseDescriptor.getKeysCachedFraction(table_)));
+        cfStore.storeLocation(writer.closeAndOpenReader());
         columnFamilies_.clear();       
     }
 }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1009,7 +1009,7 @@ boolean doFileAntiCompaction(List<String> files, List<Range> ranges, EndPoint ta
 
         if (rangeWriter != null)
         {
-            rangeWriter.closeAndOpenReader(DatabaseDescriptor.getKeysCachedFraction(table_));
+            rangeWriter.closeAndOpenReader();
             if (fileList != null)
             {
                 //Retain order. The -Data.db file needs to be last because 
@@ -1160,7 +1160,7 @@ private int doFileCompaction(List<String> files, int minBufferSize) throws IOExc
         if (writer != null)
         {
             // TODO if all the keys were the same nothing will be done here
-            ssTable = writer.closeAndOpenReader(DatabaseDescriptor.getKeysCachedFraction(table_));
+            ssTable = writer.closeAndOpenReader();
             newfile = writer.getFilename();
         }
         sstableLock_.writeLock().lock();

File: src/java/org/apache/cassandra/db/Memtable.java
Patch:
@@ -212,7 +212,7 @@ public int compare(String o1, String o2)
                 writer.append(partitioner.decorateKey(key), buffer);
             }
         }
-        SSTableReader ssTable = writer.closeAndOpenReader(DatabaseDescriptor.getKeysCachedFraction(table_));
+        SSTableReader ssTable = writer.closeAndOpenReader();
         cfStore.onMemtableFlush(cLogCtx);
         cfStore.storeLocation(ssTable);
         buffer.close();

File: test/unit/org/apache/cassandra/io/SSTableTest.java
Patch:
@@ -41,7 +41,7 @@ public void testSingleWrite() throws IOException {
 
         String key = Integer.toString(1);
         writer.append(key, bytes);
-        SSTableReader ssTable = writer.closeAndOpenReader(0.01);
+        SSTableReader ssTable = writer.closeAndOpenReader();
 
         // verify
         verifySingle(ssTable, bytes, key);
@@ -81,7 +81,7 @@ public void testManyWrites() throws IOException {
         {
             writer.append(key, map.get(key));
         }
-        SSTableReader ssTable = writer.closeAndOpenReader(0.01);
+        SSTableReader ssTable = writer.closeAndOpenReader();
 
         // verify
         verifyMany(ssTable, map);

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -24,6 +24,8 @@
 import java.util.Set;
 
 import org.apache.log4j.Logger;
+import org.apache.log4j.Level;
+
 import org.apache.thrift.protocol.TBinaryProtocol;
 import org.apache.thrift.protocol.TProtocolFactory;
 import org.apache.thrift.server.TThreadPoolServer;

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -609,7 +609,7 @@ private static AbstractType getComparator(Node columnFamily, String attr)
         String compareWith = XMLUtils.getAttributeValue(columnFamily, attr);
         if (compareWith == null)
         {
-            typeClass = AsciiType.class;
+            typeClass = BytesType.class;
         }
         else
         {

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -642,11 +642,11 @@ void load(Row row) throws IOException
         for (ColumnFamily columnFamily : row.getColumnFamilies())
         {
             Collection<IColumn> columns = columnFamily.getSortedColumns();
-            for(IColumn column : columns)
+            for (IColumn column : columns)
             {
-                ColumnFamilyStore cfStore = columnFamilyStores_.get(column.name());
+                ColumnFamilyStore cfStore = columnFamilyStores_.get(new String(column.name(), "UTF-8"));
                 cfStore.applyBinary(key, column.value());
-        	}
+            }
         }
         row.clear();
     }

File: src/java/org/apache/cassandra/net/TcpConnection.java
Patch:
@@ -387,7 +387,7 @@ public void write(SelectionKey key)
          resumeStreaming();        
     }
     
-    void doPendingWrites()
+    public void doPendingWrites()
     {
         synchronized(this)
         {

File: interface/gen-java/org/apache/cassandra/service/ColumnParent.java
Patch:
@@ -347,9 +347,6 @@ public String toString() {
 
   public void validate() throws TException {
     // check for required fields
-    if (column_family == null) {
-      throw new TProtocolException("Required field 'column_family' was not present! Struct: " + toString());
-    }
     // check that fields of type enum have valid values
   }
 

File: interface/gen-java/org/apache/cassandra/service/ColumnPath.java
Patch:
@@ -441,9 +441,6 @@ public String toString() {
 
   public void validate() throws TException {
     // check for required fields
-    if (column_family == null) {
-      throw new TProtocolException("Required field 'column_family' was not present! Struct: " + toString());
-    }
     // check that fields of type enum have valid values
   }
 

File: interface/gen-java/org/apache/cassandra/service/InvalidRequestException.java
Patch:
@@ -253,9 +253,6 @@ public String toString() {
 
   public void validate() throws TException {
     // check for required fields
-    if (why == null) {
-      throw new TProtocolException("Required field 'why' was not present! Struct: " + toString());
-    }
     // check that fields of type enum have valid values
   }
 

File: test/unit/org/apache/cassandra/db/BootstrapTest.java
Patch:
@@ -31,6 +31,8 @@
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.StringToken;
+import org.apache.cassandra.dht.BytesToken;
+import org.apache.cassandra.dht.CollatingOrderPreservingPartitioner;
 import org.apache.cassandra.net.EndPoint;
 import org.apache.cassandra.net.io.StreamContextManager;
 import org.junit.Test;
@@ -45,7 +47,6 @@ private void testAntiCompaction(String columnFamilyName, int insertsPerTable) th
     {
         Table table = Table.open("Keyspace1");
         ColumnFamilyStore store = table.getColumnFamilyStore(columnFamilyName);
-
        
         for (int j = 0; j < insertsPerTable; j++) 
         {
@@ -58,7 +59,7 @@ private void testAntiCompaction(String columnFamilyName, int insertsPerTable) th
         store.forceBlockingFlush();
         List<String> fileList = new ArrayList<String>();
         List<Range> ranges  = new ArrayList<Range>();
-        Range r = new Range(new StringToken("0"), new StringToken("zzzzzz"));
+        Range r = new Range(CollatingOrderPreservingPartitioner.MINIMUM, new BytesToken("zzzzzz".getBytes()));
         ranges.add(r);
 
         boolean result = store.doAntiCompaction(ranges, new EndPoint("127.0.0.1", 9150), fileList);

File: src/java/org/apache/cassandra/locator/IReplicaPlacementStrategy.java
Patch:
@@ -33,6 +33,7 @@
 public interface IReplicaPlacementStrategy
 {
 	public EndPoint[] getStorageEndPoints(Token token);
+	public EndPoint[] getStorageEndPointsForWrite(Token token);
     public Map<String, EndPoint[]> getStorageEndPoints(String[] keys);
     public EndPoint[] getStorageEndPoints(Token token, Map<Token, EndPoint> tokenToEndPointMap);
     public Map<EndPoint, EndPoint> getHintedStorageEndPoints(Token token);

File: src/java/org/apache/cassandra/db/marshal/LongType.java
Patch:
@@ -37,8 +37,8 @@ public int compare(byte[] o1, byte[] o2)
             return 1;
         }
 
-        long L1 = ByteBuffer.wrap(o1).order(ByteOrder.LITTLE_ENDIAN).getLong();
-        long L2 = ByteBuffer.wrap(o2).order(ByteOrder.LITTLE_ENDIAN).getLong();
+        long L1 = ByteBuffer.wrap(o1).getLong();
+        long L2 = ByteBuffer.wrap(o2).getLong();
         return Long.valueOf(L1).compareTo(Long.valueOf(L2));
     }
 

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -45,7 +45,6 @@
 import org.apache.commons.lang.ArrayUtils;
 import org.apache.commons.collections.IteratorUtils;
 import org.apache.commons.collections.Predicate;
-import org.apache.commons.collections.iterators.ReverseListIterator;
 
 import org.cliffc.high_scale_lib.NonBlockingHashMap;
 
@@ -978,7 +977,7 @@ boolean doFileAntiCompaction(List<String> files, List<Range> ranges, EndPoint ta
                     FileStruct filestruct = lfs.get(0);
                     ColumnFamily.serializer().serializeWithIndexes(filestruct.getColumnFamily(), bufOut);
                 }
-                if (Range.isTokenInRanges(StorageService.getPartitioner().getInitialToken(lastkey), ranges))
+                if (Range.isTokenInRanges(StorageService.getPartitioner().getToken(lastkey), ranges))
                 {
                     if (rangeWriter == null)
                     {
@@ -1001,7 +1000,7 @@ boolean doFileAntiCompaction(List<String> files, List<Range> ranges, EndPoint ta
                         continue;
                     }
                     /* keep on looping until we find a key in the range */
-                    while (!Range.isTokenInRanges(StorageService.getPartitioner().getInitialToken(filestruct.getKey()), ranges))
+                    while (!Range.isTokenInRanges(StorageService.getPartitioner().getToken(filestruct.getKey()), ranges))
                     {
                         filestruct.advance(true);
                         if (filestruct.isExhausted())

File: src/java/org/apache/cassandra/db/SystemTable.java
Patch:
@@ -103,6 +103,7 @@ public static synchronized StorageMetadata initMetadata() throws IOException
         if (cf == null)
         {
             Token token = p.getDefaultToken();
+            logger.info("Saved Token not found. Using " + token);
             int generation = 1;
 
             RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, LOCATION_KEY);
@@ -118,6 +119,7 @@ public static synchronized StorageMetadata initMetadata() throws IOException
         /* we crashed and came back up need to bump generation # */
         IColumn tokenColumn = cf.getColumn(TOKEN);
         Token token = p.getTokenFactory().fromByteArray(tokenColumn.value());
+        logger.info("Saved Token found: " + token);
 
         IColumn generation = cf.getColumn(GENERATION);
         int gen = BasicUtilities.byteArrayToInt(generation.value()) + 1;

File: src/java/org/apache/cassandra/dht/OrderPreservingPartitioner.java
Patch:
@@ -116,7 +116,7 @@ public Token.TokenFactory<String> getTokenFactory()
         return tokenFactory;
     }
 
-    public Token getInitialToken(String key)
+    public Token getToken(String key)
     {
         return new StringToken(key);
     }

File: src/java/org/apache/cassandra/dht/RandomPartitioner.java
Patch:
@@ -120,7 +120,7 @@ public Token.TokenFactory<BigInteger> getTokenFactory()
         return tokenFactory;
     }
 
-    public Token getInitialToken(String key)
+    public Token getToken(String key)
     {
         return new BigIntegerToken(FBUtilities.hash(key));
     }

File: src/java/org/apache/cassandra/locator/RackAwareStrategy.java
Patch:
@@ -129,7 +129,7 @@ public Map<String, EndPoint[]> getStorageEndPoints(String[] keys)
 
         for ( String key : keys )
         {
-            results.put(key, getStorageEndPoints(partitioner_.getInitialToken(key)));
+            results.put(key, getStorageEndPoints(partitioner_.getToken(key)));
         }
 
         return results;

File: src/java/org/apache/cassandra/locator/RackUnawareStrategy.java
Patch:
@@ -85,7 +85,7 @@ public Map<String, EndPoint[]> getStorageEndPoints(String[] keys)
 
         for ( String key : keys )
         {
-            results.put(key, getStorageEndPoints(partitioner_.getInitialToken(key)));
+            results.put(key, getStorageEndPoints(partitioner_.getToken(key)));
         }
 
         return results;

File: test/unit/org/apache/cassandra/db/SystemTableTest.java
Patch:
@@ -41,7 +41,7 @@ public void testOnlyOnceCreationOfStorageMetadata() throws IOException
     public void testTokenGetsUpdated() throws IOException
     {
         SystemTable.StorageMetadata storageMetadata1 = SystemTable.initMetadata();
-        SystemTable.updateToken(StorageService.getPartitioner().getInitialToken("503545744:0"));
+        SystemTable.updateToken(StorageService.getPartitioner().getToken("503545744:0"));
         SystemTable.StorageMetadata storageMetadata2 = SystemTable.initMetadata();
         Assert.assertTrue("smd should still be a singleton after updateToken", storageMetadata1 == storageMetadata2);
     }

File: test/unit/org/apache/cassandra/locator/RackUnawareStrategyTest.java
Patch:
@@ -59,7 +59,7 @@ public void testStringStorageEndPoints()
         List<Token> keyTokens = new ArrayList<Token>();
         for (int i = 0; i < 5; i++) {
             endPointTokens.add(new StringToken(String.valueOf((char)('a' + i * 2))));
-            keyTokens.add(partitioner.getInitialToken(String.valueOf((char)('a' + i * 2 + 1))));
+            keyTokens.add(partitioner.getToken(String.valueOf((char)('a' + i * 2 + 1))));
         }
         testGetStorageEndPoints(tmd, strategy, endPointTokens.toArray(new Token[0]), keyTokens.toArray(new Token[0]));
     }

File: src/java/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -88,7 +88,9 @@ public void setDigestQuery(boolean isDigestQuery)
 
     protected AbstractType getComparator()
     {
-        return DatabaseDescriptor.getComparator(table, getColumnFamilyName());
+        return queryPath.superColumnName == null
+               ? DatabaseDescriptor.getComparator(table, getColumnFamilyName())
+               : DatabaseDescriptor.getSubComparator(table, getColumnFamilyName());
     }
 }
 

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -182,7 +182,7 @@ else if (commitLogSync_ == CommitLogSync.batch)
                 assert commitLogSync_ == CommitLogSync.periodic;
                 try
                 {
-                    commitLogSyncBatchMS_ = Double.valueOf(xmlUtils.getNodeValue("/Storage/CommitLogSyncPeriodInMS"));
+                    commitLogSyncPeriodMS_ = Integer.valueOf(xmlUtils.getNodeValue("/Storage/CommitLogSyncPeriodInMS"));
                 }
                 catch (Exception e)
                 {

File: src/java/org/apache/cassandra/db/SystemTable.java
Patch:
@@ -27,9 +27,10 @@
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.utils.BasicUtilities;
-import org.apache.cassandra.db.filter.NamesQueryFilter;
+import org.apache.cassandra.db.filter.IdentityQueryFilter;
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.db.filter.QueryFilter;
+import org.apache.cassandra.db.filter.NamesQueryFilter;
 
 /**
  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )
@@ -88,7 +89,7 @@ public static StorageMetadata initMetadata() throws IOException
     {
         /* Read the system table to retrieve the storage ID and the generation */
         Table table = Table.open(Table.SYSTEM_TABLE);
-        QueryFilter filter = new NamesQueryFilter(LOCATION_KEY, new QueryPath(LOCATION_CF), GENERATION);
+        QueryFilter filter = new IdentityQueryFilter(LOCATION_KEY, new QueryPath(LOCATION_CF));
         ColumnFamily cf = table.getColumnFamilyStore(LOCATION_CF).getColumnFamily(filter);
 
         IPartitioner p = StorageService.getPartitioner();

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -906,7 +906,7 @@ public static AbstractType getComparator(String tableName, String cfName)
     public static AbstractType getSubComparator(String tableName, String cfName)
     {
         assert tableName != null;
-        return getCFMetaData(tableName, cfName).comparator;
+        return getCFMetaData(tableName, cfName).subcolumnComparator;
     }
 
     public static Map<String, Map<String, CFMetaData>> getTableToColumnFamilyMap()

File: src/java/org/apache/cassandra/service/CassandraServer.java
Patch:
@@ -210,7 +210,7 @@ public List<ColumnOrSuperColumn> get_slice(String keyspace, String key, ColumnPa
             SliceRange range = predicate.slice_range;
             if (range.count < 0)
                 throw new InvalidRequestException("get_slice requires non-negative count");
-            return getSlice(new SliceFromReadCommand(keyspace, key, column_parent, range.start, range.finish, range.is_ascending, range.count), consistency_level);
+            return getSlice(new SliceFromReadCommand(keyspace, key, column_parent, range.start, range.finish, range.reversed, range.count), consistency_level);
         }
     }
 

File: src/java/org/apache/cassandra/io/SSTableWriter.java
Patch:
@@ -11,6 +11,7 @@
 
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.utils.BloomFilter;
+import org.apache.cassandra.config.DatabaseDescriptor;
 import com.reardencommerce.kernel.collections.shared.evictable.ConcurrentLinkedHashMap;
 
 public class SSTableWriter extends SSTable
@@ -26,8 +27,8 @@ public class SSTableWriter extends SSTable
     public SSTableWriter(String filename, int keyCount, IPartitioner partitioner) throws IOException
     {
         super(filename, partitioner);
-        dataFile = new BufferedRandomAccessFile(path, "rw", 4 * 1024 * 1024);
-        indexFile = new BufferedRandomAccessFile(indexFilename(), "rw", 1024 * 1024);
+        dataFile = new BufferedRandomAccessFile(path, "rw", DatabaseDescriptor.getFlushDataBufferSizeInMB() * 1024 * 1024);
+        indexFile = new BufferedRandomAccessFile(indexFilename(), "rw", DatabaseDescriptor.getFlushIndexBufferSizeInMB() * 1024 * 1024);
         bf = new BloomFilter(keyCount, 15);
     }
 

File: src/java/org/apache/cassandra/db/filter/SSTableSliceIterator.java
Patch:
@@ -101,6 +101,8 @@ public ColumnGroupReader(String filename, String key, long position) throws IOEx
 
             columnStartPosition = file.getFilePointer();
             curRangeIndex = IndexHelper.indexFor(startColumn, indexes, comparator, isAscending);
+            if (!isAscending && curRangeIndex == indexes.size())
+                curRangeIndex--;
         }
 
         public ColumnFamily getEmptyColumnFamily()

File: test/unit/org/apache/cassandra/db/TableTest.java
Patch:
@@ -225,7 +225,6 @@ public void run() throws Exception
         {
             public void run() throws Exception
             {
-                Row result;
                 ColumnFamily cf;
 
                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), "col5".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, true, 2);

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -57,7 +57,6 @@ public final class ColumnFamilyStore implements ColumnFamilyStoreMBean
     private static Logger logger_ = Logger.getLogger(ColumnFamilyStore.class);
 
     private static final int BUFSIZE = 128 * 1024 * 1024;
-    private static final int COMPACTION_MEMORY_THRESHOLD = 1 << 30;
 
     private static NonBlockingHashMap<String, Set<Memtable>> memtablesPendingFlush = new NonBlockingHashMap<String, Set<Memtable>>();
     private static ExecutorService flusher_ = new DebuggableThreadPoolExecutor("MEMTABLE-FLUSHER-POOL");
@@ -902,7 +901,6 @@ boolean doFileAntiCompaction(List<String> files, List<Range> ranges, EndPoint ta
         long totalkeysWritten = 0;
         String rangeFileLocation;
         String mergedFileName;
-        IPartitioner p = StorageService.getPartitioner();
         // Calculate the expected compacted filesize
         long expectedRangeFileSize = getExpectedCompactedFileSize(files);
         /* in the worst case a node will be giving out half of its data so we take a chance */
@@ -1378,7 +1376,6 @@ public ColumnFamily getColumnFamily(QueryFilter filter, int gcBefore) throws IOE
         // if we are querying subcolumns of a supercolumn, fetch the supercolumn with NQF, then filter in-memory.
         if (filter.path.superColumnName != null)
         {
-            AbstractType comparator = DatabaseDescriptor.getComparator(table_, columnFamily_);
             QueryFilter nameFilter = new NamesQueryFilter(filter.key, new QueryPath(columnFamily_), filter.path.superColumnName);
             ColumnFamily cf = getColumnFamily(nameFilter);
             if (cf != null)

File: src/java/org/apache/cassandra/db/marshal/BytesType.java
Patch:
@@ -1,5 +1,7 @@
 package org.apache.cassandra.db.marshal;
 
+import java.util.Arrays;
+
 public class BytesType extends AbstractType
 {
     public int compare(byte[] o1, byte[] o2)
@@ -28,6 +30,6 @@ public int compare(byte[] o1, byte[] o2)
 
     public String getString(byte[] bytes)
     {
-        return bytes.toString();
+        return Arrays.toString(bytes);
     }
 }

File: src/java/org/apache/cassandra/db/marshal/LongType.java
Patch:
@@ -18,7 +18,7 @@ public int compare(byte[] o1, byte[] o2)
 
         long L1 = ByteBuffer.wrap(o1).order(ByteOrder.LITTLE_ENDIAN).getLong();
         long L2 = ByteBuffer.wrap(o2).order(ByteOrder.LITTLE_ENDIAN).getLong();
-        return new Long(L1).compareTo(L2);
+        return Long.valueOf(L1).compareTo(Long.valueOf(L2));
     }
 
     public String getString(byte[] bytes)

File: src/java/org/apache/cassandra/db/marshal/TimeUUIDType.java
Patch:
@@ -1,7 +1,6 @@
 package org.apache.cassandra.db.marshal;
 
 import java.util.UUID;
-import java.nio.ByteBuffer;
 
 public class TimeUUIDType extends AbstractType
 {

File: src/java/org/apache/cassandra/dht/BootStrapper.java
Patch:
@@ -19,6 +19,7 @@
 package org.apache.cassandra.dht;
 
  import java.util.ArrayList;
+ import java.util.Arrays;
  import java.util.Collections;
  import java.util.HashMap;
  import java.util.HashSet;
@@ -31,7 +32,7 @@
  import org.apache.cassandra.locator.TokenMetadata;
  import org.apache.cassandra.net.EndPoint;
  import org.apache.cassandra.service.StorageService;
- import org.apache.cassandra.utils.LogUtil;
+import org.apache.cassandra.utils.LogUtil;
 
 
 /**
@@ -59,7 +60,7 @@ public void run()
         try
         {
             if (logger_.isDebugEnabled())
-              logger_.debug("Beginning bootstrap process for " + targets_ + " ...");                                                               
+              logger_.debug("Beginning bootstrap process for " + Arrays.toString(targets_) + " ...");                                                               
             /* copy the token to endpoint map */
             Map<Token, EndPoint> tokenToEndPointMap = tokenMetadata_.cloneTokenEndPointMap();
             /* remove the tokens associated with the endpoints being bootstrapped */                

File: src/java/org/apache/cassandra/dht/BootstrapMetadataMessage.java
Patch:
@@ -60,6 +60,7 @@ protected static Message makeBootstrapMetadataMessage(BootstrapMetadataMessage b
     
     BootstrapMetadataMessage(BootstrapMetadata[] bsMetadata)
     {
+        assert bsMetadata != null;
         bsMetadata_ = bsMetadata;
     }
 }
@@ -69,9 +70,8 @@ class BootstrapMetadataMessageSerializer implements ICompactSerializer<Bootstrap
     public void serialize(BootstrapMetadataMessage bsMetadataMessage, DataOutputStream dos) throws IOException
     {
         BootstrapMetadata[] bsMetadata = bsMetadataMessage.bsMetadata_;
-        int size = (bsMetadata == null) ? 0 : bsMetadata.length;
-        dos.writeInt(size);
-        for ( BootstrapMetadata bsmd : bsMetadata )
+        dos.writeInt(bsMetadata.length);
+        for (BootstrapMetadata bsmd : bsMetadata)
         {
             BootstrapMetadata.serializer().serialize(bsmd, dos);
         }

File: src/java/org/apache/cassandra/service/ConsistencyManager.java
Patch:
@@ -98,7 +98,7 @@ private void doReadRepair() throws IOException
 		}
 	}
 	
-	class DataRepairHandler implements IAsyncCallback, ICacheExpungeHook<String, String>
+	static class DataRepairHandler implements IAsyncCallback, ICacheExpungeHook<String, String>
 	{
 		private List<Message> responses_ = new ArrayList<Message>();
 		private IResponseResolver<Row> readResponseResolver_;

File: src/java/org/apache/cassandra/tools/MembershipCleaner.java
Patch:
@@ -44,7 +44,7 @@ public static void main(String[] args) throws Throwable
     {
         if ( args.length != 3 )
         {
-            System.out.println("Usage : java com.facebook.infrastructure.tools.MembershipCleaner " +
+            System.out.println("Usage : java org.apache.cassandra.tools.MembershipCleaner " +
                     "<ip:port to send the message> " +
                     "<node which needs to be removed> " +
                     "<file containing all nodes in the cluster>");
@@ -82,7 +82,6 @@ public static void main(String[] args) throws Throwable
     public static class MembershipCleanerMessage implements Serializable
     {
         private static ICompactSerializer<MembershipCleanerMessage> serializer_;
-        private static AtomicInteger idGen_ = new AtomicInteger(0);
         
         static
         {

File: src/java/org/apache/cassandra/tools/MembershipCleanerVerbHandler.java
Patch:
@@ -69,7 +69,7 @@ public void doVerb(Message message)
             {            
                 if (logger_.isDebugEnabled())
                   logger_.debug("Processing node " + node);
-                byte[] bytes = headers.remove(node);
+                headers.remove(node);
                 /* Send a message to this node to alter its membership state. */
                 EndPoint targetNode = new EndPoint(node, DatabaseDescriptor.getStoragePort());                
                 

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1453,7 +1453,7 @@ public ColumnFamily getColumnFamily(QueryFilter filter, int gcBefore) throws IOE
                 }
                 catch (Throwable th)
                 {
-                    logger_.error(th);
+                    logger_.error("error closing " + ci, th);
                 }
             }
 

File: src/java/org/apache/cassandra/db/filter/SSTableSliceIterator.java
Patch:
@@ -127,7 +127,8 @@ protected IColumn computeNext()
 
     public void close() throws IOException
     {
-        reader.close();
+        if (reader != null)
+            reader.close();
     }
 
     /**

File: src/java/org/apache/cassandra/db/BinaryMemtableManager.java
Patch:
@@ -59,7 +59,7 @@ static BinaryMemtableManager instance()
         return instance_;
     }
     
-    class BinaryMemtableFlusher implements Runnable
+    static class BinaryMemtableFlusher implements Runnable
     {
         private BinaryMemtable memtable_;
         

File: src/java/org/apache/cassandra/db/MinorCompactionManager.java
Patch:
@@ -66,7 +66,7 @@ public static MinorCompactionManager instance()
         return instance_;
     }
 
-    class FileCompactor2 implements Callable<Boolean>
+    static class FileCompactor2 implements Callable<Boolean>
     {
         private ColumnFamilyStore columnFamilyStore_;
         private List<Range> ranges_;
@@ -100,7 +100,7 @@ public Boolean call()
         }
     }
 
-    class OnDemandCompactor implements Runnable
+    static class OnDemandCompactor implements Runnable
     {
         private ColumnFamilyStore columnFamilyStore_;
         private long skip_ = 0L;
@@ -128,7 +128,7 @@ public void run()
         }
     }
 
-    class CleanupCompactor implements Runnable
+    static class CleanupCompactor implements Runnable
     {
         private ColumnFamilyStore columnFamilyStore_;
 

File: src/java/org/apache/cassandra/db/ReadResponse.java
Patch:
@@ -22,7 +22,6 @@
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
-import java.io.Serializable;
 import org.apache.cassandra.io.ICompactSerializer;
 import org.apache.cassandra.net.Message;
 import org.apache.cassandra.net.MessagingService;
@@ -36,7 +35,7 @@
  * The table name is needed so that we can use it to create repairs.
  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )
  */
-public class ReadResponse implements Serializable 
+public class ReadResponse
 {
 private static ICompactSerializer<ReadResponse> serializer_;
 
@@ -134,4 +133,4 @@ public ReadResponse deserialize(DataInputStream dis) throws IOException
         rmsg.setIsDigestQuery(isDigest);
     	return rmsg;
     } 
-}
\ No newline at end of file
+}

File: src/java/org/apache/cassandra/db/Row.java
Patch:
@@ -102,7 +102,6 @@ void addColumnFamily(ColumnFamily columnFamily)
     void removeColumnFamily(ColumnFamily columnFamily)
     {
         columnFamilies_.remove(columnFamily.name());
-        int delta = (-1) * columnFamily.size();
     }
 
     public boolean isEmpty()

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -457,7 +457,7 @@ void doGossipToSeed(Message message)
             else
             {
                 /* Gossip with the seed with some probability. */
-                double probability = seeds_.size() / ( liveEndpoints_.size() + unreachableEndpoints_.size() );
+                double probability = seeds_.size() / (double)( liveEndpoints_.size() + unreachableEndpoints_.size() );
                 double randDbl = random_.nextDouble();
                 if ( randDbl <= probability )
                     sendGossip(message, seeds_);

File: src/java/org/apache/cassandra/locator/AbstractStrategy.java
Patch:
@@ -39,7 +39,7 @@
 */
 public abstract class AbstractStrategy implements IReplicaPlacementStrategy
 {
-    protected static Logger logger_ = Logger.getLogger(AbstractStrategy.class);
+    protected static final Logger logger_ = Logger.getLogger(AbstractStrategy.class);
 
     protected TokenMetadata tokenMetadata_;
     protected IPartitioner partitioner_;
@@ -132,4 +132,4 @@ public Map<EndPoint, EndPoint> getHintedStorageEndPoints(Token token)
     }
 
     public abstract EndPoint[] getStorageEndPoints(Token token, int offset);
-}
\ No newline at end of file
+}

File: src/java/org/apache/cassandra/net/EndPoint.java
Patch:
@@ -44,7 +44,7 @@ public class EndPoint implements Serializable, Comparable<EndPoint>
 
     // use as a kind of magic number to send ourselves a message indicating listening state
     protected static final int sentinelPort_ = 5555;
-    public static EndPoint sentinelLocalEndPoint_;
+    protected static EndPoint sentinelLocalEndPoint_;
     
     static
     {

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -456,7 +456,6 @@ public IAsyncResult sendRR(Message message, EndPoint to)
     
     public void sendUdpOneWay(Message message, EndPoint to)
     {
-        EndPoint from = message.getFrom();              
         if (message.getFrom().equals(to)) {
             MessagingService.receive(message);
             return;

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -658,7 +658,7 @@ static List<String> getKeyRange(RangeCommand command)
                     allKeys.remove(allKeys.size() - 1);
                     allKeys.addAll(rangeKeys);
                 }
-                else if (rangeKeys.size() > 0)
+                else if (rangeKeys != null && rangeKeys.size() > 0)
                 {
                     allKeys.addAll(rangeKeys);
                 }
@@ -720,4 +720,4 @@ public int getWriteOperations()
     {
         return writeStats.size();
     }
-}
\ No newline at end of file
+}

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -76,7 +76,7 @@ public final class StorageService implements IEndPointStateChangeSubscriber, Sto
     public final static String mbrshipCleanerVerbHandler_ = "MBRSHIP-CLEANER-VERB-HANDLER";
     public final static String bsMetadataVerbHandler_ = "BS-METADATA-VERB-HANDLER";
     public final static String calloutDeployVerbHandler_ = "CALLOUT-DEPLOY-VERB-HANDLER";
-    public static String rangeVerbHandler_ = "RANGE-VERB-HANDLER";
+    public final static String rangeVerbHandler_ = "RANGE-VERB-HANDLER";
 
     public static enum ConsistencyLevel
     {

File: src/java/org/apache/cassandra/net/UdpConnection.java
Patch:
@@ -78,7 +78,8 @@ public boolean write(Message message, EndPoint to) throws IOException
         byte[] data = bos.toByteArray();
         if ( data.length > 0 )
         {  
-            logger_.trace("Size of Gossip packet " + data.length);
+            if (logger_.isTraceEnabled())
+                logger_.trace("Size of Gossip packet " + data.length);
             byte[] protocol = BasicUtilities.intToByteArray(protocol_);
             ByteBuffer buffer = ByteBuffer.allocate(data.length + protocol.length);
             buffer.put( protocol );

File: src/java/org/apache/cassandra/cql/compiler/sem/SemanticPhase.java
Patch:
@@ -64,7 +64,8 @@ public static Plan doSemanticAnalysis(CommonTree ast) throws SemanticException
     {
         Plan plan = null;
 
-        logger_.debug("AST: " + ast.toStringTree());
+        if (logger_.isDebugEnabled())
+            logger_.debug("AST: " + ast.toStringTree());
 
         switch (ast.getType())
         {

File: src/java/org/apache/cassandra/db/BinaryVerbHandler.java
Patch:
@@ -58,7 +58,8 @@ public void doVerb(Message message)
 	    }        
 	    catch ( Exception e )
 	    {
-	        logger_.debug(LogUtil.throwableToString(e));            
+	        if (logger_.isDebugEnabled())
+                logger_.debug(LogUtil.throwableToString(e));            
 	    }        
     }
 

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1089,9 +1089,9 @@ boolean doFileAntiCompaction(List<String> files, List<Range> ranges, EndPoint ta
         if (logger_.isDebugEnabled())
         {
             logger_.debug("Total time taken for range split   ..." + (System.currentTimeMillis() - startTime));
-          logger_.debug("Total bytes Read for range split  ..." + totalBytesRead);
-        logger_.debug("Total bytes written for range split  ..."
-                      + totalBytesWritten + "   Total keys read ..." + totalkeysRead);
+            logger_.debug("Total bytes Read for range split  ..." + totalBytesRead);
+            logger_.debug("Total bytes written for range split  ..."
+                          + totalBytesWritten + "   Total keys read ..." + totalkeysRead);
         }
         return result;
     }

File: src/java/org/apache/cassandra/db/ReadRepairVerbHandler.java
Patch:
@@ -52,7 +52,8 @@ public void doVerb(Message message)
         }
         catch ( IOException e )
         {
-            logger_.debug(LogUtil.throwableToString(e));            
+            if (logger_.isDebugEnabled())
+                logger_.debug(LogUtil.throwableToString(e));            
         }        
     }
 }

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -190,7 +190,7 @@ public void onStreamCompletion(String host, StreamContextManager.StreamContext s
                 */                
                 SSTableReader sstable = SSTableReader.open(streamContext.getTargetFile());
                 if (logger_.isDebugEnabled())
-                logger_.debug("Merging the counting bloom filter in the sampler ...");                
+                  logger_.debug("Merging the counting bloom filter in the sampler ...");                
                 String[] peices = FBUtilities.strip(fileName, "-");
                 Table.open(peices[0]).getColumnFamilyStore(peices[1]).addToList(sstable);                
             }
@@ -248,7 +248,7 @@ public void doVerb(Message message)
                 StreamContextManager.registerStreamCompletionHandler(message.getFrom().getHost(), new Table.BootstrapCompletionHandler());
                 /* Send a bootstrap initiation done message to execute on default stage. */
                 if (logger_.isDebugEnabled())
-                logger_.debug("Sending a bootstrap initiate done message ...");                
+                  logger_.debug("Sending a bootstrap initiate done message ...");
                 Message doneMessage = new Message( StorageService.getLocalStorageEndPoint(), "", StorageService.bootStrapInitiateDoneVerbHandler_, new byte[0] );
                 MessagingService.getMessagingInstance().sendOneWay(doneMessage, message.getFrom());
             }

File: src/java/org/apache/cassandra/dht/BootStrapper.java
Patch:
@@ -65,7 +65,8 @@ public void run()
     {
         try
         {
-            logger_.debug("Beginning bootstrap process for " + targets_ + " ...");                                                               
+            if (logger_.isDebugEnabled())
+              logger_.debug("Beginning bootstrap process for " + targets_ + " ...");                                                               
             /* copy the token to endpoint map */
             Map<Token, EndPoint> tokenToEndPointMap = tokenMetadata_.cloneTokenEndPointMap();
             /* remove the tokens associated with the endpoints being bootstrapped */                

File: src/java/org/apache/cassandra/dht/LeaveJoinProtocolImpl.java
Patch:
@@ -62,7 +62,8 @@ public void run()
     {  
         try
         {
-            logger_.debug("Beginning leave/join process for ...");                                                               
+            if (logger_.isDebugEnabled())
+              logger_.debug("Beginning leave/join process for ...");                                                               
             /* copy the token to endpoint map */
             Map<Token, EndPoint> tokenToEndPointMap = tokenMetadata_.cloneTokenEndPointMap();
             /* copy the endpoint to token map */

File: src/java/org/apache/cassandra/net/MessagingService.java
Patch:
@@ -226,7 +226,8 @@ public byte[] hash(String type, byte data[])
         }
         catch(Exception e)
         {
-            LogUtil.getLogger(MessagingService.class.getName()).debug(LogUtil.throwableToString(e));
+            if (logger_.isDebugEnabled())
+                logger_.debug(LogUtil.throwableToString(e));
         }
         return result;
     }

File: src/java/org/apache/cassandra/net/TcpConnection.java
Patch:
@@ -236,7 +236,8 @@ public void stream(File file, long startPosition, long endPosition) throws IOExc
                 
                 /* returns the number of bytes transferred from file to the socket */
                 long bytesTransferred = fc.transferTo(startPosition, limit, socketChannel_);
-                logger_.debug("Bytes transferred " + bytesTransferred);                
+                if (logger_.isDebugEnabled())
+                    logger_.debug("Bytes transferred " + bytesTransferred);                
                 bytesWritten += bytesTransferred;
                 startPosition += bytesTransferred; 
                 /*

File: src/java/org/apache/cassandra/net/io/ContentStreamState.java
Patch:
@@ -90,7 +90,8 @@ public byte[] read() throws IOException, ReadNotCompleteException
             }
             if ( bytesRead_ == streamContext_.getExpectedBytes() )
             {       
-                logger_.debug("Removing stream context " + streamContext_);                 
+                if (logger_.isDebugEnabled())
+                    logger_.debug("Removing stream context " + streamContext_);                 
                 handleStreamCompletion(remoteHost);                              
                 bytesRead_ = 0L;
                 fc_.close();

File: src/java/org/apache/cassandra/service/CassandraDaemon.java
Patch:
@@ -84,7 +84,8 @@ public void uncaughtException(Thread t, Throwable e)
         Set<String> tables = DatabaseDescriptor.getTableToColumnFamilyMap().keySet();
         for (String table : tables)
         {
-            logger.debug("opening table " + table);
+            if (logger.isDebugEnabled())
+                logger.debug("opening table " + table);
             Table tbl = Table.open(table);
             tbl.onStart();
         }

File: src/java/org/apache/cassandra/service/WriteResponseResolver.java
Patch:
@@ -60,7 +60,8 @@ public Boolean resolve(List<Message> responses) throws DigestMismatchException
             }
             boolean result = writeResponseMessage.isSuccess();
             if (!result) {
-				logger_.debug("Write at " + response.getFrom()
+				if (logger_.isDebugEnabled())
+                    logger_.debug("Write at " + response.getFrom()
 						+ " may have failed for the key " + writeResponseMessage.key());
 			}
 			returnValue |= result;

File: src/java/org/apache/cassandra/utils/FBUtilities.java
Patch:
@@ -253,7 +253,8 @@ public static byte[] hash(String type, byte[] data)
     	}
     	catch (Exception e)
         {
-    		LogUtil.getLogger(FBUtilities.class.getName()).debug(LogUtil.throwableToString(e));
+    		if (logger_.isDebugEnabled())
+                logger_.debug(LogUtil.throwableToString(e));
     	}
     	return result;
 	}

File: src/java/org/apache/cassandra/db/marshal/LongType.java
Patch:
@@ -7,14 +7,13 @@ public class LongType extends AbstractType
 {
     public int compare(byte[] o1, byte[] o2)
     {
-        // TODO rm hack to support the "i'm going to pretend [] is an index entry if I didn't actually index anything" hack
         if (o1.length == 0)
         {
             return o2.length == 0 ? 0 : -1;
         }
         if (o2.length == 0)
         {
-            return -1;
+            return 1;
         }
 
         long L1 = ByteBuffer.wrap(o1).order(ByteOrder.LITTLE_ENDIAN).getLong();

File: src/java/org/apache/cassandra/db/marshal/UUIDType.java
Patch:
@@ -13,14 +13,13 @@ private UUID getUUID(byte[] bytes)
 
     public int compare(byte[] o1, byte[] o2)
     {
-        // TODO rm hack to support the "i'm going to pretend [] is an index entry if I didn't actually index anything" hack
         if (o1.length == 0)
         {
             return o2.length == 0 ? 0 : -1;
         }
         if (o2.length == 0)
         {
-            return -1;
+            return 1;
         }
 
         return getUUID(o1).compareTo(getUUID(o2));

File: src/java/org/apache/cassandra/io/SequenceFile.java
Patch:
@@ -258,7 +258,6 @@ private List<IndexHelper.ColumnIndexInfo> getFullColumnIndexList(List<IndexHelpe
             if (columnIndexList.size() == 0)
             {
                 /* if there is no column index, add an index entry that covers the full space. */
-                // TODO can we remove this?  it causes a lot of ugliness in everything that touches Marshal
                 return Arrays.asList(new IndexHelper.ColumnIndexInfo(ArrayUtils.EMPTY_BYTE_ARRAY, 0, totalNumCols, comparator_));
             }
 

File: test/unit/org/apache/cassandra/db/marshal/AsciiTypeTest.java
Patch:
@@ -4,16 +4,17 @@
 
 import org.junit.Test;
 
-import junit.framework.TestCase;
-
 public class AsciiTypeTest
 {
     @Test
     public void testCompare()
     {
         AsciiType comparator = new AsciiType();
         assert comparator.compare(ArrayUtils.EMPTY_BYTE_ARRAY, "asdf".getBytes()) < 0;
+        assert comparator.compare("asdf".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY) > 0;
+        assert comparator.compare(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY) == 0;
         assert comparator.compare("z".getBytes(), "a".getBytes()) > 0;
+        assert comparator.compare("a".getBytes(), "z".getBytes()) < 0;
         assert comparator.compare("asdf".getBytes(), "asdf".getBytes()) == 0;
         assert comparator.compare("asdz".getBytes(), "asdf".getBytes()) > 0;
     }

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -77,7 +77,7 @@ public class DatabaseDescriptor
     private static String d_columnMap_        = "COLUMN_MAP";
     private static String d_columnKey_        = "COLUMN_KEY";
     private static String d_columnValue_      = "COLUMN_VALUE";
-    private static String d_columnTimestamp_  = "ColumnIMESTAMP";
+    private static String d_columnTimestamp_  = "COLUMN_TIMESTAMP";
 
     private static Map<String, Double> tableKeysCachedFractions_;
     /*

File: src/java/org/apache/cassandra/utils/FBUtilities.java
Patch:
@@ -383,7 +383,6 @@ public static void writeByteArray(byte[] bytes, DataOutput out) throws IOExcepti
     public static byte[] readByteArray(DataInput in) throws IOException
     {
         int length = in.readInt();
-        logger_.debug(length);
         byte[] bytes = new byte[length];
         in.readFully(bytes);
         return bytes;

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -770,7 +770,7 @@ public static String getDataFileLocationForTable(String table, long expectedComp
         return dataFileDirectory;
     }
     
-    public static AbstractType getType(String tableName, String cfName)
+    public static AbstractType getComparator(String tableName, String cfName)
     {
         assert tableName != null;
         return getCFMetaData(tableName, cfName).comparator;

File: src/java/org/apache/cassandra/db/ColumnFamily.java
Patch:
@@ -22,7 +22,6 @@
 import java.io.DataOutputStream;
 import java.io.IOException;
 import java.lang.reflect.Proxy;
-import java.lang.reflect.InvocationTargetException;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
@@ -88,7 +87,7 @@ public static String getColumnType(String key)
     public static ColumnFamily create(String tableName, String cfName)
     {
         String columnType = DatabaseDescriptor.getColumnFamilyType(tableName, cfName);
-        AbstractType comparator = DatabaseDescriptor.getType(tableName, cfName);
+        AbstractType comparator = DatabaseDescriptor.getComparator(tableName, cfName);
         return new ColumnFamily(cfName, columnType, comparator);
     }
 

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1434,7 +1434,7 @@ public ColumnFamily getColumnFamily(QueryFilter filter, int gcBefore) throws IOE
         // if we are querying subcolumns of a supercolumn, fetch the supercolumn with NQF, then filter in-memory.
         if (filter.path.superColumnName != null)
         {
-            AbstractType comparator = DatabaseDescriptor.getType(table_, columnFamily_);
+            AbstractType comparator = DatabaseDescriptor.getComparator(table_, columnFamily_);
             QueryFilter nameFilter = new NamesQueryFilter(filter.key, new QueryPath(columnFamily_), filter.path.superColumnName);
             ColumnFamily cf = getColumnFamily(nameFilter);
             if (cf != null)
@@ -1519,7 +1519,7 @@ public ColumnFamily getColumnFamily(QueryFilter filter, int gcBefore) throws IOE
 
     public AbstractType getComparator()
     {
-        return DatabaseDescriptor.getType(table_, columnFamily_);
+        return DatabaseDescriptor.getComparator(table_, columnFamily_);
     }
 
     /**

File: src/java/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -85,7 +85,7 @@ public void setDigestQuery(boolean isDigestQuery)
 
     protected AbstractType getComparator()
     {
-        return DatabaseDescriptor.getType(table, getColumnFamilyName());
+        return DatabaseDescriptor.getComparator(table, getColumnFamilyName());
     }
 }
 

File: src/java/org/apache/cassandra/io/IndexHelper.java
Patch:
@@ -151,7 +151,7 @@ static int deserializeIndex(String tableName, String cfName, DataInput in, List<
         DataInputBuffer indexIn = new DataInputBuffer();
         indexIn.reset(indexOut.getData(), indexOut.getLength());
         
-        AbstractType comparator = DatabaseDescriptor.getType(tableName, cfName);
+        AbstractType comparator = DatabaseDescriptor.getComparator(tableName, cfName);
 
         while (indexIn.available() > 0)
         {

File: src/java/org/apache/cassandra/io/SSTableReader.java
Patch:
@@ -330,7 +330,7 @@ public ColumnGroupReader getColumnGroupReader(String key, String cfName, byte[]
             /* Morph key into actual key based on the partition type. */
             String decoratedKey = partitioner.decorateKey(key);
             long position = getPosition(decoratedKey, partitioner);
-            AbstractType comparator = DatabaseDescriptor.getType(getTableName(), cfName);
+            AbstractType comparator = DatabaseDescriptor.getComparator(getTableName(), cfName);
             return new ColumnGroupReader(dataFile, decoratedKey, cfName, comparator, startColumn, isAscending, position);
         }
         finally

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -711,7 +711,7 @@ protected String getReduced()
                 }
                 // make sure there is actually non-tombstone content associated w/ this key
                 // TODO record the key source(s) somehow and only check that source (e.g., memtable or sstable)
-                if (ColumnFamilyStore.removeDeleted(cfs.getColumnFamily(new SliceQueryFilter(current, new QueryPath(cfName), "", "", true, 1)), Integer.MAX_VALUE) != null)
+                if (cfs.getColumnFamily(new SliceQueryFilter(current, new QueryPath(cfName), "", "", true, 1), Integer.MAX_VALUE) != null)
                 {
                     keys.add(current);
                 }

File: src/java/org/apache/cassandra/db/filter/NamesQueryFilter.java
Patch:
@@ -49,11 +49,12 @@ public void filterSuperColumn(SuperColumn superColumn)
         }
     }
 
-    public void collectColumns(ColumnFamily returnCF, ReducingIterator<IColumn> reducedColumns)
+    public void collectColumns(ColumnFamily returnCF, ReducingIterator<IColumn> reducedColumns, int gcBefore)
     {
         for (IColumn column : reducedColumns)
         {
-            returnCF.addColumn(column);
+            if (!column.isMarkedForDelete() || column.getLocalDeletionTime() > gcBefore)
+                returnCF.addColumn(column);
         }
     }
 }

File: src/java/org/apache/cassandra/db/filter/QueryFilter.java
Patch:
@@ -36,7 +36,7 @@ protected QueryFilter(String key, QueryPath path)
      * by the filter code, which should have some limit on the number of columns
      * to avoid running out of memory on large rows.
      */
-    public abstract void collectColumns(ColumnFamily returnCF, ReducingIterator<IColumn> reducedColumns);
+    public abstract void collectColumns(ColumnFamily returnCF, ReducingIterator<IColumn> reducedColumns, int gcBefore);
 
     /**
      * subcolumns of a supercolumn are unindexed, so to pick out parts of those we operate in-memory.
@@ -55,7 +55,7 @@ public int compare(IColumn c1, IColumn c2)
         };
     }
     
-    public void collectColumns(final ColumnFamily returnCF, Iterator collatedColumns)
+    public void collectColumns(final ColumnFamily returnCF, Iterator collatedColumns, int gcBefore)
     {
         // define a 'reduced' iterator that merges columns w/ the same name, which
         // greatly simplifies computing liveColumns in the presence of tombstones.
@@ -81,7 +81,7 @@ protected IColumn getReduced()
             }
         };
 
-        collectColumns(returnCF, reduced);
+        collectColumns(returnCF, reduced, gcBefore);
     }
 
     public String getColumnFamilyName()

File: src/java/org/apache/cassandra/db/filter/TimeQueryFilter.java
Patch:
@@ -33,11 +33,12 @@ public Comparator<IColumn> getColumnComparator()
         return ColumnComparatorFactory.timestampComparator_;
     }
 
-    public void collectColumns(ColumnFamily returnCF, ReducingIterator<IColumn> reducedColumns)
+    public void collectColumns(ColumnFamily returnCF, ReducingIterator<IColumn> reducedColumns, int gcBefore)
     {
         for (IColumn column : reducedColumns)
         {
-            returnCF.addColumn(column);
+            if (!column.isMarkedForDelete() || column.getLocalDeletionTime() > gcBefore)
+                returnCF.addColumn(column);
         }
     }
 

File: src/java/org/apache/cassandra/analytics/AnalyticsContext.java
Patch:
@@ -527,7 +527,7 @@ private void timerEvent() throws IOException
 		{
 			Collection<IAnalyticsSource> myUpdaters;
 
-			// we dont need to synchronize as there will not be any
+			// we don't need to synchronize as there will not be any
 			// addition or removal of listeners
 			myUpdaters = new ArrayList<IAnalyticsSource>(updaters);
 

File: src/java/org/apache/cassandra/cli/CliOptions.java
Patch:
@@ -43,7 +43,7 @@ public class CliOptions {
     private static void printUsage()
     {
         System.err.println("");
-        System.err.println("Usage: cascli --host hostname [--port <portname>]");
+        System.err.println("Usage: cassandra-cli --host hostname [--port <portname>]");
         System.err.println("");
     }
 

File: src/java/org/apache/cassandra/cql/common/SuperColumnRangeQueryRSD.java
Patch:
@@ -33,7 +33,7 @@
 import org.apache.log4j.Logger;
 
 /**
- * A Row Source Defintion (RSD) for doing a super column range query on a Super Column Family.
+ * A Row Source Definition (RSD) for doing a super column range query on a Super Column Family.
  */
 public class SuperColumnRangeQueryRSD extends RowSourceDef
 {

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -536,7 +536,7 @@ List<ColumnFamily> getColumnFamilies(String key, String columnFamilyColumn, IFil
 
     /**
      * Fetch from disk files and go in sorted order  to be efficient
-     * This fn exits as soon as the required data is found.
+     * This function exits as soon as the required data is found.
      *
      * @param key
      * @param cf
@@ -866,7 +866,7 @@ void doMajorCompaction(long skip) throws IOException
 
     /*
      * Compact all the files irrespective of the size.
-     * skip : is the ammount in Gb of the files to be skipped
+     * skip : is the amount in GB of the files to be skipped
      * all files greater than skip GB are skipped for this compaction.
      * Except if skip is 0 , in that case this is ignored and all files are taken.
      */
@@ -1019,7 +1019,7 @@ boolean doFileAntiCompaction(List<String> files, List<Range> ranges, EndPoint ta
         IPartitioner p = StorageService.getPartitioner();
         // Calculate the expected compacted filesize
         long expectedRangeFileSize = getExpectedCompactedFileSize(files);
-        /* in the worst case a node will be giving out alf of its data so we take a chance */
+        /* in the worst case a node will be giving out half of its data so we take a chance */
         expectedRangeFileSize = expectedRangeFileSize / 2;
         rangeFileLocation = DatabaseDescriptor.getCompactionFileLocation(expectedRangeFileSize);
         // If the compaction file path is null that means we have no space left for this compaction.

File: src/java/org/apache/cassandra/db/CompactSerializerInvocationHandler.java
Patch:
@@ -25,7 +25,7 @@
 
 
 /*
- * This is the abstraction that pre-processes calls to implmentations
+ * This is the abstraction that pre-processes calls to implementations
  * of the ICompactSerializer2 serialize() via dynamic proxies.
  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )
  */
@@ -40,11 +40,11 @@ public CompactSerializerInvocationHandler(ICompactSerializer2<T> serializer)
     }
 
     /*
-     * This dynamic runtime proxy adds the indexes before the actual coumns are serialized.
+     * This dynamic runtime proxy adds the indexes before the actual columns are serialized.
     */
     public Object invoke(Object proxy, Method m, Object[] args) throws Throwable
     {
-        /* Do the preprocessing here. */
+        /* Do the pre-processing here. */
     	ColumnFamily cf = (ColumnFamily)args[0];
     	DataOutputBuffer bufOut = (DataOutputBuffer)args[1];
     	ColumnIndexer.serialize(cf, bufOut);

File: src/java/org/apache/cassandra/db/ReadResponse.java
Patch:
@@ -32,7 +32,7 @@
 
 /*
  * The read response message is sent by the server when reading data 
- * this encapsulates the tablename and teh row that has been read.
+ * this encapsulates the tablename and the row that has been read.
  * The table name is needed so that we can use it to create repairs.
  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )
  */

File: src/java/org/apache/cassandra/db/Row.java
Patch:
@@ -113,7 +113,7 @@ public boolean isEmpty()
     /*
      * This function will repair the current row with the input row
      * what that means is that if there are any differences between the 2 rows then
-     * this fn will make the current row take the latest changes .
+     * this function will make the current row take the latest changes.
      */
     public void repair(Row rowOther)
     {

File: src/java/org/apache/cassandra/db/RowMutation.java
Patch:
@@ -144,12 +144,12 @@ public void add(ColumnFamily columnFamily)
      * the column. Column name is specified as <column family>:column.
      * This will result in a ColumnFamily associated with
      * <column family> as name and a Column with <column>
-     * as name. The columan can be further broken up
+     * as name. The column can be further broken up
      * as super column name : columnname  in case of super columns
      *
      * param @ cf - column name as <column family>:<column>
      * param @ value - value associated with the column
-     * param @ timestamp - ts associated with this data.
+     * param @ timestamp - timestamp associated with this data.
     */
     public void add(String cf, byte[] value, long timestamp)
     {

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -721,7 +721,7 @@ private List<String> getKeyRangeUnsafe(final String columnFamily, final String s
         List<Iterator<String>> iterators = new ArrayList<Iterator<String>>();
         ColumnFamilyStore cfs = getColumnFamilyStore(columnFamily);
 
-        // we iterate through memtables with a priorityqueue to avoid more sorting than necessary.
+        // we iterate through memtables with a priority queue to avoid more sorting than necessary.
         // this predicate throws out the keys before the start of our range.
         Predicate p = new Predicate()
         {

File: src/java/org/apache/cassandra/db/WriteResponse.java
Patch:
@@ -34,7 +34,7 @@
 
 /*
  * This message is sent back the row mutation verb handler 
- * and basically specifes if the write succeeded or not for a particular 
+ * and basically specifies if the write succeeded or not for a particular 
  * key in a table
  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )
  */

File: src/java/org/apache/cassandra/dht/BootStrapper.java
Patch:
@@ -35,15 +35,15 @@
 
 
 /**
- * This class handles the boostrapping responsibilities for
+ * This class handles the bootstrapping responsibilities for
  * any new endpoint.
 */
 public class BootStrapper implements Runnable
 {
     private static Logger logger_ = Logger.getLogger(BootStrapper.class);
     /* endpoints that need to be bootstrapped */
     protected EndPoint[] targets_ = new EndPoint[0];
-    /* tokens of the nodes being bootstapped. */
+    /* tokens of the nodes being bootstrapped. */
     protected final Token[] tokens_;
     protected TokenMetadata tokenMetadata_ = null;
     private List<EndPoint> filters_ = new ArrayList<EndPoint>();

File: src/java/org/apache/cassandra/dht/LeaveJoinProtocolImpl.java
Patch:
@@ -36,7 +36,7 @@
 
 /**
  * This class performs the exact opposite of the
- * operations of the Bootstrapper class. Given 
+ * operations of the BootStrapper class. Given 
  * a bunch of nodes that need to move it determines 
  * who they need to hand off data in terms of ranges.
 */
@@ -209,7 +209,7 @@ private Set<Token> getTokensForLeavingNodes()
     /**
      * Here we are removing the nodes that need to leave the
      * ring and trying to calculate what the ranges would look
-     * like w/o them. For eg if we remove two nodes A and D from
+     * like w/o them. e.g. if we remove two nodes A and D from
      * the ring and the order of nodes on the ring is A, B, C
      * and D. When B is removed the range of C is the old range 
      * of C and the old range of B. We want a mapping from old

File: src/java/org/apache/cassandra/gms/ApplicationState.java
Patch:
@@ -31,12 +31,12 @@
 /**
  * This abstraction represents the state associated with a particular node which an
  * application wants to make available to the rest of the nodes in the cluster. 
- * Whenever a peice of state needs to be disseminated to the rest of cluster wrap
+ * Whenever a piece of state needs to be disseminated to the rest of cluster wrap
  * the state in an instance of <i>ApplicationState</i> and add it to the Gossiper.
  *  
- * For eg. if we want to disseminate load information for node A do the following:
+ * e.g. if we want to disseminate load information for node A do the following:
  * 
- *      ApplicationState loadState = new ApplicationState(<string reprensentation of load>);
+ *      ApplicationState loadState = new ApplicationState(<string representation of load>);
  *      Gossiper.instance().addApplicationState("LOAD STATE", loadState);
  *  
  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )

File: src/java/org/apache/cassandra/gms/FailureDetector.java
Patch:
@@ -49,7 +49,7 @@ public class FailureDetector implements IFailureDetector, FailureDetectorMBean
     private static final int sampleSize_ = 1000;
     private static final int phiSuspectThreshold_ = 5;
     private static final int phiConvictThreshold_ = 8;
-    /* The Failure Detector has to have been up for atleast 1 min. */
+    /* The Failure Detector has to have been up for at least 1 min. */
     private static final long uptimeThreshold_ = 60000;
     private static IFailureDetector failureDetector_;
     /* Used to lock the factory for creation of FailureDetector instance */

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -205,7 +205,7 @@ public void convict(EndPoint endpoint)
             {
                 /*
                  * just to be sure - is invoked just to make sure that
-                 * it was called atleast once.
+                 * it was called at least once.
                 */
                 if ( liveEndpoints_.contains(endpoint) )
                 {
@@ -870,7 +870,7 @@ synchronized void examineGossiper(List<GossipDigest> gDigestList, List<GossipDig
             }
             else
             {
-                /* We are here since we have no data for this endpoint locally so request everthing. */
+                /* We are here since we have no data for this endpoint locally so request everything. */
                 requestAll(gDigest, deltaGossipDigestList, remoteGeneration);
             }
         }

File: src/java/org/apache/cassandra/gms/IEndPointStateChangeSubscriber.java
Patch:
@@ -37,7 +37,7 @@ public interface IEndPointStateChangeSubscriber
      * Use to inform interested parties about the change in the state
      * for specified endpoint
      * 
-     * @param endpoint endpoint for which the state change occured.
+     * @param endpoint endpoint for which the state change occurred.
      * @param epState state that actually changed for the above endpoint.
      */
     public void onChange(EndPoint endpoint, EndPointState epState);

File: src/java/org/apache/cassandra/io/IndexHelper.java
Patch:
@@ -272,8 +272,8 @@ static ColumnRange getColumnRangeFromTimeIndex(IndexHelper.TimeRange timeRange,
         int numColumns = 0;      
        
         /*
-         *  Time indicies are sorted in descending order. So
-         *  we need to apply a reverse compartor for the 
+         *  Time indices are sorted in descending order. So
+         *  we need to apply a reverse comparator for the 
          *  binary search.        
         */        
         Comparator<IndexHelper.ColumnIndexInfo> comparator = Collections.reverseOrder(); 
@@ -297,7 +297,7 @@ static ColumnRange getColumnRangeFromTimeIndex(IndexHelper.TimeRange timeRange,
          * lower timestamp in the time range.      
         */
         start = (index == 0) ? 0 : columnIndexList.get(index - 1).position();
-        /* add the number of colunms in the first chunk. */
+        /* add the number of columns in the first chunk. */
         numColumns += (index ==0) ? columnIndexList.get(0).count() : columnIndexList.get(index - 1).count(); 
         if( index < size )
         {            

File: src/java/org/apache/cassandra/io/SequenceFile.java
Patch:
@@ -31,7 +31,7 @@
 import org.apache.log4j.Logger;
 
 /**
- * This class writes key/value pairs seqeuntially to disk. It is
+ * This class writes key/value pairs sequentially to disk. It is
  * also used to read sequentially from disk. However one could
  * jump to random positions to read data from the file. This class
  * also has many implementations of the IFileWriter and IFileReader
@@ -544,7 +544,7 @@ private void readTimeRange(String key, DataOutputBuffer bufOut, String columnFam
             int bytesSkipped = IndexHelper.skipBloomFilter(file_);
             /*
              * read the correct number of bytes for the column family and
-             * write data into buffer. Substract from dataSize the bloom
+             * write data into buffer. Subtract from dataSize the bloom
              * filter size.
             */
             dataSize -= bytesSkipped;

File: src/java/org/apache/cassandra/net/SelectorManager.java
Patch:
@@ -60,10 +60,10 @@ private SelectorManager(String name)
     /**
      * Registers a new channel with the selector, and attaches the given
      * SelectionKeyHandler as the handler for the newly created key. Operations
-     * which the hanlder is interested in will be called as available.
+     * which the handler is interested in will be called as available.
      * 
      * @param channel
-     *            The channel to regster with the selector
+     *            The channel to register with the selector
      * @param handler
      *            The handler to use for the callbacks
      * @param ops

File: src/java/org/apache/cassandra/net/TcpConnection.java
Patch:
@@ -497,7 +497,7 @@ private void handleException(Throwable th)
         {
             logger_.warn("Problem reading from socket connected to : " + socketChannel_);
             logger_.warn(LogUtil.throwableToString(th));
-            // This is to fix the wierd Linux bug with NIO.
+            // This is to fix the weird Linux bug with NIO.
             errorClose();
         }
     }

File: src/java/org/apache/cassandra/service/MultiQuorumResponseHandler.java
Patch:
@@ -111,7 +111,7 @@ private void onCompletion() throws IOException
             {
                 /* 
                  * The DigestMismatchException has the key for which the mismatch
-                 * occured bundled in it as context 
+                 * occurred bundled in it as context 
                 */
                 String key = ex.getMessage();
                 onDigestMismatch(key);
@@ -123,7 +123,7 @@ private void onCompletion() throws IOException
          * in order to retrieve the appropriate data message that needs
          * to be sent out to the replicas. 
          * 
-         * @param key for which the mismatch occured.
+         * @param key for which the mismatch occurred.
         */
         private void onDigestMismatch(String key) throws IOException
         {
@@ -211,7 +211,7 @@ void onCompleteResponse(Row row)
      * The handler of the response message that has been
      * sent by one of the replicas for one of the keys.
      * 
-     * @param message the reponse message for one of the
+     * @param message the response message for one of the
      *        message that we sent out.
      */
     public void response(Message message)

File: src/java/org/apache/cassandra/service/ReadResponseResolver.java
Patch:
@@ -39,8 +39,8 @@
 
 /**
  * This class is used by all read functions and is called by the Quorum 
- * when atleast a few of the servers ( few is specified in Quorum)
- * have sent the response . The resolve fn then schedules read repair 
+ * when at least a few of the servers (few is specified in Quorum)
+ * have sent the response . The resolve function then schedules read repair 
  * and resolution of read data from the various servers.
  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )
  */
@@ -129,7 +129,7 @@ public Row resolve(List<Message> responses) throws DigestMismatchException
 		}
 
         // At  this point  we have the return row .
-		// Now we need to calculate the differnce 
+		// Now we need to calculate the difference 
 		// so that we can schedule read repairs 
 		for (int i = 0 ; i < rowList.size(); i++)
 		{

File: src/java/org/apache/cassandra/service/StorageLoadBalancer.java
Patch:
@@ -51,7 +51,7 @@
  * This class keeps track of load information across the system.
  * It registers itself with the Gossiper for ApplicationState namely
  * load information i.e number of requests processed w.r.t distinct
- * keys at an Endpoint. Monitor load infomation for a 5 minute
+ * keys at an Endpoint. Monitor load information for a 5 minute
  * interval and then do load balancing operations if necessary.
  * 
  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )

File: src/java/org/apache/cassandra/service/StorageProxy.java
Patch:
@@ -371,10 +371,10 @@ public static Map<String, Row> strongReadProtocol(String[] keys, ReadCommand rea
         // 1. Get the N nodes from storage service where the data needs to be
         // replicated
         // 2. Construct a message for read\write
-         * 3. Set one of teh messages to get teh data and teh rest to get teh digest
+         * 3. Set one of the messages to get the data and the rest to get the digest
         // 4. SendRR ( to all the nodes above )
-        // 5. Wait for a response from atleast X nodes where X <= N and teh data node
-         * 6. If the digest matches return teh data.
+        // 5. Wait for a response from at least X nodes where X <= N and the data node
+         * 6. If the digest matches return the data.
          * 7. else carry out read repair by getting data from all the nodes.
         // 5. return success
      */

File: src/java/org/apache/cassandra/service/StorageServiceMBean.java
Patch:
@@ -61,7 +61,7 @@ public interface StorageServiceMBean
      * node being bootstrapped. This is used in case of normal
      * bootstrap failure. Use a tool to re-calculate the cardinality
      * at a later point at the destination.
-     * @param sources colon separated list of directories from where 
+     * @param directories colon separated list of directories from where 
      *                files need to be picked up.
      * @param target endpoint receiving data.
     */

File: src/java/org/apache/cassandra/service/WriteResponseResolver.java
Patch:
@@ -37,8 +37,8 @@ public class WriteResponseResolver implements IResponseResolver<Boolean> {
 
 	/*
 	 * The resolve function for the Write looks at all the responses if all the
-	 * respones returned are false then we have a problem since that means the
-	 * key wa not written to any of the servers we want to notify the client of
+	 * responses returned are false then we have a problem since that means the
+	 * key was not written to any of the servers we want to notify the client of
 	 * this so in that case we should return a false saying that the write
 	 * failed.
 	 * 

File: src/java/org/apache/cassandra/tools/KeyChecker.java
Patch:
@@ -36,7 +36,7 @@ public class KeyChecker
     private static final int bufSize_ = 128*1024*1024;
     /*
      * This function checks if the local storage endpoint 
-     * is reponsible for storing this key .
+     * is responsible for storing this key .
      */
     private static boolean checkIfProcessKey(String key)
     {

File: src/java/org/apache/cassandra/tools/ThreadListBuilder.java
Patch:
@@ -39,7 +39,7 @@ public static void main(String[] args) throws Throwable
     {
         if ( args.length != 2 )
         {
-            System.out.println("Usage : java com.facebook.infrastructure.tools.ThreadListBuilder <directory containing files to be processed> <directory to dump the bloom filter in.>");
+            System.out.println("Usage : java org.apache.cassandra.tools.ThreadListBuilder <directory containing files to be processed> <directory to dump the bloom filter in.>");
             System.exit(1);
         }
         

File: src/java/org/apache/cassandra/tools/TokenUpdateVerbHandler.java
Patch:
@@ -72,7 +72,7 @@ public void doVerb(Message message)
                 if (logger_.isDebugEnabled())
                   logger_.debug("Processing node " + node);
                 byte[] bytes = headers.remove(node);
-                /* Send a message to this node to update its token to the one retreived. */
+                /* Send a message to this node to update its token to the one retrieved. */
                 EndPoint target = new EndPoint(node, DatabaseDescriptor.getStoragePort());
                 token = p.getTokenFactory().fromByteArray(bytes);
                 

File: src/java/org/apache/cassandra/tools/TokenUpdater.java
Patch:
@@ -41,7 +41,7 @@ public static void main(String[] args) throws Throwable
     {
         if ( args.length != 3 )
         {
-            System.out.println("Usage : java com.facebook.infrastructure.tools.TokenUpdater <ip:port> <token> <file containing node token info>");
+            System.out.println("Usage : java org.apache.cassandra.tools.TokenUpdater <ip:port> <token> <file containing node token info>");
             System.exit(1);
         }
         

File: src/java/org/apache/cassandra/utils/BloomCalculations.java
Patch:
@@ -99,7 +99,7 @@ public BloomSpecification(int k, int bucketsPerElement) {
      * but minimize the number of buckets per element and the number of hash
      * functions used.  Because bandwidth (and therefore total bitvector size)
      * is considered more expensive than computing power, preference is given
-     * to minimizing buckets per element rather than number of hash funtions.
+     * to minimizing buckets per element rather than number of hash functions.
      *
      * @param maxFalsePosProb The maximum tolerable false positive rate.
      * @return A Bloom Specification which would result in a false positive rate

File: src/java/org/apache/cassandra/utils/BloomFilter.java
Patch:
@@ -86,7 +86,7 @@ public boolean isPresent(String key)
     }
 
     /*
-     param@ key -- value whose hash is used to fill
+     @param key -- value whose hash is used to fill
      the filter_.
      This is a general purpose API.
      */

File: src/java/org/apache/cassandra/utils/FBUtilities.java
Patch:
@@ -267,7 +267,7 @@ public static boolean isEqual(byte[] digestA, byte[] digestB)
         return MessageDigest.isEqual(digestA, digestB);
     }
 
-    // The given bytearray is compressed onto the specifed stream.
+    // The given byte array is compressed onto the specified stream.
     // The method does not close the stream. The caller will have to do it.
     public static void compressToStream(byte[] input, ByteArrayOutputStream bos) throws IOException
     {

File: src/java/org/apache/cassandra/utils/FastObjectHash.java
Patch:
@@ -256,7 +256,7 @@ else if (cur != REMOVED && cur.equals(obj))
                 return (cur != FREE) ? -index - 1 : firstRemoved;
             }
             // if it's full, the key is already stored
-            // NOTE: cur cannot equal REMOVE here (would have retuned already
+            // NOTE: cur cannot equal REMOVE here (would have returned already
             // (see above)
             return (cur != FREE) ? -index - 1 : index;
         }

File: src/java/org/apache/cassandra/utils/Filter.java
Patch:
@@ -62,8 +62,8 @@ ICompactSerializer<Filter> getSerializer()
         }
     }
 
-    // murmur is faster than a sha-based approach and provides as-good collision
-    // resistance.  the combinatorial generation approach described in
+    // Murmur is faster than an SHA-based approach and provides as-good collision
+    // resistance.  The combinatorial generation approach described in
     // http://www.eecs.harvard.edu/~kirsch/pubs/bbbf/esa06.pdf
     // does prove to work in actual tests, and is obviously faster
     // than performing further iterations of murmur.

File: src/java/org/apache/cassandra/utils/Log4jLogger.java
Patch:
@@ -20,7 +20,7 @@
 
 /**
  * Log4j configurations may change while the application is running, 
- * potentially invalidating a logger's appender(s).  This is a convinience
+ * potentially invalidating a logger's appender(s).  This is a convenience
  * class to wrap logger calls so that a logger is always explicitly 
  * invoked.
  */

File: src/java/org/apache/cassandra/db/ColumnReadCommand.java
Patch:
@@ -35,8 +35,7 @@ public ColumnReadCommand(String table, String key, String columnFamilyColumn)
     @Override
     public String getColumnFamilyName()
     {
-        String[] values = RowMutation.getColumnAndColumnFamily(columnFamilyColumn);
-        return values[0];
+        return RowMutation.getColumnAndColumnFamily(columnFamilyColumn)[0];
     }
 
     @Override

File: src/java/org/apache/cassandra/db/SliceByNamesReadCommand.java
Patch:
@@ -41,7 +41,7 @@ public SliceByNamesReadCommand(String table, String key, String columnFamily, Li
     @Override
     public String getColumnFamilyName()
     {
-        return columnFamily;
+        return RowMutation.getColumnAndColumnFamily(columnFamily)[0];
     }
 
     @Override

File: src/java/org/apache/cassandra/db/SliceByRangeReadCommand.java
Patch:
@@ -1 +1 @@
-package org.apache.cassandra.db;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;public class SliceByRangeReadCommand extends ReadCommand {		public final String columnFamily;	public final String startColumn;	public final String endColumn;	public final int count;		public SliceByRangeReadCommand(String table, String key, String columnFamily, String startCol, String endCol, int count)	{		super(table, key, CMD_TYPE_GET_SLICE_BY_RANGE);		this.columnFamily = columnFamily;		this.startColumn = startCol;		this.endColumn = endCol;		this.count = count;	}		@Override	public ReadCommand copy() 	{		ReadCommand readCommand= new SliceByRangeReadCommand(table, key, columnFamily, startColumn, endColumn,count);		readCommand.setDigestQuery(isDigestQuery());		return readCommand;	}	@Override	public String getColumnFamilyName() 	{		return columnFamily;	}	@Override	public Row getRow(Table table) throws IOException 	{		return table.getRow(key, columnFamily, startColumn, endColumn, count);	}		@Override    public String toString()    {        return "SliceByRangeReadCommand(" +               "table='" + table + '\'' +               ", key='" + key + '\'' +               ", columnFamily='" + columnFamily + '\'' +               ", startColumn=" + startColumn +               ", endColumn=" + endColumn +               ')';    }}class SliceByRangeReadCommandSerializer extends ReadCommandSerializer{	@Override	public void serialize(ReadCommand rm, DataOutputStream dos) throws IOException	{		SliceByRangeReadCommand realRM = (SliceByRangeReadCommand)rm;		dos.writeBoolean(realRM.isDigestQuery());		dos.writeUTF(realRM.table);		dos.writeUTF(realRM.key);		dos.writeUTF(realRM.columnFamily);		dos.writeUTF(realRM.startColumn);		dos.writeUTF(realRM.endColumn);		dos.writeInt(realRM.count);	}	@Override	public ReadCommand deserialize(DataInputStream dis) throws IOException	{		boolean isDigest = dis.readBoolean();		String table = dis.readUTF();		String key = dis.readUTF();		String columnFamily = dis.readUTF();		String startColumn = dis.readUTF();		String endColumn = dis.readUTF();		int count = dis.readInt();		SliceByRangeReadCommand rm = new SliceByRangeReadCommand(table, key, columnFamily, startColumn, endColumn, count);		rm.setDigestQuery(isDigest);		return rm;	}}
\ No newline at end of file
+package org.apache.cassandra.db;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;public class SliceByRangeReadCommand extends ReadCommand {		public final String columnFamily;	public final String startColumn;	public final String endColumn;	public final int count;		public SliceByRangeReadCommand(String table, String key, String columnFamily, String startCol, String endCol, int count)	{		super(table, key, CMD_TYPE_GET_SLICE_BY_RANGE);		this.columnFamily = columnFamily;		this.startColumn = startCol;		this.endColumn = endCol;		this.count = count;	}		@Override	public ReadCommand copy() 	{		ReadCommand readCommand= new SliceByRangeReadCommand(table, key, columnFamily, startColumn, endColumn,count);		readCommand.setDigestQuery(isDigestQuery());		return readCommand;	}	@Override	public String getColumnFamilyName() 	{        return RowMutation.getColumnAndColumnFamily(columnFamily)[0];	}	@Override	public Row getRow(Table table) throws IOException 	{		return table.getRow(key, columnFamily, startColumn, endColumn, count);	}		@Override    public String toString()    {        return "SliceByRangeReadCommand(" +               "table='" + table + '\'' +               ", key='" + key + '\'' +               ", columnFamily='" + columnFamily + '\'' +               ", startColumn=" + startColumn +               ", endColumn=" + endColumn +               ')';    }}class SliceByRangeReadCommandSerializer extends ReadCommandSerializer{	@Override	public void serialize(ReadCommand rm, DataOutputStream dos) throws IOException	{		SliceByRangeReadCommand realRM = (SliceByRangeReadCommand)rm;		dos.writeBoolean(realRM.isDigestQuery());		dos.writeUTF(realRM.table);		dos.writeUTF(realRM.key);		dos.writeUTF(realRM.columnFamily);		dos.writeUTF(realRM.startColumn);		dos.writeUTF(realRM.endColumn);		dos.writeInt(realRM.count);	}	@Override	public ReadCommand deserialize(DataInputStream dis) throws IOException	{		boolean isDigest = dis.readBoolean();		String table = dis.readUTF();		String key = dis.readUTF();		String columnFamily = dis.readUTF();		String startColumn = dis.readUTF();		String endColumn = dis.readUTF();		int count = dis.readInt();		SliceByRangeReadCommand rm = new SliceByRangeReadCommand(table, key, columnFamily, startColumn, endColumn, count);		rm.setDigestQuery(isDigest);		return rm;	}}
\ No newline at end of file

File: src/java/org/apache/cassandra/config/DatabaseDescriptor.java
Patch:
@@ -117,7 +117,8 @@ public class DatabaseDescriptor
         try
         {
             configFileName_ = System.getProperty("storage-config") + System.getProperty("file.separator") + "storage-conf.xml";
-            logger_.debug("Loading settings from " + configFileName_);
+            if (logger_.isDebugEnabled())
+              logger_.debug("Loading settings from " + configFileName_);
             XMLUtils xmlUtils = new XMLUtils(configFileName_);
 
             /* Cluster Name */

File: src/java/org/apache/cassandra/db/BinaryMemtable.java
Patch:
@@ -75,7 +75,8 @@ boolean isThresholdViolated()
     {
         if (currentSize_.get() >= threshold_ || columnFamilies_.size() > 50000)
         {
-            logger_.debug("CURRENT SIZE:" + currentSize_.get());
+            if (logger_.isDebugEnabled())
+              logger_.debug("CURRENT SIZE:" + currentSize_.get());
         	return true;
         }
         return false;

File: src/java/org/apache/cassandra/db/BinaryMemtableManager.java
Patch:
@@ -76,7 +76,8 @@ public void run()
             }
             catch (IOException e)
             {
-                logger_.debug( LogUtil.throwableToString(e) );
+                if (logger_.isDebugEnabled())
+                  logger_.debug( LogUtil.throwableToString(e) );
             }        	
         }
     }

File: src/java/org/apache/cassandra/db/CalloutManager.java
Patch:
@@ -161,7 +161,8 @@ public void addCallout(String callout, String script) throws IOException
         File file = new File(scriptFile);
         if ( file.exists() )
         {
-            logger_.debug("Deleting the old script file ...");
+            if (logger_.isDebugEnabled())
+              logger_.debug("Deleting the old script file ...");
             file.delete();
         }
         FileOutputStream fos = new FileOutputStream(scriptFile);

File: src/java/org/apache/cassandra/db/ColumnFamily.java
Patch:
@@ -220,7 +220,8 @@ public void addColumn(String name, byte[] value, long timestamp, boolean deleted
 
     void clear()
     {
-        logger_.debug("clearing");
+        if (logger_.isDebugEnabled())
+          logger_.debug("clearing");
     	columns_.clear();
     	size_.set(0);
     }

File: src/java/org/apache/cassandra/db/CommitLog.java
Patch:
@@ -464,7 +464,8 @@ private void discard(CommitLog.CommitLogContext cLogCtx, int id) throws IOExcept
                 oldCommitLogHeader.and(commitLogHeader);
                 if(oldCommitLogHeader.isSafeToDelete())
                 {
-                	logger_.debug("Deleting commit log:"+ oldFile);
+                	if (logger_.isDebugEnabled())
+                	  logger_.debug("Deleting commit log:"+ oldFile);
                     FileUtils.deleteAsync(oldFile);
                     listOfDeletedFiles.add(oldFile);
                 }

File: src/java/org/apache/cassandra/db/ReadVerbHandler.java
Patch:
@@ -95,7 +95,8 @@ public void doVerb(Message message)
             System.arraycopy(readCtx.bufOut_.getData(), 0, bytes, 0, bytes.length);
 
             Message response = message.getReply(StorageService.getLocalStorageEndPoint(), bytes);
-            logger_.debug("Read key " + readCommand.key + "; sending response to " + message.getMessageId() + "@" + message.getFrom());
+            if (logger_.isDebugEnabled())
+              logger_.debug("Read key " + readCommand.key + "; sending response to " + message.getMessageId() + "@" + message.getFrom());
             MessagingService.getMessagingInstance().sendOneWay(response, message.getFrom());
 
             /* Do read repair if header of the message says so */

File: src/java/org/apache/cassandra/db/SystemTable.java
Patch:
@@ -52,7 +52,8 @@ public static void updateToken(Token token) throws IOException
         /* create the "Token" whose value is the new token. */
         IColumn tokenColumn = new Column(SystemTable.TOKEN, p.getTokenFactory().toByteArray(token), oldTokenColumnTimestamp + 1);
         /* replace the old "Token" column with this new one. */
-        logger_.debug("Replacing old token " + p.getTokenFactory().fromByteArray(cf.getColumn(SystemTable.TOKEN).value()) + " with " + token);
+        if (logger_.isDebugEnabled())
+          logger_.debug("Replacing old token " + p.getTokenFactory().fromByteArray(cf.getColumn(SystemTable.TOKEN).value()) + " with " + token);
         RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, LOCATION_KEY);
         cf.addColumn(tokenColumn);
         rm.add(cf);

File: src/java/org/apache/cassandra/dht/LeaveJoinProtocolImpl.java
Patch:
@@ -70,7 +70,8 @@ public void run()
             
             Set<Token> oldTokens = new HashSet<Token>( tokenToEndPointMap.keySet() );
             Range[] oldRanges = StorageService.instance().getAllRanges(oldTokens);
-            logger_.debug("Total number of old ranges " + oldRanges.length);
+            if (logger_.isDebugEnabled())
+              logger_.debug("Total number of old ranges " + oldRanges.length);
             /* Calculate the list of nodes that handle the old ranges */
             Map<Range, List<EndPoint>> oldRangeToEndPointMap = StorageService.instance().constructRangeToEndPointMap(oldRanges);
             

File: src/java/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -927,7 +927,8 @@ class JoinVerbHandler implements IVerbHandler
     public void doVerb(Message message)
     {
         EndPoint from = message.getFrom();
-        logger_.debug("Received a JoinMessage from " + from);
+        if (logger_.isDebugEnabled())
+          logger_.debug("Received a JoinMessage from " + from);
 
         byte[] bytes = message.getMessageBody();
         DataInputStream dis = new DataInputStream( new ByteArrayInputStream(bytes) );

File: src/java/org/apache/cassandra/net/FileStreamTask.java
Patch:
@@ -57,7 +57,8 @@ public void run()
             File file = new File(file_);             
             connection.stream(file, startPosition_, total_);
             MessagingService.setStreamingMode(false);
-            logger_.debug("Done streaming " + file);
+            if (logger_.isDebugEnabled())
+              logger_.debug("Done streaming " + file);
         }            
         catch ( SocketException se )
         {                        

File: src/java/org/apache/cassandra/net/UdpConnection.java
Patch:
@@ -138,7 +138,8 @@ public void read(SelectionKey key)
             SocketAddress sa = socketChannel_.receive(buffer);
             if ( sa == null )
             {
-                logger_.debug("*** No datagram packet was available to be read ***");
+                if (logger_.isDebugEnabled())
+                  logger_.debug("*** No datagram packet was available to be read ***");
                 return;
             }            
             buffer.flip();

File: src/java/org/apache/cassandra/net/io/ContentStreamState.java
Patch:
@@ -57,7 +57,8 @@ private void createFileChannel() throws IOException
     {
         if ( fc_ == null )
         {
-            logger_.debug("Creating file for " + streamContext_.getTargetFile());
+            if (logger_.isDebugEnabled())
+              logger_.debug("Creating file for " + streamContext_.getTargetFile());
             FileOutputStream fos = new FileOutputStream( streamContext_.getTargetFile(), true );
             fc_ = fos.getChannel();            
         }

File: src/java/org/apache/cassandra/service/LoadDisseminator.java
Patch:
@@ -36,7 +36,8 @@ public void run()
         {
             long diskSpace = FileUtils.getUsedDiskSpace();                
             String diskUtilization = FileUtils.stringifyFileSize(diskSpace);
-            logger_.debug("Disseminating load info ...");
+            if (logger_.isDebugEnabled())
+              logger_.debug("Disseminating load info ...");
             Gossiper.instance().addApplicationState(LoadDisseminator.loadInfo_, new ApplicationState(diskUtilization));
         }
         catch ( Throwable ex )

File: src/java/org/apache/cassandra/service/MultiQuorumResponseHandler.java
Patch:
@@ -163,7 +163,8 @@ public Row[] get() throws TimeoutException
             }
             catch ( InterruptedException ex )
             {
-                logger_.debug( LogUtil.throwableToString(ex) );
+                if (logger_.isDebugEnabled())
+                  logger_.debug( LogUtil.throwableToString(ex) );
             }
             
             if ( !bVal && !done_.get() )

File: src/java/org/apache/cassandra/service/QuorumResponseHandler.java
Patch:
@@ -72,7 +72,8 @@ public T get() throws TimeoutException, DigestMismatchException
             }
             catch ( InterruptedException ex )
             {
-                logger_.debug( LogUtil.throwableToString(ex) );
+                if (logger_.isDebugEnabled())
+                  logger_.debug( LogUtil.throwableToString(ex) );
             }
             
             if ( !bVal && !done_.get() )

File: src/java/org/apache/cassandra/service/ReadResponseResolver.java
Patch:
@@ -81,7 +81,8 @@ public Row resolve(List<Message> responses) throws DigestMismatchException
             {
                 long start = System.currentTimeMillis();
                 ReadResponse result = ReadResponse.serializer().deserialize(bufIn);
-                logger_.debug( "Response deserialization time : " + (System.currentTimeMillis() - start) + " ms.");
+                if (logger_.isDebugEnabled())
+                  logger_.debug( "Response deserialization time : " + (System.currentTimeMillis() - start) + " ms.");
     			if(!result.isDigestQuery())
     			{
     				rowList.add(result.row());

File: src/java/org/apache/cassandra/service/TokenUpdateVerbHandler.java
Patch:
@@ -46,7 +46,8 @@ public void doVerb(Message message)
         }
     	catch( IOException ex )
     	{
-    		logger_.debug(LogUtil.throwableToString(ex));
+    		if (logger_.isDebugEnabled())
+    		  logger_.debug(LogUtil.throwableToString(ex));
     	}
     }
 

File: src/java/org/apache/cassandra/test/TestRunner.java
Patch:
@@ -248,7 +248,8 @@ public void run()
             while ( scanner.hasNext() )
             {
                 Row row = scanner.next();    
-                logger_.debug(row.key());
+                if (logger_.isDebugEnabled())
+                  logger_.debug(row.key());
             }            
         }
         catch ( IOException ex )

File: src/java/org/apache/cassandra/utils/FileUtils.java
Patch:
@@ -144,7 +144,8 @@ public static boolean delete(List<String> files) throws IOException
             bVal = delete(file);
             if (bVal)
             {
-            	logger_.debug("Deleted file " + file);
+            	if (logger_.isDebugEnabled())
+            	  logger_.debug("Deleted file " + file);
                 files.remove(i);
             }
         }

File: test/unit/org/apache/cassandra/db/RangeFilterTest.java
Patch:
@@ -41,7 +41,6 @@ public void testRangeFilterOnColumns() throws IOException
         ColumnFamily filteredCf = f.filter(cf.name(), cf);
         
         assertEquals(filteredCf.getColumnCount(),3);
-        assertFalse(f.isDone());
     }
     
     @Test
@@ -59,7 +58,6 @@ public void testRangeFilterOnColumnsWithCount() throws IOException
         ColumnFamily filteredCf = f.filter(cf.name(), cf);
         
         assertEquals(filteredCf.getColumnCount(),2);
-        assertTrue(f.isDone());
     }
 
     @Test
@@ -100,7 +98,6 @@ public void testRangeFilterOnSuperColumns() throws IOException
 
         col = filteredCf.getColumn("c");
         assertNotNull(col);
-        assertFalse(f.isDone());
     }
 
 }

File: src/java/org/apache/cassandra/db/TimeFilter.java
Patch:
@@ -84,6 +84,7 @@ else if (values.length == 2 && columnFamily.isSuper())
             {
                 SuperColumn superColumn = (SuperColumn) column;
                 SuperColumn filteredSuperColumn = new SuperColumn(superColumn.name());
+                filteredSuperColumn.markForDeleteAt(column.getLocalDeletionTime(), column.getMarkedForDeleteAt());
                 filteredCf.addColumn(filteredSuperColumn);
                 Collection<IColumn> subColumns = superColumn.getSubColumns();
                 int i = 0;

File: src/java/org/apache/cassandra/io/SequenceFile.java
Patch:
@@ -493,7 +493,6 @@ private int handleColumnTimeIndexes(String cfName, List<IndexHelper.ColumnIndexI
          */
         public long next(String key, DataOutputBuffer bufOut, String columnFamilyName, List<String> columnNames, IndexHelper.TimeRange timeRange, long position) throws IOException
         {
-            assert !columnFamilyName.contains(":");
             assert timeRange == null || columnNames == null; // at most one may be non-null
 
             long bytesRead = -1L;

File: src/java/org/apache/cassandra/db/BinaryVerbHandler.java
Patch:
@@ -52,7 +52,7 @@ public void doVerb(Message message)
 	    {
             RowMutationMessage rmMsg = RowMutationMessage.serializer().deserialize(rowMutationCtx.buffer_);
             RowMutation rm = rmMsg.getRowMutation();            	                
-            rowMutationCtx.row_.key(rm.key());
+            rowMutationCtx.row_.setKey(rm.key());
             rm.applyBinary(rowMutationCtx.row_);
 	
 	    }        

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -659,7 +659,7 @@ public Row getRow(String key, String cf, List<String> columns) throws IOExceptio
     */
     public Row getSliceFrom(String key, String cf, boolean isAscending, int count) throws IOException
     {
-        Row row = new Row(key);
+        Row row = new Row(table_, key);
         String[] values = RowMutation.getColumnAndColumnFamily(cf);
         String cfName = values[0];
         String startWith = values.length > 1 ? values[1] : "";

File: src/java/org/apache/cassandra/service/CassandraServer.java
Patch:
@@ -227,7 +227,7 @@ public column_t get_column(String tablename, String key, String columnPath) thro
         {
             throw new InvalidRequestException("get_column requires non-empty columnfamily");
         }
-        if (DatabaseDescriptor.getColumnFamilyType(null, values[0]).equals("Standard"))
+        if (DatabaseDescriptor.getColumnFamilyType(tablename, values[0]).equals("Standard"))
         {
             if (values.length != 2)
             {

File: src/java/org/apache/cassandra/db/BinaryMemtable.java
Patch:
@@ -145,7 +145,7 @@ void flush() throws IOException
          * Use the SSTable to write the contents of the TreeMap
          * to disk.
         */
-        SSTable ssTable = new SSTable(directory, filename, null, StorageService.getPartitioner());
+        SSTable ssTable = new SSTable(directory, filename, StorageService.getPartitioner());
         List<String> keys = new ArrayList<String>( columnFamilies_.keySet() );
         Collections.sort(keys);        
         /* Use this BloomFilter to decide if a key exists in a SSTable */

File: src/java/org/apache/cassandra/db/ColumnIterator.java
Patch:
@@ -58,7 +58,7 @@ public SSTableColumnIterator(String filename, String key, String cfName, String
     throws IOException
     {
         this.isAscending = isAscending;
-        SSTable ssTable = new SSTable(filename, null, StorageService.getPartitioner());
+        SSTable ssTable = new SSTable(filename, StorageService.getPartitioner());
         reader = ssTable.getColumnGroupReader(key, cfName, startColumn, isAscending);
         this.startColumn = startColumn;
         curColumnIndex = isAscending ? 0 : -1;

File: src/java/org/apache/cassandra/db/CommitLog.java
Patch:
@@ -272,7 +272,7 @@ void recover(File[] clogs) throws IOException
         for (File file : clogs)
         {
             // IFileReader reader = SequenceFile.bufferedReader(file.getAbsolutePath(), DatabaseDescriptor.getLogFileSizeThreshold());
-            IFileReader reader = SequenceFile.reader(table_, file.getAbsolutePath());
+            IFileReader reader = SequenceFile.reader(file.getAbsolutePath());
             try
             {
                 CommitLogHeader clHeader = readCommitLogHeader(reader);

File: src/java/org/apache/cassandra/db/Memtable.java
Patch:
@@ -253,7 +253,7 @@ void flush(CommitLog.CommitLogContext cLogCtx) throws IOException
 
         String directory = DatabaseDescriptor.getDataFileLocation();
         String filename = cfStore.getTempFileName();
-        SSTable ssTable = new SSTable(directory, filename, table_, StorageService.getPartitioner());
+        SSTable ssTable = new SSTable(directory, filename, StorageService.getPartitioner());
 
         // sort keys in the order they would be in when decorated
         final IPartitioner partitioner = StorageService.getPartitioner();

File: src/java/org/apache/cassandra/db/SystemTable.java
Patch:
@@ -82,7 +82,7 @@ public static SystemTable openSystemTable(String tableName) throws IOException
         table_ = table;
         String systemTable = getFileName();
         writer_ = SequenceFile.writer(systemTable);
-        reader_ = SequenceFile.reader(systemTable, table);
+        reader_ = SequenceFile.reader(systemTable);
     }
 
     private String getFileName()

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -92,7 +92,7 @@ public static Table.TableMetadata instance(String table) throws IOException
             {
                 String file = getFileName(table);
                 writer_ = SequenceFile.writer(file);        
-                reader_ = SequenceFile.reader(file, table);
+                reader_ = SequenceFile.reader(file);
                 Table.TableMetadata.load(table);
 
                 metadata = new Table.TableMetadata();
@@ -118,7 +118,7 @@ private static void load(String table) throws IOException
                 
                 if ( reader_ == null )
                 {
-                    reader_ = SequenceFile.reader(file, table);
+                    reader_ = SequenceFile.reader(file);
                 }
                 
                 while ( !reader_.isEOF() )
@@ -962,7 +962,7 @@ public boolean evaluate(Object key)
             // sstables
             for (String filename : cfs.getSSTableFilenames())
             {
-                FileStruct fs = new FileStruct(SequenceFile.reader(filename, table_), StorageService.getPartitioner());
+                FileStruct fs = new FileStruct(SequenceFile.reader(filename), StorageService.getPartitioner());
                 fs.seekTo(startWith);
                 iterators.add(fs);
             }

File: test/unit/org/apache/cassandra/io/SSTableTest.java
Patch:
@@ -56,7 +56,7 @@ public void testSingleWrite() throws IOException {
 
     private void verifySingle(File f, byte[] bytes, String key) throws IOException
     {
-        SSTable ssTable = new SSTable(f.getPath() + "-Data.db", "Table1", new OrderPreservingPartitioner());
+        SSTable ssTable = new SSTable(f.getPath() + "-Data.db", new OrderPreservingPartitioner());
         FileStruct fs = new FileStruct(SequenceFile.bufferedReader(ssTable.dataFile_, 128 * 1024), new OrderPreservingPartitioner());
         fs.seekTo(key);
         int size = fs.getBufIn().readInt();
@@ -95,7 +95,7 @@ private void verifyMany(File f, TreeMap<String, byte[]> map) throws IOException
     {
         List<String> keys = new ArrayList(map.keySet());
         Collections.shuffle(keys);
-        SSTable ssTable = new SSTable(f.getPath() + "-Data.db", "Table1", new OrderPreservingPartitioner());
+        SSTable ssTable = new SSTable(f.getPath() + "-Data.db", new OrderPreservingPartitioner());
         FileStruct fs = new FileStruct(SequenceFile.bufferedReader(ssTable.dataFile_, 128 * 1024), new OrderPreservingPartitioner());
         for (String key : keys)
         {

File: test/unit/org/apache/cassandra/db/NameSortTest.java
Patch:
@@ -89,7 +89,7 @@ private void validateNameSort(Table table, int N) throws IOException
             }
 
             cf = table.get(key, "Super1");
-            assert cf != null;
+            assert cf != null : "key " + key + " is missing!";
             Collection<IColumn> superColumns = cf.getAllColumns();
             assert superColumns.size() == 8;
             for (IColumn superColumn : superColumns)

File: src/java/org/apache/cassandra/db/Memtable.java
Patch:
@@ -393,7 +393,7 @@ public void flushWhenTerminated(final CommitLog.CommitLogContext cLogCtx)
             {
                 public void run()
                 {
-                    MemtableManager.instance().submit(cfName_, Memtable.this, cLogCtx);
+                    ColumnFamilyStore.submitFlush(Memtable.this, cLogCtx);
                 }
             };
             flushQueuer = new FutureTask(runnable, null);

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -886,7 +886,7 @@ public List<String> getKeyRange(final String startWith, final String stopAt, int
             // memtable keys: current and historical
             Iterator<Memtable> memtables = (Iterator<Memtable>) IteratorUtils.chainedIterator(
                     IteratorUtils.singletonIterator(cfs.getMemtable()),
-                    MemtableManager.instance().getUnflushedMemtables(cfName).iterator());
+                    ColumnFamilyStore.getUnflushedMemtables(cfName).iterator());
             while (memtables.hasNext())
             {
                 iterators.add(IteratorUtils.filteredIterator(memtables.next().sortedKeyIterator(), new Predicate()

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -26,6 +26,7 @@
 import java.io.FileNotFoundException;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
+import java.util.concurrent.ExecutionException;
 
 import org.apache.commons.collections.IteratorUtils;
 import org.apache.commons.collections.Predicate;
@@ -870,7 +871,7 @@ public Set<String> getApplicationColumnFamilies()
      * @param maxResults
      * @return list of keys between startWith and stopAt
      */
-    public List<String> getKeyRange(final String startWith, final String stopAt, int maxResults) throws IOException
+    public List<String> getKeyRange(final String startWith, final String stopAt, int maxResults) throws IOException, ExecutionException, InterruptedException
     {
         // (OPP key decoration is a no-op so using the "decorated" comparator against raw keys is fine)
         final Comparator<String> comparator = StorageService.getPartitioner().getDecoratedKeyComparator();

File: src/java/org/apache/cassandra/service/RangeVerbHandler.java
Patch:
@@ -22,7 +22,7 @@ public void doVerb(Message message)
             Table table = Table.open(command.table);
             keys = table.getKeyRange(command.startWith, command.stopAt, command.maxResults);
         }
-        catch (IOException e)
+        catch (Exception e)
         {
             throw new RuntimeException(e);
         }

File: src/java/org/apache/cassandra/db/Memtable.java
Patch:
@@ -226,7 +226,8 @@ public void forceflush()
     }
 
     void flushOnRecovery() throws IOException {
-        flush(CommitLog.CommitLogContext.NULL);
+        if (!isClean())
+            flush(CommitLog.CommitLogContext.NULL);
     }
 
     private void resolve(String key, ColumnFamily columnFamily)

File: src/java/org/apache/cassandra/db/ReadResponse.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.cassandra.net.Message;
 import org.apache.cassandra.net.MessagingService;
 import org.apache.cassandra.service.StorageService;
+import org.apache.commons.lang.ArrayUtils;
 
 
 /*
@@ -60,11 +61,12 @@ public static Message makeReadResponseMessage(ReadResponse readResponse) throws
 	
 	private String table_;
 	private Row row_;
-	private byte[] digest_ = new byte[0];
+	private byte[] digest_ = ArrayUtils.EMPTY_BYTE_ARRAY;
     private boolean isDigestQuery_ = false;
 
 	public ReadResponse(String table, byte[] digest )
     {
+        assert digest != null;
 		table_ = table;
 		digest_= digest;
 	}

File: src/java/org/apache/cassandra/db/ReadVerbHandler.java
Patch:
@@ -77,7 +77,7 @@ public void doVerb(Message message)
             Row row = null;
             row = readCommand.getRow(table);
             ReadResponse readResponse = null;
-            if(readCommand.isDigestQuery())
+            if (readCommand.isDigestQuery())
             {
                 readResponse = new ReadResponse(table.getTableName(), row.digest());
             }

File: src/java/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -437,7 +437,8 @@ public void forceFlush()
 
     void forceBlockingFlush() throws IOException, ExecutionException, InterruptedException
     {
-        forceFlush();
+        Memtable oldMemtable = memtable_.get();
+        oldMemtable.forceflush();
         // block for flush to finish by adding a no-op action to the flush executorservice
         // and waiting for that to finish.  (this works since flush ES is single-threaded.)
         Future f = MemtableManager.instance().flusher_.submit(new Runnable()
@@ -447,6 +448,7 @@ public void run()
             }
         });
         f.get();
+        assert oldMemtable.isFlushed() || oldMemtable.isClean();
     }
 
     void forceFlushBinary()

File: test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
Patch:
@@ -257,6 +257,7 @@ public void testRemoveSuperColumn() throws IOException, ExecutionException, Inte
         rm.apply();
 
         List<ColumnFamily> families = store.getColumnFamilies("key1", "Super1", new IdentityFilter());
+        assert families.size() == 2 : StringUtils.join(families, ", ");
         assert families.get(0).getAllColumns().first().getMarkedForDeleteAt() == 1; // delete marker, just added
         assert !families.get(1).getAllColumns().first().isMarkedForDelete(); // flushed old version
         ColumnFamily resolved = ColumnFamily.resolve(families);

File: src/java/org/apache/cassandra/concurrent/ContinuationStage.java
Patch:
@@ -85,7 +85,7 @@ public boolean isShutdown()
         return executorService_.isShutdown();
     }
     
-    public long getTaskCount(){
+    public long getPendingTasks(){
         return (executorService_.getTaskCount() - executorService_.getCompletedTaskCount());
     }
 }

File: src/java/org/apache/cassandra/concurrent/IStage.java
Patch:
@@ -116,5 +116,5 @@ public interface IStage
      * pending on this stage to be executed.
      * @return task count.
      */
-    public long getTaskCount();
+    public long getPendingTasks();
 }

File: src/java/org/apache/cassandra/concurrent/MultiThreadedStage.java
Patch:
@@ -92,7 +92,7 @@ public boolean isShutdown()
         return executorService_.isShutdown();
     }
     
-    public long getTaskCount(){
-        return (executorService_.getTaskCount() - executorService_.getCompletedTaskCount());
+    public long getPendingTasks(){
+        return executorService_.getPendingTasks();
     }
 }

File: src/java/org/apache/cassandra/concurrent/SingleThreadedContinuationStage.java
Patch:
@@ -92,7 +92,7 @@ public boolean isShutdown()
         return executorService_.isShutdown();
     }    
     
-    public long getTaskCount(){
+    public long getPendingTasks(){
         return (executorService_.getTaskCount() - executorService_.getCompletedTaskCount());
     }
     /* Finished implementing the IStage interface methods */

File: src/java/org/apache/cassandra/concurrent/SingleThreadedStage.java
Patch:
@@ -94,8 +94,7 @@ public boolean isShutdown()
         return executorService_.isShutdown();
     }    
     
-    public long getTaskCount(){
-        return (executorService_.getTaskCount() - executorService_.getCompletedTaskCount());
+    public long getPendingTasks(){
+        return executorService_.getPendingTasks();
     }
-    /* Finished implementing the IStage interface methods */
 }

File: src/java/org/apache/cassandra/concurrent/StageManager.java
Patch:
@@ -23,8 +23,6 @@
 import java.util.Set;
 import java.util.concurrent.ExecutorService;
 
-import org.apache.cassandra.continuations.Suspendable;
-
 
 /**
  * This class manages all stages that exist within a process. The application registers
@@ -101,7 +99,7 @@ public static void deregisterStage(String stageName)
      */
     public static long getStageTaskCount(String stage)
     {
-        return stageQueues_.get(stage).getTaskCount();
+        return stageQueues_.get(stage).getPendingTasks();
     }
 
     /**

File: src/java/org/apache/cassandra/net/TcpConnection.java
Patch:
@@ -174,7 +174,7 @@ public void write(Message message) throws IOException
         byte[] data = serializer_.serialize(message);        
         if ( data.length > 0 )
         {    
-            boolean listening = ( message.getFrom().equals(EndPoint.randomLocalEndPoint_) ) ? false : true;
+            boolean listening = !message.getFrom().equals(EndPoint.randomLocalEndPoint_);
             ByteBuffer buffer = MessagingService.packIt( data , false, false, listening);   
             synchronized(this)
             {
@@ -184,7 +184,6 @@ public void write(Message message) throws IOException
                     return;
                 }
                 
-                logger_.debug("Sending packets of size " + data.length);            
                 socketChannel_.write(buffer);                
                 
                 if (buffer.remaining() > 0) 

File: src/java/org/apache/cassandra/net/UdpConnection.java
Patch:
@@ -78,7 +78,7 @@ public boolean write(Message message, EndPoint to) throws IOException
         byte[] data = bos.toByteArray();
         if ( data.length > 0 )
         {  
-            logger_.debug("Size of Gossip packet " + data.length);
+            logger_.trace("Size of Gossip packet " + data.length);
             byte[] protocol = BasicUtilities.intToByteArray(protocol_);
             ByteBuffer buffer = ByteBuffer.allocate(data.length + protocol.length);
             buffer.put( protocol );

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -263,7 +263,6 @@ public static StorageService instance()
      */
     private void init()
     {
-        // Register this instance with JMX
         try
         {
             MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();

File: src/java/org/apache/cassandra/db/BinaryVerbHandler.java
Patch:
@@ -39,7 +39,7 @@ public class BinaryVerbHandler implements IVerbHandler
     
     public void doVerb(Message message)
     { 
-        byte[] bytes = (byte[])message.getMessageBody()[0];
+        byte[] bytes = message.getMessageBody();
         /* Obtain a Row Mutation Context from TLS */
         RowMutationContext rowMutationCtx = tls_.get();
         if ( rowMutationCtx == null )

File: src/java/org/apache/cassandra/db/CalloutDeployMessage.java
Patch:
@@ -46,7 +46,7 @@ public static Message getCalloutDeployMessage(CalloutDeployMessage cdMessage) th
         ByteArrayOutputStream bos = new ByteArrayOutputStream();
         DataOutputStream dos = new DataOutputStream(bos);
         serializer_.serialize(cdMessage, dos);
-        Message message = new Message(StorageService.getLocalStorageEndPoint(), "", StorageService.calloutDeployVerbHandler_, new Object[]{bos.toByteArray()});
+        Message message = new Message(StorageService.getLocalStorageEndPoint(), "", StorageService.calloutDeployVerbHandler_, bos.toByteArray());
         return message;
     }
     

File: src/java/org/apache/cassandra/db/CalloutDeployVerbHandler.java
Patch:
@@ -32,8 +32,7 @@ public class CalloutDeployVerbHandler implements IVerbHandler
     
     public void doVerb(Message message)
     {
-        Object[] body = message.getMessageBody();
-        byte[] bytes = (byte[])body[0];
+        byte[] bytes = message.getMessageBody();
         DataInputBuffer bufIn = new DataInputBuffer();
         bufIn.reset(bytes, bytes.length);
         try

File: src/java/org/apache/cassandra/db/DataFileVerbHandler.java
Patch:
@@ -20,8 +20,7 @@ public class DataFileVerbHandler implements IVerbHandler
     
     public void doVerb(Message message)
     {        
-        Object[] body = message.getMessageBody();
-        byte[] bytes = (byte[])body[0];
+        byte[] bytes = message.getMessageBody();
         String table = new String(bytes);
         logger_.info("**** Received a request from " + message.getFrom());
         
@@ -35,7 +34,7 @@ public void doVerb(Message message)
             {
                 dos.writeUTF(file);
             }
-            Message response = message.getReply( StorageService.getLocalStorageEndPoint(), new Object[]{bos.toByteArray()});
+            Message response = message.getReply( StorageService.getLocalStorageEndPoint(), bos.toByteArray());
             MessagingService.getMessagingInstance().sendOneWay(response, message.getFrom());
         }
         catch ( IOException ex )

File: src/java/org/apache/cassandra/db/RangeCommand.java
Patch:
@@ -40,7 +40,7 @@ public Message getMessage() throws IOException
 
     public static RangeCommand read(Message message) throws IOException
     {
-        byte[] bytes = (byte[]) message.getMessageBody()[0];
+        byte[] bytes = message.getMessageBody();
         DataInputBuffer dib = new DataInputBuffer();
         dib.reset(bytes, bytes.length);
         return serializer.deserialize(new DataInputStream(dib));

File: src/java/org/apache/cassandra/db/ReadRepairVerbHandler.java
Patch:
@@ -40,7 +40,7 @@ public class ReadRepairVerbHandler implements IVerbHandler
     
     public void doVerb(Message message)
     {          
-        byte[] body = (byte[])message.getMessageBody()[0];
+        byte[] body = message.getMessageBody();
         DataInputBuffer buffer = new DataInputBuffer();
         buffer.reset(body, body.length);        
         

File: src/java/org/apache/cassandra/db/ReadResponse.java
Patch:
@@ -54,7 +54,7 @@ public static Message makeReadResponseMessage(ReadResponse readResponse) throws
     	ByteArrayOutputStream bos = new ByteArrayOutputStream();
         DataOutputStream dos = new DataOutputStream( bos );
         ReadResponse.serializer().serialize(readResponse, dos);
-        Message message = new Message(StorageService.getLocalStorageEndPoint(), MessagingService.responseStage_, MessagingService.responseVerbHandler_, new Object[]{bos.toByteArray()});         
+        Message message = new Message(StorageService.getLocalStorageEndPoint(), MessagingService.responseStage_, MessagingService.responseVerbHandler_, bos.toByteArray());         
         return message;
     }
 	

File: src/java/org/apache/cassandra/db/ReadVerbHandler.java
Patch:
@@ -60,7 +60,7 @@ protected static void setCurrentReadContext(ReadVerbHandler.ReadContext readCont
 
     public void doVerb(Message message)
     {
-        byte[] body = (byte[])message.getMessageBody()[0];
+        byte[] body = message.getMessageBody();
         /* Obtain a Read Context from TLS */
         ReadContext readCtx = tls_.get();
         if ( readCtx == null )
@@ -101,7 +101,7 @@ public void doVerb(Message message)
             System.arraycopy(readCtx.bufOut_.getData(), 0, bytes, 0, bytes.length);
             logger_.info("copy  TIME: " + (System.currentTimeMillis() - start) + " ms.");
 
-            Message response = message.getReply( StorageService.getLocalStorageEndPoint(), new Object[]{bytes} );
+            Message response = message.getReply( StorageService.getLocalStorageEndPoint(), bytes );
             MessagingService.getMessagingInstance().sendOneWay(response, message.getFrom());
             logger_.info("ReadVerbHandler  TIME 2: " + (System.currentTimeMillis() - start) + " ms.");
             

File: src/java/org/apache/cassandra/db/RowMutationVerbHandler.java
Patch:
@@ -53,7 +53,7 @@ protected static class RowMutationContext
 
     public void doVerb(Message message)
     {
-        byte[] bytes = (byte[]) message.getMessageBody()[0];
+        byte[] bytes = message.getMessageBody();
         /* Obtain a Row Mutation Context from TLS */
         RowMutationContext rowMutationCtx = tls_.get();
         if ( rowMutationCtx == null )

File: src/java/org/apache/cassandra/db/Table.java
Patch:
@@ -299,7 +299,7 @@ public static class BootStrapInitiateVerbHandler implements IVerbHandler
         */
         public void doVerb(Message message)
         {
-            byte[] body = (byte[])message.getMessageBody()[0];
+            byte[] body = message.getMessageBody();
             DataInputBuffer bufIn = new DataInputBuffer();
             bufIn.reset(body, body.length); 
             
@@ -330,7 +330,7 @@ public void doVerb(Message message)
                 StreamContextManager.registerStreamCompletionHandler(message.getFrom().getHost(), new Table.BootstrapCompletionHandler());
                 /* Send a bootstrap initiation done message to execute on default stage. */
                 logger_.debug("Sending a bootstrap initiate done message ...");                
-                Message doneMessage = new Message( StorageService.getLocalStorageEndPoint(), "", StorageService.bootStrapInitiateDoneVerbHandler_, new Object[]{new byte[0]} );
+                Message doneMessage = new Message( StorageService.getLocalStorageEndPoint(), "", StorageService.bootStrapInitiateDoneVerbHandler_, new byte[0] );
                 MessagingService.getMessagingInstance().sendOneWay(doneMessage, message.getFrom());
             }
             catch ( IOException ex )

File: src/java/org/apache/cassandra/db/TouchMessage.java
Patch:
@@ -32,7 +32,7 @@ public static Message makeTouchMessage(TouchMessage touchMessage) throws IOExcep
     	ByteArrayOutputStream bos = new ByteArrayOutputStream();
         DataOutputStream dos = new DataOutputStream( bos );
         TouchMessage.serializer().serialize(touchMessage, dos);
-        Message message = new Message(StorageService.getLocalStorageEndPoint(), StorageService.readStage_, StorageService.touchVerbHandler_, new Object[]{bos.toByteArray()});         
+        Message message = new Message(StorageService.getLocalStorageEndPoint(), StorageService.readStage_, StorageService.touchVerbHandler_, bos.toByteArray());         
         return message;
     }
     

File: src/java/org/apache/cassandra/db/TouchVerbHandler.java
Patch:
@@ -23,7 +23,7 @@ private static class ReadContext
 
     public void doVerb(Message message)
     {
-        byte[] body = (byte[])message.getMessageBody()[0];
+        byte[] body = message.getMessageBody();
         /* Obtain a Read Context from TLS */
         ReadContext readCtx = tls_.get();
         if ( readCtx == null )

File: src/java/org/apache/cassandra/dht/BootstrapInitiateMessage.java
Patch:
@@ -54,7 +54,7 @@ public static Message makeBootstrapInitiateMessage(BootstrapInitiateMessage biMe
         ByteArrayOutputStream bos = new ByteArrayOutputStream();
         DataOutputStream dos = new DataOutputStream( bos );
         BootstrapInitiateMessage.serializer().serialize(biMessage, dos);
-        return new Message( StorageService.getLocalStorageEndPoint(), "", StorageService.bootStrapInitiateVerbHandler_, new Object[]{bos.toByteArray()} );
+        return new Message( StorageService.getLocalStorageEndPoint(), "", StorageService.bootStrapInitiateVerbHandler_, bos.toByteArray() );
     }
     
     protected StreamContextManager.StreamContext[] streamContexts_ = new StreamContextManager.StreamContext[0];

File: src/java/org/apache/cassandra/dht/BootstrapMetadataMessage.java
Patch:
@@ -53,7 +53,7 @@ protected static Message makeBootstrapMetadataMessage(BootstrapMetadataMessage b
         ByteArrayOutputStream bos = new ByteArrayOutputStream();
         DataOutputStream dos = new DataOutputStream( bos );
         BootstrapMetadataMessage.serializer().serialize(bsMetadataMessage, dos);
-        return new Message( StorageService.getLocalStorageEndPoint(), "", StorageService.bsMetadataVerbHandler_, new Object[]{bos.toByteArray()} );            
+        return new Message( StorageService.getLocalStorageEndPoint(), "", StorageService.bsMetadataVerbHandler_, bos.toByteArray() );
     }        
     
     protected BootstrapMetadata[] bsMetadata_ = new BootstrapMetadata[0];

File: src/java/org/apache/cassandra/dht/BootstrapMetadataVerbHandler.java
Patch:
@@ -47,7 +47,7 @@ public class BootstrapMetadataVerbHandler implements IVerbHandler
     public void doVerb(Message message)
     {
         logger_.debug("Received a BootstrapMetadataMessage from " + message.getFrom());
-        byte[] body = (byte[])message.getMessageBody()[0];
+        byte[] body = message.getMessageBody();
         DataInputBuffer bufIn = new DataInputBuffer();
         bufIn.reset(body, body.length);
         try

File: src/java/org/apache/cassandra/net/io/StreamContextManager.java
Patch:
@@ -219,7 +219,7 @@ public static Message makeStreamStatusMessage(StreamStatusMessage streamStatusMe
             ByteArrayOutputStream bos = new ByteArrayOutputStream();
             DataOutputStream dos = new DataOutputStream( bos );
             StreamStatusMessage.serializer().serialize(streamStatusMessage, dos);
-            return new Message(StorageService.getLocalStorageEndPoint(), "", StorageService.bootStrapTerminateVerbHandler_, new Object[]{bos.toByteArray()});
+            return new Message(StorageService.getLocalStorageEndPoint(), "", StorageService.bootStrapTerminateVerbHandler_, bos.toByteArray());
         }
         
         protected StreamContextManager.StreamStatus streamStatus_;

File: src/java/org/apache/cassandra/service/CassandraServer.java
Patch:
@@ -573,7 +573,7 @@ public List<String> get_key_range(String tablename, String startWith, String sto
             // read response
             // TODO send more requests if we need to span multiple nodes
             // double the usual timeout since range requests are expensive
-            byte[] responseBody = (byte[])iar.get(2 * DatabaseDescriptor.getRpcTimeout(), TimeUnit.MILLISECONDS)[0];
+            byte[] responseBody = iar.get(2 * DatabaseDescriptor.getRpcTimeout(), TimeUnit.MILLISECONDS);
             return RangeReply.read(responseBody).keys;
         }
         catch (Exception e)

File: src/java/org/apache/cassandra/service/ConsistencyManager.java
Patch:
@@ -66,7 +66,7 @@ private void handleDigestResponses()
 			logger_.debug("Handle Digest reponses");
 			for( Message response : responses_ )
 			{
-				byte[] body = (byte[])response.getMessageBody()[0];            
+				byte[] body = response.getMessageBody();            
 	            bufIn.reset(body, body.length);
 	            try
 	            {	               

File: src/java/org/apache/cassandra/service/ReadRepairManager.java
Patch:
@@ -113,7 +113,7 @@ public void schedule(EndPoint target, RowMutationMessage rowMutationMessage)
 	{
         try
         {
-            Message message = RowMutationMessage.makeRowMutationMessage(rowMutationMessage, StorageService.readRepairVerbHandler_);
+            Message message = rowMutationMessage.makeRowMutationMessage(StorageService.readRepairVerbHandler_);
     		String key = target + ":" + message.getMessageId();
     		readRepairTable_.put(key, message);
         }

File: src/java/org/apache/cassandra/service/ReadResponseResolver.java
Patch:
@@ -75,7 +75,7 @@ public Row resolve(List<Message> responses) throws DigestMismatchException
         DataInputBuffer bufIn = new DataInputBuffer();
 		for (Message response : responses)
 		{					            
-            byte[] body = (byte[])response.getMessageBody()[0];            
+            byte[] body = response.getMessageBody();
             bufIn.reset(body, body.length);
             try
             {
@@ -154,7 +154,7 @@ public boolean isDataPresent(List<Message> responses)
 		boolean isDataPresent = false;
 		for (Message response : responses)
 		{
-            byte[] body = (byte[])response.getMessageBody()[0];
+            byte[] body = response.getMessageBody();
 			DataInputBuffer bufIn = new DataInputBuffer();
             bufIn.reset(body, body.length);
             try

File: src/java/org/apache/cassandra/service/StorageLoadBalancer.java
Patch:
@@ -156,11 +156,11 @@ class MoveMessageVerbHandler implements IVerbHandler
     {
         public void doVerb(Message message)
         {
-            Message reply = message.getReply(StorageService.getLocalStorageEndPoint(), new Object[]{isMoveable_.get()});
+            Message reply = message.getReply(StorageService.getLocalStorageEndPoint(), new byte[] {(byte)(isMoveable_.get() ? 1 : 0)});
             MessagingService.getMessagingInstance().sendOneWay(reply, message.getFrom());
             if ( isMoveable_.get() )
             {
-                MoveMessage moveMessage = (MoveMessage)message.getMessageBody()[0];
+                // MoveMessage moveMessage = (MoveMessage)message.getMessageBody()[0];
                 /* Start the leave operation and join the ring at the position specified */
                 isMoveable_.set(false);
             }

File: src/java/org/apache/cassandra/service/StreamManager.java
Patch:
@@ -48,7 +48,7 @@ public static class BootstrapTerminateVerbHandler implements IVerbHandler
 
         public void doVerb(Message message)
         {
-            byte[] body = (byte[])message.getMessageBody()[0];
+            byte[] body = message.getMessageBody();
             DataInputBuffer bufIn = new DataInputBuffer();
             bufIn.reset(body, body.length);
 

File: src/java/org/apache/cassandra/service/TokenUpdateVerbHandler.java
Patch:
@@ -37,7 +37,7 @@ public class TokenUpdateVerbHandler implements IVerbHandler
 
     public void doVerb(Message message)
     {
-    	byte[] body = (byte[])message.getMessageBody()[0];
+    	byte[] body = message.getMessageBody();
         Token token = StorageService.getPartitioner().getTokenFactory().fromByteArray(body);
         try
         {

File: src/java/org/apache/cassandra/tools/AdminTool.java
Patch:
@@ -159,15 +159,15 @@ public void run(int operation, String columnFamilyName, long skip) throws Throwa
 		RowMutationMessage rmMsg = new RowMutationMessage(rm);
         if( server_ != null)
         {
-            Message message = RowMutationMessage.makeRowMutationMessage(rmMsg, StorageService.binaryVerbHandler_);
+            Message message = rmMsg.makeRowMutationMessage(StorageService.binaryVerbHandler_);
 	        EndPoint to = new EndPoint(server_, 7000);
 			MessagingService.getMessagingInstance().sendOneWay(message, to);
         }
         else
         {
         	for( String server : servers_ )
         	{
-                Message message = RowMutationMessage.makeRowMutationMessage(rmMsg, StorageService.binaryVerbHandler_);
+                Message message = rmMsg.makeRowMutationMessage(StorageService.binaryVerbHandler_);
 		        EndPoint to = new EndPoint(server, 7000);
 				MessagingService.getMessagingInstance().sendOneWay(message, to);
         	}

File: src/java/org/apache/cassandra/tools/MembershipCleaner.java
Patch:
@@ -63,7 +63,7 @@ public static void main(String[] args) throws Throwable
         DataOutputStream dos = new DataOutputStream(bos);
         MembershipCleanerMessage.serializer().serialize(mcMessage, dos);
         /* Construct the token update message to be sent */
-        Message mbrshipCleanerMessage = new Message( new EndPoint(FBUtilities.getHostAddress(), port_), "", StorageService.mbrshipCleanerVerbHandler_, new Object[]{bos.toByteArray()} );
+        Message mbrshipCleanerMessage = new Message( new EndPoint(FBUtilities.getHostAddress(), port_), "", StorageService.mbrshipCleanerVerbHandler_, bos.toByteArray() );
         
         BufferedReader bufReader = new BufferedReader( new InputStreamReader( new FileInputStream(file) ) );
         String line = null;

File: src/java/org/apache/cassandra/tools/MembershipCleanerVerbHandler.java
Patch:
@@ -43,7 +43,7 @@ public class MembershipCleanerVerbHandler implements IVerbHandler
 
     public void doVerb(Message message)
     {
-        byte[] body = (byte[])message.getMessageBody()[0];
+        byte[] body = message.getMessageBody();
         
         try
         {

File: src/java/org/apache/cassandra/tools/TokenUpdateVerbHandler.java
Patch:
@@ -47,7 +47,7 @@ public class TokenUpdateVerbHandler implements IVerbHandler
 
     public void doVerb(Message message)
     {
-    	byte[] body = (byte[])message.getMessageBody()[0];
+    	byte[] body = message.getMessageBody();
         
         try
         {
@@ -78,7 +78,7 @@ public void doVerb(Message message)
                 ByteArrayOutputStream bos = new ByteArrayOutputStream();
                 DataOutputStream dos = new DataOutputStream(bos);
                 Token.serializer().serialize(token, dos);
-                message.setMessageBody(new Object[]{bos.toByteArray()});
+                message.setMessageBody(bos.toByteArray());
                 
                 logger_.debug("Sending a token update message to " + target + " to update it to " + token);
                 MessagingService.getMessagingInstance().sendOneWay(message, target);

File: src/java/org/apache/cassandra/tools/TokenUpdater.java
Patch:
@@ -58,7 +58,7 @@ public static void main(String[] args) throws Throwable
         Token.serializer().serialize(token, dos);
 
         /* Construct the token update message to be sent */
-        Message tokenUpdateMessage = new Message( new EndPoint(FBUtilities.getHostAddress(), port_), "", StorageService.tokenVerbHandler_, new Object[]{bos.toByteArray()} );
+        Message tokenUpdateMessage = new Message( new EndPoint(FBUtilities.getHostAddress(), port_), "", StorageService.tokenVerbHandler_, bos.toByteArray() );
         
         BufferedReader bufReader = new BufferedReader( new InputStreamReader( new FileInputStream(file) ) );
         String line = null;

File: src/java/org/apache/cassandra/service/StorageService.java
Patch:
@@ -549,9 +549,9 @@ public boolean isInSameDataCenter(EndPoint endpoint) throws IOException
      * sure that the N replicas are in sync. We do this in the
      * background when we do not care much about consistency.
      */
-    public void doConsistencyCheck(Row row, List<EndPoint> endpoints, ReadCommand message)
+    public void doConsistencyCheck(Row row, List<EndPoint> endpoints, ReadCommand command)
     {
-        Runnable consistencySentinel = new ConsistencyManager(row.cloneMe(), endpoints, message);
+        Runnable consistencySentinel = new ConsistencyManager(row.cloneMe(), endpoints, command);
         consistencyManager_.submit(consistencySentinel);
     }
 

File: src/org/apache/cassandra/net/SelectorManager.java
Patch:
@@ -52,7 +52,6 @@ private SelectorManager(String name)
         }
 
         setDaemon(false);
-        start();
     }
 
     /**

File: src/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -1113,7 +1113,7 @@ boolean doFileAntiCompaction(List<String> files, List<Range> ranges, EndPoint ta
 	                            continue;
 	                    	}
 	                    }
-                        if (Range.isTokenInRanges(StorageService.getPartitioner().getTokenForKey(lastkey), ranges))
+                        if (Range.isTokenInRanges(StorageService.getPartitioner().getInitialToken(lastkey), ranges))
 	                    {
 	                        if(ssTableRange == null )
 	                        {
@@ -1143,7 +1143,7 @@ boolean doFileAntiCompaction(List<String> files, List<Range> ranges, EndPoint ta
 	                    			continue;
 	                    		}
 	                    		/* keep on looping until we find a key in the range */
-                                while (!Range.isTokenInRanges(StorageService.getPartitioner().getTokenForKey(filestruct.getKey()), ranges))
+                                while (!Range.isTokenInRanges(StorageService.getPartitioner().getInitialToken(filestruct.getKey()), ranges))
 	                            {
                                     filestruct.advance();
                                     if (filestruct.isExhausted())

File: src/org/apache/cassandra/dht/OrderPreservingPartitioner.java
Patch:
@@ -110,7 +110,7 @@ public Token.TokenFactory<String> getTokenFactory()
         return tokenFactory;
     }
 
-    public Token getTokenForKey(String key)
+    public Token getInitialToken(String key)
     {
         return new StringToken(key);
     }

File: src/org/apache/cassandra/dht/RandomPartitioner.java
Patch:
@@ -103,7 +103,7 @@ public Token.TokenFactory<BigInteger> getTokenFactory()
         return tokenFactory;
     }
 
-    public Token getTokenForKey(String key)
+    public Token getInitialToken(String key)
     {
         return new BigIntegerToken(FBUtilities.hash(key));
     }

File: src/org/apache/cassandra/locator/RackAwareStrategy.java
Patch:
@@ -110,7 +110,7 @@ public Map<String, EndPoint[]> getStorageEndPoints(String[] keys)
 
         for ( String key : keys )
         {
-            results.put(key, getStorageEndPoints(partitioner_.getTokenForKey(key)));
+            results.put(key, getStorageEndPoints(partitioner_.getInitialToken(key)));
         }
 
         return results;

File: src/org/apache/cassandra/locator/RackUnawareStrategy.java
Patch:
@@ -67,7 +67,7 @@ public Map<String, EndPoint[]> getStorageEndPoints(String[] keys)
 
         for ( String key : keys )
         {
-            results.put(key, getStorageEndPoints(partitioner_.getTokenForKey(key)));
+            results.put(key, getStorageEndPoints(partitioner_.getInitialToken(key)));
         }
 
         return results;

File: test/org/apache/cassandra/locator/RackUnawareStrategyTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import java.util.List;
 import java.util.ArrayList;
-import java.math.BigInteger;
 
 import org.testng.annotations.Test;
 import org.apache.cassandra.dht.IPartitioner;
@@ -42,7 +41,7 @@ public void testStringStorageEndPoints()
         List<Token> keyTokens = new ArrayList<Token>();
         for (int i = 0; i < 5; i++) {
             endPointTokens.add(new StringToken(String.valueOf((char)('a' + i * 2))));
-            keyTokens.add(partitioner.getTokenForKey(String.valueOf((char)('a' + i * 2 + 1))));
+            keyTokens.add(partitioner.getInitialToken(String.valueOf((char)('a' + i * 2 + 1))));
         }
         testGetStorageEndPoints(tmd, strategy, endPointTokens.toArray(new Token[0]), keyTokens.toArray(new Token[0]));
     }

File: test/unit/org/apache/cassandra/db/SystemTableTest.java
Patch:
@@ -9,6 +9,6 @@
 public class SystemTableTest extends ServerTest {
     @Test
     public void testMain() throws IOException {
-        SystemTable.openSystemTable(SystemTable.cfName_).updateToken(StorageService.getPartitioner().getTokenForKey("503545744:0"));
+        SystemTable.openSystemTable(SystemTable.cfName_).updateToken(StorageService.getPartitioner().getInitialToken("503545744:0"));
     }
 }

File: src/org/apache/cassandra/cql/common/ColumnRangeQueryRSD.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.cql.execution.RuntimeErrorMsg;
 import org.apache.cassandra.db.ColumnFamily;
+import org.apache.cassandra.db.SliceReadCommand;
 import org.apache.cassandra.db.IColumn;
 import org.apache.cassandra.db.ReadCommand;
 import org.apache.cassandra.db.Row;
@@ -100,7 +101,7 @@ public List<Map<String,String>> getRows()
         try
         {
             String key = (String)(rowKey_.get());
-            ReadCommand readCommand = new ReadCommand(cfMetaData_.tableName, key, columnFamily_column, offset_, limit_);
+            ReadCommand readCommand = new SliceReadCommand(cfMetaData_.tableName, key, columnFamily_column, offset_, limit_);
             row = StorageProxy.readProtocol(readCommand, StorageService.ConsistencyLevel.WEAK);
         }
         catch (Exception e)

File: src/org/apache/cassandra/cql/common/SuperColumnRangeQueryRSD.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.cql.execution.RuntimeErrorMsg;
 import org.apache.cassandra.db.ColumnFamily;
+import org.apache.cassandra.db.SliceReadCommand;
 import org.apache.cassandra.db.IColumn;
 import org.apache.cassandra.db.ReadCommand;
 import org.apache.cassandra.db.Row;
@@ -69,7 +70,7 @@ public List<Map<String,String>> getRows()
         try
         {
             String key = (String)(rowKey_.get());
-            ReadCommand readCommand = new ReadCommand(cfMetaData_.tableName, key, cfMetaData_.cfName, offset_, limit_);
+            ReadCommand readCommand = new SliceReadCommand(cfMetaData_.tableName, key, cfMetaData_.cfName, offset_, limit_);
             row = StorageProxy.readProtocol(readCommand, StorageService.ConsistencyLevel.WEAK);
         }
         catch (Exception e)

File: src/org/apache/cassandra/cql/common/UniqueKeyQueryRSD.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.cql.execution.RuntimeErrorMsg;
 import org.apache.cassandra.db.ColumnFamily;
+import org.apache.cassandra.db.ColumnReadCommand;
 import org.apache.cassandra.db.IColumn;
 import org.apache.cassandra.db.Row;
 import org.apache.cassandra.db.ReadCommand;
@@ -85,7 +86,7 @@ public List<Map<String,String>> getRows() throws RuntimeException
         try
         {
             String key = (String)(rowKey_.get());
-            ReadCommand readCommand = new ReadCommand(cfMetaData_.tableName, key, columnFamily_column, -1, Integer.MAX_VALUE);
+            ReadCommand readCommand = new ColumnReadCommand(cfMetaData_.tableName, key, columnFamily_column);
             row = StorageProxy.readProtocol(readCommand, StorageService.ConsistencyLevel.WEAK);
         }
         catch (Exception e)

File: src/org/apache/cassandra/test/DataImporter.java
Patch:
@@ -42,6 +42,7 @@
 import org.apache.cassandra.concurrent.DebuggableScheduledThreadPoolExecutor;
 import org.apache.cassandra.concurrent.ThreadFactoryImpl;
 import org.apache.cassandra.db.ColumnFamily;
+import org.apache.cassandra.db.RowReadCommand;
 import org.apache.cassandra.db.IColumn;
 import org.apache.cassandra.db.ReadCommand;
 import org.apache.cassandra.db.ReadResponse;
@@ -880,7 +881,7 @@ public void testRead(String filepath) throws Throwable {
 				key = user + ":1";
 			}
 
-			ReadCommand readCommand = new ReadCommand(tablename_, key);
+			ReadCommand readCommand = new RowReadCommand(tablename_, key);
 			Message message = new Message(from_, StorageService.readStage_,
 					StorageService.readVerbHandler_,
 					new Object[] {readCommand});

File: src/org/apache/cassandra/test/StressTest.java
Patch:
@@ -29,6 +29,7 @@
 
 import org.apache.cassandra.concurrent.DebuggableThreadPoolExecutor;
 import org.apache.cassandra.concurrent.ThreadFactoryImpl;
+import org.apache.cassandra.db.ColumnReadCommand;
 import org.apache.cassandra.db.ReadCommand;
 import org.apache.cassandra.db.Row;
 import org.apache.cassandra.db.RowMutation;
@@ -180,7 +181,7 @@ public void randomReadColumn  (int keys, int columns, int size, int tps)
 	            String stringKey = new Integer(key).toString();
 	            stringKey = stringKey + keyFix_ ;
             	int j = random.nextInt(columns) + 1;
-	            ReadCommand rm = new ReadCommand(tablename_, stringKey, columnFamilyColumn_ + ":" + columnFix_ + j);
+	            ReadCommand rm = new ColumnReadCommand(tablename_, stringKey, columnFamilyColumn_ + ":" + columnFix_ + j);
 	            readLoad(rm);
 				if ( requestsPerSecond_ > 1000)
 					Thread.sleep(0, 1000000000/requestsPerSecond_);
@@ -250,7 +251,7 @@ public void randomReadSuperColumn(int keys, int superColumns, int columns, int s
 	            stringKey = stringKey + keyFix_ ;
             	int i = random.nextInt(superColumns) + 1;
             	int j = random.nextInt(columns) + 1;
-	            ReadCommand rm = new ReadCommand(tablename_, stringKey, columnFamilySuperColumn_ + ":" + superColumnFix_ + i + ":" + columnFix_ + j);
+	            ReadCommand rm = new ColumnReadCommand(tablename_, stringKey, columnFamilySuperColumn_ + ":" + superColumnFix_ + i + ":" + columnFix_ + j);
 	            readLoad(rm);
 			}
 		}

File: src/org/apache/cassandra/service/NotFoundException.java
Patch:
@@ -12,11 +12,10 @@
 import java.util.Set;
 import java.util.HashSet;
 import java.util.Collections;
+
 import org.apache.thrift.*;
 import org.apache.thrift.meta_data.*;
-
 import org.apache.thrift.protocol.*;
-import org.apache.thrift.transport.*;
 
 public class NotFoundException extends Exception implements TBase, java.io.Serializable, Cloneable {
   private static final TStruct STRUCT_DESC = new TStruct("NotFoundException");

File: src/org/apache/cassandra/gms/Gossiper.java
Patch:
@@ -470,7 +470,6 @@ void doGossipToSeed(Message message)
 
     void doStatusCheck()
     {
-        long now = System.currentTimeMillis();
         Set<EndPoint> eps = endPointStateMap_.keySet();
 
         for ( EndPoint endpoint : eps )
@@ -482,8 +481,7 @@ void doStatusCheck()
             EndPointState epState = endPointStateMap_.get(endpoint);
             if ( epState != null )
             {
-                long l = now - epState.getUpdateTimestamp();
-                long duration = now - l;
+                long duration = System.currentTimeMillis() - epState.getUpdateTimestamp();
                 if ( !epState.isAlive() && (duration > aVeryLongTime_) )
                 {
                     evictFromMembership(endpoint);

File: src/org/apache/cassandra/db/ReadCommand.java
Patch:
@@ -128,7 +128,7 @@ public ReadCommand copy()
 
     public Row getRow(Table table) throws IOException, ColumnFamilyNotDefinedException
     {
-        if (columnNames != EMPTY_COLUMNS)
+        if (!columnNames.isEmpty())
         {
             return table.getRow(key, columnFamilyColumn, columnNames);
         }

File: src/org/apache/cassandra/io/SequenceFile.java
Patch:
@@ -903,7 +903,7 @@ private void readTimeRange(String key, DataOutputBuffer bufOut, String columnFam
              *  one booleanfor deleted or not +
              *  one int for number of columns
             */
-            bufOut.writeInt(dataSize + utfPrefix_ + cfName.length() + 4 + 1);
+            bufOut.writeInt(dataSize + utfPrefix_ + cfName.length() + 4 + 8 + 4);
             /* write the column family name */
             bufOut.writeUTF(cfName);
             /* write local deletion time */
@@ -991,7 +991,7 @@ private void readColumns(String key, DataOutputBuffer bufOut, String columnFamil
                  * 	one booleanfor deleted or not +
                  * 	one int for number of columns
                 */
-                bufOut.writeInt(dataSizeReturned + utfPrefix_ + cfName.length() + 4 + 1);
+                bufOut.writeInt(dataSizeReturned + utfPrefix_ + cfName.length() + 4 + 8 + 4);
                 /* write the column family name */
                 bufOut.writeUTF(cfName);
                 /* write local deletion time */

File: src/org/apache/cassandra/db/Memtable.java
Patch:
@@ -315,7 +315,7 @@ ColumnFamily getLocalCopy(String key, String columnFamilyColumn, IFilter filter)
                 IColumn column = cFamily.getColumn(values[1]); // super or normal column
                 if (column != null )
                 {
-                    columnFamily = new ColumnFamily(cfName_, cFamily.type());
+                    columnFamily = cFamily.cloneMeShallow();
                     columnFamily.addColumn(column);
                 }
         	}
@@ -328,7 +328,7 @@ ColumnFamily getLocalCopy(String key, String columnFamilyColumn, IFilter filter)
                     IColumn subColumn = superColumn.getSubColumn(values[2]);
                     if (subColumn != null)
                     {
-                        columnFamily = new ColumnFamily(cfName_, cFamily.type());
+                        columnFamily = cFamily.cloneMeShallow();
                         columnFamily.addColumn(values[1] + ":" + values[2], subColumn.value(), subColumn.timestamp(), subColumn.isMarkedForDelete());
                     }
                 }

File: src/org/apache/cassandra/db/CountFilter.java
Patch:
@@ -49,8 +49,7 @@ public ColumnFamily filter(String cfNameParam, ColumnFamily columnFamily)
         if ( columnFamily == null )
             return columnFamily;
 
-		String cfName = columnFamily.name();
-		ColumnFamily filteredCf = new ColumnFamily(cfName);
+        ColumnFamily filteredCf = new ColumnFamily(columnFamily.name(), columnFamily.type());
 		if( countLimit_ <= 0 )
 		{
 			isDone_ = true;

File: src/org/apache/cassandra/db/DBManager.java
Patch:
@@ -130,7 +130,7 @@ public DBManager.StorageMetadata start() throws IOException
 
             String key = FBUtilities.getHostName();
             row = new Row(key);
-            ColumnFamily cf = new ColumnFamily(SystemTable.cfName_);
+            ColumnFamily cf = new ColumnFamily(SystemTable.cfName_, "Standard");
             cf.addColumn(new Column(SystemTable.token_, token.toByteArray()));
             cf.addColumn(new Column(SystemTable.generation_, BasicUtilities.intToByteArray(generation)));
             row.addColumnFamily(cf);

File: src/org/apache/cassandra/db/IdentityFilter.java
Patch:
@@ -25,13 +25,13 @@ public ColumnFamily filter(String cfString, ColumnFamily columnFamily)
     	if( columnFamily == null )
     		return columnFamily;
 		String cfName = columnFamily.name();
-		if ( values.length == 2 && !DatabaseDescriptor.getColumnType(cfName).equals("Super") )
+		if (values.length == 2 && !columnFamily.isSuper())
 		{
 			Collection<IColumn> columns = columnFamily.getAllColumns();
 			if(columns.size() >= 1)
 				isDone_ = true;
 		}
-		if ( values.length == 3 && DatabaseDescriptor.getColumnType(cfName).equals("Super"))
+		if (values.length == 3 && columnFamily.isSuper())
 		{
     		Collection<IColumn> columns = columnFamily.getAllColumns();
     		for(IColumn column : columns)

File: src/org/apache/cassandra/db/Memtable.java
Patch:
@@ -314,7 +314,7 @@ ColumnFamily getLocalCopy(String key, String columnFamilyColumn, IFilter filter)
                 IColumn column = cFamily.getColumn(values[1]); // super or normal column
                 if (column != null )
                 {
-                    columnFamily = new ColumnFamily(cfName_);
+                    columnFamily = new ColumnFamily(cfName_, cFamily.type());
                     columnFamily.addColumn(column);
                 }
         	}
@@ -327,7 +327,7 @@ ColumnFamily getLocalCopy(String key, String columnFamilyColumn, IFilter filter)
                     IColumn subColumn = superColumn.getSubColumn(values[2]);
                     if (subColumn != null)
                     {
-                        columnFamily = new ColumnFamily(cfName_);
+                        columnFamily = new ColumnFamily(cfName_, cFamily.type());
                         columnFamily.addColumn(values[1] + ":" + values[2], subColumn.value(), subColumn.timestamp(), subColumn.isMarkedForDelete());
                     }
                 }

File: src/org/apache/cassandra/db/NamesFilter.java
Patch:
@@ -46,8 +46,7 @@ public ColumnFamily filter(String cf, ColumnFamily columnFamily)
             return columnFamily;
         }
     	String[] values = RowMutation.getColumnAndColumnFamily(cf);
-		String cfName = columnFamily.name();
-		ColumnFamily filteredCf = new ColumnFamily(cfName);
+        ColumnFamily filteredCf = new ColumnFamily(columnFamily.name(), columnFamily.type());
 		if( values.length == 1 )
 		{
 			Collection<IColumn> columns = columnFamily.getAllColumns();
@@ -64,7 +63,7 @@ public ColumnFamily filter(String cf, ColumnFamily columnFamily)
 				}
 			}
 		}
-		else if ( values.length == 2 && DatabaseDescriptor.getColumnType(cfName).equals("Super"))
+		else if (values.length == 2 && columnFamily.isSuper())
 		{
     		Collection<IColumn> columns = columnFamily.getAllColumns();
     		for(IColumn column : columns)

File: src/org/apache/cassandra/db/RangeFilter.java
Patch:
@@ -63,7 +63,7 @@ public ColumnFamily filter(String cfName, ColumnFamily cf)
             return null;
         }
 
-        ColumnFamily filteredColumnFamily = new ColumnFamily(cfName);
+        ColumnFamily filteredColumnFamily = new ColumnFamily(cfName, cf.type());
 
         Collection<IColumn> columns = cf.getAllColumns();
         for (IColumn c : columns)

File: src/org/apache/cassandra/db/Row.java
Patch:
@@ -120,7 +120,7 @@ public void repair(Row row)
             ColumnFamily cf = columnFamilies_.get(cfName);
             if (cf == null)
             {
-                cf = new ColumnFamily(cfName);
+                cf = new ColumnFamily(cfName, cf.type());
                 columnFamilies_.put(cfName, cf);
             }
             cf.repair(columnFamilies.get(cfName));

File: src/org/apache/cassandra/net/http/ColumnFamilyFormatter.java
Patch:
@@ -35,9 +35,8 @@ public void printColumnFamily(StringBuilder sb, ColumnFamily cf)
     	// first print the column family specific data
     	sb.append("ColumnFamily = " + cf.name() + "<br>");
 
-    	String columnFamilyType = DatabaseDescriptor.getColumnType(cf.name());
     	Collection<IColumn> cols = cf.getAllColumns();
-    	if("Super".equals(columnFamilyType))
+    	if (cf.isSuper())
     	{
     		printSuperColumns(sb, cols);
     	}

File: test/org/apache/cassandra/db/ColumnComparatorFactoryTest.java
Patch:
@@ -5,13 +5,12 @@
 import java.util.Comparator;
 
 public class ColumnComparatorFactoryTest {
-    public Comparator<IColumn> nameComparator;
+    public Comparator<IColumn> nameComparator  = ColumnComparatorFactory.getComparator(ColumnComparatorFactory.ComparatorType.NAME);
 
     @Test
     public void testLT() {
         IColumn col1 = new Column("Column-8");
         IColumn col2 = new Column("Column-9");
-        nameComparator = ColumnComparatorFactory.getComparator(ColumnComparatorFactory.ComparatorType.NAME);
         assert nameComparator.compare(col1, col2) < 0;
     }
 

File: src/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -664,7 +664,7 @@ PriorityQueue<FileStruct> initializePriorityQueue(List<String> files, List<Range
             {
             	try
             	{
-            		fs = new FileStruct(SequenceFile.bufferedReader(file, bufferSize));
+            		fs = new FileStruct(SequenceFile.bufferedReader(file, bufferSize), StorageService.getPartitioner());
 	                fs.advance();
 	                if(fs.isExhausted())
 	                	continue;

File: src/org/apache/cassandra/db/ColumnFamilyStore.java
Patch:
@@ -30,6 +30,7 @@
 import java.util.StringTokenizer;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
@@ -50,7 +51,6 @@
 import org.apache.cassandra.utils.BloomFilter;
 import org.apache.cassandra.utils.FileUtils;
 import org.apache.cassandra.utils.LogUtil;
-import org.cliffc.high_scale_lib.NonBlockingHashMap;
 
 /**
  * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )
@@ -694,7 +694,7 @@ PriorityQueue<FileStruct> initializePriorityQueue(List<String> files, List<Range
      */
     static Set<List<String>> getCompactionBuckets(List<String> files, long min)
     {
-    	Map<List<String>, Long> buckets = new NonBlockingHashMap<List<String>, Long>();
+    	Map<List<String>, Long> buckets = new ConcurrentHashMap<List<String>, Long>();
     	for(String fname : files)
     	{
     		File f = new File(fname);

File: src/org/apache/cassandra/io/Coordinate.java
Patch:
@@ -21,10 +21,10 @@
  * Section of a file that needs to be scanned
  * is represented by this class.
 */
-class Coordinate
+public class Coordinate
 {
-    long start_;
-    long end_;
+    public final long start_;
+    public final long end_;
     
     Coordinate(long start, long end)
     {

File: src/org/apache/cassandra/io/SSTable.java
Patch:
@@ -644,9 +644,9 @@ public void append(String decoratedKey, byte[] value) throws IOException
         afterAppend(decoratedKey, currentPosition, value.length );
     }
 
-    private Coordinate getCoordinates(String decoratedKey, IFileReader dataReader) throws IOException
+    public static Coordinate getCoordinates(String decoratedKey, IFileReader dataReader) throws IOException
     {
-    	List<KeyPositionInfo> indexInfo = indexMetadataMap_.get(dataFile_);
+    	List<KeyPositionInfo> indexInfo = indexMetadataMap_.get(dataReader.getFileName());
     	int size = (indexInfo == null) ? 0 : indexInfo.size();
     	long start = 0L;
     	long end = dataReader.getEOF();

File: src/org/apache/cassandra/io/IFileWriter.java
Patch:
@@ -18,11 +18,8 @@
 
 package org.apache.cassandra.io;
 
-import java.io.File;
 import java.io.IOException;
 
-import org.apache.cassandra.db.PrimaryKey;
-
 
 /**
  * An interface for writing into the SequenceFile abstraction.

File: test/org/apache/cassandra/db/ColumnFamilyStoreTest.java
Patch:
@@ -64,7 +64,7 @@ public void testNameSort() throws IOException, ColumnFamilyNotDefinedException,
             }
         }
 
-        validateNameSort(table);
+        // validateNameSort(table);
 
         table.getColumnFamilyStore("Standard1").forceFlush();
         table.getColumnFamilyStore("Super1").forceFlush();

File: test/org/apache/cassandra/db/ColumnFamilyStoreTest.java
Patch:
@@ -163,6 +163,7 @@ public void run()
             }
         });
         f.get();
+        Thread.sleep(1000);
     }
 
     private void validateNameSort(Table table)

File: src/org/apache/cassandra/db/Memtable.java
Patch:
@@ -262,6 +262,7 @@ void put(String key, ColumnFamily columnFamily, CommitLog.CommitLogContext cLogC
 
     /*
      * This version is used to switch memtable and force flush.
+     * Flushing is still done in a separate executor -- forceFlush does not block.
     */
     public void forceflush(ColumnFamilyStore cfStore) throws IOException
     {

File: src/org/apache/cassandra/db/MemtableManager.java
Patch:
@@ -93,7 +93,7 @@ public void run()
     }
     
     private Map<String, List<Memtable>> history_ = new HashMap<String, List<Memtable>>();
-    private ExecutorService flusher_ = new DebuggableThreadPoolExecutor( 1,
+    ExecutorService flusher_ = new DebuggableThreadPoolExecutor( 1,
             1,
             Integer.MAX_VALUE,
             TimeUnit.SECONDS,

File: src/org/apache/cassandra/concurrent/StageManager.java
Patch:
@@ -52,7 +52,7 @@ public static void registerStage(String stageName, IStage stage)
      * Returns the stage that we are currently executing on.
      * This relies on the fact that the thread names in the
      * stage have the name of the stage as the prefix.
-     * @return
+     * @return Returns the stage that we are currently executing on.
      */
     public static IStage getCurrentStage()
     {
@@ -97,7 +97,7 @@ public static void deregisterStage(String stageName)
      * This method gets the number of tasks on the
      * stage's internal queue.
      * @param stage name of the stage
-     * @return
+     * @return stage task count.
      */
     public static long getStageTaskCount(String stage)
     {

File: src/org/apache/cassandra/db/CalloutManager.java
Patch:
@@ -187,7 +187,7 @@ public void removeCallout(String callout)
     /**
      * Execute the specified callout.
      * @param callout to be executed.
-     * @params args arguments to be passed to the callouts.
+     * @param args arguments to be passed to the callouts.
      */
     public Object executeCallout(String callout, Object ... args)
     {

File: src/org/apache/cassandra/db/ICompactSerializer2.java
Patch:
@@ -40,7 +40,6 @@ public interface ICompactSerializer2<T> extends ICompactSerializer<T>
      * argument.
      * 
      * @param dis DataInput from which we need to deserialize.
-     * @param columnNames list of items that are required.
      * @throws IOException
      * @return type which contains the specified items.
 	*/
@@ -52,7 +51,6 @@ public interface ICompactSerializer2<T> extends ICompactSerializer<T>
      * 
      * @param dis DataInput from which we need to deserialize.
      * @param name name of the desired field.
-     * @param count count of the number of fields required.
      * @throws IOException
      * @return the deserialized type.
     */

File: src/org/apache/cassandra/db/Memtable.java
Patch:
@@ -166,8 +166,9 @@ public void run()
 
     /**
      * Compares two Memtable based on creation time.
-     * @param rhs
-     * @return
+     * @param rhs Memtable to compare to.
+     * @return a negative integer, zero, or a positive integer as this object
+     * is less than, equal to, or greater than the specified object.
      */
     public int compareTo(Memtable rhs)
     {

File: src/org/apache/cassandra/db/PrimaryKey.java
Patch:
@@ -93,7 +93,8 @@ public BigInteger hash()
      * is an OPHF then the key is used.
      * 
      * @param rhs primary against which we wish to compare.
-     * @return
+     * @return a negative integer, zero, or a positive integer as this object
+     * is less than, equal to, or greater than the specified object.
      */
     public int compareTo(PrimaryKey rhs)
     {

File: src/org/apache/cassandra/net/IAsyncCallback.java
Patch:
@@ -25,7 +25,7 @@
 public interface IAsyncCallback 
 {
 	/**
-	 * @param response responses to be returned
+	 * @param msg responses to be returned
 	 */
 	public void response(Message msg);
     

File: src/org/apache/cassandra/net/IAsyncResult.java
Patch:
@@ -67,8 +67,6 @@ public interface IAsyncResult
     
     /**
      * Store the result obtained for the submitted task.
-     * @param result result wrapped in an Object[]
-     * 
      * @param result the response message
      */
     public void result(Message result);

File: src/org/apache/cassandra/net/IMessagingService.java
Patch:
@@ -137,7 +137,7 @@ public interface IMessagingService
      * whose results are harnessed via the <i>IAsyncResult</i>
      * @param messages groups of grouped messages.
      * @param to destination for the groups of messages
-     * @param the callback handler to be invoked for the responses
+     * @param cb the callback handler to be invoked for the responses
      * @return the group id which is basically useless - it is only returned for API's
      *         to look compatible.
      */

File: src/org/apache/cassandra/net/SelectorManager.java
Patch:
@@ -58,8 +58,7 @@ public class SelectorManager extends Thread
     /**
      * Constructor, which is private since there is only one selector per JVM.
      * 
-     * @param profile
-     *            DESCRIBE THE PARAMETER
+     * @param name name of thread. 
      */
     protected SelectorManager(String name)
     {

File: src/org/apache/cassandra/service/CassandraServer.java
Patch:
@@ -997,7 +997,7 @@ public String getStatusDetails()
 
 	public static void main(String[] args) throws Throwable
 	{
-		int port = 9160;		
+		int port = DatabaseDescriptor.getThriftPort();		
 		try
 		{
 			CassandraServer peerStorageServer = new CassandraServer();

File: src/org/apache/cassandra/io/SequenceFile.java
Patch:
@@ -1179,8 +1179,8 @@ public long next(String key, DataOutputBuffer bufOut, String cf, List<String> co
                         dataSize -= (utfPrefix_ + cfName.length());
 
                         /* read if this cf is marked for delete */
-                        boolean markedForDelete = file_.readBoolean();
-                        dataSize -= 1;
+                        long markedForDeleteAt = file_.readLong();
+                        dataSize -= 8;
 
                         /* read the total number of columns */
                         int totalNumCols = file_.readInt();
@@ -1213,7 +1213,7 @@ public long next(String key, DataOutputBuffer bufOut, String cf, List<String> co
                         /* write the column family name */
                         bufOut.writeUTF(cfName);
                         /* write if this cf is marked for delete */
-                        bufOut.writeBoolean(markedForDelete);
+                        bufOut.writeLong(markedForDeleteAt);
                         /* write number of columns */
                         bufOut.writeInt(numColsReturned);
                         int prevPosition = 0;

File: src/org/apache/cassandra/cql/common/ColumnRangeQueryRSD.java
Patch:
@@ -33,6 +33,7 @@
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.LogUtil;
 import org.apache.log4j.Logger;
+import org.apache.cassandra.db.*;
 
 /**
  * A Row Source Defintion (RSD) for doing a range query on a column map
@@ -111,7 +112,7 @@ public List<Map<String,String>> getRows()
         List<Map<String, String>> rows = new LinkedList<Map<String, String>>();
         if (row != null)
         {
-            Map<String, ColumnFamily> cfMap = row.getColumnFamilyMap();
+            Map<String, ColumnFamily> cfMap = row.getColumnFamilies();
             if (cfMap != null && cfMap.size() > 0)
             {
                 ColumnFamily cfamily = cfMap.get(cfMetaData_.cfName);

File: src/org/apache/cassandra/cql/common/UniqueKeyQueryRSD.java
Patch:
@@ -33,6 +33,7 @@
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.LogUtil;
 import org.apache.log4j.Logger;
+import org.apache.cassandra.db.*;
 
 /**
  * A Row Source Defintion (RSD) for looking up a unique column within a column family.
@@ -95,7 +96,7 @@ public List<Map<String,String>> getRows() throws RuntimeException
 
         if (row != null)
         {
-            Map<String, ColumnFamily> cfMap = row.getColumnFamilyMap();
+            Map<String, ColumnFamily> cfMap = row.getColumnFamilies();
             if (cfMap != null && cfMap.size() > 0)
             {
                 ColumnFamily cfamily = cfMap.get(cfMetaData_.cfName);

File: src/org/apache/cassandra/gms/FailureDetector.java
Patch:
@@ -177,7 +177,7 @@ public void intepret(EndPoint ep)
         /* We need this so that we do not suspect a convict. */
         boolean isConvicted = false;
         double phi = hbWnd.phi(now);
-        logger_.trace("PHI for " + ep + " : " + phi);
+        logger_.info("PHI for " + ep + " : " + phi);
         
         /*
         if ( phi > phiConvictThreshold_ )

File: src/org/apache/cassandra/io/Coordinate.java
Patch:
@@ -21,10 +21,10 @@
  * Section of a file that needs to be scanned
  * is represented by this class.
 */
-public class Coordinate
+class Coordinate
 {
-    public final long start_;
-    public final long end_;
+    long start_;
+    long end_;
     
     Coordinate(long start, long end)
     {

File: src/org/apache/cassandra/io/IFileWriter.java
Patch:
@@ -18,8 +18,11 @@
 
 package org.apache.cassandra.io;
 
+import java.io.File;
 import java.io.IOException;
 
+import org.apache.cassandra.db.PrimaryKey;
+
 
 /**
  * An interface for writing into the SequenceFile abstraction.

File: src/org/apache/cassandra/test/DBTest.java
Patch:
@@ -109,7 +109,7 @@ private static void doScannerTest() throws Throwable
             System.out.println(scanner.next().name());
         }             
     }
-
+    
     public static void doTest()
     {
         String host = "insearch00";
@@ -182,6 +182,7 @@ public static void main(String[] args) throws Throwable
         //doWrites();
         //doRead("543");
         
+        DatabaseDescriptor.init();
         DBTest.doTest();
     }
 }

File: src/org/apache/cassandra/utils/FastObjectHash.java
Patch:
@@ -187,7 +187,7 @@ else if (cur != REMOVED && cur.equals(obj))
         }
         else
         { // already FULL or REMOVED, must probe
-            // compute the double token
+            // compute the double hash
             final int probe = 1 + (hash % (length - 2));
 
             // if the slot we landed on is FULL (but not removed), probe

File: src/org/apache/cassandra/db/BinaryMemtable.java
Patch:
@@ -29,9 +29,8 @@
 import java.util.concurrent.locks.ReentrantLock;
 
 import org.apache.cassandra.config.DatabaseDescriptor;
-import org.apache.cassandra.utils.BloomFilter;
 import org.apache.cassandra.io.SSTable;
-
+import org.apache.cassandra.utils.BloomFilter;
 import org.apache.log4j.Logger;
 import org.cliffc.high_scale_lib.NonBlockingHashMap;
 

File: src/org/apache/cassandra/db/RecoveryManager.java
Patch:
@@ -93,6 +93,7 @@ private void recoverEachTable(Map<String, List<File>> tableToCommitLogs) throws
     
     public static void main(String[] args) throws Throwable
     {
+        DatabaseDescriptor.init();
         long start = System.currentTimeMillis();
         RecoveryManager rm = RecoveryManager.instance();
         rm.doRecovery();  

File: src/org/apache/cassandra/db/TimeFilter.java
Patch:
@@ -146,6 +146,6 @@ public boolean isDone()
 
 	public DataInputBuffer next(String key, String cf, SSTable ssTable) throws IOException
     {
-    	return ssTable.next( key, cf, new IndexHelper.TimeRange( timeLimit_, System.currentTimeMillis() ) );
+    	return ssTable.next( key, cf, null, new IndexHelper.TimeRange( timeLimit_, System.currentTimeMillis() ) );
     }
 }

File: src/org/apache/cassandra/io/IFileWriter.java
Patch:
@@ -18,11 +18,8 @@
 
 package org.apache.cassandra.io;
 
-import java.io.File;
 import java.io.IOException;
 
-import org.apache.cassandra.db.PrimaryKey;
-
 
 /**
  * An interface for writing into the SequenceFile abstraction.

File: src/org/apache/cassandra/io/SequenceFile.java
Patch:
@@ -1179,8 +1179,8 @@ public long next(String key, DataOutputBuffer bufOut, String cf, List<String> co
                         dataSize -= (utfPrefix_ + cfName.length());
 
                         /* read if this cf is marked for delete */
-                        boolean markedForDelete = file_.readBoolean();
-                        dataSize -= 1;
+                        long markedForDeleteAt = file_.readLong();
+                        dataSize -= 8;
 
                         /* read the total number of columns */
                         int totalNumCols = file_.readInt();
@@ -1213,7 +1213,7 @@ public long next(String key, DataOutputBuffer bufOut, String cf, List<String> co
                         /* write the column family name */
                         bufOut.writeUTF(cfName);
                         /* write if this cf is marked for delete */
-                        bufOut.writeBoolean(markedForDelete);
+                        bufOut.writeLong(markedForDeleteAt);
                         /* write number of columns */
                         bufOut.writeInt(numColsReturned);
                         int prevPosition = 0;

File: src/org/apache/cassandra/io/ChecksumRandomAccessFile.java
Patch:
@@ -391,8 +391,8 @@ public void write(byte[] b, int off, int len) throws IOException
             int n = this.writeAtMost(b, off, len);
             off += n;
             len -= n;
+            this.dirty_ = true;
         }
-        this.dirty_ = true;
     }
     
     /*

File: src/org/apache/cassandra/io/SequenceFile.java
Patch:
@@ -974,7 +974,7 @@ public long next(String key, DataOutputBuffer bufOut, String cf, Coordinate sect
 
                         Coordinate coordinate = columnRange.coordinate();
                 		/* seek to the correct offset to the data, and calculate the data size */
-                        file_.skipBytes((int)coordinate.start_);
+                        file_.skipBytes((int)coordinate.start_);                        
                         dataSize = (int)(coordinate.end_ - coordinate.start_);
                         
                         /*

File: src/org/apache/cassandra/io/ChecksumRandomAccessFile.java
Patch:
@@ -197,7 +197,7 @@ private void doChecksumOperation(ChecksumOperations chksumOps) throws IOExceptio
         int chksumChunkId = (int)(chksumChunks*(chunk - 1) + 1);
         do
         {            
-            int fId = SequenceFile.getFileId(filename_);               
+            int fId = ChecksumManager.getFileId(filename_);               
             switch( chksumOps )
             {
                 case LOG:                    

